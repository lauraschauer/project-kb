{
    "advisory_record": {
        "cve_id": "CVE-2018-1000134",
        "description": "UnboundID LDAP SDK version from commit 801111d8b5c732266a5dbd4b3bb0b6c7b94d7afb up to commit 8471904a02438c03965d21367890276bc25fa5a6, where the issue was reported and fixed contains an Incorrect Access Control vulnerability in process function in SimpleBindRequest class doesn't check for empty password when running in synchronous mode. commit with applied fix https://github.com/pingidentity/ldapsdk/commit/8471904a02438c03965d21367890276bc25fa5a6#diff-f6cb23b459be1ec17df1da33760087fd that can result in Ability to impersonate any valid user. This attack appear to be exploitable via Providing valid username and empty password against servers that do not do additional validation as per https://tools.ietf.org/html/rfc4513#section-5.1.1. This vulnerability appears to have been fixed in after commit 8471904a02438c03965d21367890276bc25fa5a6.",
        "reserved_timestamp": 1521158400,
        "published_timestamp": 1521209040,
        "updated_timestamp": 1527155821,
        "repository_url": null,
        "references": {
            "": 109,
            "https://access.redhat.com/support/": 15,
            "https://access.redhat.com/downloads/": 12,
            "https://access.redhat.com/errata/": 9,
            "https://access.redhat.com/labs/": 9,
            "https://access.redhat.com/management/": 6,
            "https://access.redhat.com/": 6,
            "https://access.redhat.com/products/red-hat-enterprise-linux/": 6,
            "https://access.redhat.com/products/red-hat-openshift-container-platform": 6,
            "https://access.redhat.com/products/red-hat-ansible-automation-platform/": 6,
            "https://access.redhat.com/products/": 6,
            "https://access.redhat.com/documentation": 6,
            "https://access.redhat.com/product-life-cycles/": 6,
            "https://access.redhat.com/security": 6,
            "https://access.redhat.com/security/security-updates/#/security-advisories": 6,
            "https://access.redhat.com/security/security-updates/#/cve": 6,
            "https://access.redhat.com/support/contact/": 6,
            "https://status.redhat.com": 6,
            "https://access.redhat.com/errata/RHSA-2018:1713": 4,
            "https://github.com/pingidentity/ldapsdk/issues/40": 4,
            "commit::8471904a02438c03965d21367890276bc25fa5a6": 3,
            "https://nawilson.com/2018/03/19/cve-2018-1000134-and-the-unboundid-ldap-sdk-for-java/": 3,
            "https://access.redhat.com/downloads/content/package-browser": 3,
            "https://catalog.redhat.com/software/containers/explore/": 3,
            "https://access.redhat.com/articles/1202803": 3,
            "https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Solution": 3,
            "https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Article": 3,
            "https://access.redhat.com/documentation/en/red_hat_enterprise_linux": 3,
            "https://access.redhat.com/documentation/en/openshift_container_platform": 3,
            "https://access.redhat.com/documentation/en/red_hat_ansible_automation_platform": 3,
            "https://access.redhat.com/documentation/": 3,
            "https://access.redhat.com/security/": 3,
            "https://access.redhat.com/security/vulnerabilities": 3,
            "https://access.redhat.com/security/data": 3,
            "https://access.redhat.com/security/security-updates/#/security-labs": 3,
            "https://access.redhat.com/security/updates/backporting/": 3,
            "https://access.redhat.com/support/cases/": 3,
            "https://access.redhat.com/support/cases/#/troubleshoot": 3,
            "https://access.redhat.com/community": 3,
            "https://access.redhat.com/community/": 3,
            "https://access.redhat.com/discussions/": 3,
            "https://access.redhat.com/announcements/": 3,
            "https://access.redhat.com/accelerators/": 3,
            "https://access.redhat.com/jbossnetwork/restricted/listSoftware.html": 3,
            "https://cloud.redhat.com/insights": 3,
            "https://access.redhat.com/changeLanguage?language=en": 3,
            "https://access.redhat.com/changeLanguage?language=fr": 3,
            "https://access.redhat.com/changeLanguage?language=ko": 3,
            "https://access.redhat.com/changeLanguage?language=ja": 3,
            "https://access.redhat.com/changeLanguage?language=zh_CN": 3,
            "https://access.redhat.com/products/red-hat-satellite/": 3,
            "https://access.redhat.com/products/red-hat-subscription-management/": 3,
            "https://access.redhat.com/products/red-hat-insights/": 3,
            "https://access.redhat.com/products/red-hat-openstack-platform/": 3,
            "https://access.redhat.com/products/red-hat-openshift-container-platform/": 3,
            "https://access.redhat.com/products/red-hat-openshift-ai/": 3,
            "https://access.redhat.com/products/openshift-dedicated-red-hat/": 3,
            "https://access.redhat.com/products/red-hat-advanced-cluster-security-for-kubernetes/": 3,
            "https://access.redhat.com/products/red-hat-advanced-cluster-management-for-kubernetes/": 3,
            "https://access.redhat.com/products/red-hat-quay/": 3,
            "https://access.redhat.com/products/red-hat-openshift-dev-spaces": 3,
            "https://access.redhat.com/products/red-hat-openshift-service-aws": 3,
            "https://access.redhat.com/products/red-hat-storage/": 3,
            "https://access.redhat.com/products/red-hat-hyperconverged-infrastructure/": 3,
            "https://access.redhat.com/products/red-hat-ceph-storage/": 3,
            "https://access.redhat.com/products/red-hat-openshift-data-foundation": 3,
            "https://access.redhat.com/products/red-hat-runtimes/": 3,
            "https://access.redhat.com/products/red-hat-jboss-enterprise-application-platform/": 3,
            "https://access.redhat.com/products/red-hat-data-grid/": 3,
            "https://access.redhat.com/products/red-hat-jboss-web-server/": 3,
            "https://access.redhat.com/products/red-hat-build-of-keycloak/": 3,
            "https://access.redhat.com/products/spring-boot/": 3,
            "https://access.redhat.com/products/nodejs/": 3,
            "https://access.redhat.com/products/quarkus/": 3,
            "https://access.redhat.com/products/red-hat-application-foundations/": 3,
            "https://access.redhat.com/products/red-hat-fuse/": 3,
            "https://access.redhat.com/products/red-hat-amq/": 3,
            "https://access.redhat.com/products/red-hat-3scale/": 3,
            "https://redhat.com/en": 3,
            "https://twitter.com/RedHat": 3,
            "https://access.redhat.com/management": 3,
            "https://access.redhat.com/support": 3,
            "https://access.redhat.com/support/customer-service": 3,
            "https://access.redhat.com/articles/33844": 3,
            "https://access.redhat.com/help/login_assistance": 3,
            "https://www.redhat.com/en/trust": 3,
            "https://www.redhat.com/en/about/browser-support": 3,
            "https://www.redhat.com/en/about/digital-accessibility": 3,
            "https://access.redhat.com/recognition/": 3,
            "https://access.redhat.com/help/colophon/": 3,
            "https://www.redhat.com/": 3,
            "http://developers.redhat.com/": 3,
            "https://connect.redhat.com/": 3,
            "https://cloud.redhat.com/": 3,
            "https://access.redhat.com/subscription-value": 3,
            "https://www.redhat.com/about/": 3,
            "http://jobs.redhat.com": 3,
            "https://redhat.com/en/about/company": 3,
            "https://redhat.com/en/jobs": 3,
            "https://redhat.com/en/events": 3,
            "https://redhat.com/en/about/office-locations": 3,
            "https://redhat.com/en/contact": 3,
            "https://redhat.com/en/blog": 3,
            "https://redhat.com/en/about/our-culture/diversity-equity-inclusion": 3,
            "https://coolstuff.redhat.com/": 3,
            "https://www.redhat.com/en/summit": 3,
            "https://redhat.com/en/about/privacy-policy": 3,
            "https://redhat.com/en/about/terms-use": 3,
            "https://redhat.com/en/about/all-policies-guidelines": 3,
            "https://redhat.com/en/about/digital-accessibility": 3,
            "http://www.securityfocus.com/bid/103458": 2,
            "https://tools.ietf.org/html/rfc4513#section-5.1.1": 2,
            "https://errata.devel.redhat.com/advisory/33225": 2,
            "https://access.redhat.com/security/cve/cve-2018-1000134": 2,
            "https://access.redhat.com/errata/RHSA-2023:1334": 2,
            "https://bugzilla.redhat.com/show_bug.cgi?id=1557531": 2,
            "https://access.redhat.com/security/team/contact/": 2,
            "https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax": 2,
            "https://console.redhat.com/insights/patch/advisories/RHSA-2018:1713": 1,
            "https://access.redhat.com/articles/11258": 1,
            "https://www.redhat.com/security/data/cve/CVE-2018-1000134.html": 1,
            "https://access.redhat.com/security/updates/classification/#moderate": 1,
            "https://github.com/features/actions": 1,
            "https://github.com/features/packages": 1,
            "https://github.com/features/security": 1,
            "https://github.com/features/codespaces": 1,
            "https://github.com/features/copilot": 1,
            "https://github.com/features/code-review": 1,
            "https://github.com/features/issues": 1,
            "https://github.com/features/discussions": 1,
            "https://github.com/features": 1,
            "https://docs.github.com": 1,
            "https://skills.github.com": 1,
            "https://github.blog": 1,
            "https://github.com/enterprise": 1,
            "https://github.com/team": 1,
            "https://github.com/enterprise/startups": 1,
            "https://github.com/solutions/industries/healthcare": 1,
            "https://github.com/solutions/industries/financial-services": 1,
            "https://github.com/solutions/industries/manufacturing": 1,
            "https://github.com/solutions/ci-cd": 1,
            "https://github.com/solutions/devops": 1,
            "https://github.com/solutions/devsecops": 1,
            "https://resources.github.com/learn/pathways": 1,
            "https://resources.github.com": 1,
            "https://github.com/customer-stories": 1,
            "https://partner.github.com": 1,
            "https://github.com/readme": 1,
            "https://github.com/topics": 1,
            "https://github.com/trending": 1,
            "https://github.com/collections": 1,
            "https://github.com/enterprise/advanced-security": 1,
            "https://github.com/pricing": 1,
            "https://docs.github.com/terms": 1,
            "https://docs.github.com/privacy": 1,
            "https://github.com/pingidentity/ldapsdk/blob/master/src/com/unboundid/ldap/sdk/SimpleBindRequest.java#L513": 1,
            "https://github.com": 1,
            "https://docs.github.com/site-policy/github-terms/github-terms-of-service": 1,
            "https://docs.github.com/site-policy/privacy-policies/github-privacy-statement": 1,
            "https://github.com/security": 1,
            "https://www.githubstatus.com/": 1,
            "https://docs.github.com/": 1,
            "https://support.github.com?tags=dotcom-footer": 1,
            "https://bugzilla.redhat.com/show_bug.cgi?id=1501529": 1,
            "https://bugzilla.redhat.com/show_bug.cgi?id=1789959": 1,
            "https://bugzilla.redhat.com/show_bug.cgi?id=1882256": 1,
            "https://bugzilla.redhat.com/show_bug.cgi?id=1882260": 1,
            "https://bugzilla.redhat.com/show_bug.cgi?id=1948761": 1,
            "https://bugzilla.redhat.com/show_bug.cgi?id=1955739": 1,
            "https://bugzilla.redhat.com/show_bug.cgi?id=1956688": 1,
            "https://access.redhat.com/security/cve/CVE-2017-12629": 1,
            "https://access.redhat.com/security/cve/CVE-2018-1000134": 1,
            "https://access.redhat.com/security/cve/CVE-2019-19919": 1,
            "https://access.redhat.com/security/cve/CVE-2019-20920": 1,
            "https://access.redhat.com/security/cve/CVE-2019-20922": 1,
            "https://access.redhat.com/security/cve/CVE-2021-23369": 1,
            "https://access.redhat.com/security/cve/CVE-2021-23383": 1,
            "https://access.redhat.com/security/cve/CVE-2021-26291": 1,
            "https://access.redhat.com/security/updates/classification/#critical": 1
        },
        "affected_products": [
            "Access",
            "Incorrect",
            "Control",
            "n/a",
            "SDK",
            "LDAP"
        ],
        "versions": {
            "status": "affected",
            "version": "n/a"
        },
        "files": [
            "UnboundID",
            "SDK",
            "SimpleBindRequest",
            "LDAP"
        ],
        "keywords": [
            "simplebindrequest",
            "unboundid",
            "function",
            "commit",
            "process",
            "appear",
            "class",
            "access",
            "result",
            "version",
            "validation",
            "password",
            "server",
            "contain",
            "ability",
            "issue",
            "apply",
            "vulnerability",
            "incorrect",
            "provide",
            "check",
            "ldap",
            "impersonate",
            "report",
            "mode",
            "attack",
            "control",
            "user",
            "801111d8b5c732266a5dbd4b3bb0b6c7b94d7afb"
        ],
        "files_extension": [],
        "has_fixing_commit": true
    },
    "commits": [
        {
            "commit_id": "8471904a02438c03965d21367890276bc25fa5a6",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1520616563,
            "hunks": 9,
            "message": "Fix a SimpleBindRequest bug Fixed a bug in SimpleBindRequest that prevented it from rejecting a bind request that includes a DN without a password (when it is appropriate to do so, based on the LDAPConnectionOptions.bindWithDNRequiresPassword() setting) when operating in synchronous mode.  The setting was properly honored in the default asynchronous mode.",
            "diff": [
                "diff --git a/docs/release-notes.html b/docs/release-notes.html",
                "index 0dabf2ee..33861126 100644",
                "--- a/docs/release-notes.html",
                "+++ b/docs/release-notes.html",
                "@@ -15,2 +15,11 @@ ${TARGET=\"offline\"}                <br>",
                "               <ul>",
                "+                <li>",
                "+                  Fixed a bug in simple bind request processing in which the LDAP SDK would only",
                "+                  reject a bind request that contains a DN but no password (subject to the",
                "+                  <tt>LDAPConnectionOptions.bindWithDNRequiresPassword()</tt> setting) when using",
                "+                  the default asynchronous mode, but not when configured to operate in synchronous",
                "+                  mode.",
                "+                  <br><br>",
                "+                </li>",
                "+",
                "                 <li>",
                "diff --git a/src/com/unboundid/ldap/sdk/SimpleBindRequest.java b/src/com/unboundid/ldap/sdk/SimpleBindRequest.java",
                "index c811d2aa..8b218df9 100644",
                "--- a/src/com/unboundid/ldap/sdk/SimpleBindRequest.java",
                "+++ b/src/com/unboundid/ldap/sdk/SimpleBindRequest.java",
                "@@ -515,10 +515,2 @@ public final class SimpleBindRequest",
                "   {",
                "-    if (connection.synchronousMode())",
                "-    {",
                "-      @SuppressWarnings(\"deprecation\")",
                "-      final boolean autoReconnect =",
                "-           connection.getConnectionOptions().autoReconnect();",
                "-      return processSync(connection, autoReconnect);",
                "-    }",
                "-",
                "     // See if a bind DN was provided without a password.  If that is the case",
                "@@ -538,2 +530,10 @@ public final class SimpleBindRequest",
                "+    if (connection.synchronousMode())",
                "+    {",
                "+      @SuppressWarnings(\"deprecation\")",
                "+      final boolean autoReconnect =",
                "+           connection.getConnectionOptions().autoReconnect();",
                "+      return processSync(connection, autoReconnect);",
                "+    }",
                "+",
                "     // Create the LDAP message.",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/SimpleBindRequestTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/SimpleBindRequestTestCase.java",
                "index 5630bb23..18ff21c5 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/SimpleBindRequestTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/SimpleBindRequestTestCase.java",
                "@@ -29,2 +29,3 @@ import org.testng.annotations.Test;",
                " import com.unboundid.asn1.ASN1OctetString;",
                "+import com.unboundid.ldap.listener.InMemoryDirectoryServer;",
                " import com.unboundid.ldap.protocol.LDAPMessage;",
                "@@ -1395,4 +1396,3 @@ public class SimpleBindRequestTestCase",
                "    * Tests to ensure that the LDAP SDK will reject attempts to perform a simple",
                "-   * bind with a DN but without a password.  Note that processing for this test",
                "-   * will only be performed if a Directory Server instance is available.",
                "+   * bind with a DN but without a password, when operating in synchronous mode.",
                "    *",
                "@@ -1401,12 +1401,63 @@ public class SimpleBindRequestTestCase",
                "   @Test()",
                "-  public void testRejectBindWithDNButNoPassword()",
                "+  public void testRejectBindWithDNButNoPasswordSyncMode()",
                "          throws Exception",
                "   {",
                "-    if (! isDirectoryInstanceAvailable())",
                "+    final InMemoryDirectoryServer ds = getTestDS(true, true);",
                "+",
                "+    final LDAPConnectionOptions options = new LDAPConnectionOptions();",
                "+    options.setUseSynchronousMode(true);",
                "+",
                "+    final LDAPConnection conn = ds.getConnection(options);",
                "+    final SimpleBindRequest bindRequest =",
                "+         new SimpleBindRequest(\"cn=Directory Manager\", \"\");",
                "+",
                "+    try",
                "     {",
                "-      return;",
                "+      bindRequest.process(conn, 1);",
                "+      fail(\"Expected an exception when binding with a DN but no password\");",
                "+    }",
                "+    catch (LDAPException le)",
                "+    {",
                "+      assertEquals(le.getResultCode(), ResultCode.PARAM_ERROR);",
                "     }",
                "-    LDAPConnection conn = getUnauthenticatedConnection();",
                "-    SimpleBindRequest bindRequest = new SimpleBindRequest(getTestBindDN(), \"\");",
                "+",
                "+    // Reconfigure the connection so that it will allow binds with a DN but no",
                "+    // password.",
                "+    conn.getConnectionOptions().setBindWithDNRequiresPassword(false);",
                "+    try",
                "+    {",
                "+      bindRequest.process(conn, 1);",
                "+    }",
                "+    catch (LDAPException le)",
                "+    {",
                "+      // The server will still likely reject the operation, but we should at",
                "+      // least verify that it wasn't a parameter error.",
                "+      assertFalse(le.getResultCode() == ResultCode.PARAM_ERROR);",
                "+    }",
                "+",
                "+    conn.getConnectionOptions().setBindWithDNRequiresPassword(true);",
                "+    conn.close();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests to ensure that the LDAP SDK will reject attempts to perform a simple",
                "+   * bind with a DN but without a password, when operating in asynchronous mode.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testRejectBindWithDNButNoPasswordAsyncMode()",
                "+         throws Exception",
                "+  {",
                "+    final InMemoryDirectoryServer ds = getTestDS(true, true);",
                "+",
                "+    final LDAPConnectionOptions options = new LDAPConnectionOptions();",
                "+    options.setUseSynchronousMode(false);",
                "+",
                "+    final LDAPConnection conn = ds.getConnection(options);",
                "+    final SimpleBindRequest bindRequest =",
                "+         new SimpleBindRequest(\"cn=Directory Manager\", \"\");"
            ],
            "changed_files": [
                "docs/release-notes.html",
                "src/com/unboundid/ldap/sdk/SimpleBindRequest.java",
                "tests/unit/src/com/unboundid/ldap/sdk/SimpleBindRequestTestCase.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "COMMIT_IN_REFERENCE",
                    "message": "This commit is mentioned 3 times in the references.",
                    "relevance": 64
                },
                {
                    "id": "RELEVANT_WORDS_IN_MESSAGE",
                    "message": "The commit message contains some relevant words: SimpleBindRequest",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: SDK, SimpleBindRequest, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: tests/unit/src/com/unboundid/ldap/sdk/SimpleBindRequestTestCase.java, src/com/unboundid/ldap/sdk/SimpleBindRequest.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: simplebindrequest, mode, password",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: simplebindrequest, unboundid",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "b28fb50058dfe2864171df2448ad2ad2b4c2ad58",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1521443138,
            "hunks": 9,
            "message": "Update the release notes for the 4.0.5 release Updated the LDAP SDK release notes in preparation for version 4.0.5. The release notes now include a link to CVE-2018-1000134, and the order in which some of the items were listed has been changed.",
            "diff": [
                "diff --git a/docs/release-notes.html b/docs/release-notes.html",
                "index 96d1c165..188ea7d2 100644",
                "--- a/docs/release-notes.html",
                "+++ b/docs/release-notes.html",
                "@@ -20,3 +20,9 @@ ${TARGET=\"offline\"}                <br>",
                "                   the default asynchronous mode, but not when configured to operate in synchronous",
                "-                  mode.",
                "+                  mode.  In applications that use a simple bind operation to authenticate users,",
                "+                  that do not ensure that the user provided a non-empty password, and that",
                "+                  communicate with a server that does not follow the RFC 4513 section 5.1.2",
                "+                  recommendation to reject binds with a DN but no password, this bug could have",
                "+                  allowed an attacker to impersonate any legitimate user by identifying themselves",
                "+                  as the desired user and leaving the password field empty.",
                "+                  (<a href=\"http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1000134\">CVE-2018-1000134</a>).",
                "                   <br><br>",
                "@@ -25,12 +31,5 @@ ${TARGET=\"offline\"}                <br>",
                "                 <li>",
                "-                  Added support for two new UnboundID/Ping-proprietary request controls that can",
                "-                  help clients prevent inadvertently requesting unindexed searches.  The reject",
                "-                  unindexed search request control can be used to indicate that the server should",
                "-                  reject a search request if it cannot be efficiently processed using server",
                "-                  indexes, even if the requester has the unindexed-search privilege.  The permit",
                "-                  unindexed search request control can be used to indicate that the server should",
                "-                  process the search request even if it is unindexed, as long as the requester has",
                "-                  the unindexed-search-with-control privilege.  The <tt>ldapsearch</tt> tool has",
                "-                  also been updated allow these controls to be included in the search requests",
                "-                  that it generates.",
                "+                  Updated the command-line argument parser so that it will not assign a value from",
                "+                  a properties file to an argument if that argument is part of an exclusive",
                "+                  argument set and another argument in that set was provided on the command line.",
                "                   <br><br>",
                "@@ -39,7 +38,7 @@ ${TARGET=\"offline\"}                <br>",
                "                 <li>",
                "-                  Added support for a new UnboundID/Ping-proprietary request control that can be",
                "-                  included in a search request to indicate that the client wishes to override an",
                "-                  internal limit that might otherwise be in effect for that operation.  The",
                "-                  <tt>ldapsearch</tt> tool has been updated to allow this control to be included",
                "-                  in the search requests that it generates.",
                "+                  Fixed a <tt>manage-certificates</tt> bug in which the validity start time and",
                "+                  validity duration values would be ignored when generating a self-signed",
                "+                  certificate intended to replace an existing certificate.  In that case, the tool",
                "+                  would have always used the current time as the start time and a duration of one",
                "+                  year.",
                "                   <br><br>",
                "@@ -48,10 +47,10 @@ ${TARGET=\"offline\"}                <br>",
                "                 <li>",
                "-                  Added a new <tt>FixedBarrier.await(int)</tt> method that can be used to",
                "-                  request rate limiting for the specified number of occurrences, rather than just",
                "-                  a single occurrence.  This can be used to make it easier to impose rate limiting",
                "-                  in instances where the event that you're limiting doesn't fit into the",
                "-                  existing paradigm.  For example, it could be used to implement a rate-limited",
                "-                  output stream in which you want to be able to specify the number of bytes being",
                "-                  written at a time, instead of requiring a separate <tt>await()</tt> call for",
                "-                  each byte being written.",
                "+                  Updated the <tt>manage-certificates</tt> tool to change the primary name for the",
                "+                  existing <tt>--replace-existing-certificate</tt> argument in the",
                "+                  <tt>generate-certificate-signing-request</tt> subcommand to be",
                "+                  <tt>--use-existing-key-pair</tt>, and updated the usage information to make it",
                "+                  clearer that using this option will not cause the keystore to be updated.",
                "+                  The former <tt>--replace-existing-certificate</tt> identifier can still be used",
                "+                  and will behave in exactly the same way as before, so there is no change in",
                "+                  functionality.",
                "                   <br><br>",
                "@@ -60,5 +59,14 @@ ${TARGET=\"offline\"}                <br>",
                "                 <li>",
                "-                  Updated the command-line argument parser so that it will not assign a value from",
                "-                  a properties file to an argument if that argument is part of an exclusive",
                "-                  argument set and another argument in that set was provided on the command line.",
                "+                  Improved the usability of the <tt>ldap-debugger</tt> tool when using the",
                "+                  <tt>--listenUsingSSL</tt> argument by ensuring that the <tt>--keyStorePath</tt>",
                "+                  argument is also provided, along with one of the <tt>--keyStorePassword</tt>,",
                "+                  <tt>--keyStorePasswordFile</tt>, and <tt>--promptForKeyStorePassword</tt>",
                "+                  arguments.",
                "+                  <br><br>",
                "+                </li>",
                "+",
                "+                <li>",
                "+                  Fixed a number of cases in which there was a mismatch between the arguments",
                "+                  provided to a message format string and the arguments expected by that format",
                "+                  string.  Unit tests have been added to help prevent this from recurring.",
                "                   <br><br>",
                "@@ -92,19 +100,10 @@ ${TARGET=\"offline\"}                <br>",
                "                 <li>",
                "-                  Fixed a <tt>manage-certificates</tt> bug in which the validity start time and",
                "-                  validity duration values would be ignored when generating a self-signed",
                "-                  certificate intended to replace an existing certificate.  In that case, the tool",
                "-                  would have always used the current time as the start time and a duration of one",
                "-                  year.",
                "-                  <br><br>",
                "-                </li>",
                "-",
                "-                <li>",
                "-                  Updated the <tt>manage-certificates</tt> tool to change the primary name for the",
                "-                  existing <tt>--replace-existing-certificate</tt> argument in the",
                "-                  <tt>generate-certificate-signing-request</tt> subcommand to be",
                "-                  <tt>--use-existing-key-pair</tt>, and updated the usage information to make it",
                "-                  clearer that using this option will not cause the keystore to be updated.",
                "-                  The former <tt>--replace-existing-certificate</tt> identifier can still be used",
                "-                  and will behave in exactly the same way as before, so there is no change in",
                "-                  functionality.",
                "+                  Added a new <tt>FixedBarrier.await(int)</tt> method that can be used to",
                "+                  request rate limiting for the specified number of occurrences, rather than just",
                "+                  a single occurrence.  This can be used to make it easier to impose rate limiting",
                "+                  in instances where the event that you're limiting doesn't fit into the",
                "+                  existing paradigm.  For example, it could be used to implement a rate-limited",
                "+                  output stream in which you want to be able to specify the number of bytes being",
                "+                  written at a time, instead of requiring a separate <tt>await()</tt> call for",
                "+                  each byte being written.",
                "                   <br><br>",
                "@@ -121,5 +120,12 @@ ${TARGET=\"offline\"}                <br>",
                "                 <li>",
                "-                  Updated the <tt>summarize-access-log</tt> tool to add support for encrypted log",
                "-                  files.  The passphrase used to generate the encryption key can be provided",
                "-                  interactively or read from a file.",
                "+                  Added support for two new UnboundID/Ping-proprietary request controls that can",
                "+                  help clients prevent inadvertently requesting unindexed searches.  The reject",
                "+                  unindexed search request control can be used to indicate that the server should",
                "+                  reject a search request if it cannot be efficiently processed using server",
                "+                  indexes, even if the requester has the unindexed-search privilege.  The permit",
                "+                  unindexed search request control can be used to indicate that the server should",
                "+                  process the search request even if it is unindexed, as long as the requester has",
                "+                  the unindexed-search-with-control privilege.  The <tt>ldapsearch</tt> tool has",
                "+                  also been updated allow these controls to be included in the search requests",
                "+                  that it generates.",
                "                   <br><br>",
                "@@ -128,7 +134,7 @@ ${TARGET=\"offline\"}                <br>",
                "                 <li>",
                "-                  Improved the usability of the <tt>ldap-debugger</tt> tool when using the",
                "-                  <tt>--listenUsingSSL</tt> argument by ensuring that the <tt>--keyStorePath</tt>",
                "-                  argument is also provided, along with one of the <tt>--keyStorePassword</tt>,",
                "-                  <tt>--keyStorePasswordFile</tt>, and <tt>--promptForKeyStorePassword</tt>",
                "-                  arguments.",
                "+                  Added support for a new UnboundID/Ping-proprietary request control that can be",
                "+                  included in a search request to indicate that the client wishes to override an",
                "+                  internal limit that might otherwise be in effect for that operation.  The",
                "+                  <tt>ldapsearch</tt> tool has been updated to allow this control to be included",
                "+                  in the search requests that it generates.",
                "                   <br><br>",
                "@@ -137,5 +143,5 @@ ${TARGET=\"offline\"}                <br>",
                "                 <li>",
                "-                  Fixed a number of cases in which there was a mismatch between the arguments",
                "-                  provided to a message format string and the arguments expected by that format",
                "-                  string.  Unit tests have been added to help prevent this from recurring.",
                "+                  Updated the <tt>summarize-access-log</tt> tool to add support for encrypted log",
                "+                  files.  The passphrase used to generate the encryption key can be provided",
                "+                  interactively or read from a file.",
                "                   <br><br>"
            ],
            "changed_files": [
                "docs/release-notes.html"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [
                "CVE-2018-1000134"
            ],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "VULN_ID_IN_MESSAGE",
                    "message": "The commit message mentions the vulnerability ID",
                    "relevance": 64
                },
                {
                    "id": "RELEVANT_WORDS_IN_MESSAGE",
                    "message": "The commit message contains some relevant words: SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: UnboundID",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: version",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "d13541f620d5d6061c73ebd3bc13c40825f64787",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1520312323,
            "hunks": 6,
            "message": "Revert to PBKDF2WithHmacSHA1 Updated the passphrase-encrypted output stream to downgrade the baseline key factory algorithm from PBKDF2WithHmacSHA256 to PBKDF2WithHmacSHA1.  The LDAP SDK needs to support Java 7, and Java 7 doesn't support PBKDF2WithHmacSHA256.  If you're using a more modern JVM with support for strong encryption, you can request strong encryption, which will use a key factory algorithm of PBKDF2WithHmacSHA512 (as well as 256-bit AES).",
            "diff": [
                "diff --git a/src/com/unboundid/util/PassphraseEncryptedOutputStream.java b/src/com/unboundid/util/PassphraseEncryptedOutputStream.java",
                "index 4fe294db..9af8b468 100644",
                "--- a/src/com/unboundid/util/PassphraseEncryptedOutputStream.java",
                "+++ b/src/com/unboundid/util/PassphraseEncryptedOutputStream.java",
                "@@ -51,9 +51,11 @@ import javax.crypto.CipherOutputStream;",
                "  * baseline of 128-bit AES/CBC/PKCS5Padding using a key generated from the",
                "- * provided passphrase using the PBKDF2WithHmacSHA256 key factory algorithm with",
                "- * 16,384 iterations and a 128-bit (16-byte) salt.  However, if the output",
                "- * stream is configured to use strong encryption, then it will attempt to use",
                "- * 256-bit AES/CBC/PKCS5Padding with a PBKDF2WithHmacSHA512 key factory",
                "- * algorithm with 131,072 iterations and a 128-bit salt.  If the JVM does not",
                "- * support this level of encryption, then it will fall back to a key size of 128",
                "- * bits and a key factory algorithm of PBKDF2WithHmacSHA256.",
                "+ * provided passphrase using the PBKDF2WithHmacSHA1 key factory algorithm",
                "+ * (unfortunately, PBKDF2WithHmacSHA256 isn't available on Java 7, which is",
                "+ * still a supported Java version for the LDAP SDK) with 16,384 iterations and a",
                "+ * 128-bit (16-byte) salt.  However, if the  output stream is configured to use",
                "+ * strong encryption, then it will attempt to use 256-bit AES/CBC/PKCS5Padding",
                "+ * with a PBKDF2WithHmacSHA512 key factory algorithm with 131,072 iterations and",
                "+ * a 128-bit salt.  If the JVM does not support this level of encryption, then",
                "+ * it will fall back to a key size of 128 bits and a key factory algorithm of",
                "+ * PBKDF2WithHmacSHA1.",
                "  * <BR><BR>",
                "@@ -143,3 +145,3 @@ public final class PassphraseEncryptedOutputStream",
                "   private static final String BASELINE_KEY_FACTORY_ALGORITHM =",
                "-       \"PBKDF2WithHmacSHA256\";",
                "+       \"PBKDF2WithHmacSHA1\";",
                "diff --git a/tests/unit/src/com/unboundid/util/PassphraseEncryptedStreamsTestCase.java b/tests/unit/src/com/unboundid/util/PassphraseEncryptedStreamsTestCase.java",
                "index 41240f10..d16d1ba9 100644",
                "--- a/tests/unit/src/com/unboundid/util/PassphraseEncryptedStreamsTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/util/PassphraseEncryptedStreamsTestCase.java",
                "@@ -570,3 +570,3 @@ public final class PassphraseEncryptedStreamsTestCase",
                "       assertNotNull(header.getKeyFactoryAlgorithm());",
                "-      assertEquals(header.getKeyFactoryAlgorithm(), \"PBKDF2WithHmacSHA256\");",
                "+      assertEquals(header.getKeyFactoryAlgorithm(), \"PBKDF2WithHmacSHA1\");",
                "@@ -690,3 +690,3 @@ public final class PassphraseEncryptedStreamsTestCase",
                "               PassphraseEncryptedStreamHeader.TYPE_KEY_FACTORY_ALGORITHM,",
                "-              \"PBKDF2WithHmacSHA256\"),",
                "+              \"PBKDF2WithHmacSHA1\"),",
                "          new ASN1Integer(",
                "@@ -743,3 +743,3 @@ public final class PassphraseEncryptedStreamsTestCase",
                "               PassphraseEncryptedStreamHeader.TYPE_KEY_FACTORY_ALGORITHM,",
                "-              \"PBKDF2WithHmacSHA256\"),",
                "+              \"PBKDF2WithHmacSHA1\"),",
                "          new ASN1Integer(",
                "@@ -789,3 +789,3 @@ public final class PassphraseEncryptedStreamsTestCase",
                "               PassphraseEncryptedStreamHeader.TYPE_KEY_FACTORY_ALGORITHM,",
                "-              \"PBKDF2WithHmacSHA256\"));",
                "+              \"PBKDF2WithHmacSHA1\"));"
            ],
            "changed_files": [
                "src/com/unboundid/util/PassphraseEncryptedOutputStream.java",
                "tests/unit/src/com/unboundid/util/PassphraseEncryptedStreamsTestCase.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "RELEVANT_WORDS_IN_MESSAGE",
                    "message": "The commit message contains some relevant words: SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: tests/unit/src/com/unboundid/util/PassphraseEncryptedStreamsTestCase.java, src/com/unboundid/util/PassphraseEncryptedOutputStream.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: mode",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "942703d0fcb8197e2c1bb9842cf18cf911aa022d",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1521477639,
            "hunks": 2,
            "message": "Post-4.0.5 release updates Following the 4.0.5 release, the LDAP SDK has been updated to make the following changes: * New builds will now have a version of 4.0.6. * The public API of the 4.0.5 release has been preserved and the   unit test framework has been updated to ensure that the LDAP SDK   provides backward compatibility with that release.",
            "diff": [
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/APITestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/APITestCase.java",
                "index 519c1e0a..68c4d4c6 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/APITestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/APITestCase.java",
                "@@ -1410,3 +1410,4 @@ public class APITestCase",
                "       new Object[] { new File(resourceDir, \"public-api-4.0.3.txt\")  },",
                "-      new Object[] { new File(resourceDir, \"public-api-4.0.4.txt\")  }",
                "+      new Object[] { new File(resourceDir, \"public-api-4.0.4.txt\")  },",
                "+      new Object[] { new File(resourceDir, \"public-api-4.0.5.txt\")  }",
                "     };",
                "diff --git a/version.properties b/version.properties",
                "index 7c70b721..68037b73 100644",
                "--- a/version.properties",
                "+++ b/version.properties",
                "@@ -16,3 +16,3 @@ MINOR_VERSION=0",
                " # The point version number for the LDAP SDK.",
                "-POINT_VERSION=5",
                "+POINT_VERSION=6"
            ],
            "changed_files": [
                "tests/unit/src/com/unboundid/ldap/sdk/APITestCase.java",
                "version.properties"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "RELEVANT_WORDS_IN_MESSAGE",
                    "message": "The commit message contains some relevant words: SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: tests/unit/src/com/unboundid/ldap/sdk/APITestCase.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: provide, version",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid, version",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "d3fa3a09c46af010d7499c4ed12e3bf4ec59fd31",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1520129079,
            "hunks": 7,
            "message": "Add a CloseableLock class Added a new com.unbound.util.CloseableLock class that behaves like a ReentrantLock, but that can also be used in conjunction with Java's try-with-resources facility to guarantee that the lock is released when JVM execution leaves the try block.",
            "diff": [
                "diff --git a/docs/release-notes.html b/docs/release-notes.html",
                "index 849cf620..3e64c999 100644",
                "--- a/docs/release-notes.html",
                "+++ b/docs/release-notes.html",
                "@@ -64,2 +64,9 @@ ${TARGET=\"offline\"}                <br>",
                "+                <li>",
                "+                  Added a new <tt>CloseableLock</tt> class that provides the same basic",
                "+                  functionality as a Java <tt>ReentrantLock</tt>, but can also be used with Java's",
                "+                  try-with-resources facility.",
                "+                  <br><br>",
                "+                </li>",
                "+",
                "                 <li>",
                "diff --git a/messages/unboundid-ldapsdk-util.properties b/messages/unboundid-ldapsdk-util.properties",
                "index 32a142a2..eb9147aa 100644",
                "--- a/messages/unboundid-ldapsdk-util.properties",
                "+++ b/messages/unboundid-ldapsdk-util.properties",
                "@@ -809 +809,3 @@ ERR_PW_ENCRYPTED_HEADER_NO_KEY_AVAILABLE=Unable to create a cipher from the \\",
                "   decoding the header.",
                "+ERR_CLOSEABLE_LOCK_TRY_LOCK_TIMEOUT=Unable to acquire the closeable lock with \\",
                "+  a timeout of {0}.",
                "diff --git a/src/com/unboundid/util/CloseableLock.java b/src/com/unboundid/util/CloseableLock.java",
                "new file mode 100644",
                "index 00000000..d6b845df",
                "--- /dev/null",
                "+++ b/src/com/unboundid/util/CloseableLock.java",
                "@@ -0,0 +1,321 @@",
                "+/*",
                "+ * Copyright 2018 Ping Identity Corporation",
                "+ * All Rights Reserved.",
                "+ */",
                "+/*",
                "+ * Copyright (C) 2018 Ping Identity Corporation",
                "+ *",
                "+ * This program is free software; you can redistribute it and/or modify",
                "+ * it under the terms of the GNU General Public License (GPLv2 only)",
                "+ * or the terms of the GNU Lesser General Public License (LGPLv2.1 only)",
                "+ * as published by the Free Software Foundation.",
                "+ *",
                "+ * This program is distributed in the hope that it will be useful,",
                "+ * but WITHOUT ANY WARRANTY; without even the implied warranty of",
                "+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
                "+ * GNU General Public License for more details.",
                "+ *",
                "+ * You should have received a copy of the GNU General Public License",
                "+ * along with this program; if not, see <http://www.gnu.org/licenses>.",
                "+ */",
                "+package com.unboundid.util;",
                "+",
                "+",
                "+",
                "+import java.io.Closeable;",
                "+import java.util.concurrent.TimeUnit;",
                "+import java.util.concurrent.TimeoutException;",
                "+import java.util.concurrent.locks.ReentrantLock;",
                "+",
                "+import static com.unboundid.util.UtilityMessages.*;",
                "+",
                "+",
                "+",
                "+/**",
                "+ * This class provides an implementation of a reentrant lock that can be used",
                "+ * with the Java try-with-resources facility.  It does not implement the",
                "+ * {@code java.util.concurrent.locks.Lock} interface in order to ensure that it",
                "+ * can only be used through lock-with-resources mechanism, but it uses a",
                "+ * {@code java.util.concurrent.locks.ReentrantLock} behind the scenes to provide",
                "+ * its functionality.",
                "+ * <BR><BR>",
                "+ * <H2>Example</H2>",
                "+ * The following example demonstrates how to use this lock using the Java",
                "+ * try-with-resources facility:",
                "+ * <PRE>",
                "+ * // Wait for up to 5 seconds to acquire the lock.",
                "+ * try (final CloseableLock.Lock lock =",
                "+ *           closeableLock.tryLock(5L, TimeUnit.SECONDS))",
                "+ * {",
                "+ *   // Do something while the lock is held.  The lock will automatically be",
                "+ *   // released once code execution leaves this block.",
                "+ * }",
                "+ * catch (final InterruptedException e)",
                "+ * {",
                "+ *   // The thread was interrupted before the lock could be acquired.",
                "+ * }",
                "+ * catch (final TimeoutException)",
                "+ * {",
                "+ *   // The lock could not be acquired within the specified 5-second timeout.",
                "+ * }",
                "+ * </PRE>",
                "+ */",
                "+@Mutable()",
                "+@ThreadSafety(level=ThreadSafetyLevel.COMPLETELY_THREADSAFE)",
                "+public final class CloseableLock",
                "+{",
                "+  // The {@code Closeable} object that will be returned by all of the methods",
                "+  // used to acquire the lock.",
                "+  private final Lock lock;",
                "+",
                "+  // The reentrant lock that will be used to actually perform the locking.",
                "+  private final ReentrantLock reentrantLock;",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new instance of this lock with a non-fair ordering policy.",
                "+   */",
                "+  public CloseableLock()",
                "+  {",
                "+    this(false);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new instance of this lock with the specified ordering policy.",
                "+   *",
                "+   * @param  fair  Indicates whether the lock should use fair ordering.  If",
                "+   *               {@code true}, then if multiple threads are waiting on the",
                "+   *               lock, then the one that has been waiting the longest is the",
                "+   *               one that will get it.  If {@code false}, then no guarantee",
                "+   *               will be made about the order.  Fair ordering can incur a",
                "+   *               performance penalty.",
                "+   */",
                "+  public CloseableLock(final boolean fair)",
                "+  {",
                "+    reentrantLock = new ReentrantLock(fair);",
                "+    lock = new Lock(reentrantLock);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Acquires this lock, blocking until the lock is available.",
                "+   *",
                "+   * @return  The {@link Lock} instance that may be used to perform the",
                "+   *          unlock via the try-with-resources facility.",
                "+   */",
                "+  public Lock lock()",
                "+  {",
                "+    reentrantLock.lock();",
                "+    return lock;",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Acquires this lock, blocking until the lock is available.",
                "+   *",
                "+   * @return  The {@link Lock} instance that may be used to perform the unlock",
                "+   *          via the try-with-resources facility.",
                "+   *",
                "+   * @throws  InterruptedException  If the thread is interrupted while waiting",
                "+   *                                to acquire the lock.",
                "+   */",
                "+  public Lock lockInterruptibly()",
                "+         throws InterruptedException",
                "+  {",
                "+    reentrantLock.lockInterruptibly();",
                "+    return lock;",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tries to acquire the lock, waiting up to the specified length of time for",
                "+   * it to become available.",
                "+   *",
                "+   * @param  waitTime  The maximum length of time to wait for the lock.  It must",
                "+   *                   be greater than zero.",
                "+   * @param  timeUnit  The time unit that should be used when evaluating the",
                "+   *                   {@code waitTime} value.",
                "+   *",
                "+   * @return  The {@link Lock} instance that may be used to perform the unlock",
                "+   *          via the try-with-resources facility.",
                "+   *",
                "+   * @throws  InterruptedException  If the thread is interrupted while waiting",
                "+   *                                to acquire the lock.",
                "+   *",
                "+   * @throws  TimeoutException  If the lock could not be acquired within the",
                "+   *                            specified length of time.",
                "+   */",
                "+  public Lock tryLock(final long waitTime, final TimeUnit timeUnit)",
                "+         throws InterruptedException, TimeoutException",
                "+  {",
                "+    if (waitTime <= 0)",
                "+    {",
                "+      Validator.violation(",
                "+           \"CloseableLock.tryLock.waitTime must be greater than zero.  The \" +",
                "+                \"provided value was \" + waitTime);",
                "+    }",
                "+",
                "+    if (reentrantLock.tryLock(waitTime, timeUnit))",
                "+    {",
                "+      return lock;",
                "+    }",
                "+    else",
                "+    {",
                "+      throw new TimeoutException(ERR_CLOSEABLE_LOCK_TRY_LOCK_TIMEOUT.get(",
                "+           StaticUtils.millisToHumanReadableDuration(",
                "+                timeUnit.toMillis(waitTime))));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates whether this lock uses fair ordering.",
                "+   *",
                "+   * @return  {@code true} if this lock uses fair ordering, or {@code false} if",
                "+   *          not.",
                "+   */",
                "+  public boolean isFair()",
                "+  {",
                "+    return reentrantLock.isFair();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates whether this lock is currently held by any thread.",
                "+   *",
                "+   * @return  {@code true} if this lock is currently held by any thread, or",
                "+   *          {@code false} if not.",
                "+   */",
                "+  public boolean isLocked()",
                "+  {",
                "+    return reentrantLock.isLocked();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates whether this lock is currently held by the current thread.",
                "+   *",
                "+   * @return  {@code true} if this lock is currently held by the current thread,",
                "+   *          or {@code false} if not.",
                "+   */",
                "+  public boolean isHeldByCurrentThread()",
                "+  {",
                "+    return reentrantLock.isHeldByCurrentThread();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the number of holds that the current thread has on the lock.",
                "+   *",
                "+   * @return  The number of holds that the current thread has on the lock.",
                "+   */",
                "+  public int getHoldCount()",
                "+  {",
                "+    return reentrantLock.getHoldCount();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates whether any threads are currently waiting to acquire this lock.",
                "+   *",
                "+   * @return  {@code true} if any threads are currently waiting to acquire this",
                "+   *          lock, or {@code false} if not.",
                "+   */",
                "+  public boolean hasQueuedThreads()",
                "+  {",
                "+    return reentrantLock.hasQueuedThreads();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates whether the specified thread is currently waiting to acquire this",
                "+   * lock, or {@code false} if not.",
                "+   *",
                "+   * @param  thread  The thread for which to make the determination.  It must",
                "+   *                 not be {@code null}.",
                "+   *",
                "+   * @return  {@code true} if the specified thread is currently waiting to",
                "+   *          acquire this lock, or {@code false} if not.",
                "+   */",
                "+  public boolean hasQueuedThread(final Thread thread)",
                "+  {",
                "+    Validator.ensureNotNull(thread);",
                "+",
                "+    return reentrantLock.hasQueuedThread(thread);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the number of threads currently waiting to acquire this lock.",
                "+   *",
                "+   * @return  The number of threads currently waiting to acquire this lock.",
                "+   */",
                "+  public int getQueueLength()",
                "+  {",
                "+    return reentrantLock.getQueueLength();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves a string representation of this lock.",
                "+   *",
                "+   * @return  A string representation of this lock.",
                "+   */",
                "+  @Override()",
                "+  public String toString()",
                "+  {",
                "+    return \"CloseableLock(lock=\" + reentrantLock.toString() + ')';",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * This class provides a {@code Closeable} implementation that may be used to",
                "+   * unlock a {@link CloseableLock} via Java's try-with-resources",
                "+   * facility.",
                "+   */",
                "+  public final class Lock",
                "+         implements Closeable",
                "+  {",
                "+    // The associated reentrant lock.",
                "+    private final ReentrantLock lock;",
                "+",
                "+",
                "+",
                "+    /**",
                "+     * Creates a new instance with the provided lock.",
                "+     *",
                "+     * @param  lock  The lock that will be unlocked when the [@link #close()}",
                "+     *               method is called.  This must not be {@code null}.",
                "+     */",
                "+    private Lock(final ReentrantLock lock)",
                "+    {",
                "+      this.lock = lock;",
                "+    }",
                "+",
                "+",
                "+",
                "+    /**",
                "+     * Unlocks the associated lock.",
                "+     */",
                "+    @Override()",
                "+    public void close()",
                "+    {",
                "+      lock.unlock();",
                "+    }",
                "+  }",
                "+}",
                "diff --git a/src/com/unboundid/util/Validator.java b/src/com/unboundid/util/Validator.java",
                "index 944e3719..a35798aa 100644",
                "--- a/src/com/unboundid/util/Validator.java",
                "+++ b/src/com/unboundid/util/Validator.java",
                "@@ -354,2 +354,40 @@ public final class Validator",
                "   }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates that an expected condition was not true by throwing an",
                "+   * {@link LDAPSDKUsageException} with the provided information.",
                "+   *",
                "+   * @param  message  The message to use for the resulting exception.  It must",
                "+   *                  not be {@code null}.",
                "+   *",
                "+   * @throws  LDAPSDKUsageException  To indicate that a violation occurred.",
                "+   */",
                "+  public static void violation(final String message)",
                "+         throws LDAPSDKUsageException",
                "+  {",
                "+    violation(message, null);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates that an expected condition was not true by throwing an",
                "+   * {@link LDAPSDKUsageException} with the provided information.",
                "+   *",
                "+   * @param  message  The message to use for the resulting exception.  It must",
                "+   *                  not be {@code null}.",
                "+   * @param  cause    The exception that triggered the violation.  It may be",
                "+   *                  {@code null} if there is no associated exception.",
                "+   *",
                "+   * @throws  LDAPSDKUsageException  To indicate that a violation occurred.",
                "+   */",
                "+  public static void violation(final String message, final Throwable cause)",
                "+         throws LDAPSDKUsageException",
                "+  {",
                "+    final LDAPSDKUsageException e = new LDAPSDKUsageException(message, cause);",
                "+    debugCodingError(e);",
                "+    throw e;",
                "+  }",
                " }",
                "diff --git a/tests/unit/src/com/unboundid/util/CloseableLockTestCase.java b/tests/unit/src/com/unboundid/util/CloseableLockTestCase.java",
                "new file mode 100644",
                "index 00000000..2607a3e2",
                "--- /dev/null",
                "+++ b/tests/unit/src/com/unboundid/util/CloseableLockTestCase.java",
                "@@ -0,0 +1,213 @@",
                "+/*",
                "+ * Copyright 2018 Ping Identity Corporation",
                "+ * All Rights Reserved.",
                "+ */",
                "+/*",
                "+ * Copyright (C) 2018 Ping Identity Corporation",
                "+ *",
                "+ * This program is free software; you can redistribute it and/or modify",
                "+ * it under the terms of the GNU General Public License (GPLv2 only)",
                "+ * or the terms of the GNU Lesser General Public License (LGPLv2.1 only)",
                "+ * as published by the Free Software Foundation.",
                "+ *",
                "+ * This program is distributed in the hope that it will be useful,",
                "+ * but WITHOUT ANY WARRANTY; without even the implied warranty of",
                "+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
                "+ * GNU General Public License for more details.",
                "+ *",
                "+ * You should have received a copy of the GNU General Public License",
                "+ * along with this program; if not, see <http://www.gnu.org/licenses>.",
                "+ */",
                "+package com.unboundid.util;",
                "+",
                "+",
                "+",
                "+import java.util.concurrent.TimeUnit;",
                "+import java.util.concurrent.TimeoutException;",
                "+import java.util.concurrent.atomic.AtomicBoolean;",
                "+",
                "+import org.testng.annotations.Test;",
                "+",
                "+import com.unboundid.ldap.sdk.LDAPSDKTestCase;",
                "+",
                "+",
                "+",
                "+/**",
                "+ * This class provides a set of test cases for the {@code CloseableLock} class.",
                "+ */",
                "+public final class CloseableLockTestCase",
                "+       extends LDAPSDKTestCase",
                "+{",
                "+  /**",
                "+   * Tests basic lock functionality.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testLock()",
                "+         throws Exception",
                "+  {",
                "+    final CloseableLock lock = new CloseableLock();",
                "+",
                "+    assertFalse(lock.isFair());",
                "+    assertFalse(lock.isLocked());",
                "+    assertFalse(lock.isHeldByCurrentThread());",
                "+    assertEquals(lock.getHoldCount(), 0);",
                "+    assertFalse(lock.hasQueuedThreads());",
                "+    assertFalse(lock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(lock.getQueueLength(), 0);",
                "+    assertNotNull(lock.toString());",
                "+",
                "+    try (final CloseableLock.Lock l1 = lock.lock())",
                "+    {",
                "+      assertNotNull(l1);",
                "+",
                "+      assertFalse(lock.isFair());",
                "+      assertTrue(lock.isLocked());",
                "+      assertTrue(lock.isHeldByCurrentThread());",
                "+      assertEquals(lock.getHoldCount(), 1);",
                "+      assertFalse(lock.hasQueuedThreads());",
                "+      assertFalse(lock.hasQueuedThread(Thread.currentThread()));",
                "+      assertEquals(lock.getQueueLength(), 0);",
                "+      assertNotNull(lock.toString());",
                "+",
                "+      try (final CloseableLock.Lock l2 = lock.lockInterruptibly())",
                "+      {",
                "+        assertNotNull(l2);",
                "+",
                "+        assertFalse(lock.isFair());",
                "+        assertTrue(lock.isLocked());",
                "+        assertTrue(lock.isHeldByCurrentThread());",
                "+        assertEquals(lock.getHoldCount(), 2);",
                "+        assertFalse(lock.hasQueuedThreads());",
                "+        assertFalse(lock.hasQueuedThread(Thread.currentThread()));",
                "+        assertEquals(lock.getQueueLength(), 0);",
                "+        assertNotNull(lock.toString());",
                "+",
                "+        try (final CloseableLock.Lock l3 = lock.tryLock(1L, TimeUnit.SECONDS))",
                "+        {",
                "+          assertNotNull(l3);",
                "+",
                "+          assertFalse(lock.isFair());",
                "+          assertTrue(lock.isLocked());",
                "+          assertTrue(lock.isHeldByCurrentThread());",
                "+          assertEquals(lock.getHoldCount(), 3);",
                "+          assertFalse(lock.hasQueuedThreads());",
                "+          assertFalse(lock.hasQueuedThread(Thread.currentThread()));",
                "+          assertEquals(lock.getQueueLength(), 0);",
                "+          assertNotNull(lock.toString());",
                "+",
                "+          try (final CloseableLock.Lock l4 = lock.tryLock(0L, TimeUnit.SECONDS))",
                "+          {",
                "+            fail(\"Expected an exception when trying to acquire the lock with \" +",
                "+                 \"a timeout of zero seconds.  Instead, got lock \" + l4);",
                "+          }",
                "+          catch (final LDAPSDKUsageException e)",
                "+          {",
                "+            // This was expected.",
                "+          }",
                "+",
                "+          assertFalse(lock.isFair());",
                "+          assertTrue(lock.isLocked());",
                "+          assertTrue(lock.isHeldByCurrentThread());",
                "+          assertEquals(lock.getHoldCount(), 3);",
                "+          assertFalse(lock.hasQueuedThreads());",
                "+          assertFalse(lock.hasQueuedThread(Thread.currentThread()));",
                "+          assertEquals(lock.getQueueLength(), 0);",
                "+          assertNotNull(lock.toString());",
                "+",
                "+          assertNotNull(l3);",
                "+        }",
                "+",
                "+        assertFalse(lock.isFair());",
                "+        assertTrue(lock.isLocked());",
                "+        assertTrue(lock.isHeldByCurrentThread());",
                "+        assertEquals(lock.getHoldCount(), 2);",
                "+        assertFalse(lock.hasQueuedThreads());",
                "+        assertFalse(lock.hasQueuedThread(Thread.currentThread()));",
                "+        assertEquals(lock.getQueueLength(), 0);",
                "+        assertNotNull(lock.toString());",
                "+",
                "+        assertNotNull(l2);",
                "+      }",
                "+",
                "+      assertFalse(lock.isFair());",
                "+      assertTrue(lock.isLocked());",
                "+      assertTrue(lock.isHeldByCurrentThread());",
                "+      assertEquals(lock.getHoldCount(), 1);",
                "+      assertFalse(lock.hasQueuedThreads());",
                "+      assertFalse(lock.hasQueuedThread(Thread.currentThread()));",
                "+      assertEquals(lock.getQueueLength(), 0);",
                "+      assertNotNull(lock.toString());",
                "+",
                "+      assertNotNull(l1);",
                "+    }",
                "+",
                "+    assertFalse(lock.isFair());",
                "+    assertFalse(lock.isLocked());",
                "+    assertFalse(lock.isHeldByCurrentThread());",
                "+    assertEquals(lock.getHoldCount(), 0);",
                "+    assertFalse(lock.hasQueuedThreads());",
                "+    assertFalse(lock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(lock.getQueueLength(), 0);",
                "+    assertNotNull(lock.toString());",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to acquire the lock while it is held by",
                "+   * another thread.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testLockThatIsAlreadyHeld()",
                "+         throws Exception",
                "+  {",
                "+    final CloseableLock lock = new CloseableLock(true);",
                "+    final AtomicBoolean isLocked = new AtomicBoolean(false);",
                "+    final AtomicBoolean tryLockFailed = new AtomicBoolean(false);",
                "+",
                "+    assertTrue(lock.isFair());",
                "+    assertFalse(lock.isLocked());",
                "+    assertFalse(lock.isHeldByCurrentThread());",
                "+    assertEquals(lock.getHoldCount(), 0);",
                "+    assertFalse(lock.hasQueuedThreads());",
                "+    assertFalse(lock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(lock.getQueueLength(), 0);",
                "+    assertNotNull(lock.toString());",
                "+",
                "+    final CloseableLockTestCaseThread thread =",
                "+         new CloseableLockTestCaseThread(lock, isLocked, tryLockFailed);",
                "+    thread.start();",
                "+",
                "+    while (! isLocked.get())",
                "+    {",
                "+      Thread.sleep(1L);",
                "+    }",
                "+",
                "+    assertTrue(lock.isFair());",
                "+    assertTrue(lock.isLocked());",
                "+    assertFalse(lock.isHeldByCurrentThread());",
                "+    assertEquals(lock.getHoldCount(), 0); // Not held by current thread.",
                "+    assertFalse(lock.hasQueuedThreads());",
                "+    assertFalse(lock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(lock.getQueueLength(), 0);",
                "+    assertNotNull(lock.toString());",
                "+",
                "+    try (CloseableLock.Lock l = lock.tryLock(1L, TimeUnit.MILLISECONDS))",
                "+    {",
                "+      fail(\"Expected to fail to acquire the lock held by another thread, but \" +",
                "+           \"instead got \" + l);",
                "+    }",
                "+    catch (final TimeoutException e)",
                "+    {",
                "+      // This was expected.",
                "+      assertNotNull(e.getMessage());",
                "+    }",
                "+",
                "+    tryLockFailed.set(true);",
                "+    thread.join();",
                "+  }",
                "+}",
                "diff --git a/tests/unit/src/com/unboundid/util/CloseableLockTestCaseThread.java b/tests/unit/src/com/unboundid/util/CloseableLockTestCaseThread.java",
                "new file mode 100644",
                "index 00000000..a907264e",
                "--- /dev/null",
                "+++ b/tests/unit/src/com/unboundid/util/CloseableLockTestCaseThread.java",
                "@@ -0,0 +1,105 @@",
                "+/*",
                "+ * Copyright 2018 Ping Identity Corporation",
                "+ * All Rights Reserved.",
                "+ */",
                "+/*",
                "+ * Copyright (C) 2018 Ping Identity Corporation",
                "+ *",
                "+ * This program is free software; you can redistribute it and/or modify",
                "+ * it under the terms of the GNU General Public License (GPLv2 only)",
                "+ * or the terms of the GNU Lesser General Public License (LGPLv2.1 only)",
                "+ * as published by the Free Software Foundation.",
                "+ *",
                "+ * This program is distributed in the hope that it will be useful,",
                "+ * but WITHOUT ANY WARRANTY; without even the implied warranty of",
                "+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
                "+ * GNU General Public License for more details.",
                "+ *",
                "+ * You should have received a copy of the GNU General Public License",
                "+ * along with this program; if not, see <http://www.gnu.org/licenses>.",
                "+ */",
                "+package com.unboundid.util;",
                "+",
                "+",
                "+",
                "+import java.util.concurrent.atomic.AtomicBoolean;",
                "+",
                "+",
                "+",
                "+/**",
                "+ * This class provides a background thread that can be used in testing the",
                "+ * {@code CloseableLock} class.",
                "+ */",
                "+final class CloseableLockTestCaseThread",
                "+      extends Thread",
                "+{",
                "+  // Indicates whether the thread currently holds the lock.",
                "+  private final AtomicBoolean isLocked;",
                "+",
                "+  // Indicates whether the other thread has failed an attempt to acquire the",
                "+  // lock.",
                "+  private final AtomicBoolean tryLockFailed;",
                "+",
                "+  // The lock to use for testing.",
                "+  private final CloseableLock lock;",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new instance of this thread with the provided information.",
                "+   *",
                "+   * @param  lock           The lock that will be used for testing.",
                "+   * @param  isLocked       An {@code AtomicBoolean} instance that this thread",
                "+   *                        will update once it has acquired the lock.",
                "+   * @param  tryLockFailed  An {@code AtomicBoolean} value that the",
                "+   *                        {@code CloseableLockTestCase} instance will update",
                "+   *                        once it has failed to acquire the lock.",
                "+   */",
                "+  CloseableLockTestCaseThread(final CloseableLock lock,",
                "+                              final AtomicBoolean isLocked,",
                "+                              final AtomicBoolean tryLockFailed)",
                "+  {",
                "+    Validator.ensureNotNull(lock);",
                "+    Validator.ensureFalse(isLocked.get());",
                "+    Validator.ensureFalse(tryLockFailed.get());",
                "+",
                "+    setName(\"CloseableLockTestCase Thread\");",
                "+    setDaemon(true);",
                "+",
                "+    this.lock = lock;",
                "+    this.isLocked = isLocked;",
                "+    this.tryLockFailed = tryLockFailed;",
                "+",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Acquires the lock and waits for the {@code CloseableLockTestCase} thread to",
                "+   * fail to acquire it.",
                "+   */",
                "+  @Override()",
                "+  public void run()",
                "+  {",
                "+    Validator.ensureFalse(isLocked.get());",
                "+    Validator.ensureFalse(tryLockFailed.get());",
                "+",
                "+    try (final CloseableLock.Lock l = lock.lock())",
                "+    {",
                "+      Validator.ensureNotNull(l);",
                "+      isLocked.set(true);",
                "+",
                "+      while (! tryLockFailed.get())",
                "+      {",
                "+        try",
                "+        {",
                "+          Thread.sleep(1L);",
                "+        }",
                "+        catch (final Exception e)",
                "+        {",
                "+          Thread.yield();",
                "+        }",
                "+      }",
                "+    }",
                "+  }",
                "+}",
                "diff --git a/tests/unit/src/com/unboundid/util/ValidatorTestCase.java b/tests/unit/src/com/unboundid/util/ValidatorTestCase.java",
                "index e4a0376e..2df64499 100644",
                "--- a/tests/unit/src/com/unboundid/util/ValidatorTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/util/ValidatorTestCase.java",
                "@@ -298,2 +298,57 @@ public class ValidatorTestCase",
                "+  /**",
                "+   * Tests the {@code violation} method with a message but no cause.",
                "+   */",
                "+  @Test()",
                "+  public void testViolationWithoutCause()",
                "+  {",
                "+    final String message = \"This is the message.\";",
                "+",
                "+    try",
                "+    {",
                "+      Validator.violation(message);",
                "+      fail(\"Expected an exception when calling Validator.violation with no \" +",
                "+           \"cause\");",
                "+    }",
                "+    catch (final LDAPSDKUsageException e)",
                "+    {",
                "+      assertNotNull(e.getMessage());",
                "+      assertEquals(e.getMessage(), message);",
                "+",
                "+      assertNull(e.getCause());",
                "+    }",
                "+",
                "+    try",
                "+    {",
                "+      Validator.violation(message, null);",
                "+      fail(\"Expected an exception when calling Validator.violation with a \" +",
                "+           \"null cause\");",
                "+    }",
                "+    catch (final LDAPSDKUsageException e)",
                "+    {",
                "+      assertNotNull(e.getMessage());",
                "+      assertEquals(e.getMessage(), message);",
                "+",
                "+      assertNull(e.getCause());",
                "+    }",
                "+",
                "+    final RuntimeException cause = new RuntimeException();",
                "+    try",
                "+    {",
                "+      Validator.violation(message, cause);",
                "+      fail(\"Expected an exception when calling Validator.violation with a \" +",
                "+           \"non-null cause\");",
                "+    }",
                "+    catch (final LDAPSDKUsageException e)",
                "+    {",
                "+      assertNotNull(e.getMessage());",
                "+      assertEquals(e.getMessage(), message);",
                "+",
                "+      assertNotNull(e.getCause());",
                "+      assertEquals(e.getCause(), cause);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**"
            ],
            "changed_files": [
                "docs/release-notes.html",
                "messages/unboundid-ldapsdk-util.properties",
                "src/com/unboundid/util/CloseableLock.java",
                "src/com/unboundid/util/Validator.java",
                "tests/unit/src/com/unboundid/util/CloseableLockTestCase.java",
                "tests/unit/src/com/unboundid/util/CloseableLockTestCaseThread.java",
                "tests/unit/src/com/unboundid/util/ValidatorTestCase.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: tests/unit/src/com/unboundid/util/CloseableLockTestCaseThread.java, tests/unit/src/com/unboundid/util/ValidatorTestCase.java, src/com/unboundid/util/Validator.java, tests/unit/src/com/unboundid/util/CloseableLockTestCase.java, src/com/unboundid/util/CloseableLock.java, messages/unboundid-ldapsdk-util.properties",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: class",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "7d02fa0b94e2523c735e6da5fe20f287f9bd8ea5",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1521234250,
            "hunks": 14,
            "message": "Add an override search limits request control Added support for an UnboundID/Ping-proprietary control that can be included in a search request to allow the client to attempt to override various internal limits that might otherwise be in place for that operation.  The ldapsearch tool has also been updated to include support for this control.",
            "diff": [
                "diff --git a/docs/release-notes.html b/docs/release-notes.html",
                "index 81f0d251..96d1c165 100644",
                "--- a/docs/release-notes.html",
                "+++ b/docs/release-notes.html",
                "@@ -25,11 +25,21 @@ ${TARGET=\"offline\"}                <br>",
                "                 <li>",
                "-                  Added support for two new UnboundID/Ping-proprietary request controls.  The",
                "-                  reject unindexed search request control can be used to indicate that the server",
                "-                  should reject a search request if it cannot be efficiently processed using",
                "-                  server indexes, even if the requester has the unindexed-search privilege.  The",
                "-                  permit unindexed search request control can be used to indicate that the server",
                "-                  should process the search request even if it is unindexed, as long as the",
                "-                  requester has the unindexed-search-with-control privilege.  The",
                "-                  <tt>ldapsearch</tt> tool has also been updated allow these controls to be",
                "-                  included in the search requests that it generates.",
                "+                  Added support for two new UnboundID/Ping-proprietary request controls that can",
                "+                  help clients prevent inadvertently requesting unindexed searches.  The reject",
                "+                  unindexed search request control can be used to indicate that the server should",
                "+                  reject a search request if it cannot be efficiently processed using server",
                "+                  indexes, even if the requester has the unindexed-search privilege.  The permit",
                "+                  unindexed search request control can be used to indicate that the server should",
                "+                  process the search request even if it is unindexed, as long as the requester has",
                "+                  the unindexed-search-with-control privilege.  The <tt>ldapsearch</tt> tool has",
                "+                  also been updated allow these controls to be included in the search requests",
                "+                  that it generates.",
                "+                  <br><br>",
                "+                </li>",
                "+",
                "+                <li>",
                "+                  Added support for a new UnboundID/Ping-proprietary request control that can be",
                "+                  included in a search request to indicate that the client wishes to override an",
                "+                  internal limit that might otherwise be in effect for that operation.  The",
                "+                  <tt>ldapsearch</tt> tool has been updated to allow this control to be included",
                "+                  in the search requests that it generates.",
                "                   <br><br>",
                "diff --git a/messages/unboundid-ldapsdk-tools.properties b/messages/unboundid-ldapsdk-tools.properties",
                "index 69f6584c..4c2a9254 100644",
                "--- a/messages/unboundid-ldapsdk-tools.properties",
                "+++ b/messages/unboundid-ldapsdk-tools.properties",
                "@@ -1336,2 +1336,7 @@ INFO_LDAPMODIFY_ARG_DESCRIPTION_OPERATION_PURPOSE=Indicates that all \\",
                "   request control to provide the specified reason for the operation.",
                "+INFO_LDAPSEARCH_NAME_VALUE_PLACEHOLDER={name=value}",
                "+INFO_LDAPSEARCH_ARG_DESCRIPTION_OVERRIDE_SEARCH_LIMIT=Indicates that search \\",
                "+  operations should include the override search limits request control with \\",
                "+  the specified name-value pair.  This may be provided multiple times to \\",
                "+  specify multiple property name-value pairs to include in the control.",
                " INFO_LDAPMODIFY_ARG_DESCRIPTION_MULTI_UPDATE_ERROR_BEHAVIOR=Indicates that \\",
                "@@ -1995,2 +2000,15 @@ ERR_LDAPSEARCH_MATCHING_ENTRY_COUNT_INVALID_VALUE=The value provided for the \\",
                "   performed in the course of making the determination.",
                "+ERR_LDAPSEARCH_OVERRIDE_LIMIT_NO_EQUAL=A value provided for the ''{0}'' \\",
                "+  argument is invalid because it does not contain an equal sign to separate \\",
                "+  the property name from the value.",
                "+ERR_LDAPSEARCH_OVERRIDE_LIMIT_EMPTY_PROPERTY_NAME=A value provided for the \\",
                "+  ''{0}'' argument is invalid because it starts with an equal sign, \\",
                "+  indicating an empty property name.  Property names must not be empty.",
                "+ERR_LDAPSEARCH_OVERRIDE_LIMIT_DUPLICATE_PROPERTY_NAME=A value provided for \\",
                "+  the ''{0}'' argument is invalid because there are multiple attempts to set \\",
                "+  a value for property ''{1}''.  The same property cannot be set multiple \\",
                "+  times.",
                "+ERR_LDAPSEARCH_OVERRIDE_LIMIT_EMPTY_PROPERTY_VALUE=A value provided for the \\",
                "+  ''{0}'' argument is invalid because it contains an empty value for property \\",
                "+  ''{1}''.  Property values must not be empty.",
                " ERR_LDAPSEARCH_PERSISTENT_SEARCH_INVALID_VALUE=The value provided for the \\",
                "diff --git a/messages/unboundid-ldapsdk-unboundid-controls.properties b/messages/unboundid-ldapsdk-unboundid-controls.properties",
                "index b51003e1..916a15dd 100644",
                "--- a/messages/unboundid-ldapsdk-unboundid-controls.properties",
                "+++ b/messages/unboundid-ldapsdk-unboundid-controls.properties",
                "@@ -644 +644,21 @@ INFO_CONTROL_NAME_PERMIT_UNINDEXED_SEARCH_REQUEST=Permit Unindexed Search \\",
                "   Request Control",
                "+ERR_OVERRIDE_SEARCH_LIMITS_REQUEST_NO_VALUE=Unable to decode the provided \\",
                "+  control as an override search limits request control because the provided \\",
                "+  control does not have a value.",
                "+ERR_OVERRIDE_SEARCH_LIMITS_REQUEST_EMPTY_PROPERTY_NAME=Unable to decode the \\",
                "+  provided control as an override search limits request control because the \\",
                "+  provided control contained a property with an empty name.",
                "+ERR_OVERRIDE_SEARCH_LIMITS_REQUEST_EMPTY_PROPERTY_VALUE=Unable to decode the \\",
                "+  provided control as an override search limits request control because the \\",
                "+  provided control contained property ''{0}''' with an empty value.",
                "+ERR_OVERRIDE_SEARCH_LIMITS_REQUEST_DUPLICATE_PROPERTY_NAME=Unable to decode \\",
                "+  the provided control as an override search limits request control because \\",
                "+  the provided control contained multiple values for property ''{0}''.",
                "+ERR_OVERRIDE_SEARCH_LIMITS_REQUEST_CANNOT_DECODE_VALUE=Unable to decode the \\",
                "+  provided control as an override search limits request control because an \\",
                "+  error occurred while parsing the request value:  {0}",
                "+ERR_OVERRIDE_SEARCH_LIMITS_REQUEST_CONTROL_NO_PROPERTIES=Unable to decode the \\",
                "+  provided control as an override search limits request control because the \\",
                "+  control value did not include any properties.",
                "+INFO_OVERRIDE_SEARCH_LIMITS_REQUEST_CONTROL_NAME=Override Search Limits \\",
                "+  Request Control",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/controls/OverrideSearchLimitsRequestControl.java b/src/com/unboundid/ldap/sdk/unboundidds/controls/OverrideSearchLimitsRequestControl.java",
                "new file mode 100644",
                "index 00000000..a757e00f",
                "--- /dev/null",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/controls/OverrideSearchLimitsRequestControl.java",
                "@@ -0,0 +1,471 @@",
                "+/*",
                "+ * Copyright 2018 Ping Identity Corporation",
                "+ * All Rights Reserved.",
                "+ */",
                "+/*",
                "+ * Copyright (C) 2018 Ping Identity Corporation",
                "+ *",
                "+ * This program is free software; you can redistribute it and/or modify",
                "+ * it under the terms of the GNU General Public License (GPLv2 only)",
                "+ * or the terms of the GNU Lesser General Public License (LGPLv2.1 only)",
                "+ * as published by the Free Software Foundation.",
                "+ *",
                "+ * This program is distributed in the hope that it will be useful,",
                "+ * but WITHOUT ANY WARRANTY; without even the implied warranty of",
                "+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
                "+ * GNU General Public License for more details.",
                "+ *",
                "+ * You should have received a copy of the GNU General Public License",
                "+ * along with this program; if not, see <http://www.gnu.org/licenses>.",
                "+ */",
                "+package com.unboundid.ldap.sdk.unboundidds.controls;",
                "+",
                "+",
                "+",
                "+import java.util.ArrayList;",
                "+import java.util.Collections;",
                "+import java.util.Iterator;",
                "+import java.util.LinkedHashMap;",
                "+import java.util.Map;",
                "+",
                "+import com.unboundid.asn1.ASN1Element;",
                "+import com.unboundid.asn1.ASN1OctetString;",
                "+import com.unboundid.asn1.ASN1Sequence;",
                "+import com.unboundid.ldap.sdk.Control;",
                "+import com.unboundid.ldap.sdk.LDAPException;",
                "+import com.unboundid.ldap.sdk.ResultCode;",
                "+import com.unboundid.util.Debug;",
                "+import com.unboundid.util.NotMutable;",
                "+import com.unboundid.util.StaticUtils;",
                "+import com.unboundid.util.ThreadSafety;",
                "+import com.unboundid.util.ThreadSafetyLevel;",
                "+import com.unboundid.util.Validator;",
                "+",
                "+import static com.unboundid.ldap.sdk.unboundidds.controls.ControlMessages.*;",
                "+",
                "+",
                "+",
                "+/**",
                "+ * This class provides an implementation of a control that may be included in a",
                "+ * search request to override certain default limits that would normally be in",
                "+ * place for the operation.  The override behavior is specified using one or",
                "+ * more name-value pairs, with property names being case sensitive.",
                "+ * <BR>",
                "+ * <BLOCKQUOTE>",
                "+ *   <B>NOTE:</B>  This class, and other classes within the",
                "+ *   {@code com.unboundid.ldap.sdk.unboundidds} package structure, are only",
                "+ *   supported for use against Ping Identity, UnboundID, and Alcatel-Lucent 8661",
                "+ *   server products.  These classes provide support for proprietary",
                "+ *   functionality or for external specifications that are not considered stable",
                "+ *   or mature enough to be guaranteed to work in an interoperable way with",
                "+ *   other types of LDAP servers.",
                "+ * </BLOCKQUOTE>",
                "+ * <BR>",
                "+ * The control has an OID of 1.3.6.1.4.1.30221.2.5.56, a criticality of either",
                "+ * {@code true} or {@code false}, and a value with the provided encoding:",
                "+ *",
                "+ * that contains a mapping of one or",
                "+ * more case-sensitive property-value pairs.  Property names will be treated in",
                "+ * a case-sensitive manner.",
                "+ * the following encoding:",
                "+ * <PRE>",
                "+ *   OverrideSearchLimitsRequestValue ::= SEQUENCE OF SEQUENCE {",
                "+ *        propertyName      OCTET STRING,",
                "+ *        propertyValue     OCTET STRING }",
                "+ * </PRE>",
                "+ */",
                "+@NotMutable()",
                "+@ThreadSafety(level= ThreadSafetyLevel.COMPLETELY_THREADSAFE)",
                "+public final class OverrideSearchLimitsRequestControl",
                "+       extends Control",
                "+{",
                "+  /**",
                "+   * The OID (1.3.6.1.4.1.30221.2.5.56) for the override search limits request",
                "+   * control.",
                "+   */",
                "+  public static final String OVERRIDE_SEARCH_LIMITS_REQUEST_OID =",
                "+       \"1.3.6.1.4.1.30221.2.5.56\";",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * The serial version UID for this serializable class.",
                "+   */",
                "+  private static final long serialVersionUID = 3685279915414141978L;",
                "+",
                "+",
                "+",
                "+  // The set of properties included in this control.",
                "+  private final Map<String,String> properties;",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new instance of this override search limits request control with",
                "+   * the specified property name and value.  It will not be critical.",
                "+   *",
                "+   * @param  propertyName   The name of the property to set.  It must not be",
                "+   *                        {@code null} or empty.",
                "+   * @param  propertyValue  The value for the specified property.  It must not",
                "+   *                        be {@code null} or empty.",
                "+   */",
                "+  public OverrideSearchLimitsRequestControl(final String propertyName,",
                "+                                            final String propertyValue)",
                "+  {",
                "+    this(Collections.singletonMap(propertyName, propertyValue), false);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new instance of this override search limits request control with",
                "+   * the provided set of properties.",
                "+   *",
                "+   * @param  properties  The map of properties to set in this control.  It must",
                "+   *                     not be {@code null} or empty, and none of the keys or",
                "+   *                     values inside it may be {@code null} or empty.",
                "+   * @param  isCritical  Indicates whether the control should be considered",
                "+   *                     critical.",
                "+   */",
                "+  public OverrideSearchLimitsRequestControl(final Map<String,String> properties,",
                "+                                            final boolean isCritical)",
                "+  {",
                "+    super(OVERRIDE_SEARCH_LIMITS_REQUEST_OID, isCritical,",
                "+         encodeValue(properties));",
                "+",
                "+    this.properties =",
                "+         Collections.unmodifiableMap(new LinkedHashMap<>(properties));",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new instance of this override search limits request control that",
                "+   * is decoded from the provided generic control.",
                "+   *",
                "+   * @param  control  The generic control to decode as an override search limits",
                "+   *                  request control.  It must not be {@code null}.",
                "+   *",
                "+   * @throws  LDAPException  If the provided control cannot be decoded as an",
                "+   *                         override search limits request control.",
                "+   */",
                "+  public OverrideSearchLimitsRequestControl(final Control control)",
                "+         throws LDAPException",
                "+  {",
                "+    super(control);",
                "+",
                "+    final ASN1OctetString value = control.getValue();",
                "+    if (value == null)",
                "+    {",
                "+      throw new LDAPException(ResultCode.DECODING_ERROR,",
                "+           ERR_OVERRIDE_SEARCH_LIMITS_REQUEST_NO_VALUE.get());",
                "+    }",
                "+",
                "+    final LinkedHashMap<String,String> propertyMap = new LinkedHashMap<>(10);",
                "+    try",
                "+    {",
                "+      for (final ASN1Element valueElement :",
                "+           ASN1Sequence.decodeAsSequence(value.getValue()).elements())",
                "+      {",
                "+        final ASN1Element[] propertyElements =",
                "+             ASN1Sequence.decodeAsSequence(valueElement).elements();",
                "+        final String propertyName = ASN1OctetString.decodeAsOctetString(",
                "+             propertyElements[0]).stringValue();",
                "+        final String propertyValue = ASN1OctetString.decodeAsOctetString(",
                "+             propertyElements[1]).stringValue();",
                "+",
                "+        if (propertyName.isEmpty())",
                "+        {",
                "+          throw new LDAPException(ResultCode.DECODING_ERROR,",
                "+               ERR_OVERRIDE_SEARCH_LIMITS_REQUEST_EMPTY_PROPERTY_NAME.get());",
                "+        }",
                "+",
                "+        if (propertyValue.isEmpty())",
                "+        {",
                "+          throw new LDAPException(ResultCode.DECODING_ERROR,",
                "+               ERR_OVERRIDE_SEARCH_LIMITS_REQUEST_EMPTY_PROPERTY_VALUE.get(",
                "+                    propertyName));",
                "+        }",
                "+",
                "+        if (propertyMap.containsKey(propertyName))",
                "+        {",
                "+          throw new LDAPException(ResultCode.DECODING_ERROR,",
                "+               ERR_OVERRIDE_SEARCH_LIMITS_REQUEST_DUPLICATE_PROPERTY_NAME.get(",
                "+                    propertyName));",
                "+        }",
                "+",
                "+        propertyMap.put(propertyName, propertyValue);",
                "+      }",
                "+    }",
                "+    catch (final LDAPException e)",
                "+    {",
                "+      Debug.debugException(e);",
                "+      throw e;",
                "+    }",
                "+    catch (final Exception e)",
                "+    {",
                "+      Debug.debugException(e);",
                "+      throw new LDAPException(ResultCode.DECODING_ERROR,",
                "+           ERR_OVERRIDE_SEARCH_LIMITS_REQUEST_CANNOT_DECODE_VALUE.get(",
                "+                StaticUtils.getExceptionMessage(e)),",
                "+           e);",
                "+    }",
                "+",
                "+    if (propertyMap.isEmpty())",
                "+    {",
                "+      throw new LDAPException(ResultCode.DECODING_ERROR,",
                "+           ERR_OVERRIDE_SEARCH_LIMITS_REQUEST_CONTROL_NO_PROPERTIES.get());",
                "+    }",
                "+",
                "+    properties = Collections.unmodifiableMap(propertyMap);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Encodes the provided set of properties into an ASN.1 element suitable for",
                "+   * use as the value of this control.",
                "+   *",
                "+   * @param  properties  The map of properties to set in this control.  It must",
                "+   *                     not be {@code null} or empty, and none of the keys or",
                "+   *                     values inside it may be {@code null} or empty.",
                "+   *",
                "+   * @return  The ASN.1 octet string containing the encoded value.",
                "+   */",
                "+  static ASN1OctetString encodeValue(final Map<String,String> properties)",
                "+  {",
                "+    Validator.ensureTrue(((properties != null) && (! properties.isEmpty())),",
                "+         \"OverrideSearchLimitsRequestControl.<init>properties must not be \" +",
                "+              \"null or empty\");",
                "+",
                "+    final ArrayList<ASN1Element> propertyElements =",
                "+         new ArrayList<>(properties.size());",
                "+    for (final Map.Entry<String,String> e : properties.entrySet())",
                "+    {",
                "+      final String propertyName = e.getKey();",
                "+      final String propertyValue = e.getValue();",
                "+      Validator.ensureTrue(",
                "+           ((propertyName != null) && (! propertyName.isEmpty())),",
                "+           \"OverrideSearchLimitsRequestControl.<init>properties keys must \" +",
                "+                \"not be null or empty\");",
                "+      Validator.ensureTrue(",
                "+           ((propertyValue != null) && (! propertyValue.isEmpty())),",
                "+           \"OverrideSearchLimitsRequestControl.<init>properties values must \" +",
                "+                \"not be null or empty\");",
                "+",
                "+      propertyElements.add(new ASN1Sequence(",
                "+           new ASN1OctetString(propertyName),",
                "+           new ASN1OctetString(propertyValue)));",
                "+    }",
                "+",
                "+    return new ASN1OctetString(new ASN1Sequence(propertyElements).encode());",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves a map of the properties included in this request control.",
                "+   *",
                "+   * @return  A map of the properties included in this request control.",
                "+   */",
                "+  public Map<String,String> getProperties()",
                "+  {",
                "+    return properties;",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the value of the specified property.",
                "+   *",
                "+   * @param  propertyName  The name of the property for which to retrieve the",
                "+   *                       value.  It must not be {@code null} or empty, and it",
                "+   *                       will be treated in a case-sensitive manner.",
                "+   *",
                "+   * @return  The value of the requested property, or {@code null} if the",
                "+   *          property is not set in the control.",
                "+   */",
                "+  public String getProperty(final String propertyName)",
                "+  {",
                "+    Validator.ensureTrue(((propertyName != null) && (! propertyName.isEmpty())),",
                "+         \"OverrideSearchLimitsRequestControl.getProperty.propertyName must \" +",
                "+              \"not be null or empty.\");",
                "+",
                "+    return properties.get(propertyName);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the value of the specified property as a {@code Boolean}.",
                "+   *",
                "+   * @param  propertyName  The name of the property for which to retrieve the",
                "+   *                       value.  It must not be {@code null} or empty, and it",
                "+   *                       will be treated in a case-sensitive manner.",
                "+   * @param  defaultValue  The default value that will be used if the requested",
                "+   *                       property is not set or if its value cannot be parsed",
                "+   *                       as a {@code Boolean}.  It may be {@code null} if the",
                "+   *                       default value should be {@code null}.",
                "+   *",
                "+   * @return  The Boolean value of the requested property, or the provided",
                "+   *          default value if the property is not set or if its value cannot be",
                "+   *          parsed as a {@code Boolean}.",
                "+   */",
                "+  public Boolean getPropertyAsBoolean(final String propertyName,",
                "+                                      final Boolean defaultValue)",
                "+  {",
                "+    final String propertyValue = getProperty(propertyName);",
                "+    if (propertyValue == null)",
                "+    {",
                "+      return defaultValue;",
                "+    }",
                "+",
                "+    switch (StaticUtils.toLowerCase(propertyValue))",
                "+    {",
                "+      case \"true\":",
                "+      case \"t\":",
                "+      case \"yes\":",
                "+      case \"y\":",
                "+      case \"on\":",
                "+      case \"1\":",
                "+        return Boolean.TRUE;",
                "+      case \"false\":",
                "+      case \"f\":",
                "+      case \"no\":",
                "+      case \"n\":",
                "+      case \"off\":",
                "+      case \"0\":",
                "+        return Boolean.FALSE;",
                "+      default:",
                "+        return defaultValue;",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the value of the specified property as an {@code Integer}.",
                "+   *",
                "+   * @param  propertyName  The name of the property for which to retrieve the",
                "+   *                       value.  It must not be {@code null} or empty, and it",
                "+   *                       will be treated in a case-sensitive manner.",
                "+   * @param  defaultValue  The default value that will be used if the requested",
                "+   *                       property is not set or if its value cannot be parsed",
                "+   *                       as an {@code Integer}.  It may be {@code null} if the",
                "+   *                       default value should be {@code null}.",
                "+   *",
                "+   * @return  The integer value of the requested property, or the provided",
                "+   *          default value if the property is not set or if its value cannot be",
                "+   *          parsed as an {@code Integer}.",
                "+   */",
                "+  public Integer getPropertyAsInteger(final String propertyName,",
                "+                                      final Integer defaultValue)",
                "+  {",
                "+    final String propertyValue = getProperty(propertyName);",
                "+    if (propertyValue == null)",
                "+    {",
                "+      return defaultValue;",
                "+    }",
                "+",
                "+    try",
                "+    {",
                "+      return Integer.parseInt(propertyValue);",
                "+    }",
                "+    catch (final Exception e)",
                "+    {",
                "+      Debug.debugException(e);",
                "+      return defaultValue;",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the value of the specified property as a {@code Long}.",
                "+   *",
                "+   * @param  propertyName  The name of the property for which to retrieve the",
                "+   *                       value.  It must not be {@code null} or empty, and it",
                "+   *                       will be treated in a case-sensitive manner.",
                "+   * @param  defaultValue  The default value that will be used if the requested",
                "+   *                       property is not set or if its value cannot be parsed",
                "+   *                       as an {@code Long}.  It may be {@code null} if the",
                "+   *                       default value should be {@code null}.",
                "+   *",
                "+   * @return  The long value of the requested property, or the provided default",
                "+   *          value if the property is not set or if its value cannot be parsed",
                "+   *          as a {@code Long}.",
                "+   */",
                "+  public Long getPropertyAsLong(final String propertyName,",
                "+                                final Long defaultValue)",
                "+  {",
                "+    final String propertyValue = getProperty(propertyName);",
                "+    if (propertyValue == null)",
                "+    {",
                "+      return defaultValue;",
                "+    }",
                "+",
                "+    try",
                "+    {",
                "+      return Long.parseLong(propertyValue);",
                "+    }",
                "+    catch (final Exception e)",
                "+    {",
                "+      Debug.debugException(e);",
                "+      return defaultValue;",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the user-friendly name for this control, if available.  If no",
                "+   * user-friendly name has been defined, then the OID will be returned.",
                "+   *",
                "+   * @return  The user-friendly name for this control, or the OID if no",
                "+   *          user-friendly name is available.",
                "+   */",
                "+  @Override()",
                "+  public String getControlName()",
                "+  {",
                "+    return INFO_OVERRIDE_SEARCH_LIMITS_REQUEST_CONTROL_NAME.get();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Appends a string representation of this LDAP control to the provided",
                "+   * buffer.",
                "+   *",
                "+   * @param  buffer  The buffer to which to append the string representation of",
                "+   *                 this buffer.",
                "+   */",
                "+  @Override()",
                "+  public void toString(final StringBuilder buffer)",
                "+  {",
                "+    buffer.append(\"OverrideSearchLimitsRequestControl(oid='\");",
                "+    buffer.append(getOID());",
                "+    buffer.append(\"', isCritical=\");",
                "+    buffer.append(isCritical());",
                "+    buffer.append(\", properties={\");",
                "+",
                "+    final Iterator<Map.Entry<String,String>> iterator =",
                "+         properties.entrySet().iterator();",
                "+    while (iterator.hasNext())",
                "+    {",
                "+      final Map.Entry<String,String> e = iterator.next();",
                "+",
                "+      buffer.append('\\'');",
                "+      buffer.append(e.getKey());",
                "+      buffer.append(\"'='\");",
                "+      buffer.append(e.getValue());",
                "+      buffer.append('\\'');",
                "+",
                "+      if (iterator.hasNext())",
                "+      {",
                "+        buffer.append(\", \");",
                "+      }",
                "+    }",
                "+",
                "+    buffer.append(\"})\");",
                "+  }",
                "+}",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearch.java b/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearch.java",
                "index 4466c7b5..579858e1 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearch.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearch.java",
                "@@ -99,2 +99,3 @@ import com.unboundid.ldap.sdk.unboundidds.controls.",
                "             OperationPurposeRequestControl;",
                "+import com.unboundid.ldap.sdk.unboundidds.controls.OverrideSearchLimitsRequestControl;",
                " import com.unboundid.ldap.sdk.unboundidds.controls.PasswordPolicyRequestControl;",
                "@@ -241,2 +242,3 @@ public final class LDAPSearch",
                "   private StringArgument outputFormat = null;",
                "+  private StringArgument overrideSearchLimit = null;",
                "   private StringArgument persistentSearch = null;",
                "@@ -262,2 +264,4 @@ public final class LDAPSearch",
                "        matchingEntryCountRequestControl = null;",
                "+  private volatile OverrideSearchLimitsRequestControl",
                "+       overrideSearchLimitsRequestControl = null;",
                "   private volatile PersistentSearchRequestControl",
                "@@ -918,2 +922,12 @@ public final class LDAPSearch",
                "+    overrideSearchLimit = new StringArgument(null, \"overrideSearchLimit\",",
                "+         false, 0, INFO_LDAPSEARCH_NAME_VALUE_PLACEHOLDER.get(),",
                "+         INFO_LDAPSEARCH_ARG_DESCRIPTION_OVERRIDE_SEARCH_LIMIT.get());",
                "+    overrideSearchLimit.addLongIdentifier(\"overrideSearchLimits\", true);",
                "+    overrideSearchLimit.addLongIdentifier(\"override-search-limit\", true);",
                "+    overrideSearchLimit.addLongIdentifier(\"override-search-limits\", true);",
                "+    overrideSearchLimit.setArgumentGroupName(",
                "+         INFO_LDAPSEARCH_ARG_GROUP_CONTROLS.get());",
                "+    parser.addArgument(overrideSearchLimit);",
                "+",
                "     persistentSearch = new StringArgument('C', \"persistentSearch\", false, 1,",
                "@@ -1539,2 +1553,46 @@ public final class LDAPSearch",
                "+    // If we should include the override search limits request control, then",
                "+    // validate the provided values.",
                "+    if (overrideSearchLimit.isPresent())",
                "+    {",
                "+      final LinkedHashMap<String,String> properties = new LinkedHashMap<>(10);",
                "+      for (final String value : overrideSearchLimit.getValues())",
                "+      {",
                "+        final int equalPos = value.indexOf('=');",
                "+        if (equalPos < 0)",
                "+        {",
                "+          throw new ArgumentException(",
                "+               ERR_LDAPSEARCH_OVERRIDE_LIMIT_NO_EQUAL.get(",
                "+                    overrideSearchLimit.getIdentifierString()));",
                "+        }",
                "+        else if (equalPos == 0)",
                "+        {",
                "+          throw new ArgumentException(",
                "+               ERR_LDAPSEARCH_OVERRIDE_LIMIT_EMPTY_PROPERTY_NAME.get(",
                "+                    overrideSearchLimit.getIdentifierString()));",
                "+        }",
                "+",
                "+        final String propertyName = value.substring(0, equalPos);",
                "+        if (properties.containsKey(propertyName))",
                "+        {",
                "+          throw new ArgumentException(",
                "+               ERR_LDAPSEARCH_OVERRIDE_LIMIT_DUPLICATE_PROPERTY_NAME.get(",
                "+                    overrideSearchLimit.getIdentifierString(), propertyName));",
                "+        }",
                "+",
                "+        if (equalPos == (value.length() - 1))",
                "+        {",
                "+          throw new ArgumentException(",
                "+               ERR_LDAPSEARCH_OVERRIDE_LIMIT_EMPTY_PROPERTY_VALUE.get(",
                "+                    overrideSearchLimit.getIdentifierString(), propertyName));",
                "+        }",
                "+",
                "+        properties.put(propertyName, value.substring(equalPos+1));",
                "+      }",
                "+",
                "+      overrideSearchLimitsRequestControl =",
                "+           new OverrideSearchLimitsRequestControl(properties, false);",
                "+    }",
                "+",
                "+",
                "     // If we should use the persistent search request control, then validate",
                "@@ -2883,2 +2941,7 @@ public final class LDAPSearch",
                "+    if (overrideSearchLimitsRequestControl != null)",
                "+    {",
                "+      controls.add(overrideSearchLimitsRequestControl);",
                "+    }",
                "+",
                "     if (persistentSearchRequestControl != null)",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/controls/OverrideSearchLimitsRequestControlTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/controls/OverrideSearchLimitsRequestControlTestCase.java",
                "new file mode 100644",
                "index 00000000..fda614ba",
                "--- /dev/null",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/controls/OverrideSearchLimitsRequestControlTestCase.java",
                "@@ -0,0 +1,671 @@",
                "+/*",
                "+ * Copyright 2018 Ping Identity Corporation",
                "+ * All Rights Reserved.",
                "+ */",
                "+package com.unboundid.ldap.sdk.unboundidds.controls;",
                "+",
                "+",
                "+",
                "+import java.util.LinkedHashMap;",
                "+",
                "+import org.testng.annotations.DataProvider;",
                "+import org.testng.annotations.Test;",
                "+",
                "+import com.unboundid.asn1.ASN1OctetString;",
                "+import com.unboundid.asn1.ASN1Sequence;",
                "+import com.unboundid.ldap.sdk.Control;",
                "+import com.unboundid.ldap.sdk.LDAPException;",
                "+import com.unboundid.ldap.sdk.LDAPSDKTestCase;",
                "+import com.unboundid.util.LDAPSDKUsageException;",
                "+",
                "+",
                "+",
                "+/**",
                "+ * This class defines a set of test cases for the override search limits request",
                "+ * control.",
                "+ */",
                "+public final class OverrideSearchLimitsRequestControlTestCase",
                "+       extends LDAPSDKTestCase",
                "+{",
                "+  /**",
                "+   * Tests the behavior of a control created with the constructor that allows a",
                "+   * single property to be set.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testSinglePropertyConstructor()",
                "+         throws Exception",
                "+  {",
                "+    OverrideSearchLimitsRequestControl c =",
                "+         new OverrideSearchLimitsRequestControl(\"propertyName\",",
                "+              \"propertyValue\");",
                "+",
                "+    c = new OverrideSearchLimitsRequestControl(c);",
                "+",
                "+    assertNotNull(c.getOID());",
                "+    assertEquals(c.getOID(), \"1.3.6.1.4.1.30221.2.5.56\");",
                "+",
                "+    assertFalse(c.isCritical());",
                "+",
                "+    assertTrue(c.hasValue());",
                "+    assertNotNull(c.getValue());",
                "+",
                "+    assertNotNull(c.getProperties());",
                "+    assertFalse(c.getProperties().isEmpty());",
                "+    assertEquals(c.getProperties().size(), 1);",
                "+",
                "+    assertNotNull(c.getProperty(\"propertyName\"));",
                "+    assertEquals(c.getProperty(\"propertyName\"), \"propertyValue\");",
                "+",
                "+    assertNull(c.getProperty(\"propertyName\".toLowerCase()));",
                "+    assertNull(c.getProperty(\"propertyName\".toUpperCase()));",
                "+",
                "+    assertNull(c.getProperty(\"undefinedProperty\"));",
                "+",
                "+    assertNull(c.getPropertyAsBoolean(\"propertyName\", null));",
                "+",
                "+    assertNull(c.getPropertyAsBoolean(\"undefinedProperty\", null));",
                "+",
                "+    assertNull(c.getPropertyAsInteger(\"propertyName\", null));",
                "+",
                "+    assertNull(c.getPropertyAsInteger(\"undefinedProperty\", null));",
                "+",
                "+    assertNull(c.getPropertyAsLong(\"propertyName\", null));",
                "+",
                "+    assertNull(c.getPropertyAsLong(\"undefinedProperty\", null));",
                "+",
                "+    assertNotNull(c.getControlName());",
                "+",
                "+    assertNotNull(c.toString());",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior of a control created with the constructor that takes a",
                "+   * map of properties.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testPropertyMapConstructor()",
                "+         throws Exception",
                "+  {",
                "+    final LinkedHashMap<String,String> propertyMap = new LinkedHashMap<>(10);",
                "+    propertyMap.put(\"stringValue\", \"hello\");",
                "+    propertyMap.put(\"trueValue\", \"true\");",
                "+    propertyMap.put(\"falseValue\", \"false\");",
                "+    propertyMap.put(\"zeroValue\", \"0\");",
                "+    propertyMap.put(\"positiveOneValue\", \"1\");",
                "+    propertyMap.put(\"negativeOneValue\", \"-1\");",
                "+    propertyMap.put(\"integerMaxValue\", String.valueOf(Integer.MAX_VALUE));",
                "+    propertyMap.put(\"integerMinValue\", String.valueOf(Integer.MIN_VALUE));",
                "+    propertyMap.put(\"longMaxValue\", String.valueOf(Long.MAX_VALUE));",
                "+    propertyMap.put(\"longMinValue\", String.valueOf(Long.MIN_VALUE));",
                "+",
                "+    OverrideSearchLimitsRequestControl c =",
                "+         new OverrideSearchLimitsRequestControl(propertyMap, true);",
                "+",
                "+    c = new OverrideSearchLimitsRequestControl(c);",
                "+",
                "+    assertNotNull(c.getOID());",
                "+    assertEquals(c.getOID(), \"1.3.6.1.4.1.30221.2.5.56\");",
                "+",
                "+    assertTrue(c.isCritical());",
                "+",
                "+    assertTrue(c.hasValue());",
                "+    assertNotNull(c.getValue());",
                "+",
                "+    assertNotNull(c.getProperties());",
                "+    assertFalse(c.getProperties().isEmpty());",
                "+    assertEquals(c.getProperties().size(), 10);",
                "+",
                "+    assertNotNull(c.getProperty(\"stringValue\"));",
                "+    assertEquals(c.getProperty(\"stringValue\"), \"hello\");",
                "+    assertNull(c.getPropertyAsBoolean(\"stringValue\", null));",
                "+    assertNull(c.getPropertyAsInteger(\"stringValue\", null));",
                "+    assertNull(c.getPropertyAsLong(\"stringValue\", null));",
                "+",
                "+    assertNotNull(c.getPropertyAsBoolean(\"stringValue\", Boolean.TRUE));",
                "+    assertEquals(c.getPropertyAsBoolean(\"stringValue\", Boolean.TRUE),",
                "+         Boolean.TRUE);",
                "+",
                "+    assertNotNull(c.getPropertyAsBoolean(\"stringValue\", Boolean.FALSE));",
                "+    assertEquals(c.getPropertyAsBoolean(\"stringValue\", Boolean.FALSE),",
                "+         Boolean.FALSE);",
                "+",
                "+    assertNotNull(c.getPropertyAsInteger(\"stringValue\", 1234));",
                "+    assertEquals(c.getPropertyAsInteger(\"stringValue\", 1234),",
                "+         Integer.valueOf(1234));",
                "+",
                "+    assertNotNull(c.getPropertyAsLong(\"stringValue\", 1234L));",
                "+    assertEquals(c.getPropertyAsLong(\"stringValue\", 1234L),",
                "+         Long.valueOf(1234L));",
                "+",
                "+    assertNotNull(c.getProperty(\"trueValue\"));",
                "+    assertEquals(c.getProperty(\"trueValue\"), \"true\");",
                "+    assertNotNull(c.getPropertyAsBoolean(\"trueValue\", null));",
                "+    assertEquals(c.getPropertyAsBoolean(\"trueValue\", null), Boolean.TRUE);",
                "+    assertNull(c.getPropertyAsInteger(\"trueValue\", null));",
                "+    assertNull(c.getPropertyAsLong(\"trueValue\", null));",
                "+",
                "+    assertNotNull(c.getProperty(\"falseValue\"));",
                "+    assertEquals(c.getProperty(\"falseValue\"), \"false\");",
                "+    assertNotNull(c.getPropertyAsBoolean(\"falseValue\", null));",
                "+    assertEquals(c.getPropertyAsBoolean(\"falseValue\", null), Boolean.FALSE);",
                "+    assertNull(c.getPropertyAsInteger(\"falseValue\", null));",
                "+    assertNull(c.getPropertyAsLong(\"falseValue\", null));",
                "+",
                "+    assertNotNull(c.getProperty(\"zeroValue\"));",
                "+    assertEquals(c.getProperty(\"zeroValue\"), \"0\");",
                "+    assertNotNull(c.getPropertyAsBoolean(\"zeroValue\", null));",
                "+    assertEquals(c.getPropertyAsBoolean(\"zeroValue\", null), Boolean.FALSE);",
                "+    assertNotNull(c.getPropertyAsInteger(\"zeroValue\", null));",
                "+    assertEquals(c.getPropertyAsInteger(\"zeroValue\", null), Integer.valueOf(0));",
                "+    assertNotNull(c.getPropertyAsLong(\"zeroValue\", null));",
                "+    assertEquals(c.getPropertyAsLong(\"zeroValue\", null), Long.valueOf(0L));",
                "+",
                "+    assertNotNull(c.getProperty(\"positiveOneValue\"));",
                "+    assertEquals(c.getProperty(\"positiveOneValue\"), \"1\");",
                "+    assertNotNull(c.getPropertyAsBoolean(\"positiveOneValue\", null));",
                "+    assertEquals(c.getPropertyAsBoolean(\"positiveOneValue\", null),",
                "+         Boolean.TRUE);",
                "+    assertNotNull(c.getPropertyAsInteger(\"positiveOneValue\", null));",
                "+    assertEquals(c.getPropertyAsInteger(\"positiveOneValue\", null),",
                "+         Integer.valueOf(1));",
                "+    assertNotNull(c.getPropertyAsLong(\"positiveOneValue\", null));",
                "+    assertEquals(c.getPropertyAsLong(\"positiveOneValue\", null),",
                "+         Long.valueOf(1L));",
                "+",
                "+    assertNotNull(c.getProperty(\"negativeOneValue\"));",
                "+    assertEquals(c.getProperty(\"negativeOneValue\"), \"-1\");",
                "+    assertNull(c.getPropertyAsBoolean(\"negativeOneValue\", null));",
                "+    assertNotNull(c.getPropertyAsInteger(\"negativeOneValue\", null));",
                "+    assertEquals(c.getPropertyAsInteger(\"negativeOneValue\", null),",
                "+         Integer.valueOf(-1));",
                "+    assertNotNull(c.getPropertyAsLong(\"negativeOneValue\", null));",
                "+    assertEquals(c.getPropertyAsLong(\"negativeOneValue\", null),",
                "+         Long.valueOf(-1L));",
                "+",
                "+    assertNotNull(c.getProperty(\"integerMaxValue\"));",
                "+    assertEquals(c.getProperty(\"integerMaxValue\"),",
                "+         String.valueOf(Integer.MAX_VALUE));",
                "+    assertNull(c.getPropertyAsBoolean(\"integerMaxValue\", null));",
                "+    assertNotNull(c.getPropertyAsInteger(\"integerMaxValue\", null));",
                "+    assertEquals(c.getPropertyAsInteger(\"integerMaxValue\", null),",
                "+         Integer.valueOf(Integer.MAX_VALUE));",
                "+    assertNotNull(c.getPropertyAsLong(\"integerMaxValue\", null));",
                "+    assertEquals(c.getPropertyAsLong(\"integerMaxValue\", null),",
                "+         Long.valueOf(Integer.MAX_VALUE));",
                "+",
                "+    assertNotNull(c.getProperty(\"integerMinValue\"));",
                "+    assertEquals(c.getProperty(\"integerMinValue\"),",
                "+         String.valueOf(Integer.MIN_VALUE));",
                "+    assertNull(c.getPropertyAsBoolean(\"integerMinValue\", null));",
                "+    assertNotNull(c.getPropertyAsInteger(\"integerMinValue\", null));",
                "+    assertEquals(c.getPropertyAsInteger(\"integerMinValue\", null),",
                "+         Integer.valueOf(Integer.MIN_VALUE));",
                "+    assertNotNull(c.getPropertyAsLong(\"integerMinValue\", null));",
                "+    assertEquals(c.getPropertyAsLong(\"integerMinValue\", null),",
                "+         Long.valueOf(Integer.MIN_VALUE));",
                "+",
                "+    assertNotNull(c.getProperty(\"longMaxValue\"));",
                "+    assertEquals(c.getProperty(\"longMaxValue\"),",
                "+         String.valueOf(Long.MAX_VALUE));",
                "+    assertNull(c.getPropertyAsBoolean(\"longMaxValue\", null));",
                "+    assertNull(c.getPropertyAsInteger(\"longMaxValue\", null));",
                "+    assertNotNull(c.getPropertyAsLong(\"longMaxValue\", null));",
                "+    assertEquals(c.getPropertyAsLong(\"longMaxValue\", null),",
                "+         Long.valueOf(Long.MAX_VALUE));",
                "+",
                "+    assertNotNull(c.getProperty(\"longMinValue\"));",
                "+    assertEquals(c.getProperty(\"longMinValue\"),",
                "+         String.valueOf(Long.MIN_VALUE));",
                "+    assertNull(c.getPropertyAsBoolean(\"longMinValue\", null));",
                "+    assertNull(c.getPropertyAsInteger(\"longMinValue\", null));",
                "+    assertNotNull(c.getPropertyAsLong(\"longMinValue\", null));",
                "+    assertEquals(c.getPropertyAsLong(\"longMinValue\", null),",
                "+         Long.valueOf(Long.MIN_VALUE));",
                "+",
                "+    assertNotNull(c.getControlName());",
                "+",
                "+    assertNotNull(c.toString());",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior of the {@code getPropertyAsBoolean} method with the",
                "+   * provided value.",
                "+   *",
                "+   * @param  stringValue   The string value to use when testing.",
                "+   * @param  booleanValue  The expected return value from the",
                "+   *                       {@code getPropertyAsBoolean} method.",
                "+   */",
                "+  @Test(dataProvider = \"getPropertyAsBooleanTestData\")",
                "+  public void testGetPropertyAsBoolean(final String stringValue,",
                "+                                       final Boolean booleanValue)",
                "+  {",
                "+    final OverrideSearchLimitsRequestControl c =",
                "+         new OverrideSearchLimitsRequestControl(\"name\", stringValue);",
                "+",
                "+    assertEquals(c.getPropertyAsBoolean(\"name\", null), booleanValue);",
                "+",
                "+    if (booleanValue == null)",
                "+    {",
                "+      assertNull(c.getPropertyAsBoolean(\"name\", null));",
                "+",
                "+      assertNotNull(c.getPropertyAsBoolean(\"name\", Boolean.TRUE));",
                "+      assertEquals(c.getPropertyAsBoolean(\"name\", Boolean.TRUE), Boolean.TRUE);",
                "+",
                "+      assertNotNull(c.getPropertyAsBoolean(\"name\", Boolean.FALSE));",
                "+      assertEquals(c.getPropertyAsBoolean(\"name\", Boolean.FALSE),",
                "+           Boolean.FALSE);",
                "+    }",
                "+    else",
                "+    {",
                "+      assertNotNull(c.getPropertyAsBoolean(\"name\", null));",
                "+",
                "+      assertNotNull(c.getPropertyAsBoolean(\"name\", Boolean.TRUE));",
                "+      assertEquals(c.getPropertyAsBoolean(\"name\", Boolean.TRUE), booleanValue);",
                "+",
                "+      assertNotNull(c.getPropertyAsBoolean(\"name\", Boolean.FALSE));",
                "+      assertEquals(c.getPropertyAsBoolean(\"name\", Boolean.FALSE), booleanValue);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves a set of data to use when testing the",
                "+   * {@code getPropertyAsBoolean} method.",
                "+   *",
                "+   * @return  A set of data to use when testing the {@code getPropertyAsBoolean}",
                "+   *          method.",
                "+   */",
                "+  @DataProvider(name=\"getPropertyAsBooleanTestData\")",
                "+  public Object[][] getGetPropertyAsBooleanTestData()",
                "+  {",
                "+    return new Object[][]",
                "+    {",
                "+      new Object[]",
                "+      {",
                "+        \"true\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"TRUE\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"True\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"t\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"T\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"yes\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"YES\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"Yes\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"y\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"Y\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"on\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"ON\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"On\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"1\",",
                "+        Boolean.TRUE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"false\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"FALSE\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"False\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"f\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"F\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"no\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"NO\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"No\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"n\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"N\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"off\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"OFF\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"Off\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"0\",",
                "+        Boolean.FALSE",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"I guess\",",
                "+        null",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        \"2\",",
                "+        null",
                "+      },",
                "+    };",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to retrieve a property with a {@code null}",
                "+   * property name.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetPropertyNullPropertyName()",
                "+         throws Exception",
                "+  {",
                "+    final OverrideSearchLimitsRequestControl c =",
                "+         new OverrideSearchLimitsRequestControl(\"name\", \"value\");",
                "+",
                "+    c.getProperty(null);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to retrieve a property with an empty",
                "+   * property name.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetPropertyEmptyPropertyName()",
                "+         throws Exception",
                "+  {",
                "+    final OverrideSearchLimitsRequestControl c =",
                "+         new OverrideSearchLimitsRequestControl(\"name\", \"value\");",
                "+",
                "+    c.getProperty(\"\");",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to encode a control with a {@code null}",
                "+   * property map.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testEncodeNullPropertyMap()",
                "+         throws Exception",
                "+  {",
                "+    OverrideSearchLimitsRequestControl.encodeValue(null);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to encode a control with an empty property",
                "+   * map.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testEncodeEmptyPropertyMap()",
                "+         throws Exception",
                "+  {",
                "+    final LinkedHashMap<String,String> propertyMap = new LinkedHashMap<>(0);",
                "+    OverrideSearchLimitsRequestControl.encodeValue(propertyMap);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to encode a control with a property map that",
                "+   * contains an empty key.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testEncodePropertyMapWithEmptyKey()",
                "+         throws Exception",
                "+  {",
                "+    final LinkedHashMap<String,String> propertyMap = new LinkedHashMap<>(1);",
                "+    propertyMap.put(\"\", \"value\");",
                "+",
                "+    OverrideSearchLimitsRequestControl.encodeValue(propertyMap);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to encode a control with a property map that",
                "+   * contains an empty value.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testEncodePropertyMapWithEmptyValue()",
                "+         throws Exception",
                "+  {",
                "+    final LinkedHashMap<String,String> propertyMap = new LinkedHashMap<>(1);",
                "+    propertyMap.put(\"key\", \"\");",
                "+",
                "+    OverrideSearchLimitsRequestControl.encodeValue(propertyMap);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to decode a control that does not have a",
                "+   * value.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPException.class })",
                "+  public void testDecodeControlWithoutValue()",
                "+         throws Exception",
                "+  {",
                "+    final Control c = new Control(\"1.3.6.1.4.1.30221.2.5.56\", false);",
                "+    new OverrideSearchLimitsRequestControl(c);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to decode a control whose value is not an",
                "+   * ASN.1 sequence.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPException.class })",
                "+  public void testDecodeControlValueNotSequence()",
                "+         throws Exception",
                "+  {",
                "+    final Control c = new Control(\"1.3.6.1.4.1.30221.2.5.56\", false,",
                "+         new ASN1OctetString(\"this is not a sequence\"));",
                "+    new OverrideSearchLimitsRequestControl(c);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to decode a control whose value sequence is",
                "+   * empty.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPException.class })",
                "+  public void testDecodeControlEmptyValueSequence()",
                "+         throws Exception",
                "+  {",
                "+    final ASN1Sequence valueSequence = new ASN1Sequence();",
                "+",
                "+    final Control c = new Control(\"1.3.6.1.4.1.30221.2.5.56\", false,",
                "+         new ASN1OctetString(valueSequence.encode()));",
                "+    new OverrideSearchLimitsRequestControl(c);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to decode a control whose value sequence",
                "+   * contains a property with an empty name.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPException.class })",
                "+  public void testDecodeControlEmptyPropertyName()",
                "+         throws Exception",
                "+  {",
                "+    final ASN1Sequence valueSequence = new ASN1Sequence(",
                "+         new ASN1Sequence(",
                "+              new ASN1OctetString(\"\"),",
                "+              new ASN1OctetString(\"value\")));",
                "+",
                "+    final Control c = new Control(\"1.3.6.1.4.1.30221.2.5.56\", false,",
                "+         new ASN1OctetString(valueSequence.encode()));",
                "+    new OverrideSearchLimitsRequestControl(c);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to decode a control whose value sequence",
                "+   * contains a property with an empty value.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPException.class })",
                "+  public void testDecodeControlEmptyPropertyValue()",
                "+         throws Exception",
                "+  {",
                "+    final ASN1Sequence valueSequence = new ASN1Sequence(",
                "+         new ASN1Sequence(",
                "+              new ASN1OctetString(\"name\"),",
                "+              new ASN1OctetString(\"\")));",
                "+",
                "+    final Control c = new Control(\"1.3.6.1.4.1.30221.2.5.56\", false,",
                "+         new ASN1OctetString(valueSequence.encode()));",
                "+    new OverrideSearchLimitsRequestControl(c);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to decode a control whose value sequence",
                "+   * contains multiple properties with the same name.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPException.class })",
                "+  public void testDecodeControlDuplicatePropertyName()",
                "+         throws Exception",
                "+  {",
                "+    final ASN1Sequence valueSequence = new ASN1Sequence(",
                "+         new ASN1Sequence(",
                "+              new ASN1OctetString(\"name1\"),",
                "+              new ASN1OctetString(\"value1\")),",
                "+         new ASN1Sequence(",
                "+              new ASN1OctetString(\"name2\"),",
                "+              new ASN1OctetString(\"value2\")),",
                "+         new ASN1Sequence(",
                "+              new ASN1OctetString(\"name1\"),",
                "+              new ASN1OctetString(\"value3\")));",
                "+",
                "+    final Control c = new Control(\"1.3.6.1.4.1.30221.2.5.56\", false,",
                "+         new ASN1OctetString(valueSequence.encode()));",
                "+    new OverrideSearchLimitsRequestControl(c);",
                "+  }",
                "+}",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearchTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearchTestCase.java",
                "index 79e301a1..3f77a026 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearchTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearchTestCase.java",
                "@@ -304,2 +304,4 @@ public final class LDAPSearchTestCase",
                "                    \":slowShortCircuitThreshold=100:debug\",",
                "+         \"--overrideSearchLimit\", \"name1=value1\",",
                "+         \"--overrideSearchLimit\", \"name2=value2\",",
                "          \"--operationPurpose\", \"Testing\",",
                "@@ -677,2 +679,56 @@ public final class LDAPSearchTestCase",
                "+  /**",
                "+   * Tests to ensure that the tool properly handles invalid values for the",
                "+   * --overrideSearchLimit argument.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWithInvalidOverrideSearchLimitsControl()",
                "+         throws Exception",
                "+  {",
                "+    assertEquals(",
                "+         LDAPSearch.main(NULL_OUTPUT_STREAM, NULL_OUTPUT_STREAM,",
                "+              \"--hostname\", \"localhost\",",
                "+              \"--port\", String.valueOf(ds.getListenPort()),",
                "+              \"--baseDN\", \"dc=example,dc=com\",",
                "+              \"--searchScope\", \"sub\",",
                "+              \"--overrideSearchLimit\", \"noEqualSign\",",
                "+              \"(objectClass=*)\"),",
                "+         ResultCode.PARAM_ERROR);",
                "+",
                "+    assertEquals(",
                "+         LDAPSearch.main(NULL_OUTPUT_STREAM, NULL_OUTPUT_STREAM,",
                "+              \"--hostname\", \"localhost\",",
                "+              \"--port\", String.valueOf(ds.getListenPort()),",
                "+              \"--baseDN\", \"dc=example,dc=com\",",
                "+              \"--searchScope\", \"sub\",",
                "+              \"--overrideSearchLimit\", \"=startsWithEqualSign\",",
                "+              \"(objectClass=*)\"),",
                "+         ResultCode.PARAM_ERROR);",
                "+",
                "+    assertEquals(",
                "+         LDAPSearch.main(NULL_OUTPUT_STREAM, NULL_OUTPUT_STREAM,",
                "+              \"--hostname\", \"localhost\",",
                "+              \"--port\", String.valueOf(ds.getListenPort()),",
                "+              \"--baseDN\", \"dc=example,dc=com\",",
                "+              \"--searchScope\", \"sub\",",
                "+              \"--overrideSearchLimit\", \"endsWithEqualSign=\",",
                "+              \"(objectClass=*)\"),",
                "+         ResultCode.PARAM_ERROR);",
                "+",
                "+    assertEquals(",
                "+         LDAPSearch.main(NULL_OUTPUT_STREAM, NULL_OUTPUT_STREAM,",
                "+              \"--hostname\", \"localhost\",",
                "+              \"--port\", String.valueOf(ds.getListenPort()),",
                "+              \"--baseDN\", \"dc=example,dc=com\",",
                "+              \"--searchScope\", \"sub\",",
                "+              \"--overrideSearchLimit\", \"duplicatePropertyName=value1\",",
                "+              \"--overrideSearchLimit\", \"duplicatePropertyName=value2\",",
                "+              \"(objectClass=*)\"),",
                "+         ResultCode.PARAM_ERROR);",
                "+  }",
                "+",
                "+",
                "+",
                "   /**"
            ],
            "changed_files": [
                "docs/release-notes.html",
                "messages/unboundid-ldapsdk-tools.properties",
                "messages/unboundid-ldapsdk-unboundid-controls.properties",
                "src/com/unboundid/ldap/sdk/unboundidds/controls/OverrideSearchLimitsRequestControl.java",
                "src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearch.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/controls/OverrideSearchLimitsRequestControlTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearchTestCase.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: UnboundID, SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: messages/unboundid-ldapsdk-tools.properties, messages/unboundid-ldapsdk-unboundid-controls.properties, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/controls/OverrideSearchLimitsRequestControlTestCase.java, src/com/unboundid/ldap/sdk/unboundidds/controls/OverrideSearchLimitsRequestControl.java, src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearch.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearchTestCase.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: unboundid, control",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid, control",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "a87ef9d576e775462addb2b6cc747a3302b647e4",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1520213809,
            "hunks": 16,
            "message": "Add a CloseableReadwriteLock class Added a new com.unbound.util.CloseableReadWriteLock class that behaves like a ReentrantReadWriteLock, but that can also be used in conjunction with Java's try-with-resources facility to guarantee that the acquired read or write lock is released when JVM execution leaves the try block.",
            "diff": [
                "diff --git a/docs/release-notes.html b/docs/release-notes.html",
                "index 3e64c999..81f69a1b 100644",
                "--- a/docs/release-notes.html",
                "+++ b/docs/release-notes.html",
                "@@ -65,4 +65,5 @@ ${TARGET=\"offline\"}                <br>",
                "                 <li>",
                "-                  Added a new <tt>CloseableLock</tt> class that provides the same basic",
                "-                  functionality as a Java <tt>ReentrantLock</tt>, but can also be used with Java's",
                "+                  Added new <tt>CloseableLock</tt> and <tt>CloseableReadWriteLock</tt> classes",
                "+                  that provide the same basic functionality as Java's <tt>ReentrantLock</tt> and",
                "+                  <tt>ReentrantReadWriteLock</tt> classes, but that can also be used with Java's",
                "                   try-with-resources facility.",
                "diff --git a/messages/unboundid-ldapsdk-util.properties b/messages/unboundid-ldapsdk-util.properties",
                "index eb9147aa..33f62952 100644",
                "--- a/messages/unboundid-ldapsdk-util.properties",
                "+++ b/messages/unboundid-ldapsdk-util.properties",
                "@@ -811 +811,5 @@ ERR_CLOSEABLE_LOCK_TRY_LOCK_TIMEOUT=Unable to acquire the closeable lock with \\",
                "   a timeout of {0}.",
                "+ERR_CLOSEABLE_RW_LOCK_TRY_LOCK_WRITE_TIMEOUT=Unable to acquire the closeable \\",
                "+  write lock with a timeout of {0}.",
                "+ERR_CLOSEABLE_RW_LOCK_TRY_LOCK_READ_TIMEOUT=Unable to acquire the closeable \\",
                "+  read lock with a timeout of {0}.",
                "diff --git a/src/com/unboundid/util/CloseableLock.java b/src/com/unboundid/util/CloseableLock.java",
                "index d6b845df..f288f3a1 100644",
                "--- a/src/com/unboundid/util/CloseableLock.java",
                "+++ b/src/com/unboundid/util/CloseableLock.java",
                "@@ -49,2 +49,6 @@ import static com.unboundid.util.UtilityMessages.*;",
                "  * {",
                "+ *   // NOTE:  If you don't reference the lock object inside the try block, the",
                "+ *   // compiler will issue a warning.",
                "+ *   lock.avoidCompilerWarning();",
                "+ *",
                "  *   // Do something while the lock is held.  The lock will automatically be",
                "@@ -261,5 +265,7 @@ public final class CloseableLock",
                "   /**",
                "-   * Retrieves the number of threads currently waiting to acquire this lock.",
                "+   * Retrieves an estimate of the number of threads currently waiting to acquire",
                "+   * this lock.",
                "    *",
                "-   * @return  The number of threads currently waiting to acquire this lock.",
                "+   * @return  An estimate of the number of threads currently waiting to acquire",
                "+   *          this lock.",
                "    */",
                "@@ -311,2 +317,15 @@ public final class CloseableLock",
                "+    /**",
                "+     * This method does nothing.  However, calling it inside a try block when",
                "+     * used in the try-with-resources framework can help avoid a compiler",
                "+     * warning that the JVM will give you if you don't reference the",
                "+     * {@code Closeable} object inside the try block.",
                "+     */",
                "+    public void avoidCompilerWarning()",
                "+    {",
                "+      // No implementation is required.",
                "+    }",
                "+",
                "+",
                "+",
                "     /**",
                "diff --git a/src/com/unboundid/util/CloseableReadWriteLock.java b/src/com/unboundid/util/CloseableReadWriteLock.java",
                "new file mode 100644",
                "index 00000000..ad2f46f5",
                "--- /dev/null",
                "+++ b/src/com/unboundid/util/CloseableReadWriteLock.java",
                "@@ -0,0 +1,505 @@",
                "+/*",
                "+ * Copyright 2018 Ping Identity Corporation",
                "+ * All Rights Reserved.",
                "+ */",
                "+/*",
                "+ * Copyright (C) 2018 Ping Identity Corporation",
                "+ *",
                "+ * This program is free software; you can redistribute it and/or modify",
                "+ * it under the terms of the GNU General Public License (GPLv2 only)",
                "+ * or the terms of the GNU Lesser General Public License (LGPLv2.1 only)",
                "+ * as published by the Free Software Foundation.",
                "+ *",
                "+ * This program is distributed in the hope that it will be useful,",
                "+ * but WITHOUT ANY WARRANTY; without even the implied warranty of",
                "+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
                "+ * GNU General Public License for more details.",
                "+ *",
                "+ * You should have received a copy of the GNU General Public License",
                "+ * along with this program; if not, see <http://www.gnu.org/licenses>.",
                "+ */",
                "+package com.unboundid.util;",
                "+",
                "+",
                "+",
                "+import java.io.Closeable;",
                "+import java.util.concurrent.TimeUnit;",
                "+import java.util.concurrent.TimeoutException;",
                "+import java.util.concurrent.locks.ReentrantReadWriteLock;",
                "+",
                "+import static com.unboundid.util.UtilityMessages.*;",
                "+",
                "+",
                "+",
                "+/**",
                "+ * This class provides an implementation of a reentrant read-write lock that can",
                "+ * be used with the Java try-with-resources facility.  With a read-write lock,",
                "+ * either exactly one thread can hold the write lock while no other threads hold",
                "+ * read locks, or zero or more threads can hold read locks while no thread holds",
                "+ * the write lock.  The one exception to this policy is that the thread that",
                "+ * holds the write lock can downgrade will be permitted to acquire a read lock",
                "+ * before it releases the write lock to downgrade from a write lock to a read",
                "+ * lock while ensuring that no other thread is permitted to acquire the write",
                "+ * lock while it is in the process of downgrading.",
                "+ * <BR><BR>",
                "+ * This class does not implement the",
                "+ * {@code java.util.concurrent.locks.ReadWriteLock} interface in order to ensure",
                "+ * that it can only be used through the try-with-resources mechanism, but it",
                "+ * uses a {@code java.util.concurrent.locks.ReentrantReadWriteLock} behind the",
                "+ * scenes to provide its functionality.",
                "+ * <BR><BR>",
                "+ * <H2>Example</H2>",
                "+ * The following example demonstrates how to use this lock using the Java",
                "+ * try-with-resources facility:",
                "+ * <PRE>",
                "+ * // Wait for up to 5 seconds to acquire the lock.",
                "+ * try (final CloseableReadWriteLock.WriteLock writeLock =",
                "+ *           closeableReadWriteLock.tryLock(5L, TimeUnit.SECONDS))",
                "+ * {",
                "+ *   // NOTE:  If you don't reference the lock object inside the try block, the",
                "+ *   // compiler will issue a warning.",
                "+ *   writeLock.avoidCompilerWarning();",
                "+ *",
                "+ *   // Do something while the lock is held.  The lock will automatically be",
                "+ *   // released once code execution leaves this block.",
                "+ * }",
                "+ * catch (final InterruptedException e)",
                "+ * {",
                "+ *   // The thread was interrupted before the lock could be acquired.",
                "+ * }",
                "+ * catch (final TimeoutException)",
                "+ * {",
                "+ *   // The lock could not be acquired within the specified 5-second timeout.",
                "+ * }",
                "+ * </PRE>",
                "+ */",
                "+@Mutable()",
                "+@ThreadSafety(level=ThreadSafetyLevel.COMPLETELY_THREADSAFE)",
                "+public final class CloseableReadWriteLock",
                "+{",
                "+  // The closeable read lock.",
                "+  private final ReadLock readLock;",
                "+",
                "+  // The Java lock that is used behind the scenes for all locking functionality.",
                "+  private final ReentrantReadWriteLock readWriteLock;",
                "+",
                "+  // The closeable write lock.",
                "+  private final WriteLock writeLock;",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new instance of this read-write lock with a non-fair ordering",
                "+   * policy.",
                "+   */",
                "+  public CloseableReadWriteLock()",
                "+  {",
                "+    this(false);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new instance of this read-write lock with the specified ordering",
                "+   * policy.",
                "+   *",
                "+   * @param  fair  Indicates whether the lock should use fair ordering.  If",
                "+   *               {@code true}, then if multiple threads are waiting on the",
                "+   *               lock, then the one that has been waiting the longest is the",
                "+   *               one that will get it.  If {@code false}, then no guarantee",
                "+   *               will be made about the order.  Fair ordering can incur a",
                "+   *               performance penalty.",
                "+   */",
                "+  public CloseableReadWriteLock(final boolean fair)",
                "+  {",
                "+    readWriteLock = new ReentrantReadWriteLock(fair);",
                "+    readLock = new ReadLock(readWriteLock.readLock());",
                "+    writeLock = new WriteLock(readWriteLock.writeLock());",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Acquires the write lock, blocking until the lock is available.",
                "+   *",
                "+   * @return  The {@link WriteLock} instance that may be used to perform the",
                "+   *          unlock via the try-with-resources facility.",
                "+   */",
                "+  public WriteLock lockWrite()",
                "+  {",
                "+    readWriteLock.writeLock().lock();",
                "+    return writeLock;",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Acquires the write lock, blocking until the lock is available.",
                "+   *",
                "+   * @return  The {@link WriteLock} instance that may be used to perform the",
                "+   *          unlock via the try-with-resources facility.",
                "+   *",
                "+   * @throws  InterruptedException  If the thread is interrupted while waiting",
                "+   *                                to acquire the lock.",
                "+   */",
                "+  public WriteLock lockWriteInterruptibly()",
                "+         throws InterruptedException",
                "+  {",
                "+    readWriteLock.writeLock().lockInterruptibly();",
                "+    return writeLock;",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tries to acquire the write lock, waiting up to the specified length of time",
                "+   * for it to become available.",
                "+   *",
                "+   * @param  waitTime  The maximum length of time to wait for the lock.  It must",
                "+   *                   be greater than zero.",
                "+   * @param  timeUnit  The time unit that should be used when evaluating the",
                "+   *                   {@code waitTime} value.",
                "+   *",
                "+   * @return  The {@link WriteLock} instance that may be used to perform the",
                "+   *          unlock via the try-with-resources facility.",
                "+   *",
                "+   * @throws  InterruptedException  If the thread is interrupted while waiting",
                "+   *                                to acquire the lock.",
                "+   *",
                "+   * @throws  TimeoutException  If the lock could not be acquired within the",
                "+   *                            specified length of time.",
                "+   */",
                "+  public WriteLock tryLockWrite(final long waitTime, final TimeUnit timeUnit)",
                "+         throws InterruptedException, TimeoutException",
                "+  {",
                "+    if (waitTime <= 0)",
                "+    {",
                "+      Validator.violation(",
                "+           \"CloseableLock.tryLockWrite.waitTime must be greater than zero.  \" +",
                "+                \"The provided value was \" + waitTime);",
                "+    }",
                "+",
                "+    if (readWriteLock.writeLock().tryLock(waitTime, timeUnit))",
                "+    {",
                "+      return writeLock;",
                "+    }",
                "+    else",
                "+    {",
                "+      throw new TimeoutException(",
                "+           ERR_CLOSEABLE_RW_LOCK_TRY_LOCK_WRITE_TIMEOUT.get(",
                "+                StaticUtils.millisToHumanReadableDuration(",
                "+                     timeUnit.toMillis(waitTime))));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Acquires a read lock, blocking until the lock is available.",
                "+   *",
                "+   * @return  The {@link ReadLock} instance that may be used to perform the",
                "+   *          unlock via the try-with-resources facility.",
                "+   */",
                "+  public ReadLock lockRead()",
                "+  {",
                "+    readWriteLock.readLock().lock();",
                "+    return readLock;",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Acquires a read lock, blocking until the lock is available.",
                "+   *",
                "+   * @return  The {@link ReadLock} instance that may be used to perform the",
                "+   *          unlock via the try-with-resources facility.",
                "+   *",
                "+   * @throws  InterruptedException  If the thread is interrupted while waiting",
                "+   *                                to acquire the lock.",
                "+   */",
                "+  public ReadLock lockReadInterruptibly()",
                "+         throws InterruptedException",
                "+  {",
                "+    readWriteLock.readLock().lockInterruptibly();",
                "+    return readLock;",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tries to acquire a read lock, waiting up to the specified length of time",
                "+   * for it to become available.",
                "+   *",
                "+   * @param  waitTime  The maximum length of time to wait for the lock.  It must",
                "+   *                   be greater than zero.",
                "+   * @param  timeUnit  The time unit that should be used when evaluating the",
                "+   *                   {@code waitTime} value.",
                "+   *",
                "+   * @return  The {@link ReadLock} instance that may be used to perform the",
                "+   *          unlock via the try-with-resources facility.",
                "+   *",
                "+   * @throws  InterruptedException  If the thread is interrupted while waiting",
                "+   *                                to acquire the lock.",
                "+   *",
                "+   * @throws  TimeoutException  If the lock could not be acquired within the",
                "+   *                            specified length of time.",
                "+   */",
                "+  public ReadLock tryLockRead(final long waitTime, final TimeUnit timeUnit)",
                "+         throws InterruptedException, TimeoutException",
                "+  {",
                "+    if (waitTime <= 0)",
                "+    {",
                "+      Validator.violation(",
                "+           \"CloseableLock.tryLockRead.waitTime must be greater than zero.  \" +",
                "+                \"The provided value was \" + waitTime);",
                "+    }",
                "+",
                "+    if (readWriteLock.readLock().tryLock(waitTime, timeUnit))",
                "+    {",
                "+      return readLock;",
                "+    }",
                "+    else",
                "+    {",
                "+      throw new TimeoutException(",
                "+           ERR_CLOSEABLE_RW_LOCK_TRY_LOCK_READ_TIMEOUT.get(",
                "+                StaticUtils.millisToHumanReadableDuration(",
                "+                     timeUnit.toMillis(waitTime))));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates whether this lock uses fair ordering.",
                "+   *",
                "+   * @return  {@code true} if this lock uses fair ordering, or {@code false} if",
                "+   *          not.",
                "+   */",
                "+  public boolean isFair()",
                "+  {",
                "+    return readWriteLock.isFair();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates whether the write lock is currently held by any thread.",
                "+   *",
                "+   * @return  {@code true} if the write lock is currently held by any thread, or",
                "+   *          {@code false} if not.",
                "+   */",
                "+  public boolean isWriteLocked()",
                "+  {",
                "+    return readWriteLock.isWriteLocked();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates whether the write lock is currently held by the current thread.",
                "+   *",
                "+   * @return  {@code true} if the write lock is currently held by the current",
                "+   *          thread, or {@code false} if not.",
                "+   */",
                "+  public boolean isWriteLockedByCurrentThread()",
                "+  {",
                "+    return readWriteLock.isWriteLockedByCurrentThread();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the number of holds that the current thread has on the write",
                "+   * lock.",
                "+   *",
                "+   * @return  The number of holds that the current thread has on the write lock.",
                "+   */",
                "+  public int getWriteHoldCount()",
                "+  {",
                "+    return readWriteLock.getWriteHoldCount();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the number of threads that currently hold the read lock.",
                "+   *",
                "+   * @return  The number of threads that currently hold the read lock.",
                "+   */",
                "+  public int getReadLockCount()",
                "+  {",
                "+    return readWriteLock.getReadLockCount();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the number of holds that the current thread has on the read lock.",
                "+   *",
                "+   * @return  The number of holds that the current thread has on the read lock.",
                "+   */",
                "+  public int getReadHoldCount()",
                "+  {",
                "+    return readWriteLock.getReadHoldCount();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates whether any threads are currently waiting to acquire either the",
                "+   * write or read lock.",
                "+   *",
                "+   * @return  {@code true} if any threads are currently waiting to acquire",
                "+   *          either the write or read lock, or {@code false} if not.",
                "+   */",
                "+  public boolean hasQueuedThreads()",
                "+  {",
                "+    return readWriteLock.hasQueuedThreads();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates whether the specified thread is currently waiting to acquire",
                "+   * either the write or read lock.",
                "+   *",
                "+   * @param  thread  The thread for which to make the determination.  It must",
                "+   *                 not be {@code null}.",
                "+   *",
                "+   * @return  {@code true} if the specified thread is currently waiting to",
                "+   *          acquire either the write or read lock, or {@code false} if not.",
                "+   */",
                "+  public boolean hasQueuedThread(final Thread thread)",
                "+  {",
                "+    return readWriteLock.hasQueuedThread(thread);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves an estimate of the number of threads currently waiting to acquire",
                "+   * either the write or read lock.",
                "+   *",
                "+   * @return  An estimate of the number of threads currently waiting to acquire",
                "+   *          either the write or read lock.",
                "+   */",
                "+  public int getQueueLength()",
                "+  {",
                "+    return readWriteLock.getQueueLength();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves a string representation of this read-write lock.",
                "+   *",
                "+   * @return  A string representation of this read-write lock.",
                "+   */",
                "+  @Override()",
                "+  public String toString()",
                "+  {",
                "+    return \"CloseableReadWriteLock(lock=\" + readWriteLock.toString() + ')';",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * This class provides a {@code Closeable} implementation that may be used to",
                "+   * unlock a {@link CloseableReadWriteLock}'s read lock via Java's",
                "+   * try-with-resources facility.",
                "+   */",
                "+  public final class ReadLock",
                "+         implements Closeable",
                "+  {",
                "+    // The associated read lock.",
                "+    private final ReentrantReadWriteLock.ReadLock lock;",
                "+",
                "+",
                "+",
                "+    /**",
                "+     * Creates a new instance with the provided lock.",
                "+     *",
                "+     * @param  lock  The lock that will be unlocked when the [@link #close()}",
                "+     *               method is called.  This must not be {@code null}.",
                "+     */",
                "+    private ReadLock(final ReentrantReadWriteLock.ReadLock lock)",
                "+    {",
                "+      this.lock = lock;",
                "+    }",
                "+",
                "+",
                "+",
                "+    /**",
                "+     * This method does nothing.  However, calling it inside a try block when",
                "+     * used in the try-with-resources framework can help avoid a compiler",
                "+     * warning that the JVM will give you if you don't reference the",
                "+     * {@code Closeable} object inside the try block.",
                "+     */",
                "+    public void avoidCompilerWarning()",
                "+    {",
                "+      // No implementation is required.",
                "+    }",
                "+",
                "+",
                "+",
                "+    /**",
                "+     * Unlocks the associated lock.",
                "+     */",
                "+    @Override()",
                "+    public void close()",
                "+    {",
                "+      lock.unlock();",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * This class provides a {@code Closeable} implementation that may be used to",
                "+   * unlock a {@link CloseableReadWriteLock}'s write lock via Java's",
                "+   * try-with-resources facility.",
                "+   */",
                "+  public final class WriteLock",
                "+         implements Closeable",
                "+  {",
                "+    // The associated read lock.",
                "+    private final ReentrantReadWriteLock.WriteLock lock;",
                "+",
                "+",
                "+",
                "+    /**",
                "+     * Creates a new instance with the provided lock.",
                "+     *",
                "+     * @param  lock  The lock that will be unlocked when the [@link #close()}",
                "+     *               method is called.  This must not be {@code null}.",
                "+     */",
                "+    private WriteLock(final ReentrantReadWriteLock.WriteLock lock)",
                "+    {",
                "+      this.lock = lock;",
                "+    }",
                "+",
                "+",
                "+",
                "+    /**",
                "+     * This method does nothing.  However, calling it inside a try block when",
                "+     * used in the try-with-resources framework can help avoid a compiler",
                "+     * warning that the JVM will give you if you don't reference the",
                "+     * {@code Closeable} object inside the try block.",
                "+     */",
                "+    public void avoidCompilerWarning()",
                "+    {",
                "+      // No implementation is required.",
                "+    }",
                "+",
                "+",
                "+",
                "+    /**",
                "+     * Unlocks the associated lock.",
                "+     */",
                "+    @Override()",
                "+    public void close()",
                "+    {",
                "+      lock.unlock();",
                "+    }",
                "+  }",
                "+}",
                "diff --git a/tests/unit/src/com/unboundid/util/CloseableLockTestCase.java b/tests/unit/src/com/unboundid/util/CloseableLockTestCase.java",
                "index 2607a3e2..fe7d60dc 100644",
                "--- a/tests/unit/src/com/unboundid/util/CloseableLockTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/util/CloseableLockTestCase.java",
                "@@ -62,3 +62,3 @@ public final class CloseableLockTestCase",
                "     {",
                "-      assertNotNull(l1);",
                "+      l1.avoidCompilerWarning();",
                "@@ -75,3 +75,3 @@ public final class CloseableLockTestCase",
                "       {",
                "-        assertNotNull(l2);",
                "+        l2.avoidCompilerWarning();",
                "@@ -88,3 +88,3 @@ public final class CloseableLockTestCase",
                "         {",
                "-          assertNotNull(l3);",
                "+          l3.avoidCompilerWarning();",
                "@@ -118,3 +118,3 @@ public final class CloseableLockTestCase",
                "-          assertNotNull(l3);",
                "+          l3.avoidCompilerWarning();",
                "         }",
                "@@ -130,3 +130,3 @@ public final class CloseableLockTestCase",
                "-        assertNotNull(l2);",
                "+        l2.avoidCompilerWarning();",
                "       }",
                "@@ -142,3 +142,3 @@ public final class CloseableLockTestCase",
                "-      assertNotNull(l1);",
                "+      l1.avoidCompilerWarning();",
                "     }",
                "diff --git a/tests/unit/src/com/unboundid/util/CloseableLockTestCaseThread.java b/tests/unit/src/com/unboundid/util/CloseableLockTestCaseThread.java",
                "index a907264e..25f17ad9 100644",
                "--- a/tests/unit/src/com/unboundid/util/CloseableLockTestCaseThread.java",
                "+++ b/tests/unit/src/com/unboundid/util/CloseableLockTestCaseThread.java",
                "@@ -88,3 +88,3 @@ final class CloseableLockTestCaseThread",
                "     {",
                "-      Validator.ensureNotNull(l);",
                "+      l.avoidCompilerWarning();",
                "       isLocked.set(true);",
                "diff --git a/tests/unit/src/com/unboundid/util/CloseableReadWriteLockTestCase.java b/tests/unit/src/com/unboundid/util/CloseableReadWriteLockTestCase.java",
                "new file mode 100644",
                "index 00000000..5f72fa85",
                "--- /dev/null",
                "+++ b/tests/unit/src/com/unboundid/util/CloseableReadWriteLockTestCase.java",
                "@@ -0,0 +1,579 @@",
                "+/*",
                "+ * Copyright 2018 Ping Identity Corporation",
                "+ * All Rights Reserved.",
                "+ */",
                "+/*",
                "+ * Copyright (C) 2018 Ping Identity Corporation",
                "+ *",
                "+ * This program is free software; you can redistribute it and/or modify",
                "+ * it under the terms of the GNU General Public License (GPLv2 only)",
                "+ * or the terms of the GNU Lesser General Public License (LGPLv2.1 only)",
                "+ * as published by the Free Software Foundation.",
                "+ *",
                "+ * This program is distributed in the hope that it will be useful,",
                "+ * but WITHOUT ANY WARRANTY; without even the implied warranty of",
                "+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
                "+ * GNU General Public License for more details.",
                "+ *",
                "+ * You should have received a copy of the GNU General Public License",
                "+ * along with this program; if not, see <http://www.gnu.org/licenses>.",
                "+ */",
                "+package com.unboundid.util;",
                "+",
                "+",
                "+",
                "+import java.util.concurrent.TimeUnit;",
                "+import java.util.concurrent.TimeoutException;",
                "+import java.util.concurrent.atomic.AtomicBoolean;",
                "+",
                "+import org.testng.annotations.Test;",
                "+",
                "+import com.unboundid.ldap.sdk.LDAPSDKTestCase;",
                "+",
                "+",
                "+",
                "+/**",
                "+ * This class provides a set of test cases for the",
                "+ * {@code CloseableReadWriteLock} class.",
                "+ */",
                "+public final class CloseableReadWriteLockTestCase",
                "+       extends LDAPSDKTestCase",
                "+{",
                "+  /**",
                "+   * Tests basic write lock functionality.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWriteLock()",
                "+         throws Exception",
                "+  {",
                "+    final CloseableReadWriteLock rwLock = new CloseableReadWriteLock();",
                "+",
                "+    assertFalse(rwLock.isFair());",
                "+    assertFalse(rwLock.isWriteLocked());",
                "+    assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+    assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+    assertEquals(rwLock.getReadLockCount(), 0);",
                "+    assertEquals(rwLock.getReadHoldCount(), 0);",
                "+    assertFalse(rwLock.hasQueuedThreads());",
                "+    assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(rwLock.getQueueLength(), 0);",
                "+    assertNotNull(rwLock.toString());",
                "+",
                "+    try (final CloseableReadWriteLock.WriteLock l1 = rwLock.lockWrite())",
                "+    {",
                "+      l1.avoidCompilerWarning();",
                "+",
                "+      assertFalse(rwLock.isFair());",
                "+      assertTrue(rwLock.isWriteLocked());",
                "+      assertTrue(rwLock.isWriteLockedByCurrentThread());",
                "+      assertEquals(rwLock.getWriteHoldCount(), 1);",
                "+      assertEquals(rwLock.getReadLockCount(), 0);",
                "+      assertEquals(rwLock.getReadHoldCount(), 0);",
                "+      assertFalse(rwLock.hasQueuedThreads());",
                "+      assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+      assertEquals(rwLock.getQueueLength(), 0);",
                "+      assertNotNull(rwLock.toString());",
                "+",
                "+      try (final CloseableReadWriteLock.WriteLock l2 =",
                "+                rwLock.lockWriteInterruptibly())",
                "+      {",
                "+        l2.avoidCompilerWarning();",
                "+",
                "+        assertFalse(rwLock.isFair());",
                "+        assertTrue(rwLock.isWriteLocked());",
                "+        assertTrue(rwLock.isWriteLockedByCurrentThread());",
                "+        assertEquals(rwLock.getWriteHoldCount(), 2);",
                "+        assertEquals(rwLock.getReadLockCount(), 0);",
                "+        assertEquals(rwLock.getReadHoldCount(), 0);",
                "+        assertFalse(rwLock.hasQueuedThreads());",
                "+        assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+        assertEquals(rwLock.getQueueLength(), 0);",
                "+        assertNotNull(rwLock.toString());",
                "+",
                "+        try (final CloseableReadWriteLock.WriteLock l3 =",
                "+                  rwLock.tryLockWrite(1L, TimeUnit.SECONDS))",
                "+        {",
                "+          l3.avoidCompilerWarning();",
                "+",
                "+          assertFalse(rwLock.isFair());",
                "+          assertTrue(rwLock.isWriteLocked());",
                "+          assertTrue(rwLock.isWriteLockedByCurrentThread());",
                "+          assertEquals(rwLock.getWriteHoldCount(), 3);",
                "+          assertEquals(rwLock.getReadLockCount(), 0);",
                "+          assertEquals(rwLock.getReadHoldCount(), 0);",
                "+          assertFalse(rwLock.hasQueuedThreads());",
                "+          assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+          assertEquals(rwLock.getQueueLength(), 0);",
                "+          assertNotNull(rwLock.toString());",
                "+",
                "+          try (final CloseableReadWriteLock.WriteLock l4 =",
                "+                    rwLock.tryLockWrite(0L, TimeUnit.SECONDS))",
                "+          {",
                "+            fail(\"Expected an exception when trying to acquire the write \" +",
                "+                 \"lock with a timeout of zero seconds.  Instead, got lock \" +",
                "+                 l4);",
                "+          }",
                "+          catch (final LDAPSDKUsageException e)",
                "+          {",
                "+            // This was expected.",
                "+          }",
                "+",
                "+          assertFalse(rwLock.isFair());",
                "+          assertTrue(rwLock.isWriteLocked());",
                "+          assertTrue(rwLock.isWriteLockedByCurrentThread());",
                "+          assertEquals(rwLock.getWriteHoldCount(), 3);",
                "+          assertEquals(rwLock.getReadLockCount(), 0);",
                "+          assertEquals(rwLock.getReadHoldCount(), 0);",
                "+          assertFalse(rwLock.hasQueuedThreads());",
                "+          assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+          assertEquals(rwLock.getQueueLength(), 0);",
                "+          assertNotNull(rwLock.toString());",
                "+        }",
                "+",
                "+        assertFalse(rwLock.isFair());",
                "+        assertTrue(rwLock.isWriteLocked());",
                "+        assertTrue(rwLock.isWriteLockedByCurrentThread());",
                "+        assertEquals(rwLock.getWriteHoldCount(), 2);",
                "+        assertEquals(rwLock.getReadLockCount(), 0);",
                "+        assertEquals(rwLock.getReadHoldCount(), 0);",
                "+        assertFalse(rwLock.hasQueuedThreads());",
                "+        assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+        assertEquals(rwLock.getQueueLength(), 0);",
                "+        assertNotNull(rwLock.toString());",
                "+      }",
                "+",
                "+      assertFalse(rwLock.isFair());",
                "+      assertTrue(rwLock.isWriteLocked());",
                "+      assertTrue(rwLock.isWriteLockedByCurrentThread());",
                "+      assertEquals(rwLock.getWriteHoldCount(), 1);",
                "+      assertEquals(rwLock.getReadLockCount(), 0);",
                "+      assertEquals(rwLock.getReadHoldCount(), 0);",
                "+      assertFalse(rwLock.hasQueuedThreads());",
                "+      assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+      assertEquals(rwLock.getQueueLength(), 0);",
                "+      assertNotNull(rwLock.toString());",
                "+    }",
                "+",
                "+    assertFalse(rwLock.isFair());",
                "+    assertFalse(rwLock.isWriteLocked());",
                "+    assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+    assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+    assertEquals(rwLock.getReadLockCount(), 0);",
                "+    assertEquals(rwLock.getReadHoldCount(), 0);",
                "+    assertFalse(rwLock.hasQueuedThreads());",
                "+    assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(rwLock.getQueueLength(), 0);",
                "+    assertNotNull(rwLock.toString());",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests basic read lock functionality.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testReadLock()",
                "+         throws Exception",
                "+  {",
                "+    final CloseableReadWriteLock rwLock = new CloseableReadWriteLock(true);",
                "+",
                "+    assertTrue(rwLock.isFair());",
                "+    assertFalse(rwLock.isWriteLocked());",
                "+    assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+    assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+    assertEquals(rwLock.getReadLockCount(), 0);",
                "+    assertEquals(rwLock.getReadHoldCount(), 0);",
                "+    assertFalse(rwLock.hasQueuedThreads());",
                "+    assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(rwLock.getQueueLength(), 0);",
                "+    assertNotNull(rwLock.toString());",
                "+",
                "+    try (final CloseableReadWriteLock.ReadLock l1 = rwLock.lockRead())",
                "+    {",
                "+      l1.avoidCompilerWarning();",
                "+",
                "+      assertTrue(rwLock.isFair());",
                "+      assertFalse(rwLock.isWriteLocked());",
                "+      assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+      assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+      assertEquals(rwLock.getReadLockCount(), 1);",
                "+      assertEquals(rwLock.getReadHoldCount(), 1);",
                "+      assertFalse(rwLock.hasQueuedThreads());",
                "+      assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+      assertEquals(rwLock.getQueueLength(), 0);",
                "+      assertNotNull(rwLock.toString());",
                "+",
                "+      try (final CloseableReadWriteLock.ReadLock l2 =",
                "+                rwLock.lockReadInterruptibly())",
                "+      {",
                "+        l2.avoidCompilerWarning();",
                "+",
                "+        assertTrue(rwLock.isFair());",
                "+        assertFalse(rwLock.isWriteLocked());",
                "+        assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+        assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+        assertEquals(rwLock.getReadLockCount(), 2);",
                "+        assertEquals(rwLock.getReadHoldCount(), 2);",
                "+        assertFalse(rwLock.hasQueuedThreads());",
                "+        assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+        assertEquals(rwLock.getQueueLength(), 0);",
                "+        assertNotNull(rwLock.toString());",
                "+",
                "+        try (final CloseableReadWriteLock.ReadLock l3 =",
                "+                  rwLock.tryLockRead(1L, TimeUnit.SECONDS))",
                "+        {",
                "+          l3.avoidCompilerWarning();",
                "+",
                "+          assertTrue(rwLock.isFair());",
                "+          assertFalse(rwLock.isWriteLocked());",
                "+          assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+          assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+          assertEquals(rwLock.getReadLockCount(), 3);",
                "+          assertEquals(rwLock.getReadHoldCount(), 3);",
                "+          assertFalse(rwLock.hasQueuedThreads());",
                "+          assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+          assertEquals(rwLock.getQueueLength(), 0);",
                "+          assertNotNull(rwLock.toString());",
                "+",
                "+          try (final CloseableReadWriteLock.ReadLock l4 =",
                "+                    rwLock.tryLockRead(0L, TimeUnit.SECONDS))",
                "+          {",
                "+            fail(\"Expected an exception when trying to acquire the read lock \" +",
                "+                 \"with a timeout of zero seconds.  Instead, got lock \" + l4);",
                "+          }",
                "+          catch (final LDAPSDKUsageException e)",
                "+          {",
                "+            // This was expected.",
                "+          }",
                "+",
                "+          assertTrue(rwLock.isFair());",
                "+          assertFalse(rwLock.isWriteLocked());",
                "+          assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+          assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+          assertEquals(rwLock.getReadLockCount(), 3);",
                "+          assertEquals(rwLock.getReadHoldCount(), 3);",
                "+          assertFalse(rwLock.hasQueuedThreads());",
                "+          assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+          assertEquals(rwLock.getQueueLength(), 0);",
                "+          assertNotNull(rwLock.toString());",
                "+        }",
                "+",
                "+        assertTrue(rwLock.isFair());",
                "+        assertFalse(rwLock.isWriteLocked());",
                "+        assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+        assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+        assertEquals(rwLock.getReadLockCount(), 2);",
                "+        assertEquals(rwLock.getReadHoldCount(), 2);",
                "+        assertFalse(rwLock.hasQueuedThreads());",
                "+        assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+        assertEquals(rwLock.getQueueLength(), 0);",
                "+        assertNotNull(rwLock.toString());",
                "+      }",
                "+",
                "+      assertTrue(rwLock.isFair());",
                "+      assertFalse(rwLock.isWriteLocked());",
                "+      assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+      assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+      assertEquals(rwLock.getReadLockCount(), 1);",
                "+      assertEquals(rwLock.getReadHoldCount(), 1);",
                "+      assertFalse(rwLock.hasQueuedThreads());",
                "+      assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+      assertEquals(rwLock.getQueueLength(), 0);",
                "+      assertNotNull(rwLock.toString());",
                "+    }",
                "+",
                "+    assertTrue(rwLock.isFair());",
                "+    assertFalse(rwLock.isWriteLocked());",
                "+    assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+    assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+    assertEquals(rwLock.getReadLockCount(), 0);",
                "+    assertEquals(rwLock.getReadHoldCount(), 0);",
                "+    assertFalse(rwLock.hasQueuedThreads());",
                "+    assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(rwLock.getQueueLength(), 0);",
                "+    assertNotNull(rwLock.toString());",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests to ensure that a write lock can be downgraded to a read lock.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWriteLockDowngrade()",
                "+         throws Exception",
                "+  {",
                "+    final CloseableReadWriteLock rwLock = new CloseableReadWriteLock(false);",
                "+",
                "+    try (final CloseableReadWriteLock.WriteLock writeLock = rwLock.lockWrite())",
                "+    {",
                "+      writeLock.avoidCompilerWarning();",
                "+",
                "+      try (final CloseableReadWriteLock.ReadLock readLock =",
                "+                rwLock.tryLockRead(1L, TimeUnit.SECONDS))",
                "+      {",
                "+        readLock.avoidCompilerWarning();",
                "+      }",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests to ensure that a read lock can be upgraded to a write lock.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testReadLockUpgrade()",
                "+         throws Exception",
                "+  {",
                "+    final CloseableReadWriteLock rwLock = new CloseableReadWriteLock(true);",
                "+",
                "+    try (final CloseableReadWriteLock.ReadLock readLock = rwLock.lockRead())",
                "+    {",
                "+      readLock.avoidCompilerWarning();",
                "+",
                "+      try (final CloseableReadWriteLock.WriteLock writeLock =",
                "+                rwLock.tryLockWrite(10L, TimeUnit.MILLISECONDS))",
                "+      {",
                "+        fail(\"Expected an exception when trying to upgrade a read lock to \" +",
                "+             \"a write lock, but instead got \" + writeLock);",
                "+      }",
                "+      catch (final TimeoutException e)",
                "+      {",
                "+        // This was expected.",
                "+        assertNotNull(e.getMessage());",
                "+      }",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to acquire the write lock while another",
                "+   * thread already holds the write lock.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testLockWriteWhileAnotherThreadAlreadyHoldsWriteLock()",
                "+         throws Exception",
                "+  {",
                "+    final CloseableReadWriteLock rwLock = new CloseableReadWriteLock();",
                "+    final AtomicBoolean isLocked = new AtomicBoolean(false);",
                "+    final AtomicBoolean tryLockFailed = new AtomicBoolean(false);",
                "+",
                "+    assertFalse(rwLock.isFair());",
                "+    assertFalse(rwLock.isWriteLocked());",
                "+    assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+    assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+    assertEquals(rwLock.getReadLockCount(), 0);",
                "+    assertEquals(rwLock.getReadHoldCount(), 0);",
                "+    assertFalse(rwLock.hasQueuedThreads());",
                "+    assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(rwLock.getQueueLength(), 0);",
                "+    assertNotNull(rwLock.toString());",
                "+",
                "+    final CloseableReadWriteLockTestCaseThread thread =",
                "+         new CloseableReadWriteLockTestCaseThread(rwLock, true, isLocked,",
                "+              tryLockFailed);",
                "+    thread.start();",
                "+",
                "+    while (! isLocked.get())",
                "+    {",
                "+      Thread.sleep(1L);",
                "+    }",
                "+",
                "+    assertFalse(rwLock.isFair());",
                "+    assertTrue(rwLock.isWriteLocked());",
                "+    assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+    assertEquals(rwLock.getWriteHoldCount(), 0); // Not held by current thread",
                "+    assertEquals(rwLock.getReadLockCount(), 0);",
                "+    assertEquals(rwLock.getReadHoldCount(), 0);",
                "+    assertFalse(rwLock.hasQueuedThreads());",
                "+    assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(rwLock.getQueueLength(), 0);",
                "+    assertNotNull(rwLock.toString());",
                "+",
                "+    try (CloseableReadWriteLock.WriteLock l =",
                "+              rwLock.tryLockWrite(1L, TimeUnit.MILLISECONDS))",
                "+    {",
                "+      fail(\"Expected to fail to acquire the write lock held by another \" +",
                "+           \"thread, but instead got \" + l);",
                "+    }",
                "+    catch (final TimeoutException e)",
                "+    {",
                "+      // This was expected.",
                "+      assertNotNull(e.getMessage());",
                "+    }",
                "+",
                "+    tryLockFailed.set(true);",
                "+    thread.join();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to acquire the write lock while another",
                "+   * thread already holds the read lock.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testLockWriteWhileAnotherThreadAlreadyHoldsReadLock()",
                "+         throws Exception",
                "+  {",
                "+    final CloseableReadWriteLock rwLock = new CloseableReadWriteLock();",
                "+    final AtomicBoolean isLocked = new AtomicBoolean(false);",
                "+    final AtomicBoolean tryLockFailed = new AtomicBoolean(false);",
                "+",
                "+    assertFalse(rwLock.isFair());",
                "+    assertFalse(rwLock.isWriteLocked());",
                "+    assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+    assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+    assertEquals(rwLock.getReadLockCount(), 0);",
                "+    assertEquals(rwLock.getReadHoldCount(), 0);",
                "+    assertFalse(rwLock.hasQueuedThreads());",
                "+    assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(rwLock.getQueueLength(), 0);",
                "+    assertNotNull(rwLock.toString());",
                "+",
                "+    final CloseableReadWriteLockTestCaseThread thread =",
                "+         new CloseableReadWriteLockTestCaseThread(rwLock, false, isLocked,",
                "+              tryLockFailed);",
                "+    thread.start();",
                "+",
                "+    while (! isLocked.get())",
                "+    {",
                "+      Thread.sleep(1L);",
                "+    }",
                "+",
                "+    assertFalse(rwLock.isFair());",
                "+    assertFalse(rwLock.isWriteLocked());",
                "+    assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+    assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+    assertEquals(rwLock.getReadLockCount(), 1);",
                "+    assertEquals(rwLock.getReadHoldCount(), 0); // Not held by current thread",
                "+    assertFalse(rwLock.hasQueuedThreads());",
                "+    assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(rwLock.getQueueLength(), 0);",
                "+    assertNotNull(rwLock.toString());",
                "+",
                "+    // Verify that we can successfully acquire the read lock.",
                "+    try (CloseableReadWriteLock.ReadLock l =",
                "+              rwLock.tryLockRead(1L, TimeUnit.SECONDS))",
                "+    {",
                "+      l.avoidCompilerWarning();",
                "+",
                "+      assertFalse(rwLock.isFair());",
                "+      assertFalse(rwLock.isWriteLocked());",
                "+      assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+      assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+      assertEquals(rwLock.getReadLockCount(), 2);",
                "+      assertEquals(rwLock.getReadHoldCount(), 1);",
                "+      assertFalse(rwLock.hasQueuedThreads());",
                "+      assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+      assertEquals(rwLock.getQueueLength(), 0);",
                "+      assertNotNull(rwLock.toString());",
                "+    }",
                "+",
                "+    assertFalse(rwLock.isFair());",
                "+    assertFalse(rwLock.isWriteLocked());",
                "+    assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+    assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+    assertEquals(rwLock.getReadLockCount(), 1);",
                "+    assertEquals(rwLock.getReadHoldCount(), 0); // Not held by current thread",
                "+    assertFalse(rwLock.hasQueuedThreads());",
                "+    assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(rwLock.getQueueLength(), 0);",
                "+    assertNotNull(rwLock.toString());",
                "+",
                "+",
                "+    // Verify that we cannot acquire the write lock.",
                "+    try (CloseableReadWriteLock.WriteLock l =",
                "+              rwLock.tryLockWrite(1L, TimeUnit.MILLISECONDS))",
                "+    {",
                "+      fail(\"Expected to fail to acquire the write lock while another thread \" +",
                "+           \"holds the read lock, but instead got \" + l);",
                "+    }",
                "+    catch (final TimeoutException e)",
                "+    {",
                "+      // This was expected.",
                "+      assertNotNull(e.getMessage());",
                "+    }",
                "+",
                "+    tryLockFailed.set(true);",
                "+    thread.join();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the behavior when trying to acquire the read lock while another",
                "+   * thread already holds the write lock.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testLockReadWhileAnotherThreadAlreadyHoldsWriteLock()",
                "+         throws Exception",
                "+  {",
                "+    final CloseableReadWriteLock rwLock = new CloseableReadWriteLock();",
                "+    final AtomicBoolean isLocked = new AtomicBoolean(false);",
                "+    final AtomicBoolean tryLockFailed = new AtomicBoolean(false);",
                "+",
                "+    assertFalse(rwLock.isFair());",
                "+    assertFalse(rwLock.isWriteLocked());",
                "+    assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+    assertEquals(rwLock.getWriteHoldCount(), 0);",
                "+    assertEquals(rwLock.getReadLockCount(), 0);",
                "+    assertEquals(rwLock.getReadHoldCount(), 0);",
                "+    assertFalse(rwLock.hasQueuedThreads());",
                "+    assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(rwLock.getQueueLength(), 0);",
                "+    assertNotNull(rwLock.toString());",
                "+",
                "+    final CloseableReadWriteLockTestCaseThread thread =",
                "+         new CloseableReadWriteLockTestCaseThread(rwLock, true, isLocked,",
                "+              tryLockFailed);",
                "+    thread.start();",
                "+",
                "+    while (! isLocked.get())",
                "+    {",
                "+      Thread.sleep(1L);",
                "+    }",
                "+",
                "+    assertFalse(rwLock.isFair());",
                "+    assertTrue(rwLock.isWriteLocked());",
                "+    assertFalse(rwLock.isWriteLockedByCurrentThread());",
                "+    assertEquals(rwLock.getWriteHoldCount(), 0); // Not held by current thread",
                "+    assertEquals(rwLock.getReadLockCount(), 0);",
                "+    assertEquals(rwLock.getReadHoldCount(), 0);",
                "+    assertFalse(rwLock.hasQueuedThreads());",
                "+    assertFalse(rwLock.hasQueuedThread(Thread.currentThread()));",
                "+    assertEquals(rwLock.getQueueLength(), 0);",
                "+    assertNotNull(rwLock.toString());",
                "+",
                "+    try (CloseableReadWriteLock.ReadLock l =",
                "+              rwLock.tryLockRead(1L, TimeUnit.MILLISECONDS))",
                "+    {",
                "+      fail(\"Expected to fail to acquire the read lock while another thread \" +",
                "+           \"holds the write lock, but instead got \" + l);",
                "+    }",
                "+    catch (final TimeoutException e)",
                "+    {",
                "+      // This was expected.",
                "+      assertNotNull(e.getMessage());",
                "+    }",
                "+",
                "+    tryLockFailed.set(true);",
                "+    thread.join();",
                "+  }",
                "+}",
                "diff --git a/tests/unit/src/com/unboundid/util/CloseableReadWriteLockTestCaseThread.java b/tests/unit/src/com/unboundid/util/CloseableReadWriteLockTestCaseThread.java",
                "new file mode 100644",
                "index 00000000..3694d302",
                "--- /dev/null",
                "+++ b/tests/unit/src/com/unboundid/util/CloseableReadWriteLockTestCaseThread.java",
                "@@ -0,0 +1,139 @@",
                "+/*",
                "+ * Copyright 2018 Ping Identity Corporation",
                "+ * All Rights Reserved.",
                "+ */",
                "+/*",
                "+ * Copyright (C) 2018 Ping Identity Corporation",
                "+ *",
                "+ * This program is free software; you can redistribute it and/or modify",
                "+ * it under the terms of the GNU General Public License (GPLv2 only)",
                "+ * or the terms of the GNU Lesser General Public License (LGPLv2.1 only)",
                "+ * as published by the Free Software Foundation.",
                "+ *",
                "+ * This program is distributed in the hope that it will be useful,",
                "+ * but WITHOUT ANY WARRANTY; without even the implied warranty of",
                "+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
                "+ * GNU General Public License for more details.",
                "+ *",
                "+ * You should have received a copy of the GNU General Public License",
                "+ * along with this program; if not, see <http://www.gnu.org/licenses>.",
                "+ */",
                "+package com.unboundid.util;",
                "+",
                "+",
                "+",
                "+import java.util.concurrent.atomic.AtomicBoolean;",
                "+",
                "+",
                "+",
                "+/**",
                "+ * This class provides a background thread that can be used in testing the",
                "+ * {@code CloseableReadWriteLock} class.",
                "+ */",
                "+final class CloseableReadWriteLockTestCaseThread",
                "+      extends Thread",
                "+{",
                "+  // Indicates whether the thread currently holds the lock.",
                "+  private final AtomicBoolean isLocked;",
                "+",
                "+  // Indicates whether the other thread has failed an attempt to acquire the",
                "+  // lock.",
                "+  private final AtomicBoolean tryLockFailed;",
                "+",
                "+  // Indicates whether this thread should acquire the write lock or the read",
                "+  // lock.",
                "+  private final boolean acquireWriteLock;",
                "+",
                "+  // The lock to use for testing.",
                "+  private final CloseableReadWriteLock lock;",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new instance of this thread with the provided information.",
                "+   *",
                "+   * @param  lock              The lock that will be used for testing.",
                "+   * @param  acquireWriteLock  Indicates whether this thread should acquire the",
                "+   *                           write lock (if {@code true}) or the read lock (if",
                "+   *                           {@code false}).",
                "+   * @param  isLocked          An {@code AtomicBoolean} instance that this",
                "+   *                           thread will update once it has acquired the lock.",
                "+   * @param  tryLockFailed     An {@code AtomicBoolean} value that the",
                "+   *                           {@code CloseableReadWriteLockTestCase} instance",
                "+   *                           will update once it has failed to acquire the",
                "+   *                           lock.",
                "+   */",
                "+  CloseableReadWriteLockTestCaseThread(final CloseableReadWriteLock lock,",
                "+                                       final boolean acquireWriteLock,",
                "+                                       final AtomicBoolean isLocked,",
                "+                                       final AtomicBoolean tryLockFailed)",
                "+  {",
                "+    Validator.ensureNotNull(lock);",
                "+    Validator.ensureFalse(isLocked.get());",
                "+    Validator.ensureFalse(tryLockFailed.get());",
                "+",
                "+    setName(\"CloseableReadWriteLockTestCase Thread (acquireWriteLock=\" +",
                "+         acquireWriteLock + ')');",
                "+    setDaemon(true);",
                "+",
                "+    this.lock = lock;",
                "+    this.acquireWriteLock = acquireWriteLock;",
                "+    this.isLocked = isLocked;",
                "+    this.tryLockFailed = tryLockFailed;",
                "+",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Acquires the lock and waits for the {@code CloseableReadWriteLockTestCase}",
                "+   * thread to fail to acquire it.",
                "+   */",
                "+  @Override()",
                "+  public void run()",
                "+  {",
                "+    Validator.ensureFalse(isLocked.get());",
                "+    Validator.ensureFalse(tryLockFailed.get());",
                "+",
                "+    if (acquireWriteLock)",
                "+    {",
                "+      try (final CloseableReadWriteLock.WriteLock l = lock.lockWrite())",
                "+      {",
                "+        l.avoidCompilerWarning();",
                "+        isLocked.set(true);",
                "+",
                "+        while (! tryLockFailed.get())",
                "+        {",
                "+          try",
                "+          {",
                "+            Thread.sleep(1L);",
                "+          }",
                "+          catch (final Exception e)",
                "+          {",
                "+            Thread.yield();",
                "+          }",
                "+        }",
                "+      }",
                "+    }",
                "+    else",
                "+    {",
                "+      try (final CloseableReadWriteLock.ReadLock l = lock.lockRead())",
                "+      {",
                "+        l.avoidCompilerWarning();",
                "+        isLocked.set(true);",
                "+",
                "+        while (! tryLockFailed.get())",
                "+        {",
                "+          try",
                "+          {",
                "+            Thread.sleep(1L);",
                "+          }",
                "+          catch (final Exception e)",
                "+          {",
                "+            Thread.yield();",
                "+          }",
                "+        }",
                "+      }",
                "+    }",
                "+  }",
                "+}"
            ],
            "changed_files": [
                "docs/release-notes.html",
                "messages/unboundid-ldapsdk-util.properties",
                "src/com/unboundid/util/CloseableLock.java",
                "src/com/unboundid/util/CloseableReadWriteLock.java",
                "tests/unit/src/com/unboundid/util/CloseableLockTestCase.java",
                "tests/unit/src/com/unboundid/util/CloseableLockTestCaseThread.java",
                "tests/unit/src/com/unboundid/util/CloseableReadWriteLockTestCase.java",
                "tests/unit/src/com/unboundid/util/CloseableReadWriteLockTestCaseThread.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: tests/unit/src/com/unboundid/util/CloseableLockTestCaseThread.java, src/com/unboundid/util/CloseableReadWriteLock.java, tests/unit/src/com/unboundid/util/CloseableLockTestCase.java, tests/unit/src/com/unboundid/util/CloseableReadWriteLockTestCase.java, src/com/unboundid/util/CloseableLock.java, tests/unit/src/com/unboundid/util/CloseableReadWriteLockTestCaseThread.java, messages/unboundid-ldapsdk-util.properties",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: class",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "c8c197f47e7819e0b1d5a28054d9413df522fdd7",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1519773657,
            "hunks": 30,
            "message": "Update DurationArgument to support week units Updated the DurationArgument class to support durations with a unit of weeks, which can be indicated with unit values of \"w\", \"week\", or \"weeks\".",
            "diff": [
                "diff --git a/messages/unboundid-ldapsdk-args.properties b/messages/unboundid-ldapsdk-args.properties",
                "index 2f7b1a56..d97284ea 100644",
                "--- a/messages/unboundid-ldapsdk-args.properties",
                "+++ b/messages/unboundid-ldapsdk-args.properties",
                "@@ -181,3 +181,3 @@ INFO_DURATION_CONSTRAINTS_FORMAT=The provided value must contain an integer \\",
                "   (for milliseconds), 's' (for seconds), 'm' (for minutes), 'h' (for hours), \\",
                "-  or 'd' (for days).",
                "+  'd' (for days), or 'w' (for weeks).",
                " INFO_DURATION_CONSTRAINTS_LOWER_BOUND=The specified duration must not be \\",
                "diff --git a/src/com/unboundid/util/args/DurationArgument.java b/src/com/unboundid/util/args/DurationArgument.java",
                "index d2db2d52..1e8c24e7 100644",
                "--- a/src/com/unboundid/util/args/DurationArgument.java",
                "+++ b/src/com/unboundid/util/args/DurationArgument.java",
                "@@ -25,3 +25,2 @@ package com.unboundid.util.args;",
                " import java.util.ArrayList;",
                "-import java.util.Arrays;",
                " import java.util.Collections;",
                "@@ -53,2 +52,3 @@ import static com.unboundid.util.args.ArgsMessages.*;",
                "  *   <LI>Days -- d, day, days</LI>",
                "+ *   <LI>Weeks -- w, week, weeks</LI>",
                "  * </UL>",
                "@@ -247,35 +247,29 @@ public final class DurationArgument",
                "       minValueNanos = lowerBoundUnit.toNanos(lowerBound);",
                "-      final String lowerBoundUnitName = lowerBoundUnit.name();",
                "-      if (lowerBoundUnitName.equals(\"NANOSECONDS\"))",
                "+      switch (lowerBoundUnit)",
                "       {",
                "-        lowerBoundStr = minValueNanos + \"ns\";",
                "-      }",
                "-      else if (lowerBoundUnitName.equals(\"MICROSECONDS\"))",
                "-      {",
                "-        lowerBoundStr = lowerBound + \"us\";",
                "-      }",
                "-      else if (lowerBoundUnitName.equals(\"MILLISECONDS\"))",
                "-      {",
                "-        lowerBoundStr = lowerBound + \"ms\";",
                "-      }",
                "-      else if (lowerBoundUnitName.equals(\"SECONDS\"))",
                "-      {",
                "-        lowerBoundStr = lowerBound + \"s\";",
                "-      }",
                "-      else if (lowerBoundUnitName.equals(\"MINUTES\"))",
                "-      {",
                "-        lowerBoundStr = lowerBound + \"m\";",
                "-      }",
                "-      else if (lowerBoundUnitName.equals(\"HOURS\"))",
                "-      {",
                "-        lowerBoundStr = lowerBound + \"h\";",
                "-      }",
                "-      else if (lowerBoundUnitName.equals(\"DAYS\"))",
                "-      {",
                "-        lowerBoundStr = lowerBound + \"d\";",
                "-      }",
                "-      else",
                "-      {",
                "-        throw new LDAPSDKUsageException(",
                "-             ERR_DURATION_UNSUPPORTED_LOWER_BOUND_UNIT.get(lowerBoundUnitName));",
                "+        case NANOSECONDS:",
                "+          lowerBoundStr = minValueNanos + \"ns\";",
                "+          break;",
                "+        case MICROSECONDS:",
                "+          lowerBoundStr = lowerBound + \"us\";",
                "+          break;",
                "+        case MILLISECONDS:",
                "+          lowerBoundStr = lowerBound + \"ms\";",
                "+          break;",
                "+        case SECONDS:",
                "+          lowerBoundStr = lowerBound + \"s\";",
                "+          break;",
                "+        case MINUTES:",
                "+          lowerBoundStr = lowerBound + \"m\";",
                "+          break;",
                "+        case HOURS:",
                "+          lowerBoundStr = lowerBound + \"h\";",
                "+          break;",
                "+        case DAYS:",
                "+          lowerBoundStr = lowerBound + \"d\";",
                "+          break;",
                "+        default:",
                "+          throw new LDAPSDKUsageException(",
                "+               ERR_DURATION_UNSUPPORTED_LOWER_BOUND_UNIT.get(",
                "+                    lowerBoundUnit.name()));",
                "       }",
                "@@ -297,35 +291,29 @@ public final class DurationArgument",
                "       maxValueNanos = upperBoundUnit.toNanos(upperBound);",
                "-      final String upperBoundUnitName = upperBoundUnit.name();",
                "-      if (upperBoundUnitName.equals(\"NANOSECONDS\"))",
                "-      {",
                "-        upperBoundStr = minValueNanos + \"ns\";",
                "-      }",
                "-      else if (upperBoundUnitName.equals(\"MICROSECONDS\"))",
                "-      {",
                "-        upperBoundStr = upperBound + \"us\";",
                "-      }",
                "-      else if (upperBoundUnitName.equals(\"MILLISECONDS\"))",
                "-      {",
                "-        upperBoundStr = upperBound + \"ms\";",
                "-      }",
                "-      else if (upperBoundUnitName.equals(\"SECONDS\"))",
                "-      {",
                "-        upperBoundStr = upperBound + \"s\";",
                "-      }",
                "-      else if (upperBoundUnitName.equals(\"MINUTES\"))",
                "-      {",
                "-        upperBoundStr = upperBound + \"m\";",
                "-      }",
                "-      else if (upperBoundUnitName.equals(\"HOURS\"))",
                "-      {",
                "-        upperBoundStr = upperBound + \"h\";",
                "-      }",
                "-      else if (upperBoundUnitName.equals(\"DAYS\"))",
                "-      {",
                "-        upperBoundStr = upperBound + \"d\";",
                "-      }",
                "-      else",
                "+      switch (upperBoundUnit)",
                "       {",
                "-        throw new LDAPSDKUsageException(",
                "-             ERR_DURATION_UNSUPPORTED_UPPER_BOUND_UNIT.get(upperBoundUnitName));",
                "+        case NANOSECONDS:",
                "+          upperBoundStr = minValueNanos + \"ns\";",
                "+          break;",
                "+        case MICROSECONDS:",
                "+          upperBoundStr = upperBound + \"us\";",
                "+          break;",
                "+        case MILLISECONDS:",
                "+          upperBoundStr = upperBound + \"ms\";",
                "+          break;",
                "+        case SECONDS:",
                "+          upperBoundStr = upperBound + \"s\";",
                "+          break;",
                "+        case MINUTES:",
                "+          upperBoundStr = upperBound + \"m\";",
                "+          break;",
                "+        case HOURS:",
                "+          upperBoundStr = upperBound + \"h\";",
                "+          break;",
                "+        case DAYS:",
                "+          upperBoundStr = upperBound + \"d\";",
                "+          break;",
                "+        default:",
                "+          throw new LDAPSDKUsageException(",
                "+               ERR_DURATION_UNSUPPORTED_UPPER_BOUND_UNIT.get(",
                "+                    upperBoundUnit.name()));",
                "       }",
                "@@ -340,3 +328,3 @@ public final class DurationArgument",
                "     valueNanos = null;",
                "-    validators = new ArrayList<ArgumentValueValidator>(5);",
                "+    validators = new ArrayList<>(5);",
                "   }",
                "@@ -360,4 +348,3 @@ public final class DurationArgument",
                "     upperBoundStr     = source.upperBoundStr;",
                "-    validators        =",
                "-         new ArrayList<ArgumentValueValidator>(source.validators);",
                "+    validators        = new ArrayList<>(source.validators);",
                "     valueNanos        = null;",
                "@@ -417,3 +404,3 @@ public final class DurationArgument",
                "-    return Collections.unmodifiableList(Arrays.asList(nanosToDuration(v)));",
                "+    return Collections.singletonList(nanosToDuration(v));",
                "   }",
                "@@ -569,3 +556,3 @@ public final class DurationArgument",
                "     final String lowerStr = StaticUtils.toLowerCase(durationString);",
                "-    if (lowerStr.length() == 0)",
                "+    if (lowerStr.isEmpty())",
                "     {",
                "@@ -662,3 +649,10 @@ public final class DurationArgument",
                "     {",
                "-      integerPortion *= 86400L;",
                "+      integerPortion *= 86_400L;",
                "+      unitFromString = TimeUnit.SECONDS;",
                "+    }",
                "+    else if (unitStr.equals(\"w\") ||",
                "+             unitStr.equals(\"week\") ||",
                "+             unitStr.equals(\"weeks\"))",
                "+    {",
                "+      integerPortion *= 604_800;",
                "       unitFromString = TimeUnit.SECONDS;",
                "@@ -757,3 +751,16 @@ public final class DurationArgument",
                "   {",
                "-    if (nanos == 86400000000000L)",
                "+    if (nanos == 0)",
                "+    {",
                "+      return \"0 nanoseconds\";",
                "+    }",
                "+",
                "+    if (nanos == 604_800_000_000_000L)",
                "+    {",
                "+      return \"1 week\";",
                "+    }",
                "+    else if ((nanos % 604_800_000_000_000L) == 0L)",
                "+    {",
                "+      return (nanos / 604_800_000_000_000L) + \" weeks\";",
                "+    }",
                "+    else if (nanos == 86_400_000_000_000L)",
                "     {",
                "@@ -761,7 +768,7 @@ public final class DurationArgument",
                "     }",
                "-    else if ((nanos % 86400000000000L) == 0L)",
                "+    else if ((nanos % 86_400_000_000_000L) == 0L)",
                "     {",
                "-      return (nanos / 86400000000000L) + \" days\";",
                "+      return (nanos / 86_400_000_000_000L) + \" days\";",
                "     }",
                "-    else if (nanos == 3600000000000L)",
                "+    else if (nanos == 3_600_000_000_000L)",
                "     {",
                "@@ -769,7 +776,7 @@ public final class DurationArgument",
                "     }",
                "-    else if ((nanos % 3600000000000L) == 0L)",
                "+    else if ((nanos % 3_600_000_000_000L) == 0L)",
                "     {",
                "-      return (nanos / 3600000000000L) + \" hours\";",
                "+      return (nanos / 3_600_000_000_000L) + \" hours\";",
                "     }",
                "-    else if (nanos == 60000000000L)",
                "+    else if (nanos == 60_000_000_000L)",
                "     {",
                "@@ -777,7 +784,7 @@ public final class DurationArgument",
                "     }",
                "-    else if ((nanos % 60000000000L) == 0L)",
                "+    else if ((nanos % 60_000_000_000L) == 0L)",
                "     {",
                "-      return (nanos / 60000000000L) + \" minutes\";",
                "+      return (nanos / 60_000_000_000L) + \" minutes\";",
                "     }",
                "-    else if (nanos == 1000000000L)",
                "+    else if (nanos == 1_000_000_000L)",
                "     {",
                "@@ -785,7 +792,7 @@ public final class DurationArgument",
                "     }",
                "-    else if ((nanos % 1000000000L) == 0L)",
                "+    else if ((nanos % 1_000_000_000L) == 0L)",
                "     {",
                "-      return (nanos / 1000000000L) + \" seconds\";",
                "+      return (nanos / 1_000_000_000L) + \" seconds\";",
                "     }",
                "-    else if (nanos == 1000000L)",
                "+    else if (nanos == 1_000_000L)",
                "     {",
                "@@ -793,5 +800,5 @@ public final class DurationArgument",
                "     }",
                "-    else if ((nanos % 1000000L) == 0L)",
                "+    else if ((nanos % 1_000_000L) == 0L)",
                "     {",
                "-     return (nanos / 1000000L) + \" milliseconds\";",
                "+     return (nanos / 1_000_000L) + \" milliseconds\";",
                "     }",
                "diff --git a/tests/unit/src/com/unboundid/util/args/DurationArgumentTestCase.java b/tests/unit/src/com/unboundid/util/args/DurationArgumentTestCase.java",
                "index ced655a2..8e34b6a5 100644",
                "--- a/tests/unit/src/com/unboundid/util/args/DurationArgumentTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/util/args/DurationArgumentTestCase.java",
                "@@ -413,2 +413,20 @@ public class DurationArgumentTestCase",
                "+  /**",
                "+   * Tests the {@code nanosToDuration} method with the provided values.",
                "+   *",
                "+   * @param  nanos             The value to provide to the method.",
                "+   * @param  expectedDuration  The expected return value from the method.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"nanosToDurationValues\")",
                "+  public void testNanosToDuration(final long nanos,",
                "+                                  final String expectedDuration)",
                "+         throws Exception",
                "+  {",
                "+    assertEquals(DurationArgument.nanosToDuration(nanos), expectedDuration);",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -469,2 +487,7 @@ public class DurationArgumentTestCase",
                "       new Object[] { \"7890 days\", 7890L, TimeUnit.DAYS },",
                "+",
                "+      new Object[] { \"1w\", 7L, TimeUnit.DAYS },",
                "+      new Object[] { \"2 w\", 14L, TimeUnit.DAYS },",
                "+      new Object[] { \"3 week\", 21L, TimeUnit.DAYS },",
                "+      new Object[] { \"4 weeks\", 28L, TimeUnit.DAYS },",
                "     };",
                "@@ -493,2 +516,134 @@ public class DurationArgumentTestCase",
                "   }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves a set of values that can be used for testing the",
                "+   * {@code nanosToDuration} method.",
                "+   *",
                "+   * @return  A set of values that can be used for testing the",
                "+   *          {@code nanosToDuration} method.",
                "+   */",
                "+  @DataProvider(name = \"nanosToDurationValues\")",
                "+  public Object[][] getNanosToDurationValues()",
                "+  {",
                "+    return new Object[][]",
                "+    {",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(7L, TimeUnit.DAYS),",
                "+        \"1 week\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(14L, TimeUnit.DAYS),",
                "+        \"2 weeks\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(1L, TimeUnit.DAYS),",
                "+        \"1 day\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(2L, TimeUnit.DAYS),",
                "+        \"2 days\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(1L, TimeUnit.HOURS),",
                "+        \"1 hour\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(2L, TimeUnit.HOURS),",
                "+        \"2 hours\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(1L, TimeUnit.MINUTES),",
                "+        \"1 minute\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(2L, TimeUnit.MINUTES),",
                "+        \"2 minutes\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(1L, TimeUnit.SECONDS),",
                "+        \"1 second\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(2L, TimeUnit.SECONDS),",
                "+        \"2 seconds\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(1L, TimeUnit.MILLISECONDS),",
                "+        \"1 millisecond\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(2L, TimeUnit.MILLISECONDS),",
                "+        \"2 milliseconds\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(1L, TimeUnit.MICROSECONDS),",
                "+        \"1 microsecond\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(2L, TimeUnit.MICROSECONDS),",
                "+        \"2 microseconds\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(1L, TimeUnit.NANOSECONDS),",
                "+        \"1 nanosecond\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(2L, TimeUnit.NANOSECONDS),",
                "+        \"2 nanoseconds\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(0L, TimeUnit.DAYS),",
                "+        \"0 nanoseconds\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(0L, TimeUnit.HOURS),",
                "+        \"0 nanoseconds\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(0L, TimeUnit.MINUTES),",
                "+        \"0 nanoseconds\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(0L, TimeUnit.SECONDS),",
                "+        \"0 nanoseconds\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(0L, TimeUnit.MILLISECONDS),",
                "+        \"0 nanoseconds\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(0L, TimeUnit.MICROSECONDS),",
                "+        \"0 nanoseconds\"",
                "+      },",
                "+      new Object[]",
                "+      {",
                "+        TimeUnit.NANOSECONDS.convert(0L, TimeUnit.NANOSECONDS),",
                "+        \"0 nanoseconds\"",
                "+      }",
                "+    };",
                "+  }",
                " }"
            ],
            "changed_files": [
                "messages/unboundid-ldapsdk-args.properties",
                "src/com/unboundid/util/args/DurationArgument.java",
                "tests/unit/src/com/unboundid/util/args/DurationArgumentTestCase.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: messages/unboundid-ldapsdk-args.properties, tests/unit/src/com/unboundid/util/args/DurationArgumentTestCase.java, src/com/unboundid/util/args/DurationArgument.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: class",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "cdb139e3e8948f1a54cf57d18751ca8156426d83",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1520389106,
            "hunks": 172,
            "message": "Add tool compression and encryption support Updated a number of tools to provide support for dealing with compressed and/or encrypted data (assuming that the compressed data is compressed with the GZIP algorithm, and that encrypted data is written with the PassphraseEncryptedOutputStream).  This includes: * If ldapsearch output is to be written to one or more LDIF files,   it is now possible to compress and/or encrypt that output.  The   --compressOutput argument can be used to indicate that the output   should be compressed, and the --encryptOutput argument can be   used to indicate that the output should be encrypted.  If the   --encryptionPassphraseFile argument is provided, the encryption   passphrase will be read from that file; otherwise, it will be   interactively requested from the user. * If ldapmodify is to read the changes to apply from one or more   LDIF files, it can automatically detect whether the files are   encrypted and/or compressed and will handle them accordingly.   If the --encryptionPassphraseFile argument is provided, the   encryption passphrase will be read from that file; otherwise, it   will be interactively requested from the user. * The split-ldif and transform-ldif tools can now automatically   detect whether the input LDIF files are compressed and/or   encrypted, and they can now be directed to encrypt their output.   The --sourceCompressed argument is still supported for the purpose   of backward compatibility, but it is no longer required.  The   --encryptTarget argument can be used to indicate that the output   should be encrypted.  If the --encryptionPassphraseFile argument   is provided, then the passphrase will be read from the specified   file; otherwise, it will be interactively requested from the user. * The validate-ldif tool can now automatically detect whether the   input LDIF file is compressed and/or encrypted.  The   --isCompressed argument is still supported for the purpose of   backward compatibility, but it is no longer required.  If the   --encryptionPassphraseFile argument is provided, then the   passphrase will read from the specified file; otherwise, it will   be interactively requested from the user. * The summarize-access-log tool can now automatically detect whether   the input log files are compressed and/or encrypted.  The   --isCompressed argument is still supported for the purpose of   backward compatibility, but it is no longer required.  If the   --encryptionPassphraseFile argument is provided, then the   passphrase will read from the specified file; otherwise, it will   be interactively requested from the user.",
            "diff": [
                "diff --git a/docs/release-notes.html b/docs/release-notes.html",
                "index 81f69a1b..0dabf2ee 100644",
                "--- a/docs/release-notes.html",
                "+++ b/docs/release-notes.html",
                "@@ -93,2 +93,10 @@ ${TARGET=\"offline\"}                <br>",
                "+                <li>",
                "+                  Updated the <tt>ldapsearch</tt>, <tt>ldapmodify</tt>, <tt>split-ldif</tt>,",
                "+                  <tt>transform-ldif</tt>, and <tt>validate-ldif</tt> tools to add support for",
                "+                  encrypted LDIF files.  The passphrase used to generate the encryption key can be",
                "+                  provided interactively or read from a file.",
                "+                  <br><br>",
                "+                </li>",
                "+",
                "                 <li>",
                "diff --git a/messages/unboundid-ldapsdk-tools.properties b/messages/unboundid-ldapsdk-tools.properties",
                "index 693adcd8..69f6584c 100644",
                "--- a/messages/unboundid-ldapsdk-tools.properties",
                "+++ b/messages/unboundid-ldapsdk-tools.properties",
                "@@ -1265,2 +1265,6 @@ INFO_LDAPMODIFY_ARG_DESCRIPTION_LDIF_FILE=The path to the LDIF file \\",
                "   in the order they were provided on the command line.",
                "+INFO_LDAPMODIFY_ARG_DESCRIPTION_ENCRYPTION_PW_FILE=The path to a file that \\",
                "+  contains the passphrase used to generate the key used to encrypt the LDIF \\",
                "+  data.  If the data is encrypted and this argument is not provided, then the \\",
                "+  tool will interactively prompt for the correct password.",
                " INFO_LDAPMODIFY_PLACEHOLDER_CHARSET={charset}",
                "@@ -1371,2 +1375,9 @@ INFO_LDAPMODIFY_CONNECTION_ESTABLISHED=Successfully connected to {0}.",
                " INFO_LDAPMODIFY_STARTED_TXN=Successfully started a transaction with ID {0}",
                "+ERR_LDAPMODIFY_ENCRYPTION_PW_FILE_EMPTY=Encryption passphrase file ''{0}'' \\",
                "+  is empty.",
                "+ERR_LDAPMODIFY_ENCRYPTION_PW_FILE_MULTIPLE_LINES=Encryption passphrase file \\",
                "+  ''{0}''has multiple lines.  The file must contain exactly one line, which \\",
                "+  is comprised entirely of the encryption passphrase.",
                "+ERR_LDAPMODIFY_ENCRYPTION_PW_FILE_READ_ERROR=An error occurred while trying \\",
                "+  to read the encryption passphrase from file ''{0}'':  {1}",
                " ERR_LDAPMODIFY_CANNOT_START_TXN=An error occurred while trying to start an \\",
                "@@ -1721,2 +1732,19 @@ INFO_LDAPSEARCH_ARG_DESCRIPTION_OUTPUT_FILE=Specifies the path to the file to \\",
                "   then results will be written to standard output.",
                "+INFO_LDAPSEARCH_ARG_DESCRIPTION_COMPRESS_OUTPUT=Indicates that the output \\",
                "+  should be gzip-compressed.  This can only be used if the --outputFile \\",
                "+  argument is provided and the --teeResultsToStandardOut argument is not \\",
                "+  provided.",
                "+INFO_LDAPSEARCH_ARG_DESCRIPTION_ENCRYPT_OUTPUT=Indicates that the output \\",
                "+  should be encrypted with a key generated from a provided password.  This \\",
                "+  can only be used if the --outputFile argument is provided and the \\",
                "+  --teeResultsToStandardOut argument is not provided.  If the \\",
                "+  --encryptionPassphraseFile argument is provided, then that file will be used \\",
                "+  to specify the encryption passphrase; otherwise, the passphrase will be \\",
                "+  interactively requested.",
                "+INFO_LDAPSEARCH_ARG_DESCRIPTION_ENCRYPTION_PW_FILE=The path to a file that \\",
                "+  specifies the passphrase to use to encrypt the output.  This can only be \\",
                "+  provided if the --encryptOutput argument is given, but if that argument is \\",
                "+  given and no passphrase file is specified, then the passphrase will be \\",
                "+  interactively requested.  If a file is specified, then that file must \\",
                "+  exist and must contain exactly one line comprised entirely of the passphrase.",
                " INFO_LDAPSEARCH_ARG_DESCRIPTION_ASSERTION_FILTER=A filter that will be used \\",
                "@@ -1990,3 +2018,3 @@ ERR_LDAPSEARCH_VLV_INVALID_VALUE=The value provided for the ''{0}'' argument \\",
                "   expected result set size, with zero used if the expected result set size is \\",
                "-  not knonw), or a colon-delimited list of two integers and one string \\",
                "+  not known), or a colon-delimited list of two integers and one string \\",
                "   (representing the before count, after count, and the primary sort attribute \\",
                "@@ -2019,4 +2047,4 @@ ERR_LDAPSEARCH_OUTPUT_FORMAT_NOT_SUPPORTED_WITH_URLS=The ''{0}'' output \\",
                " ERR_LDAPSEARCH_OUTPUT_FORMAT_REQUIRES_REQUESTED_ATTR_ARG=The ''{0}'' output \\",
                "-   format requires that the set of requested arguments be identified with the \\",
                "-   ''{1}'' argument rather than as unnamed trailing arguments.",
                "+  format requires that the set of requested arguments be identified with the \\",
                "+  ''{1}'' argument rather than as unnamed trailing arguments.",
                " ERR_LDAPSEARCH_CANNOT_OPEN_OUTPUT_FILE=Unable to open output file ''{0}'' \\",
                "@@ -2103,2 +2131,14 @@ INFO_SPLIT_LDIF_GLOBAL_ARG_DESC_COMPRESS_TARGET=Indicates that the target \\",
                "   LDIF files should be gzip-compressed.",
                "+INFO_SPLIT_LDIF_GLOBAL_ARG_DESC_ENCRYPT_TARGET=Indicates that the target LDIF \\",
                "+  LDIF files should be encrypted with a key generated from a provided \\",
                "+  passphrase.  If the --encryptionPassphraseFile argument is provided, then \\",
                "+  the passphrase will be read from the specified file.  Otherwise, it will be \\",
                "+  interactively requested from the user.",
                "+INFO_SPLIT_LDIF_GLOBAL_ARG_DESC_ENCRYPT_PW_FILE=The path to the file \\",
                "+  containing the passphrase to use to generate the encryption key.  This \\",
                "+  passphrase will be used to decrypt the input (if it is encrypted) and to \\",
                "+  encrypt the output (if it is to be encrypted).  If this is not provided and either the input or output is encrypted, then the passphrase will be \\",
                "+  interactively requested.  If it is provided, then the specified file must \\",
                "+  exist and must contain exactly one line that is comprised entirely of the \\",
                "+  encryption passphrase.",
                " INFO_SPLIT_LDIF_GLOBAL_ARG_DESC_SPLIT_BASE_DN=The base DN below which entries \\",
                "@@ -2304,2 +2344,25 @@ ERR_TOOL_LOGGER_UNABLE_TO_ACQUIRE_FILE_LOCK=Unable to acquire an exclusive \\",
                "   lock on tool invocation log file ''{0}'' after {1,number,0} attempts.",
                "+ERR_TOOL_UTILS_ENCRYPTION_PW_FILE_MISSING=Encryption passphrase file ''{0}'' \\",
                "+  does not exist.",
                "+ERR_TOOL_UTILS_ENCRYPTION_PW_FILE_NOT_FILE=Encryption passphrase file ''{0}'' \\",
                "+  exists but is not a file.",
                "+ERR_TOOL_UTILS_ENCRYPTION_PW_FILE_EMPTY=Encryption passphrase file ''{0}'' is \\",
                "+  empty.  The file must consist of exactly one line that is comprised \\",
                "+  entirely of the encryption passphrase.",
                "+ERR_TOOL_UTILS_ENCRYPTION_PW_FILE_MULTIPLE_LINES=Encryption passphrase file \\",
                "+  ''{0}'' contains multiple lines.  The file must consist of exactly one line \\",
                "+  that is comprised entirely of the encryption passphrase.",
                "+ERR_TOOL_UTILS_ENCRYPTION_PW_FILE_READ_ERROR=An error occurred while \\",
                "+  attempting to read the encryption passphrase from file ''{0}'':  {1}",
                "+INFO_TOOL_UTILS_ENCRYPTION_PW_PROMPT=Enter the encryption passphrase:",
                "+ERR_TOOL_UTILS_ENCRYPTION_PW_EMPTY=ERROR:  The encryption passphrase must not \\",
                "+  be empty.",
                "+INFO_TOOL_UTILS_ENCRYPTION_PW_CONFIRM=Confirm the encryption passphrase:",
                "+ERR_TOOL_UTILS_ENCRYPTION_PW_MISMATCH=ERROR:  The passphrases do not match.",
                "+INFO_TOOL_UTILS_ENCRYPTED_LDIF_FILE_PW_PROMPT=LDIF file ''{0}'' is \\",
                "+  encrypted.  Please enter the passphrase required to decrypt it:",
                "+ERR_TOOL_UTILS_ENCRYPTED_LDIF_FILE_WRONG_PW=The provided passphrase is \\",
                "+  incorrect.",
                "+ERR_TOOL_UTILS_ENCRYPTED_LDIF_FILE_CANNOT_DECRYPT=LDIF file ''{0}'' is \\",
                "+  encrypted, but an error occurred while attempting to decrypt it:  {1}",
                "diff --git a/messages/unboundid-ldapsdk-transformations.properties b/messages/unboundid-ldapsdk-transformations.properties",
                "index f6e2a96d..a4936ca6 100644",
                "--- a/messages/unboundid-ldapsdk-transformations.properties",
                "+++ b/messages/unboundid-ldapsdk-transformations.properties",
                "@@ -72,2 +72,13 @@ INFO_TRANSFORM_LDIF_ARG_DESC_COMPRESS_TARGET=Indicates that the target LDIF \\",
                "   file should be gzip-compressed.",
                "+INFO_TRANSFORM_LDIF_ARG_DESC_ENCRYPT_TARGET=Indicates that the target LDIF \\",
                "+  file should be encrypted with a key generated from a provided passphrase.  \\",
                "+  If the --encryptionPassphraseFile argument is provided, then the passphrase \\",
                "+  will be read from that file; otherwise, it will be interactively requested.",
                "+INFO_TRANSFORM_LDIF_ARG_DESC_ENCRYPTION_PW_FILE=The path to a file that \\",
                "+  contains the passphrase that should be used to generate the encryption \\",
                "+  key, and also to decrypt the input if it happens to be encrypted.  If the \\",
                "+  --encryptTarget argument is provided and no passphrase file is given, then \\",
                "+  the passphrase will be interactively requested.  If an encryption \\",
                "+  passphrase file is specified, then it must contain exactly one line, and \\",
                "+  that line must be comprised entirely of the passphrase.",
                " INFO_TRANSFORM_LDIF_ARG_GROUP_SCRAMBLE=Arguments for Scrambling Attribute \\",
                "@@ -361,3 +372,3 @@ INFO_TRANSFORM_LDIF_EXAMPLE_REBASE=Transform the data contained in file \\",
                "   'input.ldif' to move all entries at or below 'o=example.com' so that they \\",
                "-  will instead be below 'dc=exmaple,dc=com'.  The output will be written to \\",
                "+  will instead be below 'dc=example,dc=com'.  The output will be written to \\",
                "   the 'rebased.ldif' file.",
                "diff --git a/messages/unboundid-ldapsdk-util.properties b/messages/unboundid-ldapsdk-util.properties",
                "index 33f62952..42288a10 100644",
                "--- a/messages/unboundid-ldapsdk-util.properties",
                "+++ b/messages/unboundid-ldapsdk-util.properties",
                "@@ -815 +815,3 @@ ERR_CLOSEABLE_RW_LOCK_TRY_LOCK_READ_TIMEOUT=Unable to acquire the closeable \\",
                "   read lock with a timeout of {0}.",
                "+ERR_CANNOT_GET_ENCRYPTION_PASSPHRASE=Unable to interactively read the \\",
                "+  encryption passphrase from the user:  {0}",
                "diff --git a/src/com/unboundid/ldap/sdk/examples/ValidateLDIF.java b/src/com/unboundid/ldap/sdk/examples/ValidateLDIF.java",
                "index bb24975d..a77b1b10 100644",
                "--- a/src/com/unboundid/ldap/sdk/examples/ValidateLDIF.java",
                "+++ b/src/com/unboundid/ldap/sdk/examples/ValidateLDIF.java",
                "@@ -44,2 +44,3 @@ import com.unboundid.ldap.sdk.schema.Schema;",
                " import com.unboundid.ldap.sdk.schema.EntryValidator;",
                "+import com.unboundid.ldap.sdk.unboundidds.tools.ToolUtils;",
                " import com.unboundid.ldif.DuplicateValueBehavior;",
                "@@ -49,2 +50,3 @@ import com.unboundid.ldif.LDIFReaderEntryTranslator;",
                " import com.unboundid.ldif.LDIFWriter;",
                "+import com.unboundid.util.Debug;",
                " import com.unboundid.util.LDAPCommandLineTool;",
                "@@ -174,2 +176,3 @@ public final class ValidateLDIF",
                "   private FileArgument    rejectFile;",
                "+  private FileArgument    encryptionPassphraseFile;",
                "   private IntegerArgument numThreads;",
                "@@ -411,3 +414,5 @@ public final class ValidateLDIF",
                "   {",
                "-    String description = \"The path to the LDIF file to process.\";",
                "+    String description = \"The path to the LDIF file to process.  The tool \" +",
                "+         \"will automatically attempt to detect whether the file is \" +",
                "+         \"encrypted or compressed.\";",
                "     ldifFile = new FileArgument('f', \"ldifFile\", true, 1, \"{path}\", description,",
                "@@ -417,2 +422,8 @@ public final class ValidateLDIF",
                "+",
                "+    // Add an argument that makes it possible to read a compressed LDIF file.",
                "+    // Note that this argument is no longer needed for dealing with compressed",
                "+    // files, since the tool will automatically detect whether a file is",
                "+    // compressed.  However, the argument is still provided for the purpose of",
                "+    // backward compatibility.",
                "     description = \"Indicates that the specified LDIF file is compressed \" +",
                "@@ -421,4 +432,24 @@ public final class ValidateLDIF",
                "     isCompressed.addLongIdentifier(\"is-compressed\", true);",
                "+    isCompressed.setHidden(true);",
                "     parser.addArgument(isCompressed);",
                "+",
                "+    // Add an argument that indicates that the tool should read the encryption",
                "+    // passphrase from a file.",
                "+    description = \"Indicates that the specified LDIF file is encrypted and \" +",
                "+         \"that the encryption passphrase is contained in the specified \" +",
                "+         \"file.  If the LDIF data is encrypted and this argument is not \" +",
                "+         \"provided, then the tool will interactively prompt for the \" +",
                "+         \"encryption passphrase.\";",
                "+    encryptionPassphraseFile = new FileArgument(null,",
                "+         \"encryptionPassphraseFile\", false, 1, null, description, true, true,",
                "+         true, false);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryption-passphrase-file\",",
                "+         true);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryptionPasswordFile\", true);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryption-password-file\",",
                "+         true);",
                "+    parser.addArgument(encryptionPassphraseFile);",
                "+",
                "+",
                "     description = \"The path to the file to which rejected entries should be \" +",
                "@@ -636,2 +667,3 @@ public final class ValidateLDIF",
                "       {",
                "+        Debug.debugException(e);",
                "         err(\"Unable to read schema from files in directory \" +",
                "@@ -651,2 +683,3 @@ public final class ValidateLDIF",
                "       {",
                "+        Debug.debugException(le);",
                "         err(\"Unable to connect to the directory server and read the schema:  \",",
                "@@ -658,2 +691,20 @@ public final class ValidateLDIF",
                "+    // Get the encryption passphrase, if it was provided.",
                "+    String encryptionPassphrase = null;",
                "+    if (encryptionPassphraseFile.isPresent())",
                "+    {",
                "+      try",
                "+      {",
                "+        encryptionPassphrase = ToolUtils.readEncryptionPassphraseFromFile(",
                "+             encryptionPassphraseFile.getValue());",
                "+      }",
                "+      catch (final LDAPException e)",
                "+      {",
                "+        Debug.debugException(e);",
                "+        err(e.getMessage());",
                "+        return e.getResultCode();",
                "+      }",
                "+    }",
                "+",
                "+",
                "     // Create the entry validator and initialize its configuration.",
                "@@ -695,2 +746,10 @@ public final class ValidateLDIF",
                "       InputStream inputStream = new FileInputStream(ldifFile.getValue());",
                "+",
                "+      inputStream = ToolUtils.getPossiblyPassphraseEncryptedInputStream(",
                "+           inputStream, encryptionPassphrase, false,",
                "+           \"LDIF file '\" + ldifFile.getValue().getPath() +",
                "+                \"' is encrypted.  Please enter the encryption passphrase:\",",
                "+             \"ERROR:  The provided passphrase was incorrect.\",",
                "+             getOut(), getErr()).getFirst();",
                "+",
                "       if (isCompressed.isPresent())",
                "@@ -699,2 +758,8 @@ public final class ValidateLDIF",
                "       }",
                "+      else",
                "+      {",
                "+        inputStream =",
                "+             ToolUtils.getPossiblyGZIPCompressedInputStream(inputStream);",
                "+      }",
                "+",
                "       ldifReader = new LDIFReader(inputStream, numThreads.getValue(), this);",
                "@@ -703,2 +768,3 @@ public final class ValidateLDIF",
                "     {",
                "+      Debug.debugException(e);",
                "       err(\"Unable to open the LDIF reader:  \", getExceptionMessage(e));",
                "@@ -730,2 +796,3 @@ public final class ValidateLDIF",
                "       {",
                "+        Debug.debugException(e);",
                "         err(\"Unable to create the reject writer:  \", getExceptionMessage(e));",
                "@@ -753,2 +820,3 @@ public final class ValidateLDIF",
                "         {",
                "+          Debug.debugException(le);",
                "           malformedEntries.incrementAndGet();",
                "@@ -782,2 +850,3 @@ public final class ValidateLDIF",
                "             {",
                "+              Debug.debugException(ioe);",
                "               err(\"Unable to write to the reject file:\",",
                "@@ -792,2 +861,3 @@ public final class ValidateLDIF",
                "         {",
                "+          Debug.debugException(ioe);",
                "@@ -805,2 +875,3 @@ public final class ValidateLDIF",
                "             {",
                "+              Debug.debugException(ex);",
                "               err(\"I/O error reading from LDIF:\", getExceptionMessage(ioe));",
                "@@ -846,3 +917,6 @@ public final class ValidateLDIF",
                "       }",
                "-      catch (final Exception e) {}",
                "+      catch (final Exception e)",
                "+      {",
                "+        Debug.debugException(e);",
                "+      }",
                "@@ -855,3 +929,6 @@ public final class ValidateLDIF",
                "       }",
                "-      catch (final Exception e) {}",
                "+      catch (final Exception e)",
                "+      {",
                "+        Debug.debugException(e);",
                "+      }",
                "     }",
                "@@ -887,3 +964,6 @@ public final class ValidateLDIF",
                "           }",
                "-          catch (final IOException ioe) {}",
                "+          catch (final IOException ioe)",
                "+          {",
                "+            Debug.debugException(ioe);",
                "+          }",
                "         }",
                "diff --git a/src/com/unboundid/ldap/sdk/transformations/TransformLDIF.java b/src/com/unboundid/ldap/sdk/transformations/TransformLDIF.java",
                "index 146d8a21..bb09844c 100644",
                "--- a/src/com/unboundid/ldap/sdk/transformations/TransformLDIF.java",
                "+++ b/src/com/unboundid/ldap/sdk/transformations/TransformLDIF.java",
                "@@ -24,5 +24,3 @@ package com.unboundid.ldap.sdk.transformations;",
                "-import java.io.ByteArrayInputStream;",
                " import java.io.File;",
                "-import java.io.FileInputStream;",
                " import java.io.FileOutputStream;",
                "@@ -36,3 +34,2 @@ import java.util.TreeMap;",
                " import java.util.concurrent.atomic.AtomicLong;",
                "-import java.util.zip.GZIPInputStream;",
                " import java.util.zip.GZIPOutputStream;",
                "@@ -46,2 +43,3 @@ import com.unboundid.ldap.sdk.Version;",
                " import com.unboundid.ldap.sdk.schema.Schema;",
                "+import com.unboundid.ldap.sdk.unboundidds.tools.ToolUtils;",
                " import com.unboundid.ldif.AggregateLDIFReaderChangeRecordTranslator;",
                "@@ -53,3 +51,2 @@ import com.unboundid.ldif.LDIFReaderEntryTranslator;",
                " import com.unboundid.ldif.LDIFRecord;",
                "-import com.unboundid.util.AggregateInputStream;",
                " import com.unboundid.util.ByteStringBuffer;",
                "@@ -57,2 +54,4 @@ import com.unboundid.util.CommandLineTool;",
                " import com.unboundid.util.Debug;",
                "+import com.unboundid.util.ObjectPair;",
                "+import com.unboundid.util.PassphraseEncryptedOutputStream;",
                " import com.unboundid.util.StaticUtils;",
                "@@ -136,2 +135,3 @@ public final class TransformLDIF",
                "   private BooleanArgument compressTarget = null;",
                "+  private BooleanArgument encryptTarget = null;",
                "   private BooleanArgument excludeNonMatchingEntries = null;",
                "@@ -150,2 +150,3 @@ public final class TransformLDIF",
                "   private DNArgument moveSubtreeTo = null;",
                "+  private FileArgument encryptionPassphraseFile = null;",
                "   private FileArgument schemaPath = null;",
                "@@ -389,2 +390,25 @@ public final class TransformLDIF",
                "+    encryptTarget = new BooleanArgument(null, \"encryptTarget\",",
                "+         INFO_TRANSFORM_LDIF_ARG_DESC_ENCRYPT_TARGET.get());",
                "+    encryptTarget.addLongIdentifier(\"encryptOutput\", true);",
                "+    encryptTarget.addLongIdentifier(\"encrypt\", true);",
                "+    encryptTarget.addLongIdentifier(\"encrypt-target\", true);",
                "+    encryptTarget.addLongIdentifier(\"encrypt-output\", true);",
                "+    encryptTarget.setArgumentGroupName(",
                "+         INFO_TRANSFORM_LDIF_ARG_GROUP_LDIF.get());",
                "+    parser.addArgument(encryptTarget);",
                "+",
                "+    encryptionPassphraseFile = new FileArgument(null,",
                "+         \"encryptionPassphraseFile\", false, 1, null,",
                "+         INFO_TRANSFORM_LDIF_ARG_DESC_ENCRYPTION_PW_FILE.get(), true, true,",
                "+         true, false);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryptionPasswordFile\", true);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryption-passphrase-file\",",
                "+         true);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryption-password-file\",",
                "+         true);",
                "+    encryptionPassphraseFile.setArgumentGroupName(",
                "+         INFO_TRANSFORM_LDIF_ARG_GROUP_LDIF.get());",
                "+    parser.addArgument(encryptionPassphraseFile);",
                "+",
                "@@ -836,2 +860,20 @@ public final class TransformLDIF",
                "+    // If an encryption passphrase file is provided, then get the passphrase",
                "+    // from it.",
                "+    String encryptionPassphrase = null;",
                "+    if (encryptionPassphraseFile.isPresent())",
                "+    {",
                "+      try",
                "+      {",
                "+        encryptionPassphrase = ToolUtils.readEncryptionPassphraseFromFile(",
                "+             encryptionPassphraseFile.getValue());",
                "+      }",
                "+      catch (final LDAPException e)",
                "+      {",
                "+        wrapErr(0, MAX_OUTPUT_LINE_LENGTH, e.getMessage());",
                "+        return e.getResultCode();",
                "+      }",
                "+    }",
                "+",
                "+",
                "     // Create the translators to use to apply the transformations.",
                "@@ -873,32 +915,12 @@ public final class TransformLDIF",
                "     {",
                "-      InputStream inputStream;",
                "+      final InputStream inputStream;",
                "       if (sourceLDIF.isPresent())",
                "       {",
                "-        final List<File> sourceFiles = sourceLDIF.getValues();",
                "-        final ArrayList<InputStream> fileInputStreams =",
                "-             new ArrayList<InputStream>(2*sourceFiles.size());",
                "-        for (final File f : sourceFiles)",
                "+        final ObjectPair<InputStream,String> p =",
                "+             ToolUtils.getInputStreamForLDIFFiles(sourceLDIF.getValues(),",
                "+                  encryptionPassphrase, getOut(), getErr());",
                "+        inputStream = p.getFirst();",
                "+        if ((encryptionPassphrase == null) && (p.getSecond() != null))",
                "         {",
                "-          if (! fileInputStreams.isEmpty())",
                "-          {",
                "-            // Go ahead and ensure that there are at least new end-of-line",
                "-            // markers between each file.  Otherwise, it's possible for entries",
                "-            // to run together.",
                "-            final byte[] doubleEOL = new byte[StaticUtils.EOL_BYTES.length * 2];",
                "-            System.arraycopy(StaticUtils.EOL_BYTES, 0, doubleEOL, 0,",
                "-                 StaticUtils.EOL_BYTES.length);",
                "-            System.arraycopy(StaticUtils.EOL_BYTES, 0, doubleEOL,",
                "-                 StaticUtils.EOL_BYTES.length, StaticUtils.EOL_BYTES.length);",
                "-            fileInputStreams.add(new ByteArrayInputStream(doubleEOL));",
                "-          }",
                "-          fileInputStreams.add(new FileInputStream(f));",
                "-        }",
                "-",
                "-        if (fileInputStreams.size() == 1)",
                "-        {",
                "-          inputStream = fileInputStreams.get(0);",
                "-        }",
                "-        else",
                "-        {",
                "-          inputStream = new AggregateInputStream(fileInputStreams);",
                "+          encryptionPassphrase = p.getSecond();",
                "         }",
                "@@ -910,7 +932,2 @@ public final class TransformLDIF",
                "-      if (sourceCompressed.isPresent())",
                "-      {",
                "-        inputStream = new GZIPInputStream(inputStream);",
                "-      }",
                "-",
                "       ldifReader = new LDIFReader(inputStream, numThreads.getValue(),",
                "@@ -950,2 +967,14 @@ processingBlock:",
                "+        if (encryptTarget.isPresent())",
                "+        {",
                "+          if (encryptionPassphrase == null)",
                "+          {",
                "+            encryptionPassphrase = ToolUtils.promptForEncryptionPassphrase(",
                "+                 false, true, getOut(), getErr());",
                "+          }",
                "+",
                "+          outputStream = new PassphraseEncryptedOutputStream(",
                "+               encryptionPassphrase, outputStream);",
                "+        }",
                "+",
                "         if (compressTarget.isPresent())",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java b/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                "index f4df06d7..0accdfa8 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                "@@ -24,6 +24,4 @@ package com.unboundid.ldap.sdk.unboundidds.examples;",
                "-import java.io.BufferedReader;",
                " import java.io.File;",
                " import java.io.FileInputStream;",
                "-import java.io.FileReader;",
                " import java.io.InputStream;",
                "@@ -35,3 +33,2 @@ import java.text.DecimalFormat;",
                " import java.util.ArrayList;",
                "-import java.util.Arrays;",
                " import java.util.HashMap;",
                "@@ -69,2 +66,3 @@ import com.unboundid.ldap.sdk.unboundidds.logs.SearchResultAccessLogMessage;",
                " import com.unboundid.ldap.sdk.unboundidds.logs.UnbindRequestAccessLogMessage;",
                "+import com.unboundid.ldap.sdk.unboundidds.tools.ToolUtils;",
                " import com.unboundid.util.CommandLineTool;",
                "@@ -73,4 +71,2 @@ import com.unboundid.util.NotMutable;",
                " import com.unboundid.util.ObjectPair;",
                "-import com.unboundid.util.PassphraseEncryptedInputStream;",
                "-import com.unboundid.util.PasswordReader;",
                " import com.unboundid.util.ReverseComparator;",
                "@@ -156,3 +152,3 @@ public final class SummarizeAccessLog",
                "-  // And argument which may be used to indicate that the log files are",
                "+  // An argument which may be used to indicate that the log files are",
                "   // compressed.",
                "@@ -160,4 +156,3 @@ public final class SummarizeAccessLog",
                "-  // Arguments used to specify the encryption passphrase.",
                "-  private BooleanArgument promptForEncryptionPassphrase;",
                "+  // An argument used to specify the encryption passphrase.",
                "   private FileArgument    encryptionPassphraseFile;",
                "@@ -550,2 +545,6 @@ public final class SummarizeAccessLog",
                "     // Add an argument that makes it possible to read a compressed log file.",
                "+    // Note that this argument is no longer needed for dealing with compressed",
                "+    // files, since the tool will automatically detect whether a file is",
                "+    // compressed.  However, the argument is still provided for the purpose of",
                "+    // backward compatibility.",
                "     String description = \"Indicates that the log file is compressed.\";",
                "@@ -554,2 +553,3 @@ public final class SummarizeAccessLog",
                "     isCompressed.addLongIdentifier(\"compressed\", true);",
                "+    isCompressed.setHidden(true);",
                "     parser.addArgument(isCompressed);",
                "@@ -557,17 +557,2 @@ public final class SummarizeAccessLog",
                "-    // Add an argument that indicates that the tool should prompt for an",
                "-    // encryption passphrase.",
                "-    description = \"Indicates that the log file is encrypted and that the \" +",
                "-         \"tool should interactively prompt for the encryption passphrase.\";",
                "-    promptForEncryptionPassphrase = new BooleanArgument(null,",
                "-         \"promptForEncryptionPassphrase\", 1, description);",
                "-    promptForEncryptionPassphrase.addLongIdentifier(",
                "-         \"prompt-for-encryption-passphrase\", true);",
                "-    promptForEncryptionPassphrase.addLongIdentifier(",
                "-         \"promptForEncryptionPassword\", true);",
                "-    promptForEncryptionPassphrase.addLongIdentifier(",
                "-         \"prompt-for-encryption-password\", true);",
                "-    parser.addArgument(promptForEncryptionPassphrase);",
                "-",
                "-",
                "     // Add an argument that indicates that the tool should read the encryption",
                "@@ -575,3 +560,5 @@ public final class SummarizeAccessLog",
                "     description = \"Indicates that the log file is encrypted and that the \" +",
                "-         \"encryption passphrase is contained in the specified file.\";",
                "+         \"encryption passphrase is contained in the specified file.  If \" +",
                "+         \"the log data is encrypted and this argument is not provided, then \" +",
                "+         \"the tool will interactively prompt for the encryption passphrase.\";",
                "     encryptionPassphraseFile = new FileArgument(null,",
                "@@ -585,8 +572,2 @@ public final class SummarizeAccessLog",
                "     parser.addArgument(encryptionPassphraseFile);",
                "-",
                "-",
                "-     // Ensure that the --promptForEncryptionPassphrase and",
                "-    // --encryptionPassphraseFile arguments cannot be used together.",
                "-    parser.addExclusiveArgumentSet(promptForEncryptionPassphrase,",
                "-         encryptionPassphraseFile);",
                "   }",
                "@@ -629,61 +610,14 @@ public final class SummarizeAccessLog",
                "     String encryptionPassphrase = null;",
                "-    if (promptForEncryptionPassphrase.isPresent())",
                "+    if (encryptionPassphraseFile.isPresent())",
                "     {",
                "-      while (true)",
                "-      {",
                "-        getOut().print(\"Enter the encryption passphrase: \");",
                "-",
                "-        final char[] pwChars;",
                "-        try",
                "-        {",
                "-          pwChars = PasswordReader.readPasswordChars();",
                "-        }",
                "-        catch (final LDAPException le)",
                "-        {",
                "-          Debug.debugException(le);",
                "-          err(\"Unable to read the encryption passphrase entered at the \" +",
                "-               \"prompt:  \" + getExceptionMessage(le));",
                "-          return le.getResultCode();",
                "-        }",
                "-",
                "-        if ((pwChars == null) || (pwChars.length == 0))",
                "-        {",
                "-          err();",
                "-          err(\"The encryption passphrase must not be empty.\");",
                "-          err();",
                "-          continue;",
                "-        }",
                "-",
                "-        encryptionPassphrase = new String(pwChars);",
                "-        Arrays.fill(pwChars, '\\u0000');",
                "-        break;",
                "-      }",
                "-    }",
                "-    else if (encryptionPassphraseFile.isPresent())",
                "-    {",
                "-      try (FileReader fileReader =",
                "-                new FileReader(encryptionPassphraseFile.getValue());",
                "-           BufferedReader bufferedReader = new BufferedReader(fileReader))",
                "+      try",
                "       {",
                "-        encryptionPassphrase = bufferedReader.readLine();",
                "-        if (encryptionPassphrase == null)",
                "-        {",
                "-          err(\"The encryption passphrase file is empty.\");",
                "-          return ResultCode.PARAM_ERROR;",
                "-        }",
                "-        else if (bufferedReader.readLine() != null)",
                "-        {",
                "-          err(\"The encryption passphrase file has multiple lines  It must \" +",
                "-               \"contain exactly one line.\");",
                "-          return ResultCode.PARAM_ERROR;",
                "-        }",
                "-        else if (encryptionPassphrase.isEmpty())",
                "-        {",
                "-          err(\"The encryption passphrase is empty.\");",
                "-          return ResultCode.PARAM_ERROR;",
                "-        }",
                "+        encryptionPassphrase = ToolUtils.readEncryptionPassphraseFromFile(",
                "+             encryptionPassphraseFile.getValue());",
                "       }",
                "-      catch (final Exception e)",
                "+      catch (final LDAPException e)",
                "       {",
                "         Debug.debugException(e);",
                "+        err(e.getMessage());",
                "+        return e.getResultCode();",
                "       }",
                "@@ -703,6 +637,14 @@ public final class SummarizeAccessLog",
                "-        if (encryptionPassphrase != null)",
                "+        final ObjectPair<InputStream,String> p =",
                "+             ToolUtils.getPossiblyPassphraseEncryptedInputStream(inputStream,",
                "+                  encryptionPassphrase,",
                "+                  (! encryptionPassphraseFile.isPresent()),",
                "+                  \"Log file '\" + path + \"' is encrypted.  Please enter the \" +",
                "+                       \"encryption passphrase:\",",
                "+                  \"ERROR:  The provided passphrase was incorrect.\",",
                "+                  getOut(), getErr());",
                "+        inputStream = p.getFirst();",
                "+        if ((p.getSecond() != null) && (encryptionPassphrase == null))",
                "         {",
                "-          inputStream = new PassphraseEncryptedInputStream(",
                "-               encryptionPassphrase, inputStream);",
                "+          encryptionPassphrase = p.getSecond();",
                "         }",
                "@@ -713,2 +655,7 @@ public final class SummarizeAccessLog",
                "         }",
                "+        else",
                "+        {",
                "+          inputStream =",
                "+               ToolUtils.getPossiblyGZIPCompressedInputStream(inputStream);",
                "+        }",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPModify.java b/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPModify.java",
                "index 28d54adf..ef1fb5d1 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPModify.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPModify.java",
                "@@ -291,2 +291,3 @@ public final class LDAPModify",
                "   private DurationArgument assuredReplicationTimeout = null;",
                "+  private FileArgument encryptionPassphraseFile = null;",
                "   private FileArgument ldifFile = null;",
                "@@ -521,2 +522,16 @@ public final class LDAPModify",
                "+    encryptionPassphraseFile = new FileArgument(null,",
                "+         \"encryptionPassphraseFile\", false, 1, null,",
                "+         INFO_LDAPMODIFY_ARG_DESCRIPTION_ENCRYPTION_PW_FILE.get(), true, true,",
                "+         true, false);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryption-passphrase-file\",",
                "+         true);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryptionPasswordFile\", true);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryption-password-file\",",
                "+         true);",
                "+    encryptionPassphraseFile.setArgumentGroupName(",
                "+         INFO_LDAPMODIFY_ARG_GROUP_DATA.get());",
                "+    parser.addArgument(encryptionPassphraseFile);",
                "+",
                "+",
                "     characterSet = new StringArgument('i', \"characterSet\", false, 1,",
                "@@ -1432,2 +1447,20 @@ public final class LDAPModify",
                "+    // If an encryption passphrase file was specified, then read its value.",
                "+    String encryptionPassphrase = null;",
                "+    if (encryptionPassphraseFile.isPresent())",
                "+    {",
                "+      try",
                "+      {",
                "+        encryptionPassphrase = ToolUtils.readEncryptionPassphraseFromFile(",
                "+             encryptionPassphraseFile.getValue());",
                "+      }",
                "+      catch (final LDAPException e)",
                "+      {",
                "+        Debug.debugException(e);",
                "+        wrapErr(0, WRAP_COLUMN, e.getMessage());",
                "+        return e.getResultCode();",
                "+      }",
                "+    }",
                "+",
                "+",
                "     LDAPConnectionPool connectionPool = null;",
                "@@ -1591,21 +1624,24 @@ public final class LDAPModify",
                "       // Create an LDIF reader that will be used to read the changes to process.",
                "-      if (ldifFile.isPresent())",
                "+      try",
                "       {",
                "-        final File[] ldifFiles = ldifFile.getValues().toArray(new File[0]);",
                "-        try",
                "+        final InputStream ldifInputStream;",
                "+        if (ldifFile.isPresent())",
                "         {",
                "-          ldifReader = new LDIFReader(ldifFiles, 0, null, null,",
                "-               characterSet.getValue());",
                "+          ldifInputStream = ToolUtils.getInputStreamForLDIFFiles(",
                "+               ldifFile.getValues(), encryptionPassphrase, getOut(),",
                "+               getErr()).getFirst();",
                "         }",
                "-        catch (final Exception e)",
                "+        else",
                "         {",
                "-          Debug.debugException(e);",
                "-          commentToErr(ERR_LDAPMODIFY_CANNOT_CREATE_LDIF_READER.get(",
                "-               StaticUtils.getExceptionMessage(e)));",
                "-          return ResultCode.LOCAL_ERROR;",
                "+          ldifInputStream = in;",
                "         }",
                "+",
                "+        ldifReader = new LDIFReader(ldifInputStream, 0, null, null,",
                "+             characterSet.getValue());",
                "       }",
                "-      else",
                "+      catch (final Exception e)",
                "       {",
                "-        ldifReader = new LDIFReader(in, 0, null, null, characterSet.getValue());",
                "+        commentToErr(ERR_LDAPMODIFY_CANNOT_CREATE_LDIF_READER.get(",
                "+             StaticUtils.getExceptionMessage(e)));",
                "+        return ResultCode.LOCAL_ERROR;",
                "       }",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearch.java b/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearch.java",
                "index 066b35ec..4466c7b5 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearch.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearch.java",
                "@@ -41,2 +41,3 @@ import java.util.StringTokenizer;",
                " import java.util.concurrent.atomic.AtomicLong;",
                "+import java.util.zip.GZIPOutputStream;",
                "@@ -124,2 +125,3 @@ import com.unboundid.util.LDAPCommandLineTool;",
                " import com.unboundid.util.OutputFormat;",
                "+import com.unboundid.util.PassphraseEncryptedOutputStream;",
                " import com.unboundid.util.StaticUtils;",
                "@@ -177,2 +179,3 @@ public final class LDAPSearch",
                "   private BooleanArgument authorizationIdentity = null;",
                "+  private BooleanArgument compressOutput = null;",
                "   private BooleanArgument continueOnError = null;",
                "@@ -181,2 +184,3 @@ public final class LDAPSearch",
                "   private BooleanArgument dryRun = null;",
                "+  private BooleanArgument encryptOutput = null;",
                "   private BooleanArgument followReferrals = null;",
                "@@ -208,2 +212,3 @@ public final class LDAPSearch",
                "   private DNArgument proxyV1As = null;",
                "+  private FileArgument encryptionPassphraseFile = null;",
                "   private FileArgument filterFile = null;",
                "@@ -277,2 +282,5 @@ public final class LDAPSearch",
                "+  // The encryption passphrase to use if the output is to be encrypted.",
                "+  private String encryptionPassphrase = null;",
                "+",
                "@@ -631,2 +639,29 @@ public final class LDAPSearch",
                "+    compressOutput = new BooleanArgument(null, \"compressOutput\", 1,",
                "+         INFO_LDAPSEARCH_ARG_DESCRIPTION_COMPRESS_OUTPUT.get());",
                "+    compressOutput.addLongIdentifier(\"compress-output\", true);",
                "+    compressOutput.addLongIdentifier(\"compress\", true);",
                "+    compressOutput.setArgumentGroupName(INFO_LDAPSEARCH_ARG_GROUP_DATA.get());",
                "+    parser.addArgument(compressOutput);",
                "+",
                "+    encryptOutput = new BooleanArgument(null, \"encryptOutput\", 1,",
                "+         INFO_LDAPSEARCH_ARG_DESCRIPTION_ENCRYPT_OUTPUT.get());",
                "+    encryptOutput.addLongIdentifier(\"encrypt-output\", true);",
                "+    encryptOutput.addLongIdentifier(\"encrypt\", true);",
                "+    encryptOutput.setArgumentGroupName(INFO_LDAPSEARCH_ARG_GROUP_DATA.get());",
                "+    parser.addArgument(encryptOutput);",
                "+",
                "+    encryptionPassphraseFile = new FileArgument(null,",
                "+         \"encryptionPassphraseFile\", false, 1, null,",
                "+         INFO_LDAPSEARCH_ARG_DESCRIPTION_ENCRYPTION_PW_FILE.get(), true, true,",
                "+         true, false);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryption-passphrase-file\",",
                "+         true);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryptionPasswordFile\", true);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryption-password-file\",",
                "+         true);",
                "+    encryptionPassphraseFile.setArgumentGroupName(",
                "+         INFO_LDAPSEARCH_ARG_GROUP_DATA.get());",
                "+    parser.addArgument(encryptionPassphraseFile);",
                "+",
                "     separateOutputFilePerSearch = new BooleanArgument(null,",
                "@@ -1187,2 +1222,19 @@ public final class LDAPSearch",
                "     parser.addDependentArgumentSet(moveSubtreeTo, moveSubtreeFrom);",
                "+",
                "+",
                "+    // The compressOutput argument can only be used if an output file is",
                "+    // specified and results aren't going to be teed.",
                "+    parser.addDependentArgumentSet(compressOutput, outputFile);",
                "+    parser.addExclusiveArgumentSet(compressOutput, teeResultsToStandardOut);",
                "+",
                "+",
                "+    // The encryptOutput argument can only be used if an output file is",
                "+    // specified and results aren't going to be teed.",
                "+    parser.addDependentArgumentSet(encryptOutput, outputFile);",
                "+    parser.addExclusiveArgumentSet(encryptOutput, teeResultsToStandardOut);",
                "+",
                "+",
                "+    // The encryptionPassphraseFile argument can only be used if the",
                "+    // encryptOutput argument is also provided.",
                "+    parser.addDependentArgumentSet(encryptionPassphraseFile, encryptOutput);",
                "   }",
                "@@ -2008,2 +2060,36 @@ public final class LDAPSearch",
                "   {",
                "+    // If we should encrypt the output, then get the encryption passphrase.",
                "+    if (encryptOutput.isPresent())",
                "+    {",
                "+      if (encryptionPassphraseFile.isPresent())",
                "+      {",
                "+        try",
                "+        {",
                "+          encryptionPassphrase = ToolUtils.readEncryptionPassphraseFromFile(",
                "+               encryptionPassphraseFile.getValue());",
                "+        }",
                "+        catch (final LDAPException e)",
                "+        {",
                "+          Debug.debugException(e);",
                "+          wrapErr(0, WRAP_COLUMN, e.getMessage());",
                "+          return e.getResultCode();",
                "+        }",
                "+      }",
                "+      else",
                "+      {",
                "+        try",
                "+        {",
                "+          encryptionPassphrase = ToolUtils.promptForEncryptionPassphrase(false,",
                "+               true, getOut(), getErr());",
                "+        }",
                "+        catch (final LDAPException e)",
                "+        {",
                "+          Debug.debugException(e);",
                "+          wrapErr(0, WRAP_COLUMN, e.getMessage());",
                "+          return e.getResultCode();",
                "+        }",
                "+      }",
                "+    }",
                "+",
                "+",
                "     // If we should use an output file, then set that up now.  Otherwise, write",
                "@@ -2016,7 +2102,17 @@ public final class LDAPSearch",
                "         {",
                "-          final FileOutputStream fos =",
                "-               new FileOutputStream(outputFile.getValue());",
                "+          OutputStream s = new FileOutputStream(outputFile.getValue());",
                "+",
                "+          if (encryptOutput.isPresent())",
                "+          {",
                "+            s = new PassphraseEncryptedOutputStream(encryptionPassphrase, s);",
                "+          }",
                "+",
                "+          if (compressOutput.isPresent())",
                "+          {",
                "+            s = new GZIPOutputStream(s);",
                "+          }",
                "+",
                "           if (teeResultsToStandardOut.isPresent())",
                "           {",
                "-            outStream = new PrintStream(new TeeOutputStream(fos, getOut()));",
                "+            outStream = new PrintStream(new TeeOutputStream(s, getOut()));",
                "           }",
                "@@ -2024,3 +2120,3 @@ public final class LDAPSearch",
                "           {",
                "-            outStream = new PrintStream(fos);",
                "+            outStream = new PrintStream(s);",
                "           }",
                "@@ -2539,6 +2635,18 @@ public final class LDAPSearch",
                "              outputFileCounter.getAndIncrement();",
                "-        final FileOutputStream fos = new FileOutputStream(path);",
                "+",
                "+        OutputStream s = new FileOutputStream(path);",
                "+",
                "+        if (encryptOutput.isPresent())",
                "+        {",
                "+          s = new PassphraseEncryptedOutputStream(encryptionPassphrase, s);",
                "+        }",
                "+",
                "+        if (compressOutput.isPresent())",
                "+        {",
                "+          s = new GZIPOutputStream(s);",
                "+        }",
                "+",
                "         if (teeResultsToStandardOut.isPresent())",
                "         {",
                "-          outStream = new PrintStream(new TeeOutputStream(fos, getOut()));",
                "+          outStream = new PrintStream(new TeeOutputStream(s, getOut()));",
                "         }",
                "@@ -2546,3 +2654,3 @@ public final class LDAPSearch",
                "         {",
                "-          outStream = new PrintStream(fos);",
                "+          outStream = new PrintStream(s);",
                "         }",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/tools/SplitLDIF.java b/src/com/unboundid/ldap/sdk/unboundidds/tools/SplitLDIF.java",
                "index 54c7d2cf..65b15711 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/tools/SplitLDIF.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/tools/SplitLDIF.java",
                "@@ -24,5 +24,3 @@ package com.unboundid.ldap.sdk.unboundidds.tools;",
                "-import java.io.ByteArrayInputStream;",
                " import java.io.File;",
                "-import java.io.FileInputStream;",
                " import java.io.FileOutputStream;",
                "@@ -40,3 +38,2 @@ import java.util.TreeMap;",
                " import java.util.concurrent.atomic.AtomicLong;",
                "-import java.util.zip.GZIPInputStream;",
                " import java.util.zip.GZIPOutputStream;",
                "@@ -52,4 +49,5 @@ import com.unboundid.util.ByteStringBuffer;",
                " import com.unboundid.util.CommandLineTool;",
                "-import com.unboundid.util.AggregateInputStream;",
                " import com.unboundid.util.Debug;",
                "+import com.unboundid.util.ObjectPair;",
                "+import com.unboundid.util.PassphraseEncryptedOutputStream;",
                " import com.unboundid.util.StaticUtils;",
                "@@ -144,4 +142,6 @@ public final class SplitLDIF",
                "   private BooleanArgument compressTarget = null;",
                "+  private BooleanArgument encryptTarget = null;",
                "   private BooleanArgument sourceCompressed = null;",
                "   private DNArgument splitBaseDN = null;",
                "+  private FileArgument encryptionPassphraseFile = null;",
                "   private FileArgument schemaPath = null;",
                "@@ -332,2 +332,21 @@ public final class SplitLDIF",
                "+    encryptTarget = new BooleanArgument(null, \"encryptTarget\",",
                "+         INFO_SPLIT_LDIF_GLOBAL_ARG_DESC_ENCRYPT_TARGET.get());",
                "+    encryptTarget.addLongIdentifier(\"encryptOutput\", true);",
                "+    encryptTarget.addLongIdentifier(\"encrypt\", true);",
                "+    encryptTarget.addLongIdentifier(\"encrypt-target\", true);",
                "+    encryptTarget.addLongIdentifier(\"encrypt-output\", true);",
                "+    parser.addArgument(encryptTarget);",
                "+",
                "+    encryptionPassphraseFile = new FileArgument(null,",
                "+         \"encryptionPassphraseFile\", false, 1, null,",
                "+         INFO_SPLIT_LDIF_GLOBAL_ARG_DESC_ENCRYPT_PW_FILE.get(), true, true,",
                "+         true, false);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryptionPasswordFile\", true);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryption-passphrase-file\",",
                "+         true);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryption-password-file\",",
                "+         true);",
                "+    parser.addArgument(encryptionPassphraseFile);",
                "+",
                "     splitBaseDN = new DNArgument('b', \"splitBaseDN\", true, 1, null,",
                "@@ -622,2 +641,21 @@ public final class SplitLDIF",
                "+    // If an encryption passphrase file is provided, then get the passphrase",
                "+    // from it.",
                "+    String encryptionPassphrase = null;",
                "+    if (encryptionPassphraseFile.isPresent())",
                "+    {",
                "+      try",
                "+      {",
                "+        encryptionPassphrase = ToolUtils.readEncryptionPassphraseFromFile(",
                "+             encryptionPassphraseFile.getValue());",
                "+      }",
                "+      catch (final LDAPException e)",
                "+      {",
                "+        Debug.debugException(e);",
                "+        wrapErr(0, MAX_OUTPUT_LINE_LENGTH, e.getMessage());",
                "+        return e.getResultCode();",
                "+      }",
                "+    }",
                "+",
                "+",
                "     // Figure out which subcommand was selected, and create the appropriate",
                "@@ -682,32 +720,12 @@ public final class SplitLDIF",
                "     {",
                "-      InputStream inputStream;",
                "+      final InputStream inputStream;",
                "       if (sourceLDIF.isPresent())",
                "       {",
                "-        final List<File> sourceFiles = sourceLDIF.getValues();",
                "-        final ArrayList<InputStream> fileInputStreams =",
                "-             new ArrayList<InputStream>(2*sourceFiles.size());",
                "-        for (final File f : sourceFiles)",
                "-        {",
                "-          if (! fileInputStreams.isEmpty())",
                "-          {",
                "-            // Go ahead and ensure that there are at least new end-of-line",
                "-            // markers between each file.  Otherwise, it's possible for entries",
                "-            // to run together.",
                "-            final byte[] doubleEOL = new byte[StaticUtils.EOL_BYTES.length * 2];",
                "-            System.arraycopy(StaticUtils.EOL_BYTES, 0, doubleEOL, 0,",
                "-                 StaticUtils.EOL_BYTES.length);",
                "-            System.arraycopy(StaticUtils.EOL_BYTES, 0, doubleEOL,",
                "-                 StaticUtils.EOL_BYTES.length, StaticUtils.EOL_BYTES.length);",
                "-            fileInputStreams.add(new ByteArrayInputStream(doubleEOL));",
                "-          }",
                "-          fileInputStreams.add(new FileInputStream(f));",
                "-        }",
                "-",
                "-        if (fileInputStreams.size() == 1)",
                "-        {",
                "-          inputStream = fileInputStreams.get(0);",
                "-        }",
                "-        else",
                "+        final ObjectPair<InputStream,String> p =",
                "+             ToolUtils.getInputStreamForLDIFFiles(sourceLDIF.getValues(),",
                "+                  encryptionPassphrase, getOut(), getErr());",
                "+        inputStream = p.getFirst();",
                "+        if ((encryptionPassphrase == null) && (p.getSecond() != null))",
                "         {",
                "-          inputStream = new AggregateInputStream(fileInputStreams);",
                "+          encryptionPassphrase = p.getSecond();",
                "         }",
                "@@ -719,7 +737,2 @@ public final class SplitLDIF",
                "-      if (sourceCompressed.isPresent())",
                "-      {",
                "-        inputStream = new GZIPInputStream(inputStream);",
                "-      }",
                "-",
                "       ldifReader = new LDIFReader(inputStream, numThreads.getValue(),",
                "@@ -772,2 +785,25 @@ readLoop:",
                "               s = new FileOutputStream(f);",
                "+",
                "+              if (encryptTarget.isPresent())",
                "+              {",
                "+                if (encryptionPassphrase == null)",
                "+                {",
                "+                  try",
                "+                  {",
                "+                    encryptionPassphrase =",
                "+                         ToolUtils.promptForEncryptionPassphrase(false, true,",
                "+                              getOut(), getErr());",
                "+                  }",
                "+                  catch (final LDAPException ex)",
                "+                  {",
                "+                    Debug.debugException(ex);",
                "+                    wrapErr(0, MAX_OUTPUT_LINE_LENGTH, ex.getMessage());",
                "+                    return ex.getResultCode();",
                "+                  }",
                "+                }",
                "+",
                "+                s = new PassphraseEncryptedOutputStream(encryptionPassphrase,",
                "+                     s);",
                "+              }",
                "+",
                "               if (compressTarget.isPresent())",
                "@@ -934,2 +970,25 @@ readLoop:",
                "               s = new FileOutputStream(f);",
                "+",
                "+              if (encryptTarget.isPresent())",
                "+              {",
                "+                if (encryptionPassphrase == null)",
                "+                {",
                "+                  try",
                "+                  {",
                "+                    encryptionPassphrase =",
                "+                         ToolUtils.promptForEncryptionPassphrase(false, true,",
                "+                              getOut(), getErr());",
                "+                  }",
                "+                  catch (final LDAPException ex)",
                "+                  {",
                "+                    Debug.debugException(ex);",
                "+                    wrapErr(0, MAX_OUTPUT_LINE_LENGTH, ex.getMessage());",
                "+                    return ex.getResultCode();",
                "+                  }",
                "+                }",
                "+",
                "+                s = new PassphraseEncryptedOutputStream(encryptionPassphrase,",
                "+                     s);",
                "+              }",
                "+",
                "               if (compressTarget.isPresent())",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java b/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java",
                "new file mode 100644",
                "index 00000000..05ca3e79",
                "--- /dev/null",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java",
                "@@ -0,0 +1,949 @@",
                "+/*",
                "+ * Copyright 2018 Ping Identity Corporation",
                "+ * All Rights Reserved.",
                "+ */",
                "+/*",
                "+ * Copyright (C) 2018 Ping Identity Corporation",
                "+ *",
                "+ * This program is free software; you can redistribute it and/or modify",
                "+ * it under the terms of the GNU General Public License (GPLv2 only)",
                "+ * or the terms of the GNU Lesser General Public License (LGPLv2.1 only)",
                "+ * as published by the Free Software Foundation.",
                "+ *",
                "+ * This program is distributed in the hope that it will be useful,",
                "+ * but WITHOUT ANY WARRANTY; without even the implied warranty of",
                "+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
                "+ * GNU General Public License for more details.",
                "+ *",
                "+ * You should have received a copy of the GNU General Public License",
                "+ * along with this program; if not, see <http://www.gnu.org/licenses>.",
                "+ */",
                "+package com.unboundid.ldap.sdk.unboundidds.tools;",
                "+",
                "+",
                "+",
                "+import java.io.BufferedInputStream;",
                "+import java.io.BufferedReader;",
                "+import java.io.ByteArrayInputStream;",
                "+import java.io.File;",
                "+import java.io.FileInputStream;",
                "+import java.io.FileReader;",
                "+import java.io.IOException;",
                "+import java.io.InputStream;",
                "+import java.io.PrintStream;",
                "+import java.lang.reflect.Method;",
                "+import java.security.GeneralSecurityException;",
                "+import java.security.InvalidKeyException;",
                "+import java.util.ArrayList;",
                "+import java.util.Arrays;",
                "+import java.util.Iterator;",
                "+import java.util.List;",
                "+import java.util.logging.Level;",
                "+import java.util.zip.GZIPInputStream;",
                "+",
                "+import com.unboundid.ldap.sdk.LDAPException;",
                "+import com.unboundid.ldap.sdk.ResultCode;",
                "+import com.unboundid.util.AggregateInputStream;",
                "+import com.unboundid.util.ByteStringBuffer;",
                "+import com.unboundid.util.Debug;",
                "+import com.unboundid.util.ObjectPair;",
                "+import com.unboundid.util.PassphraseEncryptedInputStream;",
                "+import com.unboundid.util.PassphraseEncryptedOutputStream;",
                "+import com.unboundid.util.PassphraseEncryptedStreamHeader;",
                "+import com.unboundid.util.PasswordReader;",
                "+import com.unboundid.util.StaticUtils;",
                "+import com.unboundid.util.ThreadSafety;",
                "+import com.unboundid.util.ThreadSafetyLevel;",
                "+import com.unboundid.util.Validator;",
                "+",
                "+import static com.unboundid.ldap.sdk.unboundidds.tools.ToolMessages.*;",
                "+",
                "+",
                "+",
                "+/**",
                "+ * This class provides a number of utility methods primarily intended for use",
                "+ * with command-line tools.",
                "+ * <BR>",
                "+ * <BLOCKQUOTE>",
                "+ *   <B>NOTE:</B>  This class, and other classes within the",
                "+ *   {@code com.unboundid.ldap.sdk.unboundidds} package structure, are only",
                "+ *   supported for use against Ping Identity, UnboundID, and Alcatel-Lucent 8661",
                "+ *   server products.  These classes provide support for proprietary",
                "+ *   functionality or for external specifications that are not considered stable",
                "+ *   or mature enough to be guaranteed to work in an interoperable way with",
                "+ *   other types of LDAP servers.",
                "+ * </BLOCKQUOTE>",
                "+ */",
                "+@ThreadSafety(level= ThreadSafetyLevel.NOT_THREADSAFE)",
                "+public final class ToolUtils",
                "+{",
                "+  /**",
                "+   * The column at which long lines should be wrapped.",
                "+   */",
                "+  private static final int WRAP_COLUMN = StaticUtils.TERMINAL_WIDTH_COLUMNS - 1;",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * A handle to a method that can be used to get the passphrase for an",
                "+   * encryption settings definition ID if the server code is available.  We have",
                "+   * to call this via reflection because the server code may not be available.",
                "+   */",
                "+  private static final Method GET_PASSPHRASE_FOR_ENCRYPTION_SETTINGS_ID_METHOD;",
                "+  static",
                "+  {",
                "+    Method m = null;",
                "+",
                "+    try",
                "+    {",
                "+      final Class<?> serverStaticUtilsClass = Class.forName(",
                "+           \"com.unboundid.directory.server.util.StaticUtils\");",
                "+      m = serverStaticUtilsClass.getMethod(",
                "+           \"getPassphraseForEncryptionSettingsID\", String.class);",
                "+    }",
                "+    catch (final Exception e)",
                "+    {",
                "+      // This is fine.  It probably just means that the server code isn't",
                "+      // available.",
                "+      Debug.debugException(Level.FINEST, e);",
                "+    }",
                "+",
                "+    GET_PASSPHRASE_FOR_ENCRYPTION_SETTINGS_ID_METHOD = m;",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Prevent this utility class from being instantiated.",
                "+   */",
                "+  private ToolUtils()",
                "+  {",
                "+    // No implementation is required.",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Reads an encryption passphrase from the specified file.  The file must",
                "+   * contain exactly one line, which must not be empty, and must be comprised",
                "+   * entirely of the encryption passphrase.",
                "+   *",
                "+   * @param  f  The file from which the passphrase should be read.  It must not",
                "+   *            be {@code null}.",
                "+   *",
                "+   * @return  The encryption passphrase read from the specified file.",
                "+   *",
                "+   * @throws  LDAPException  If a problem occurs while attempting to read the",
                "+   *                         encryption passphrase.",
                "+   */",
                "+  public static String readEncryptionPassphraseFromFile(final File f)",
                "+         throws LDAPException",
                "+  {",
                "+    Validator.ensureTrue((f != null),",
                "+         \"ToolUtils.readEncryptionPassphraseFromFile.f must not be null.\");",
                "+",
                "+    if (! f.exists())",
                "+    {",
                "+      throw new LDAPException(ResultCode.PARAM_ERROR,",
                "+           ERR_TOOL_UTILS_ENCRYPTION_PW_FILE_MISSING.get(f.getAbsolutePath()));",
                "+    }",
                "+",
                "+    if (! f.isFile())",
                "+    {",
                "+      throw new LDAPException(ResultCode.PARAM_ERROR,",
                "+           ERR_TOOL_UTILS_ENCRYPTION_PW_FILE_NOT_FILE.get(f.getAbsolutePath()));",
                "+    }",
                "+",
                "+    try (final FileReader fileReader = new FileReader(f);",
                "+         final BufferedReader bufferedReader = new BufferedReader(fileReader))",
                "+    {",
                "+      final String encryptionPassphrase = bufferedReader.readLine();",
                "+      if (encryptionPassphrase == null)",
                "+      {",
                "+        throw new LDAPException(ResultCode.PARAM_ERROR,",
                "+             ERR_TOOL_UTILS_ENCRYPTION_PW_FILE_EMPTY.get(f.getAbsolutePath()));",
                "+      }",
                "+      else if (bufferedReader.readLine() != null)",
                "+      {",
                "+        throw new LDAPException(ResultCode.PARAM_ERROR,",
                "+             ERR_TOOL_UTILS_ENCRYPTION_PW_FILE_MULTIPLE_LINES.get(",
                "+                  f.getAbsolutePath()));",
                "+      }",
                "+      else if (encryptionPassphrase.isEmpty())",
                "+      {",
                "+        throw new LDAPException(ResultCode.PARAM_ERROR,",
                "+             ERR_TOOL_UTILS_ENCRYPTION_PW_FILE_EMPTY.get(f.getAbsolutePath()));",
                "+      }",
                "+",
                "+      return encryptionPassphrase;",
                "+    }",
                "+    catch (final LDAPException e)",
                "+    {",
                "+      Debug.debugException(e);",
                "+      throw e;",
                "+    }",
                "+    catch (final Exception e)",
                "+    {",
                "+      Debug.debugException(e);",
                "+      throw new LDAPException(ResultCode.LOCAL_ERROR,",
                "+           ERR_TOOL_UTILS_ENCRYPTION_PW_FILE_READ_ERROR.get(",
                "+                f.getAbsolutePath(), StaticUtils.getExceptionMessage(e)));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Interactively prompts the user for an encryption passphrase.",
                "+   *",
                "+   * @param  allowEmpty  Indicates whether the encryption passphrase is allowed",
                "+   *                     to be empty.  If this is {@code false}, then the user",
                "+   *                     will be re-prompted for the passphrase if the value",
                "+   *                     they enter is empty.",
                "+   * @param  confirm     Indicates whether the user will asked to confirm the",
                "+   *                     passphrase.  If this is {@code true}, then the user",
                "+   *                     will have to enter the same passphrase twice.  If this",
                "+   *                     is {@code false}, then the user will only be prompted",
                "+   *                     once.",
                "+   * @param  out         The {@code PrintStream} that will be used for standard",
                "+   *                     output.  It must not be {@code null}.",
                "+   * @param  err         The {@code PrintStream} that will be used for standard",
                "+   *                     error.  It must not be {@code null}.",
                "+   *",
                "+   * @return  The encryption passphrase provided by the user.",
                "+   *",
                "+   * @throws  LDAPException  If a problem is encountered while trying to obtain",
                "+   *                         the passphrase from the user.",
                "+   */",
                "+  public static String promptForEncryptionPassphrase(final boolean allowEmpty,",
                "+                                                     final boolean confirm,",
                "+                                                     final PrintStream out,",
                "+                                                     final PrintStream err)",
                "+          throws LDAPException",
                "+  {",
                "+    Validator.ensureTrue((out != null),",
                "+         \"ToolUtils.promptForEncryptionPassphrase.out must not be null\");",
                "+    Validator.ensureTrue((err != null),",
                "+         \"ToolUtils.promptForEncryptionPassphrase.err must not be null\");",
                "+",
                "+    while (true)",
                "+    {",
                "+      char[] passphraseChars = null;",
                "+      char[] confirmChars = null;",
                "+",
                "+      try",
                "+      {",
                "+        wrapPrompt(INFO_TOOL_UTILS_ENCRYPTION_PW_PROMPT.get(), true, out);",
                "+",
                "+        passphraseChars = PasswordReader.readPasswordChars();",
                "+        if ((passphraseChars == null) || (passphraseChars.length == 0))",
                "+        {",
                "+          if (allowEmpty)",
                "+          {",
                "+            passphraseChars = StaticUtils.NO_CHARS;",
                "+          }",
                "+          else",
                "+          {",
                "+            wrap(ERR_TOOL_UTILS_ENCRYPTION_PW_EMPTY.get(), err);",
                "+            err.println();",
                "+            continue;",
                "+          }",
                "+        }",
                "+",
                "+        if (confirm)",
                "+        {",
                "+          wrapPrompt(INFO_TOOL_UTILS_ENCRYPTION_PW_CONFIRM.get(), true, out);",
                "+",
                "+          confirmChars = PasswordReader.readPasswordChars();",
                "+          if ((confirmChars == null) ||",
                "+               (! Arrays.equals(passphraseChars, confirmChars)))",
                "+          {",
                "+            wrap(ERR_TOOL_UTILS_ENCRYPTION_PW_MISMATCH.get(), err);",
                "+            err.println();",
                "+            continue;",
                "+          }",
                "+        }",
                "+",
                "+        return new String(passphraseChars);",
                "+      }",
                "+      finally",
                "+      {",
                "+        if (passphraseChars != null)",
                "+        {",
                "+          Arrays.fill(passphraseChars, '\\u0000');",
                "+        }",
                "+",
                "+        if (confirmChars != null)",
                "+        {",
                "+          Arrays.fill(confirmChars, '\\u0000');",
                "+        }",
                "+      }",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Writes a wrapped version of the provided message to the given stream.",
                "+   *",
                "+   * @param  message  The message to be written.  If it is {@code null} or",
                "+   *                  empty, then an empty line will be printed.",
                "+   * @param  out      The {@code PrintStream} that should be used to write the",
                "+   *                  provided message.",
                "+   */",
                "+  public static void wrap(final CharSequence message, final PrintStream out)",
                "+  {",
                "+    Validator.ensureTrue((out != null), \"ToolUtils.wrap.out must not be null.\");",
                "+",
                "+    if ((message == null) || (message.length() == 0))",
                "+    {",
                "+      out.println();",
                "+      return;",
                "+    }",
                "+",
                "+    for (final String line :",
                "+         StaticUtils.wrapLine(message.toString(), WRAP_COLUMN))",
                "+    {",
                "+      out.println(line);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Wraps the provided prompt such that every line except the last will be",
                "+   * followed by a newline, but the last line will not be followed by a newline.",
                "+   *",
                "+   * @param  prompt               The prompt to be wrapped.  It must not be",
                "+   *                              {@code null} or empty.",
                "+   * @param  ensureTrailingSpace  Indicates whether to ensure that there is a",
                "+   *                              trailing space after the end of the prompt.",
                "+   * @param  out                  The {@code PrintStream} to which the prompt",
                "+   *                              should be written.  It must not be",
                "+   *                              {@code null}.",
                "+   */",
                "+  public static void wrapPrompt(final CharSequence prompt,",
                "+                                final boolean ensureTrailingSpace,",
                "+                                final PrintStream out)",
                "+  {",
                "+    Validator.ensureTrue(((prompt != null) && (prompt.length() > 0)),",
                "+         \"ToolUtils.wrapPrompt.prompt must not be null or empty.\");",
                "+    Validator.ensureTrue((out != null),",
                "+         \"ToolUtils.wrapPrompt.out must not be null.\");",
                "+",
                "+    String promptString = prompt.toString();",
                "+    if (ensureTrailingSpace && (! promptString.endsWith(\" \")))",
                "+    {",
                "+      promptString += ' ';",
                "+    }",
                "+",
                "+    final List<String> lines = StaticUtils.wrapLine(promptString, WRAP_COLUMN);",
                "+    final Iterator<String> iterator = lines.iterator();",
                "+    while (iterator.hasNext())",
                "+    {",
                "+      final String line = iterator.next();",
                "+      if (iterator.hasNext())",
                "+      {",
                "+        out.println(line);",
                "+      }",
                "+      else",
                "+      {",
                "+        out.print(line);",
                "+      }",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves an input stream that can be used to read data from the specified",
                "+   * list of files.  It will handle the possibility that any or all of the LDIF",
                "+   * files are encrypted and/or compressed.",
                "+   *",
                "+   * @param  ldifFiles             The list of LDIF files from which the data",
                "+   *                               is to be read.  It must not be {@code null}",
                "+   *                               or empty.",
                "+   * @param  encryptionPassphrase  The passphrase that should be used to access",
                "+   *                               encrypted LDIF files.  It may be {@code null}",
                "+   *                               if the user should be interactively prompted",
                "+   *                               for the passphrase if any of the files is",
                "+   *                               encrypted.",
                "+   * @param  out                   The print stream to use for standard output.",
                "+   *                               It must not be {@code null}.",
                "+   * @param  err                   The print stream to use for standard error.",
                "+   *                               It must not be {@code null}.",
                "+   *",
                "+   * @return  An {@code ObjectPair} whose first element is an input stream that",
                "+   *          can be used to read data from the specified list of files, and",
                "+   *          whose second element is a possibly-{@code null} passphrase that",
                "+   *          is used to encrypt the input data.",
                "+   *",
                "+   * @throws  IOException  If a problem is encountered while attempting to get",
                "+   *                       the input stream for reading the data.",
                "+   */",
                "+  public static ObjectPair<InputStream,String> getInputStreamForLDIFFiles(",
                "+                     final List<File> ldifFiles,",
                "+                     final String encryptionPassphrase, final PrintStream out,",
                "+                     final PrintStream err)",
                "+         throws IOException",
                "+  {",
                "+    Validator.ensureTrue(((ldifFiles != null) && (! ldifFiles.isEmpty())),",
                "+         \"ToolUtils.getInputStreamForLDIFFiles.ldifFiles must not be null or \" +",
                "+              \"empty.\");",
                "+    Validator.ensureTrue((out != null),",
                "+         \"ToolUtils.getInputStreamForLDIFFiles.out must not be null\");",
                "+    Validator.ensureTrue((err != null),",
                "+         \"ToolUtils.getInputStreamForLDIFFiles.err must not be null\");",
                "+",
                "+",
                "+    boolean createdSuccessfully = false;",
                "+    final ArrayList<InputStream> inputStreams =",
                "+         new ArrayList<>(ldifFiles.size() * 2);",
                "+",
                "+    try",
                "+    {",
                "+      byte[] twoEOLs = null;",
                "+      String passphrase = encryptionPassphrase;",
                "+      for (final File f : ldifFiles)",
                "+      {",
                "+        if (! inputStreams.isEmpty())",
                "+        {",
                "+          if (twoEOLs == null)",
                "+          {",
                "+            final ByteStringBuffer buffer = new ByteStringBuffer(4);",
                "+            buffer.append(StaticUtils.EOL_BYTES);",
                "+            buffer.append(StaticUtils.EOL_BYTES);",
                "+            twoEOLs = buffer.toByteArray();",
                "+          }",
                "+",
                "+          inputStreams.add(new ByteArrayInputStream(twoEOLs));",
                "+        }",
                "+",
                "+        InputStream inputStream = new FileInputStream(f);",
                "+        try",
                "+        {",
                "+          final ObjectPair<InputStream,String> p =",
                "+               getPossiblyPassphraseEncryptedInputStream(",
                "+                    inputStream, passphrase, (encryptionPassphrase == null),",
                "+                    INFO_TOOL_UTILS_ENCRYPTED_LDIF_FILE_PW_PROMPT.get(",
                "+                         f.getPath()),",
                "+                    ERR_TOOL_UTILS_ENCRYPTED_LDIF_FILE_WRONG_PW.get(), out,",
                "+                    err);",
                "+          inputStream = p.getFirst();",
                "+          if ((p.getSecond() != null) && (passphrase == null))",
                "+          {",
                "+            passphrase = p.getSecond();",
                "+          }",
                "+        }",
                "+        catch (final GeneralSecurityException e)",
                "+        {",
                "+          Debug.debugException(e);",
                "+          inputStream.close();",
                "+          throw new IOException(",
                "+               ERR_TOOL_UTILS_ENCRYPTED_LDIF_FILE_CANNOT_DECRYPT.get(",
                "+                    f.getPath(), StaticUtils.getExceptionMessage(e)),",
                "+               e);",
                "+        }",
                "+",
                "+        inputStream = getPossiblyGZIPCompressedInputStream(inputStream);",
                "+        inputStreams.add(inputStream);",
                "+      }",
                "+",
                "+      createdSuccessfully = true;",
                "+      if (inputStreams.size() == 1)",
                "+      {",
                "+        return new ObjectPair<>(inputStreams.get(0), passphrase);",
                "+      }",
                "+      else",
                "+      {",
                "+        return new ObjectPair<InputStream,String>(",
                "+             new AggregateInputStream(inputStreams), passphrase);",
                "+      }",
                "+    }",
                "+    finally",
                "+    {",
                "+      if (! createdSuccessfully)",
                "+      {",
                "+        for (final InputStream inputStream : inputStreams)",
                "+        {",
                "+          try",
                "+          {",
                "+            inputStream.close();",
                "+          }",
                "+          catch (final IOException e)",
                "+          {",
                "+            Debug.debugException(e);",
                "+          }",
                "+        }",
                "+      }",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves an {@code InputStream} that can be used to read data from the",
                "+   * provided input stream that may have potentially been GZIP-compressed.  If",
                "+   * the provided input stream does not appear to contain GZIP-compressed data,",
                "+   * then the returned stream will permit reading the data from the provided",
                "+   * stream without any alteration.",
                "+   * <BR><BR>",
                "+   * The determination will be made by looking to see if the first two bytes",
                "+   * read from the provided input stream are 0x1F and 0x8B, respectively (which",
                "+   * is the GZIP magic header).  To avoid false positives, this method should",
                "+   * only be used if it is known that if the input stream does not contain",
                "+   * compressed data, then it will not start with that two-byte sequence.  This",
                "+   * method should always be safe to use if the data to be read is text.  If the",
                "+   * data may be binary and that binary data may happen to start with 0x1F 0x8B,",
                "+   * then this method should not be used.",
                "+   * <BR><BR>",
                "+   * The input stream's {@code mark} and {@code reset} methods will be used to",
                "+   * permit peeking at the data at the head of the input stream.  If the",
                "+   * provided stream does not support the use of those methods, then it will be",
                "+   * wrapped in a {@code BufferedInputStream}, which does support them.",
                "+   *",
                "+   * @param  inputStream  The input stream from which the data is to be read.",
                "+   *",
                "+   * @return  A {@code GZIPInputStream} that wraps the provided input stream if",
                "+   *          the stream appears to contain GZIP-compressed data, or the",
                "+   *          provided input stream (potentially wrapped in a",
                "+   *          {@code BufferedInputStream}) if the provided stream does not",
                "+   *          appear to contain GZIP-compressed data.",
                "+   *",
                "+   * @throws  IOException  If a problem is encountered while attempting to",
                "+   *                       determine whether the stream contains GZIP-compressed",
                "+   *                       data.",
                "+   */",
                "+  public static InputStream getPossiblyGZIPCompressedInputStream(",
                "+                                 final InputStream inputStream)",
                "+         throws IOException",
                "+  {",
                "+    Validator.ensureTrue((inputStream != null),",
                "+         \"StaticUtils.getPossiblyGZIPCompressedInputStream.inputStream must \" +",
                "+              \"not be null.\");",
                "+",
                "+",
                "+    // Mark the input stream so that we can peek at data from the beginning of",
                "+    // the stream.",
                "+    final InputStream markableInputStream;",
                "+    if (inputStream.markSupported())",
                "+    {",
                "+      markableInputStream = inputStream;",
                "+    }",
                "+    else",
                "+    {",
                "+      markableInputStream = new BufferedInputStream(inputStream);",
                "+    }",
                "+",
                "+    markableInputStream.mark(2);",
                "+",
                "+",
                "+    // Check to see if the file starts with the GZIP magic header.  Whether it",
                "+    // does or not, reset the stream so that we can read it from the beginning.",
                "+    final boolean isCompressed;",
                "+    try",
                "+    {",
                "+      isCompressed = ((markableInputStream.read() == 0x1F) &&",
                "+           (markableInputStream.read() == 0x8B));",
                "+    }",
                "+    finally",
                "+    {",
                "+      markableInputStream.reset();",
                "+    }",
                "+",
                "+",
                "+    // If the stream starts with the GZIP magic header, then assume it's",
                "+    // GZIP-compressed.  Otherwise, assume it's not.",
                "+    if (isCompressed)",
                "+    {",
                "+      return new GZIPInputStream(markableInputStream);",
                "+    }",
                "+    else",
                "+    {",
                "+      return markableInputStream;",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves an {@code InputStream} that can be used to read data from the",
                "+   * provided input stream that may have potentially been encrypted with a",
                "+   * {@link PassphraseEncryptedOutputStream}.  If the provided input stream does",
                "+   * not appear to contain passphrase-encrypted data, then the returned stream",
                "+   * will permit reading the data from the provided stream without any",
                "+   * alteration.",
                "+   * <BR><BR>",
                "+   * The determination will be made by looking to see if the input stream starts",
                "+   * with a valid {@link PassphraseEncryptedStreamHeader}.  Because of the",
                "+   * complex nature of that header, it is highly unlikely that the input stream",
                "+   * will just happen to start with a valid header if the stream does not",
                "+   * actually contain encrypted data.",
                "+   * <BR><BR>",
                "+   * The input stream's {@code mark} and {@code reset} methods will be used to",
                "+   * permit peeking at the data at the head of the input stream.  If the",
                "+   * provided stream does not support the use of those methods, then it will be",
                "+   * wrapped in a {@code BufferedInputStream}, which does support them.",
                "+   *",
                "+   * @param  inputStream                  The input stream from which the data",
                "+   *                                      is to be read.  It must not be",
                "+   *                                      {@code null}.",
                "+   * @param  passphrase                   The passphrase to use to generate the",
                "+   *                                      encryption key.  It may be",
                "+   *                                      {@code null} if the passphrase should",
                "+   *                                      only be obtained via interactive",
                "+   *                                      prompting.  If the passphrase is not",
                "+   *                                      {@code null} but is incorrect, then",
                "+   *                                      the user may be interactively prompted",
                "+   *                                      for the correct passphrase.",
                "+   * @param  promptOnIncorrectPassphrase  Indicates whether the user should be",
                "+   *                                      interactively prompted for the correct",
                "+   *                                      passphrase if the provided passphrase",
                "+   *                                      is non-{@code null} and is also",
                "+   *                                      incorrect.",
                "+   * @param  passphrasePrompt             The prompt that will be presented to",
                "+   *                                      the user if the input stream does",
                "+   *                                      contain encrypted data and the",
                "+   *                                      passphrase needs to be interactively",
                "+   *                                      requested from the user.  It must not",
                "+   *                                      be {@code null} or empty.",
                "+   * @param  incorrectPassphraseError     The error message that will be",
                "+   *                                      presented to the user if the entered",
                "+   *                                      passphrase is not correct.  It must",
                "+   *                                      not be {@code null} or empty.",
                "+   * @param  standardOutput               The {@code PrintStream} to use to",
                "+   *                                      write to standard output while",
                "+   *                                      interactively prompting for the",
                "+   *                                      passphrase.  It must not be",
                "+   *                                      {@code null}.",
                "+   * @param  standardError                The {@code PrintStream} to use to",
                "+   *                                      write to standard error while",
                "+   *                                      interactively prompting for the",
                "+   *                                      passphrase.  It must not be",
                "+   *                                      {@code null}.",
                "+   *",
                "+   * @return  An {@code ObjectPair} that combines the resulting input stream",
                "+   *          with the associated encryption passphrase.  If the provided input",
                "+   *          stream is encrypted, then the returned input stream element will",
                "+   *          be a {@code PassphraseEncryptedInputStream} and the returned",
                "+   *          passphrase element will be non-{@code null}.  If the provided",
                "+   *          input stream is not encrypted, then the returned input stream",
                "+   *          element will be the provided input stream (potentially wrapped in",
                "+   *          a {@code BufferedInputStream}), and the returned passphrase",
                "+   *          element will be {@code null}.",
                "+   *",
                "+   * @throws  IOException  If a problem is encountered while attempting to",
                "+   *                       determine whether the stream contains",
                "+   *                       passphrase-encrypted data.",
                "+   *",
                "+   * @throws  InvalidKeyException  If the provided passphrase is incorrect and",
                "+   *                               the user should not be interactively prompted",
                "+   *                               for the correct passphrase.",
                "+   *",
                "+   * @throws  GeneralSecurityException  If a problem is encountered while",
                "+   *                                    attempting to prepare to decrypt data",
                "+   *                                    read from the input stream.",
                "+   */",
                "+  public static ObjectPair<InputStream,String>",
                "+                     getPossiblyPassphraseEncryptedInputStream(",
                "+                          final InputStream inputStream,",
                "+                          final String passphrase,",
                "+                          final boolean promptOnIncorrectPassphrase,",
                "+                          final CharSequence passphrasePrompt,",
                "+                          final CharSequence incorrectPassphraseError,",
                "+                          final PrintStream standardOutput,",
                "+                          final PrintStream standardError)",
                "+         throws IOException, InvalidKeyException, GeneralSecurityException",
                "+  {",
                "+    final ObjectPair<InputStream, char[]> p =",
                "+         getPossiblyPassphraseEncryptedInputStream(inputStream,",
                "+              (passphrase == null)",
                "+                   ? null",
                "+                   : passphrase.toCharArray(),",
                "+              promptOnIncorrectPassphrase, passphrasePrompt,",
                "+              incorrectPassphraseError, standardOutput, standardError);",
                "+",
                "+    if (p.getSecond() == null)",
                "+    {",
                "+      return new ObjectPair<>(p.getFirst(), null);",
                "+    }",
                "+    else",
                "+    {",
                "+      return new ObjectPair<>(p.getFirst(), new String(p.getSecond()));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves an {@code InputStream} that can be used to read data from the",
                "+   * provided input stream that may have potentially been encrypted with a",
                "+   * {@link PassphraseEncryptedOutputStream}.  If the provided input stream does",
                "+   * not appear to contain passphrase-encrypted data, then the returned stream",
                "+   * will permit reading the data from the provided stream without any",
                "+   * alteration.",
                "+   * <BR><BR>",
                "+   * The determination will be made by looking to see if the input stream starts",
                "+   * with a valid {@link PassphraseEncryptedStreamHeader}.  Because of the",
                "+   * complex nature of that header, it is highly unlikely that the input stream",
                "+   * will just happen to start with a valid header if the stream does not",
                "+   * actually contain encrypted data.",
                "+   * <BR><BR>",
                "+   * The input stream's {@code mark} and {@code reset} methods will be used to",
                "+   * permit peeking at the data at the head of the input stream.  If the",
                "+   * provided stream does not support the use of those methods, then it will be",
                "+   * wrapped in a {@code BufferedInputStream}, which does support them.",
                "+   *",
                "+   * @param  inputStream                  The input stream from which the data",
                "+   *                                      is to be read.  It must not be",
                "+   *                                      {@code null}.",
                "+   * @param  passphrase                   The passphrase to use to generate the",
                "+   *                                      encryption key.  It may be",
                "+   *                                      {@code null} if the passphrase should",
                "+   *                                      only be obtained via interactive",
                "+   *                                      prompting.  If the passphrase is not",
                "+   *                                      {@code null} but is incorrect, then",
                "+   *                                      the user may be interactively prompted",
                "+   *                                      for the correct passphrase.",
                "+   * @param  promptOnIncorrectPassphrase  Indicates whether the user should be",
                "+   *                                      interactively prompted for the correct",
                "+   *                                      passphrase if the provided passphrase",
                "+   *                                      is non-{@code null} and is also",
                "+   *                                      incorrect.",
                "+   * @param  passphrasePrompt             The prompt that will be presented to",
                "+   *                                      the user if the input stream does",
                "+   *                                      contain encrypted data and the",
                "+   *                                      passphrase needs to be interactively",
                "+   *                                      requested from the user.  It must not",
                "+   *                                      be {@code null} or empty.",
                "+   * @param  incorrectPassphraseError     The error message that will be",
                "+   *                                      presented to the user if the entered",
                "+   *                                      passphrase is not correct.  It must",
                "+   *                                      not be {@code null} or empty.",
                "+   * @param  out                          The {@code PrintStream} to use to",
                "+   *                                      write to standard output while",
                "+   *                                      interactively prompting for the",
                "+   *                                      passphrase.  It must not be",
                "+   *                                      {@code null}.",
                "+   * @param  err                          The {@code PrintStream} to use to",
                "+   *                                      write to standard error while",
                "+   *                                      interactively prompting for the",
                "+   *                                      passphrase.  It must not be",
                "+   *                                      {@code null}.",
                "+   *",
                "+   * @return  An {@code ObjectPair} that combines the resulting input stream",
                "+   *          with the associated encryption passphrase.  If the provided input",
                "+   *          stream is encrypted, then the returned input stream element will",
                "+   *          be a {@code PassphraseEncryptedInputStream} and the returned",
                "+   *          passphrase element will be non-{@code null}.  If the provided",
                "+   *          input stream is not encrypted, then the returned input stream",
                "+   *          element will be the provided input stream (potentially wrapped in",
                "+   *          a {@code BufferedInputStream}), and the returned passphrase",
                "+   *          element will be {@code null}.",
                "+   *",
                "+   * @throws  IOException  If a problem is encountered while attempting to",
                "+   *                       determine whether the stream contains",
                "+   *                       passphrase-encrypted data.",
                "+   *",
                "+   * @throws  InvalidKeyException  If the provided passphrase is incorrect and",
                "+   *                               the user should not be interactively prompted",
                "+   *                               for the correct passphrase.",
                "+   *",
                "+   * @throws  GeneralSecurityException  If a problem is encountered while",
                "+   *                                    attempting to prepare to decrypt data",
                "+   *                                    read from the input stream.",
                "+   */",
                "+  public static ObjectPair<InputStream,char[]>",
                "+                     getPossiblyPassphraseEncryptedInputStream(",
                "+                          final InputStream inputStream,",
                "+                          final char[] passphrase,",
                "+                          final boolean promptOnIncorrectPassphrase,",
                "+                          final CharSequence passphrasePrompt,",
                "+                          final CharSequence incorrectPassphraseError,",
                "+                          final PrintStream out, final PrintStream err)",
                "+         throws IOException, InvalidKeyException, GeneralSecurityException",
                "+  {",
                "+    Validator.ensureTrue((inputStream != null),",
                "+         \"StaticUtils.getPossiblyPassphraseEncryptedInputStream.inputStream \" +",
                "+              \"must not be null.\");",
                "+    Validator.ensureTrue(",
                "+         ((passphrasePrompt != null) && (passphrasePrompt.length() > 0)),",
                "+         \"StaticUtils.getPossiblyPassphraseEncryptedInputStream.\" +",
                "+              \"passphrasePrompt must not be null or empty.\");",
                "+    Validator.ensureTrue(",
                "+         ((incorrectPassphraseError != null) &&",
                "+              (incorrectPassphraseError.length() > 0)),",
                "+         \"StaticUtils.getPossiblyPassphraseEncryptedInputStream.\" +",
                "+              \"incorrectPassphraseError must not be null or empty.\");",
                "+    Validator.ensureTrue((out != null),",
                "+         \"StaticUtils.getPossiblyPassphraseEncryptedInputStream.\" +",
                "+              \"standardOutput must not be null.\");",
                "+    Validator.ensureTrue((err != null),",
                "+         \"StaticUtils.getPossiblyPassphraseEncryptedInputStream.\" +",
                "+              \"standardError must not be null.\");",
                "+",
                "+",
                "+    // Mark the input stream so that we can peek at data from the beginning of",
                "+    // the stream.",
                "+    final InputStream markableInputStream;",
                "+    if (inputStream.markSupported())",
                "+    {",
                "+      markableInputStream = inputStream;",
                "+    }",
                "+    else",
                "+    {",
                "+      markableInputStream = new BufferedInputStream(inputStream);",
                "+    }",
                "+",
                "+    markableInputStream.mark(1024);",
                "+",
                "+",
                "+    // Try to read a passphrase-encrypted stream header from the beginning of",
                "+    // the stream.  Just decode the header, but don't attempt to make it usable",
                "+    // for encryption or decryption.",
                "+    PassphraseEncryptedStreamHeader streamHeaderShell = null;",
                "+    try",
                "+    {",
                "+      streamHeaderShell = PassphraseEncryptedStreamHeader.readFrom(",
                "+           markableInputStream, null);",
                "+    }",
                "+    catch (final LDAPException e)",
                "+    {",
                "+      // This is fine.  It just means that the stream doesn't contain encrypted",
                "+      // data.  In that case, reset the stream and return it so that the",
                "+      // unencrypted data can be read.",
                "+      Debug.debugException(Level.FINEST, e);",
                "+      markableInputStream.reset();",
                "+      return new ObjectPair<>(markableInputStream, null);",
                "+    }",
                "+",
                "+",
                "+    // If a passphrase was provided, then see if it is correct.",
                "+    if (passphrase != null)",
                "+    {",
                "+      try",
                "+      {",
                "+        final PassphraseEncryptedStreamHeader validStreamHeader =",
                "+             PassphraseEncryptedStreamHeader.decode(",
                "+                  streamHeaderShell.getEncodedHeader(),",
                "+                  passphrase);",
                "+        return new ObjectPair<InputStream,char[]>(",
                "+             new PassphraseEncryptedInputStream(markableInputStream,",
                "+                  validStreamHeader),",
                "+             passphrase);",
                "+      }",
                "+      catch (final InvalidKeyException e)",
                "+      {",
                "+        // The provided passphrase is not correct.  That's fine.  We'll just",
                "+        // prompt for the correct one.",
                "+        Debug.debugException(e);",
                "+        if (! promptOnIncorrectPassphrase)",
                "+        {",
                "+          throw e;",
                "+        }",
                "+      }",
                "+      catch (final GeneralSecurityException e)",
                "+      {",
                "+        Debug.debugException(e);",
                "+        throw e;",
                "+      }",
                "+      catch (final LDAPException e)",
                "+      {",
                "+        // This should never happen, since we were previously able to decode the",
                "+        // header.  Just treat it like a GeneralSecurityException.",
                "+        Debug.debugException(e);",
                "+        throw new GeneralSecurityException(e.getMessage(), e);",
                "+      }",
                "+    }",
                "+",
                "+",
                "+    // If the header includes a key identifier, and if the server code is",
                "+    // available, then see if we can get a passphrase for the corresponding",
                "+    // encryption settings definition ID.",
                "+    if ((streamHeaderShell.getKeyIdentifier() != null) &&",
                "+         (GET_PASSPHRASE_FOR_ENCRYPTION_SETTINGS_ID_METHOD != null))",
                "+    {",
                "+      try",
                "+      {",
                "+        final Object passphraseObject =",
                "+             GET_PASSPHRASE_FOR_ENCRYPTION_SETTINGS_ID_METHOD.invoke(null,",
                "+                  streamHeaderShell.getKeyIdentifier());",
                "+        if ((passphraseObject != null) && (passphraseObject instanceof String))",
                "+        {",
                "+          final char[] passphraseChars =",
                "+               ((String) passphraseObject).toCharArray();",
                "+          final PassphraseEncryptedStreamHeader validStreamHeader =",
                "+               PassphraseEncryptedStreamHeader.decode(",
                "+                    streamHeaderShell.getEncodedHeader(),",
                "+                    passphraseChars);",
                "+          return new ObjectPair<InputStream,char[]>(",
                "+               new PassphraseEncryptedInputStream(markableInputStream,",
                "+                    validStreamHeader),",
                "+               passphraseChars);",
                "+        }",
                "+      }",
                "+      catch (final Exception e)",
                "+      {",
                "+        // This means that either an error occurred while trying to get the",
                "+        // passphrase, or the passphrase we got was incorrect.  That's fine.",
                "+        // We'll just continue on to prompt for the passphrase.",
                "+        Debug.debugException(e);",
                "+      }",
                "+    }",
                "+",
                "+",
                "+    // If we've gotten here, then we need to interactively prompt for the",
                "+    // passphrase.",
                "+    while (true)",
                "+    {",
                "+      // Read the passphrase from the user.",
                "+      final String promptedPassphrase;",
                "+      try",
                "+      {",
                "+        promptedPassphrase =",
                "+             promptForEncryptionPassphrase(false, false, out, err);",
                "+      }",
                "+      catch (final LDAPException e)",
                "+      {",
                "+        Debug.debugException(e);",
                "+        throw new IOException(e.getMessage(), e);",
                "+      }",
                "+",
                "+",
                "+      // Check to see if the passphrase was correct.  If so, then use it.",
                "+      // Otherwise, show an error and prompt again.",
                "+      try",
                "+      {",
                "+        final char[] passphraseChars = promptedPassphrase.toCharArray();",
                "+        final PassphraseEncryptedStreamHeader validStreamHeader =",
                "+             PassphraseEncryptedStreamHeader.decode(",
                "+                  streamHeaderShell.getEncodedHeader(), passphraseChars);",
                "+        return new ObjectPair<InputStream,char[]>(",
                "+             new PassphraseEncryptedInputStream(markableInputStream,",
                "+                  validStreamHeader),",
                "+             passphraseChars);",
                "+      }",
                "+      catch (final InvalidKeyException e)",
                "+      {",
                "+        Debug.debugException(e);",
                "+",
                "+        // The passphrase was incorrect.  Display a wrapped error message and",
                "+        // re-prompt.",
                "+        wrap(incorrectPassphraseError, err);",
                "+        err.println();",
                "+      }",
                "+      catch (final GeneralSecurityException e)",
                "+      {",
                "+        Debug.debugException(e);",
                "+        throw e;",
                "+      }",
                "+      catch (final LDAPException e)",
                "+      {",
                "+        // This should never happen, since we were previously able to decode the",
                "+        // header.  Just treat it like a GeneralSecurityException.",
                "+        Debug.debugException(e);",
                "+        throw new GeneralSecurityException(e.getMessage(), e);",
                "+      }",
                "+    }",
                "+  }",
                "+}",
                "diff --git a/src/com/unboundid/ldif/LDIFReader.java b/src/com/unboundid/ldif/LDIFReader.java",
                "index c7ba66e0..bd462974 100644",
                "--- a/src/com/unboundid/ldif/LDIFReader.java",
                "+++ b/src/com/unboundid/ldif/LDIFReader.java",
                "@@ -25,3 +25,2 @@ package com.unboundid.ldif;",
                " import java.io.BufferedReader;",
                "-import java.io.BufferedWriter;",
                " import java.io.Closeable;",
                "@@ -29,3 +28,2 @@ import java.io.File;",
                " import java.io.FileInputStream;",
                "-import java.io.FileWriter;",
                " import java.io.InputStream;",
                "@@ -484,35 +482,5 @@ public final class LDIFReader",
                "     }",
                "-    else if (files.length == 1)",
                "-    {",
                "-      return new FileInputStream(files[0]);",
                "-    }",
                "     else",
                "     {",
                "-      final File spacerFile =",
                "-           File.createTempFile(\"ldif-reader-spacer\", \".ldif\");",
                "-      spacerFile.deleteOnExit();",
                "-",
                "-      final BufferedWriter spacerWriter =",
                "-           new BufferedWriter(new FileWriter(spacerFile));",
                "-      try",
                "-      {",
                "-        spacerWriter.newLine();",
                "-        spacerWriter.newLine();",
                "-      }",
                "-      finally",
                "-      {",
                "-        spacerWriter.close();",
                "-      }",
                "-",
                "-      final File[] returnArray = new File[(files.length * 2) - 1];",
                "-      returnArray[0] = files[0];",
                "-",
                "-      int pos = 1;",
                "-      for (int i=1; i < files.length; i++)",
                "-      {",
                "-        returnArray[pos++] = spacerFile;",
                "-        returnArray[pos++] = files[i];",
                "-      }",
                "-",
                "-      return new AggregateInputStream(returnArray);",
                "+      return new AggregateInputStream(true, files);",
                "     }",
                "diff --git a/src/com/unboundid/util/AggregateInputStream.java b/src/com/unboundid/util/AggregateInputStream.java",
                "index 376104ae..c81c0243 100644",
                "--- a/src/com/unboundid/util/AggregateInputStream.java",
                "+++ b/src/com/unboundid/util/AggregateInputStream.java",
                "@@ -24,2 +24,3 @@ package com.unboundid.util;",
                "+import java.io.ByteArrayInputStream;",
                " import java.io.File;",
                "@@ -102,2 +103,32 @@ public final class AggregateInputStream",
                "          throws IOException",
                "+  {",
                "+    this(false, files);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new aggregate input stream that will read data from the specified",
                "+   * files.",
                "+   *",
                "+   * @param  ensureBlankLinesBetweenFiles  Indicates whether to ensure that",
                "+   *                                       there is at least one completely",
                "+   *                                       blank line between files.  This may",
                "+   *                                       be useful when blank lines are",
                "+   *                                       used as delimiters (for example, when",
                "+   *                                       reading LDIF data), there is a chance",
                "+   *                                       that the files may not end with blank",
                "+   *                                       lines, and the inclusion of extra",
                "+   *                                       blank lines between files will not",
                "+   *                                       cause any harm.",
                "+   * @param  files                         The set of files to be read by this",
                "+   *                                       aggregate input stream.  It must not",
                "+   *                                       be {@code null}.",
                "+   *",
                "+   * @throws  IOException  If a problem is encountered while attempting to",
                "+   *                       create input streams for the provided files.",
                "+   */",
                "+  public AggregateInputStream(final boolean ensureBlankLinesBetweenFiles,",
                "+                              final File... files)",
                "+         throws IOException",
                "   {",
                "@@ -105,4 +136,3 @@ public final class AggregateInputStream",
                "-    final ArrayList<InputStream> streamList =",
                "-         new ArrayList<InputStream>(files.length);",
                "+    final ArrayList<InputStream> streamList = new ArrayList<>(2 * files.length);",
                "@@ -111,2 +141,10 @@ public final class AggregateInputStream",
                "     {",
                "+      if (ensureBlankLinesBetweenFiles && (! streamList.isEmpty()))",
                "+      {",
                "+        final ByteStringBuffer buffer = new ByteStringBuffer(4);",
                "+        buffer.append(StaticUtils.EOL_BYTES);",
                "+        buffer.append(StaticUtils.EOL_BYTES);",
                "+        streamList.add(new ByteArrayInputStream(buffer.toByteArray()));",
                "+      }",
                "+",
                "       try",
                "diff --git a/src/com/unboundid/util/PasswordReader.java b/src/com/unboundid/util/PasswordReader.java",
                "index fcb0a806..c3cb9b8c 100644",
                "--- a/src/com/unboundid/util/PasswordReader.java",
                "+++ b/src/com/unboundid/util/PasswordReader.java",
                "@@ -25,2 +25,4 @@ package com.unboundid.util;",
                " import java.io.BufferedReader;",
                "+import java.io.ByteArrayInputStream;",
                "+import java.io.InputStreamReader;",
                " import java.util.Arrays;",
                "@@ -160,5 +162,34 @@ public final class PasswordReader",
                "+  /**",
                "+   * Specifies the lines that should be used as input when reading the password.",
                "+   * This should only be set when running unit tests, and the",
                "+   * {@link #setTestReader(BufferedReader)} method should be called with a value",
                "+   * of {@code null} before the end of the test to ensure that the password",
                "+   * reader is reverted back to its normal behavior.",
                "+   *",
                "+   * @param  lines  The lines of input that should be provided to the password",
                "+   *                reader instead of actually obtaining them interactively.",
                "+   *                It must not be {@code null} but may be empty.",
                "+   */",
                "+  @InternalUseOnly()",
                "+  public static void setTestReaderLines(final String... lines)",
                "+  {",
                "+    final ByteStringBuffer buffer = new ByteStringBuffer();",
                "+    for (final String line : lines)",
                "+    {",
                "+      buffer.append(line);",
                "+      buffer.append(StaticUtils.EOL_BYTES);",
                "+    }",
                "+",
                "+    TEST_READER = new BufferedReader(new InputStreamReader(",
                "+         new ByteArrayInputStream(buffer.toByteArray())));",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "    * Specifies the input stream from which to read the password.  This should",
                "-   * only be set when running unit tests.",
                "+   * only be set when running unit tests, and this method should be called",
                "+   * again with a value of {@code null} before the end of the test to ensure",
                "+   * that the password reader is reverted back to its normal behavior.",
                "    *",
                "diff --git a/src/com/unboundid/util/StaticUtils.java b/src/com/unboundid/util/StaticUtils.java",
                "index 5f262783..ec678909 100644",
                "--- a/src/com/unboundid/util/StaticUtils.java",
                "+++ b/src/com/unboundid/util/StaticUtils.java",
                "@@ -68,2 +68,9 @@ public final class StaticUtils",
                "+  /**",
                "+   * A pre-allocated empty character array.",
                "+   */",
                "+  public static final char[] NO_CHARS = new char[0];",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/examples/ValidateLDIFTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/examples/ValidateLDIFTestCase.java",
                "index 2d6a174c..1b4aeb94 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/examples/ValidateLDIFTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/examples/ValidateLDIFTestCase.java",
                "@@ -27,2 +27,3 @@ import java.io.FileInputStream;",
                " import java.io.FileOutputStream;",
                "+import java.io.OutputStream;",
                " import java.util.zip.GZIPOutputStream;",
                "@@ -39,2 +40,4 @@ import com.unboundid.ldap.sdk.ResultCode;",
                " import com.unboundid.ldif.LDIFWriter;",
                "+import com.unboundid.util.PassphraseEncryptedOutputStream;",
                "+import com.unboundid.util.PasswordReader;",
                "@@ -51,2 +54,5 @@ public class ValidateLDIFTestCase",
                "+  // The path to a compressed and encrypted version of a valid LDIF file.",
                "+  private File encryptedLDIF;",
                "+",
                "   // The path to an invalid LDIF file.",
                "@@ -149,4 +155,4 @@ public class ValidateLDIFTestCase",
                "     compressedLDIF.delete();",
                "-    final FileInputStream is = new FileInputStream(validLDIF);",
                "-    final GZIPOutputStream os =",
                "+    FileInputStream is = new FileInputStream(validLDIF);",
                "+    OutputStream os =",
                "          new GZIPOutputStream(new FileOutputStream(compressedLDIF));",
                "@@ -168,2 +174,22 @@ public class ValidateLDIFTestCase",
                "+    encryptedLDIF = createTempFile();",
                "+    encryptedLDIF.delete();",
                "+    is = new FileInputStream(validLDIF);",
                "+    os = new GZIPOutputStream(new PassphraseEncryptedOutputStream(\"passphrase\",",
                "+         new FileOutputStream(encryptedLDIF)));",
                "+    while (true)",
                "+    {",
                "+      final int bytesRead = is.read(buffer);",
                "+      if (bytesRead < 0)",
                "+      {",
                "+        break;",
                "+      }",
                "+      else",
                "+      {",
                "+        os.write(buffer, 0, bytesRead);",
                "+      }",
                "+    }",
                "+    is.close();",
                "+    os.close();",
                "+",
                "     LDAPConnection conn = getAdminConnection();",
                "@@ -384,2 +410,75 @@ public class ValidateLDIFTestCase",
                "+  /**",
                "+   * Performs a test with an encrypted LDIF file when the passphrase is",
                "+   * provided in a file.",
                "+   * <BR><BR>",
                "+   * Access to a Directory Server instance is required for complete processing.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testEncryptedLDIFWithPassphraseFromFile()",
                "+         throws Exception",
                "+  {",
                "+    if (! isDirectoryInstanceAvailable())",
                "+    {",
                "+      return;",
                "+    }",
                "+",
                "+    final File passphraseFile = createTempFile(\"passphrase\");",
                "+",
                "+    String[] args =",
                "+    {",
                "+      \"-h\", getTestHost(),",
                "+      \"-p\", String.valueOf(getTestPort()),",
                "+      \"-D\", getTestBindDN(),",
                "+      \"-w\", getTestBindPassword(),",
                "+      \"-f\", encryptedLDIF.getAbsolutePath(),",
                "+      \"--encryptionPassphraseFile\", passphraseFile.getAbsolutePath(),",
                "+      \"-c\"",
                "+    };",
                "+    assertEquals(ValidateLDIF.main(args, null, null), ResultCode.SUCCESS);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Performs a test with an encrypted LDIF file when the passphrase is",
                "+   * provided at an interactive prompt.",
                "+   * <BR><BR>",
                "+   * Access to a Directory Server instance is required for complete processing.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testEncryptedLDIFWithPromptedPassphrase()",
                "+         throws Exception",
                "+  {",
                "+    if (! isDirectoryInstanceAvailable())",
                "+    {",
                "+      return;",
                "+    }",
                "+",
                "+    try",
                "+    {",
                "+      PasswordReader.setTestReaderLines(\"passphrase\");",
                "+",
                "+      String[] args =",
                "+      {",
                "+        \"-h\", getTestHost(),",
                "+        \"-p\", String.valueOf(getTestPort()),",
                "+        \"-D\", getTestBindDN(),",
                "+        \"-w\", getTestBindPassword(),",
                "+        \"-f\", encryptedLDIF.getAbsolutePath()",
                "+      };",
                "+      assertEquals(ValidateLDIF.main(args, null, null), ResultCode.SUCCESS);",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/transformations/TransformLDIFTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/transformations/TransformLDIFTestCase.java",
                "index e4032d7f..80d4a175 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/transformations/TransformLDIFTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/transformations/TransformLDIFTestCase.java",
                "@@ -24,2 +24,3 @@ package com.unboundid.ldap.sdk.transformations;",
                "+import java.io.BufferedInputStream;",
                " import java.io.ByteArrayInputStream;",
                "@@ -47,2 +48,5 @@ import com.unboundid.ldif.LDIFModifyChangeRecord;",
                " import com.unboundid.ldif.LDIFReader;",
                "+import com.unboundid.util.PassphraseEncryptedInputStream;",
                "+import com.unboundid.util.PassphraseEncryptedOutputStream;",
                "+import com.unboundid.util.PasswordReader;",
                " import com.unboundid.util.StaticUtils;",
                "@@ -2020,2 +2024,472 @@ public final class TransformLDIFTestCase",
                "+  /**",
                "+   * Tests the tool's behavior when dealing with compressed and encrypted data",
                "+   * when using a passphrase obtained from a file.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testEncryptionWithPassphraseFromFile()",
                "+         throws Exception",
                "+  {",
                "+    // Define the source data that will be used for testing.",
                "+    final String[] sourceLines =",
                "+    {",
                "+      \"dn: dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: domain\",",
                "+      \"dc: example\",",
                "+      \"description: domain\",",
                "+      \"\",",
                "+      \"dn: ou=People,dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: organizationalUnit\",",
                "+      \"ou: People\",",
                "+      \"description: orgUnit\",",
                "+      \"\",",
                "+      \"dn: uid=user.1,ou=People,dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: person\",",
                "+      \"objectClass: organizationalPerson\",",
                "+      \"objectClass: inetOrgPerson\",",
                "+      \"uid: user.1\",",
                "+      \"givenName: User\",",
                "+      \"sn: 1\",",
                "+      \"cn: User 1\",",
                "+      \"userPassword: {CLEAR}password\",",
                "+      \"description: user\",",
                "+      \"\",",
                "+      \"dn: uid=user.2,ou=People,dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: person\",",
                "+      \"objectClass: organizationalPerson\",",
                "+      \"objectClass: inetOrgPerson\",",
                "+      \"uid: user.2\",",
                "+      \"givenName: User\",",
                "+      \"sn: 2\",",
                "+      \"cn: User 2\",",
                "+      \"userPassword: {CLEAR}password\",",
                "+      \"description: user\",",
                "+      \"\",",
                "+      \"dn: uid=user.3,ou=People,dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: person\",",
                "+      \"objectClass: organizationalPerson\",",
                "+      \"objectClass: inetOrgPerson\",",
                "+      \"uid: user.3\",",
                "+      \"givenName: User\",",
                "+      \"sn: 3\",",
                "+      \"cn: User 3\",",
                "+      \"userPassword: {CLEAR}password\",",
                "+      \"description: user\",",
                "+      \"\",",
                "+      \"dn: uid=user.4,ou=People,dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: person\",",
                "+      \"objectClass: organizationalPerson\",",
                "+      \"objectClass: inetOrgPerson\",",
                "+      \"uid: user.4\",",
                "+      \"givenName: User\",",
                "+      \"sn: 4\",",
                "+      \"cn: User 4\",",
                "+      \"userPassword: {CLEAR}password\",",
                "+      \"description: user\",",
                "+      \"\",",
                "+      \"dn: uid=user.5,ou=People,dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: person\",",
                "+      \"objectClass: organizationalPerson\",",
                "+      \"objectClass: inetOrgPerson\",",
                "+      \"uid: user.5\",",
                "+      \"givenName: User\",",
                "+      \"sn: 5\",",
                "+      \"cn: User 5\",",
                "+      \"userPassword: {CLEAR}password\",",
                "+      \"description: user\"",
                "+    };",
                "+",
                "+",
                "+    // Create the LDIF file to scramble  It will be compressed and encrypted.",
                "+    final File sourceLDIFFile = createTempFile();",
                "+    assertTrue(sourceLDIFFile.delete());",
                "+",
                "+    final PrintStream printStream = new PrintStream(new GZIPOutputStream(",
                "+         new PassphraseEncryptedOutputStream(\"passphrase\",",
                "+              new FileOutputStream(sourceLDIFFile))));",
                "+    for (final String line : sourceLines)",
                "+    {",
                "+      printStream.println(line);",
                "+    }",
                "+    printStream.close();",
                "+",
                "+    final File passphraseFile = createTempFile(\"passphrase\");",
                "+",
                "+    final File outputFile = runTool(",
                "+         \"--sourceLDIF\", sourceLDIFFile.getAbsolutePath(),",
                "+         \"--scrambleAttribute\", \"uid\",",
                "+         \"--scrambleAttribute\", \"description\",",
                "+         \"--scrambleAttribute\", \"userPassword\",",
                "+         \"--processDNs\",",
                "+         \"--schemaPath\", singleSchemaFile.getAbsolutePath(),",
                "+         \"--compressTarget\",",
                "+         \"--encryptTarget\",",
                "+         \"--encryptionPassphraseFile\", passphraseFile.getAbsolutePath());",
                "+",
                "+    final LDIFReader reader = new LDIFReader(new GZIPInputStream(",
                "+         new BufferedInputStream(new PassphraseEncryptedInputStream(",
                "+              \"passphrase\", new BufferedInputStream(new FileInputStream(",
                "+                   outputFile))))));",
                "+",
                "+    Entry e = reader.readEntry();",
                "+    assertNotNull(e);",
                "+    assertDNsEqual(e.getDN(), \"dc=example,dc=com\");",
                "+    assertTrue(e.hasAttribute(\"description\"));",
                "+    assertFalse(e.hasAttributeValue(\"description\", \"domain\"));",
                "+",
                "+    e = reader.readEntry();",
                "+    assertNotNull(e);",
                "+    assertDNsEqual(e.getDN(), \"ou=People,dc=example,dc=com\");",
                "+    assertTrue(e.hasAttribute(\"description\"));",
                "+    assertFalse(e.hasAttributeValue(\"description\", \"orgUnit\"));",
                "+",
                "+    for (int i=1; i <= 5; i++)",
                "+    {",
                "+      e = reader.readEntry();",
                "+      assertNotNull(e);",
                "+",
                "+      assertTrue(e.getDN().startsWith(\"uid=\"));",
                "+      assertTrue(e.getDN().endsWith(\",ou=People,dc=example,dc=com\"));",
                "+      assertFalse(e.getDN().equals(",
                "+           \"uid=user.\" + i + \",ou=People,dc=example,dc=com\"));",
                "+",
                "+      assertTrue(e.hasAttribute(\"uid\"));",
                "+      assertFalse(e.hasAttributeValue(\"uid\", \"user.\" + i));",
                "+",
                "+      assertTrue(e.hasAttribute(\"description\"));",
                "+      assertFalse(e.hasAttributeValue(\"description\", \"user\"));",
                "+",
                "+      assertTrue(e.hasAttribute(\"userPassword\"));",
                "+      assertFalse(e.hasAttributeValue(\"userPassword\", \"{CLEAR}password\"));",
                "+      assertTrue(e.getAttributeValue(\"userPassword\").startsWith(\"{CLEAR}\"));",
                "+    }",
                "+",
                "+    assertNull(reader.readEntry());",
                "+",
                "+    reader.close();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the tool's behavior when dealing with compressed and encrypted data",
                "+   * when using a passphrase obtained via interactive prompting.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testEncryptionWithPassphraseFromPrompt()",
                "+         throws Exception",
                "+  {",
                "+    // Define the source data that will be used for testing.",
                "+    final String[] sourceLines =",
                "+    {",
                "+      \"dn: dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: domain\",",
                "+      \"dc: example\",",
                "+      \"description: domain\",",
                "+      \"\",",
                "+      \"dn: ou=People,dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: organizationalUnit\",",
                "+      \"ou: People\",",
                "+      \"description: orgUnit\",",
                "+      \"\",",
                "+      \"dn: uid=user.1,ou=People,dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: person\",",
                "+      \"objectClass: organizationalPerson\",",
                "+      \"objectClass: inetOrgPerson\",",
                "+      \"uid: user.1\",",
                "+      \"givenName: User\",",
                "+      \"sn: 1\",",
                "+      \"cn: User 1\",",
                "+      \"userPassword: {CLEAR}password\",",
                "+      \"description: user\",",
                "+      \"\",",
                "+      \"dn: uid=user.2,ou=People,dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: person\",",
                "+      \"objectClass: organizationalPerson\",",
                "+      \"objectClass: inetOrgPerson\",",
                "+      \"uid: user.2\",",
                "+      \"givenName: User\",",
                "+      \"sn: 2\",",
                "+      \"cn: User 2\",",
                "+      \"userPassword: {CLEAR}password\",",
                "+      \"description: user\",",
                "+      \"\",",
                "+      \"dn: uid=user.3,ou=People,dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: person\",",
                "+      \"objectClass: organizationalPerson\",",
                "+      \"objectClass: inetOrgPerson\",",
                "+      \"uid: user.3\",",
                "+      \"givenName: User\",",
                "+      \"sn: 3\",",
                "+      \"cn: User 3\",",
                "+      \"userPassword: {CLEAR}password\",",
                "+      \"description: user\",",
                "+      \"\",",
                "+      \"dn: uid=user.4,ou=People,dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: person\",",
                "+      \"objectClass: organizationalPerson\",",
                "+      \"objectClass: inetOrgPerson\",",
                "+      \"uid: user.4\",",
                "+      \"givenName: User\",",
                "+      \"sn: 4\",",
                "+      \"cn: User 4\",",
                "+      \"userPassword: {CLEAR}password\",",
                "+      \"description: user\",",
                "+      \"\",",
                "+      \"dn: uid=user.5,ou=People,dc=example,dc=com\",",
                "+      \"objectClass: top\",",
                "+      \"objectClass: person\",",
                "+      \"objectClass: organizationalPerson\",",
                "+      \"objectClass: inetOrgPerson\",",
                "+      \"uid: user.5\",",
                "+      \"givenName: User\",",
                "+      \"sn: 5\",",
                "+      \"cn: User 5\",",
                "+      \"userPassword: {CLEAR}password\",",
                "+      \"description: user\"",
                "+    };",
                "+",
                "+",
                "+    // Create the LDIF file to scramble  It will be compressed and encrypted.",
                "+    final File sourceLDIFFile = createTempFile();",
                "+    assertTrue(sourceLDIFFile.delete());",
                "+",
                "+    final PrintStream printStream = new PrintStream(new GZIPOutputStream(",
                "+         new PassphraseEncryptedOutputStream(\"passphrase\",",
                "+              new FileOutputStream(sourceLDIFFile))));",
                "+    for (final String line : sourceLines)",
                "+    {",
                "+      printStream.println(line);",
                "+    }",
                "+    printStream.close();",
                "+",
                "+    final File outputFile;",
                "+    try",
                "+    {",
                "+      PasswordReader.setTestReaderLines(\"passphrase\");",
                "+",
                "+      outputFile = runTool(",
                "+           \"--sourceLDIF\", sourceLDIFFile.getAbsolutePath(),",
                "+           \"--scrambleAttribute\", \"uid\",",
                "+           \"--scrambleAttribute\", \"description\",",
                "+           \"--scrambleAttribute\", \"userPassword\",",
                "+           \"--processDNs\",",
                "+           \"--schemaPath\", singleSchemaFile.getAbsolutePath(),",
                "+           \"--compressTarget\",",
                "+           \"--encryptTarget\");",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+",
                "+    final LDIFReader reader = new LDIFReader(new GZIPInputStream(",
                "+         new BufferedInputStream(new PassphraseEncryptedInputStream(",
                "+              \"passphrase\", new BufferedInputStream(new FileInputStream(",
                "+                   outputFile))))));",
                "+",
                "+    Entry e = reader.readEntry();",
                "+    assertNotNull(e);",
                "+    assertDNsEqual(e.getDN(), \"dc=example,dc=com\");",
                "+    assertTrue(e.hasAttribute(\"description\"));",
                "+    assertFalse(e.hasAttributeValue(\"description\", \"domain\"));",
                "+",
                "+    e = reader.readEntry();",
                "+    assertNotNull(e);",
                "+    assertDNsEqual(e.getDN(), \"ou=People,dc=example,dc=com\");",
                "+    assertTrue(e.hasAttribute(\"description\"));",
                "+    assertFalse(e.hasAttributeValue(\"description\", \"orgUnit\"));",
                "+",
                "+    for (int i=1; i <= 5; i++)",
                "+    {",
                "+      e = reader.readEntry();",
                "+      assertNotNull(e);",
                "+",
                "+      assertTrue(e.getDN().startsWith(\"uid=\"));",
                "+      assertTrue(e.getDN().endsWith(\",ou=People,dc=example,dc=com\"));",
                "+      assertFalse(e.getDN().equals(",
                "+           \"uid=user.\" + i + \",ou=People,dc=example,dc=com\"));",
                "+",
                "+      assertTrue(e.hasAttribute(\"uid\"));",
                "+      assertFalse(e.hasAttributeValue(\"uid\", \"user.\" + i));",
                "+",
                "+      assertTrue(e.hasAttribute(\"description\"));",
                "+      assertFalse(e.hasAttributeValue(\"description\", \"user\"));",
                "+",
                "+      assertTrue(e.hasAttribute(\"userPassword\"));",
                "+      assertFalse(e.hasAttributeValue(\"userPassword\", \"{CLEAR}password\"));",
                "+      assertTrue(e.getAttributeValue(\"userPassword\").startsWith(\"{CLEAR}\"));",
                "+    }",
                "+",
                "+    assertNull(reader.readEntry());",
                "+",
                "+    reader.close();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the tool's behavior when dealing with compressed and encrypted data",
                "+   * when using a passphrase obtained via interactive prompting and the input",
                "+   * is not encrypted.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testEncryptionWithPassphraseFromPromptUnencryptedInput()",
                "+         throws Exception",
                "+  {",
                "+    // Create the LDIF file to scramble.",
                "+    final File sourceLDIFFile = createTempFile(",
                "+         \"dn: dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: domain\",",
                "+         \"dc: example\",",
                "+         \"description: domain\",",
                "+         \"\",",
                "+         \"dn: ou=People,dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: organizationalUnit\",",
                "+         \"ou: People\",",
                "+         \"description: orgUnit\",",
                "+         \"\",",
                "+         \"dn: uid=user.1,ou=People,dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: person\",",
                "+         \"objectClass: organizationalPerson\",",
                "+         \"objectClass: inetOrgPerson\",",
                "+         \"uid: user.1\",",
                "+         \"givenName: User\",",
                "+         \"sn: 1\",",
                "+         \"cn: User 1\",",
                "+         \"userPassword: {CLEAR}password\",",
                "+         \"description: user\",",
                "+         \"\",",
                "+         \"dn: uid=user.2,ou=People,dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: person\",",
                "+         \"objectClass: organizationalPerson\",",
                "+         \"objectClass: inetOrgPerson\",",
                "+         \"uid: user.2\",",
                "+         \"givenName: User\",",
                "+         \"sn: 2\",",
                "+         \"cn: User 2\",",
                "+         \"userPassword: {CLEAR}password\",",
                "+         \"description: user\",",
                "+         \"\",",
                "+         \"dn: uid=user.3,ou=People,dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: person\",",
                "+         \"objectClass: organizationalPerson\",",
                "+         \"objectClass: inetOrgPerson\",",
                "+         \"uid: user.3\",",
                "+         \"givenName: User\",",
                "+         \"sn: 3\",",
                "+         \"cn: User 3\",",
                "+         \"userPassword: {CLEAR}password\",",
                "+         \"description: user\",",
                "+         \"\",",
                "+         \"dn: uid=user.4,ou=People,dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: person\",",
                "+         \"objectClass: organizationalPerson\",",
                "+         \"objectClass: inetOrgPerson\",",
                "+         \"uid: user.4\",",
                "+         \"givenName: User\",",
                "+         \"sn: 4\",",
                "+         \"cn: User 4\",",
                "+         \"userPassword: {CLEAR}password\",",
                "+         \"description: user\",",
                "+         \"\",",
                "+         \"dn: uid=user.5,ou=People,dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: person\",",
                "+         \"objectClass: organizationalPerson\",",
                "+         \"objectClass: inetOrgPerson\",",
                "+         \"uid: user.5\",",
                "+         \"givenName: User\",",
                "+         \"sn: 5\",",
                "+         \"cn: User 5\",",
                "+         \"userPassword: {CLEAR}password\",",
                "+         \"description: user\");",
                "+",
                "+    final File outputFile;",
                "+    try",
                "+    {",
                "+      PasswordReader.setTestReaderLines(\"passphrase\", \"passphrase\");",
                "+",
                "+      outputFile = runTool(",
                "+           \"--sourceLDIF\", sourceLDIFFile.getAbsolutePath(),",
                "+           \"--scrambleAttribute\", \"uid\",",
                "+           \"--scrambleAttribute\", \"description\",",
                "+           \"--scrambleAttribute\", \"userPassword\",",
                "+           \"--processDNs\",",
                "+           \"--schemaPath\", singleSchemaFile.getAbsolutePath(),",
                "+           \"--encryptTarget\");",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+",
                "+    final LDIFReader reader = new LDIFReader(new PassphraseEncryptedInputStream(",
                "+         \"passphrase\", new FileInputStream(outputFile)));",
                "+",
                "+    Entry e = reader.readEntry();",
                "+    assertNotNull(e);",
                "+    assertDNsEqual(e.getDN(), \"dc=example,dc=com\");",
                "+    assertTrue(e.hasAttribute(\"description\"));",
                "+    assertFalse(e.hasAttributeValue(\"description\", \"domain\"));",
                "+",
                "+    e = reader.readEntry();",
                "+    assertNotNull(e);",
                "+    assertDNsEqual(e.getDN(), \"ou=People,dc=example,dc=com\");",
                "+    assertTrue(e.hasAttribute(\"description\"));",
                "+    assertFalse(e.hasAttributeValue(\"description\", \"orgUnit\"));",
                "+",
                "+    for (int i=1; i <= 5; i++)",
                "+    {",
                "+      e = reader.readEntry();",
                "+      assertNotNull(e);",
                "+",
                "+      assertTrue(e.getDN().startsWith(\"uid=\"));",
                "+      assertTrue(e.getDN().endsWith(\",ou=People,dc=example,dc=com\"));",
                "+      assertFalse(e.getDN().equals(",
                "+           \"uid=user.\" + i + \",ou=People,dc=example,dc=com\"));",
                "+",
                "+      assertTrue(e.hasAttribute(\"uid\"));",
                "+      assertFalse(e.hasAttributeValue(\"uid\", \"user.\" + i));",
                "+",
                "+      assertTrue(e.hasAttribute(\"description\"));",
                "+      assertFalse(e.hasAttributeValue(\"description\", \"user\"));",
                "+",
                "+      assertTrue(e.hasAttribute(\"userPassword\"));",
                "+      assertFalse(e.hasAttributeValue(\"userPassword\", \"{CLEAR}password\"));",
                "+      assertTrue(e.getAttributeValue(\"userPassword\").startsWith(\"{CLEAR}\"));",
                "+    }",
                "+",
                "+    assertNull(reader.readEntry());",
                "+",
                "+    reader.close();",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLogTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLogTestCase.java",
                "index a007a1f3..d56c4cc7 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLogTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLogTestCase.java",
                "@@ -584,4 +584,2 @@ public class SummarizeAccessLogTestCase",
                "     {",
                "-      \"--isCompressed\",",
                "-      \"--promptForEncryptionPassphrase\",",
                "       encryptedFile.getAbsolutePath()",
                "@@ -627,4 +625,2 @@ public class SummarizeAccessLogTestCase",
                "     {",
                "-      \"--isCompressed\",",
                "-      \"--promptForEncryptionPassphrase\",",
                "       encryptedFile.getAbsolutePath()",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPModifyTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPModifyTestCase.java",
                "index 68a845b4..8ca0f8cd 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPModifyTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPModifyTestCase.java",
                "@@ -27,4 +27,7 @@ import java.io.ByteArrayOutputStream;",
                " import java.io.File;",
                "+import java.io.FileOutputStream;",
                "+import java.io.PrintStream;",
                " import java.util.Arrays;",
                " import java.util.Collections;",
                "+import java.util.zip.GZIPOutputStream;",
                "@@ -45,2 +48,4 @@ import com.unboundid.util.Base64;",
                " import com.unboundid.util.ByteStringBuffer;",
                "+import com.unboundid.util.PassphraseEncryptedOutputStream;",
                "+import com.unboundid.util.PasswordReader;",
                " import com.unboundid.util.StaticUtils;",
                "@@ -2349,2 +2354,135 @@ public final class LDAPModifyTestCase",
                "+  /**",
                "+   * Tests the ability to process compressed and encrypted LDIF data when the",
                "+   * encryption passphrase is provided in a file that isn't a valid passphrase",
                "+   * file.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testCompressedAndEncryptedInputWithPassphraseFromMalformedFile()",
                "+         throws Exception",
                "+  {",
                "+    final InMemoryDirectoryServer ds = getTestDS(false, false);",
                "+",
                "+    final File inputFile = createTempFile();",
                "+    assertTrue(inputFile.delete());",
                "+",
                "+    final PrintStream printStream = new PrintStream(new GZIPOutputStream(",
                "+         new PassphraseEncryptedOutputStream(\"passphrase\", new FileOutputStream(",
                "+              inputFile))));",
                "+    printStream.println(\"dn: dc=example,dc=com\");",
                "+    printStream.println(\"changetype: add\");",
                "+    printStream.println(\"objectClass: top\");",
                "+    printStream.println(\"objectClass: domain\");",
                "+    printStream.println(\"dc: example\");",
                "+    printStream.close();",
                "+",
                "+    final File passphraseFile = createTempFile(); // Shouldn't be empty.",
                "+",
                "+    final ByteArrayOutputStream out = new ByteArrayOutputStream();",
                "+    assertEquals(",
                "+         LDAPModify.main(null, out, out,",
                "+              \"--hostname\", \"localhost\",",
                "+              \"--port\", String.valueOf(ds.getListenPort()),",
                "+              \"--bindDN\", \"cn=Directory Manager\",",
                "+              \"--bindPassword\", \"password\",",
                "+              \"--ldifFile\", inputFile.getAbsolutePath(),",
                "+              \"--encryptionPassphraseFile\", passphraseFile.getAbsolutePath()),",
                "+         ResultCode.PARAM_ERROR,",
                "+         new String(out.toByteArray(), \"UTF-8\"));",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the ability to process compressed and encrypted LDIF data when the",
                "+   * encryption passphrase is provided in a file.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testCompressedAndEncryptedInputWithPassphraseFromFile()",
                "+         throws Exception",
                "+  {",
                "+    final InMemoryDirectoryServer ds = getTestDS(false, false);",
                "+",
                "+    final File inputFile = createTempFile();",
                "+    assertTrue(inputFile.delete());",
                "+",
                "+    final PrintStream printStream = new PrintStream(new GZIPOutputStream(",
                "+         new PassphraseEncryptedOutputStream(\"passphrase\", new FileOutputStream(",
                "+              inputFile))));",
                "+    printStream.println(\"dn: dc=example,dc=com\");",
                "+    printStream.println(\"changetype: add\");",
                "+    printStream.println(\"objectClass: top\");",
                "+    printStream.println(\"objectClass: domain\");",
                "+    printStream.println(\"dc: example\");",
                "+    printStream.close();",
                "+",
                "+    final File passphraseFile = createTempFile(\"passphrase\");",
                "+",
                "+    final ByteArrayOutputStream out = new ByteArrayOutputStream();",
                "+    assertEquals(",
                "+         LDAPModify.main(null, out, out,",
                "+              \"--hostname\", \"localhost\",",
                "+              \"--port\", String.valueOf(ds.getListenPort()),",
                "+              \"--bindDN\", \"cn=Directory Manager\",",
                "+              \"--bindPassword\", \"password\",",
                "+              \"--ldifFile\", inputFile.getAbsolutePath(),",
                "+              \"--encryptionPassphraseFile\", passphraseFile.getAbsolutePath()),",
                "+         ResultCode.SUCCESS,",
                "+         new String(out.toByteArray(), \"UTF-8\"));",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the ability to process compressed and encrypted LDIF data when the",
                "+   * encryption passphrase is provided at an interactive prompt.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testCompressedAndEncryptedInputWithPassphraseFromPrompt()",
                "+         throws Exception",
                "+  {",
                "+    final InMemoryDirectoryServer ds = getTestDS(false, false);",
                "+",
                "+    final File inputFile = createTempFile();",
                "+    assertTrue(inputFile.delete());",
                "+",
                "+    final PrintStream printStream = new PrintStream(new GZIPOutputStream(",
                "+         new PassphraseEncryptedOutputStream(\"passphrase\", new FileOutputStream(",
                "+              inputFile))));",
                "+    printStream.println(\"dn: dc=example,dc=com\");",
                "+    printStream.println(\"changetype: add\");",
                "+    printStream.println(\"objectClass: top\");",
                "+    printStream.println(\"objectClass: domain\");",
                "+    printStream.println(\"dc: example\");",
                "+    printStream.close();",
                "+",
                "+    try",
                "+    {",
                "+      PasswordReader.setTestReaderLines(\"passphrase\");",
                "+",
                "+      final ByteArrayOutputStream out = new ByteArrayOutputStream();",
                "+      assertEquals(",
                "+           LDAPModify.main(null, out, out,",
                "+                \"--hostname\", \"localhost\",",
                "+                \"--port\", String.valueOf(ds.getListenPort()),",
                "+                \"--bindDN\", \"cn=Directory Manager\",",
                "+                \"--bindPassword\", \"password\",",
                "+                \"--ldifFile\", inputFile.getAbsolutePath()),",
                "+           ResultCode.SUCCESS,",
                "+           new String(out.toByteArray(), \"UTF-8\"));",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearchTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearchTestCase.java",
                "index d78ed5cb..79e301a1 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearchTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearchTestCase.java",
                "@@ -27,2 +27,3 @@ import java.io.FileInputStream;",
                " import java.io.OutputStream;",
                "+import java.util.zip.GZIPInputStream;",
                "@@ -41,2 +42,4 @@ import com.unboundid.ldap.sdk.extensions.NoticeOfDisconnectionExtendedResult;",
                " import com.unboundid.ldif.LDIFReader;",
                "+import com.unboundid.util.PassphraseEncryptedInputStream;",
                "+import com.unboundid.util.PasswordReader;",
                " import com.unboundid.util.json.JSONObject;",
                "@@ -1748,2 +1751,178 @@ public final class LDAPSearchTestCase",
                "   }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Provides test coverage for the ability to compress and encrypt the LDIF",
                "+   * output when the encryption passphrase is provided in a file that is",
                "+   * malformed.",
                "+   *",
                "+   * @throws  Exception  if an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testCompressAndEncryptOutputWithPassphraseFromMalformedFile()",
                "+         throws Exception",
                "+  {",
                "+    final File outputFile = createTempFile();",
                "+    final File passphraseFile = createTempFile(); // Shouldn't be empty.",
                "+",
                "+    assertEquals(",
                "+         LDAPSearch.main(NULL_OUTPUT_STREAM, NULL_OUTPUT_STREAM,",
                "+              \"--hostname\", \"localhost\",",
                "+              \"--port\", String.valueOf(ds.getListenPort()),",
                "+              \"--baseDN\", \"dc=example,dc=com\",",
                "+              \"--scope\", \"sub\",",
                "+              \"--dereferencePolicy\", \"find\",",
                "+              \"--outputFile\", outputFile.getAbsolutePath(),",
                "+              \"--compressOutput\",",
                "+              \"--encryptOutput\",",
                "+              \"--encryptionPassphraseFile\", passphraseFile.getAbsolutePath(),",
                "+              \"--sortOrder\", \"-sn,+givenName,uid\",",
                "+              \"--virtualListView\", \"0:100:1:0\",",
                "+              \"(objectClass=person)\",",
                "+              \"givenName\",",
                "+              \"sn\"),",
                "+         ResultCode.PARAM_ERROR);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Provides test coverage for the ability to compress and encrypt the LDIF",
                "+   * output when the encryption passphrase is provided in a file.",
                "+   *",
                "+   * @throws  Exception  if an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testCompressAndEncryptOutputWithPassphraseFromFile()",
                "+         throws Exception",
                "+  {",
                "+    final File outputFile = createTempFile();",
                "+    final File passphraseFile = createTempFile(\"passphrase\");",
                "+",
                "+    assertEquals(",
                "+         LDAPSearch.main(NULL_OUTPUT_STREAM, NULL_OUTPUT_STREAM,",
                "+              \"--hostname\", \"localhost\",",
                "+              \"--port\", String.valueOf(ds.getListenPort()),",
                "+              \"--baseDN\", \"dc=example,dc=com\",",
                "+              \"--scope\", \"sub\",",
                "+              \"--dereferencePolicy\", \"find\",",
                "+              \"--outputFile\", outputFile.getAbsolutePath(),",
                "+              \"--compressOutput\",",
                "+              \"--encryptOutput\",",
                "+              \"--encryptionPassphraseFile\", passphraseFile.getAbsolutePath(),",
                "+              \"--sortOrder\", \"-sn,+givenName,uid\",",
                "+              \"--virtualListView\", \"0:100:1:0\",",
                "+              \"(objectClass=person)\",",
                "+              \"givenName\",",
                "+              \"sn\"),",
                "+         ResultCode.SUCCESS);",
                "+",
                "+    final LDIFReader ldifReader = new LDIFReader(new GZIPInputStream(",
                "+         new PassphraseEncryptedInputStream(\"passphrase\",",
                "+              new FileInputStream(outputFile))));",
                "+",
                "+    assertEquals(ldifReader.readEntry(),",
                "+         new Entry(",
                "+              \"dn: uid=ezra.edwards,ou=People,dc=example,dc=com\",",
                "+              \"givenName: Ezra\",",
                "+              \"sn: Edwards\"));",
                "+    assertEquals(ldifReader.readEntry(),",
                "+         new Entry(",
                "+              \"dn: uid=dolly.duke,ou=People,dc=example,dc=com\",",
                "+              \"givenName: Dolly\",",
                "+              \"sn: Duke\"));",
                "+    assertEquals(ldifReader.readEntry(),",
                "+         new Entry(",
                "+              \"dn: uid=chester.cooper,ou=People,dc=example,dc=com\",",
                "+              \"givenName: Chester\",",
                "+              \"sn: Cooper\"));",
                "+    assertEquals(ldifReader.readEntry(),",
                "+         new Entry(",
                "+              \"dn: uid=brenda.brown,ou=People,dc=example,dc=com\",",
                "+              \"givenName: Brenda\",",
                "+              \"sn: Brown\"));",
                "+    assertEquals(ldifReader.readEntry(),",
                "+         new Entry(",
                "+              \"dn: uid=aaron.adams,ou=People,dc=example,dc=com\",",
                "+              \"givenName: Aaron\",",
                "+              \"sn: Adams\"));",
                "+    assertNull(ldifReader.readEntry());",
                "+",
                "+    ldifReader.close();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Provides test coverage for the ability to compress and encrypt the LDIF",
                "+   * output when the encryption passphrase is provided at an interactive prompt.",
                "+   *",
                "+   * @throws  Exception  if an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testCompressAndEncryptOutputWithPassphraseFromPrompt()",
                "+         throws Exception",
                "+  {",
                "+    final File outputFile = createTempFile();",
                "+",
                "+    try",
                "+    {",
                "+      PasswordReader.setTestReaderLines(\"passphrase\", \"passphrase\");",
                "+",
                "+      assertEquals(",
                "+           LDAPSearch.main(NULL_OUTPUT_STREAM, NULL_OUTPUT_STREAM,",
                "+                \"--hostname\", \"localhost\",",
                "+                \"--port\", String.valueOf(ds.getListenPort()),",
                "+                \"--baseDN\", \"dc=example,dc=com\",",
                "+                \"--scope\", \"sub\",",
                "+                \"--dereferencePolicy\", \"find\",",
                "+                \"--outputFile\", outputFile.getAbsolutePath(),",
                "+                \"--compressOutput\",",
                "+                \"--encryptOutput\",",
                "+                \"--sortOrder\", \"-sn,+givenName,uid\",",
                "+                \"--virtualListView\", \"0:100:1:0\",",
                "+                \"(objectClass=person)\",",
                "+                \"givenName\",",
                "+                \"sn\"),",
                "+           ResultCode.SUCCESS);",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+",
                "+    final LDIFReader ldifReader = new LDIFReader(new GZIPInputStream(",
                "+         new PassphraseEncryptedInputStream(\"passphrase\",",
                "+              new FileInputStream(outputFile))));",
                "+",
                "+    assertEquals(ldifReader.readEntry(),",
                "+         new Entry(",
                "+              \"dn: uid=ezra.edwards,ou=People,dc=example,dc=com\",",
                "+              \"givenName: Ezra\",",
                "+              \"sn: Edwards\"));",
                "+    assertEquals(ldifReader.readEntry(),",
                "+         new Entry(",
                "+              \"dn: uid=dolly.duke,ou=People,dc=example,dc=com\",",
                "+              \"givenName: Dolly\",",
                "+              \"sn: Duke\"));",
                "+    assertEquals(ldifReader.readEntry(),",
                "+         new Entry(",
                "+              \"dn: uid=chester.cooper,ou=People,dc=example,dc=com\",",
                "+              \"givenName: Chester\",",
                "+              \"sn: Cooper\"));",
                "+    assertEquals(ldifReader.readEntry(),",
                "+         new Entry(",
                "+              \"dn: uid=brenda.brown,ou=People,dc=example,dc=com\",",
                "+              \"givenName: Brenda\",",
                "+              \"sn: Brown\"));",
                "+    assertEquals(ldifReader.readEntry(),",
                "+         new Entry(",
                "+              \"dn: uid=aaron.adams,ou=People,dc=example,dc=com\",",
                "+              \"givenName: Aaron\",",
                "+              \"sn: Adams\"));",
                "+    assertNull(ldifReader.readEntry());",
                "+",
                "+    ldifReader.close();",
                "+  }",
                " }",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/SplitLDIFTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/SplitLDIFTestCase.java",
                "index 8923ab31..954d565c 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/SplitLDIFTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/SplitLDIFTestCase.java",
                "@@ -28,2 +28,3 @@ import java.io.FileInputStream;",
                " import java.io.FileOutputStream;",
                "+import java.io.InputStream;",
                " import java.io.PrintWriter;",
                "@@ -47,2 +48,4 @@ import com.unboundid.ldif.LDIFReader;",
                " import com.unboundid.ldif.LDIFWriter;",
                "+import com.unboundid.util.PassphraseEncryptedInputStream;",
                "+import com.unboundid.util.PasswordReader;",
                "@@ -1603,2 +1606,3 @@ public final class SplitLDIFTestCase",
                "     final File outputDir = createTempDir();",
                "+    final File passphraseFile = createTempFile(\"passphrase\");",
                "@@ -1612,2 +1616,4 @@ public final class SplitLDIFTestCase",
                "          \"--compressTarget\",",
                "+         \"--encryptTarget\",",
                "+         \"--encryptionPassphraseFile\", passphraseFile.getAbsolutePath(),",
                "          \"--splitBaseDN\", \"ou=People,dc=example,dc=com\",",
                "@@ -1624,3 +1630,4 @@ public final class SplitLDIFTestCase",
                "     assertEquals(",
                "-         readEntries(outputDir, \"output.ldif.outside-split\", true, true).size(),",
                "+         readEntries(outputDir, \"output.ldif.outside-split\", true, true,",
                "+              true).size(),",
                "          2);",
                "@@ -1635,9 +1642,9 @@ public final class SplitLDIFTestCase",
                "     final int set1Count =",
                "-         readEntries(outputDir, \"output.ldif.set1\", true, true).size();",
                "+         readEntries(outputDir, \"output.ldif.set1\", true, true, true).size();",
                "     final int set2Count =",
                "-         readEntries(outputDir, \"output.ldif.set2\", true, true).size();",
                "+         readEntries(outputDir, \"output.ldif.set2\", true, true, true).size();",
                "     final int set3Count =",
                "-         readEntries(outputDir, \"output.ldif.set3\", true, true).size();",
                "+         readEntries(outputDir, \"output.ldif.set3\", true, true, true).size();",
                "     final int set4Count =",
                "-         readEntries(outputDir, \"output.ldif.set4\", true, true).size();",
                "+         readEntries(outputDir, \"output.ldif.set4\", true, true, true).size();",
                "@@ -1882,3 +1889,3 @@ public final class SplitLDIFTestCase",
                "     final Map<DN,Entry> errorMap =",
                "-         readEntries(outputDir, \"output.ldif.errors\", false, false);",
                "+         readEntries(outputDir, \"output.ldif.errors\", false, false, false);",
                "     assertEquals(errorMap.size(), 26);",
                "@@ -2405,3 +2412,3 @@ public final class SplitLDIFTestCase",
                "     final Map<DN,Entry> errorMap =",
                "-         readEntries(outputDir, \"output.ldif.errors\", false, false);",
                "+         readEntries(outputDir, \"output.ldif.errors\", false, false, false);",
                "     assertEquals(errorMap.size(), 26);",
                "@@ -3137,3 +3144,3 @@ public final class SplitLDIFTestCase",
                "     final Map<DN,Entry> errorMap =",
                "-         readEntries(outputDir, \"output.ldif.errors\", false, false);",
                "+         readEntries(outputDir, \"output.ldif.errors\", false, false, false);",
                "     assertEquals(errorMap.size(), 26);",
                "@@ -3326,13 +3333,23 @@ public final class SplitLDIFTestCase",
                "-    final ResultCode rc = SplitLDIF.main(out, out,",
                "-         \"split-using-hash-on-rdn\",",
                "-         \"--sourceLDIF\", flatDITFile.getAbsolutePath(),",
                "-         \"--targetLDIFBasePath\",",
                "-              outputDir.getAbsolutePath() + File.separator + \"output.ldif\",",
                "-         \"--compressTarget\",",
                "-         \"--splitBaseDN\", \"ou=People,dc=example,dc=com\",",
                "-         \"--addEntriesOutsideSplitBaseDNToDedicatedSet\",",
                "-         \"--addEntriesOutsideSplitBaseDNToAllSets\",",
                "-         \"--numSets\", \"4\");",
                "-    assertEquals(rc, ResultCode.SUCCESS);",
                "+    try",
                "+    {",
                "+      PasswordReader.setTestReaderLines(\"passphrase\", \"passphrase\");",
                "+",
                "+      final ResultCode rc = SplitLDIF.main(out, out,",
                "+           \"split-using-hash-on-rdn\",",
                "+           \"--sourceLDIF\", flatDITFile.getAbsolutePath(),",
                "+           \"--targetLDIFBasePath\",",
                "+           outputDir.getAbsolutePath() + File.separator + \"output.ldif\",",
                "+           \"--compressTarget\",",
                "+           \"--encryptTarget\",",
                "+           \"--splitBaseDN\", \"ou=People,dc=example,dc=com\",",
                "+           \"--addEntriesOutsideSplitBaseDNToDedicatedSet\",",
                "+           \"--addEntriesOutsideSplitBaseDNToAllSets\",",
                "+           \"--numSets\", \"4\");",
                "+      assertEquals(rc, ResultCode.SUCCESS);",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "@@ -3342,3 +3359,4 @@ public final class SplitLDIFTestCase",
                "     assertEquals(",
                "-         readEntries(outputDir, \"output.ldif.outside-split\", true, true).size(),",
                "+         readEntries(outputDir, \"output.ldif.outside-split\", true, true,",
                "+              true).size(),",
                "          2);",
                "@@ -3353,9 +3371,9 @@ public final class SplitLDIFTestCase",
                "     final int set1Count =",
                "-         readEntries(outputDir, \"output.ldif.set1\", true, true).size();",
                "+         readEntries(outputDir, \"output.ldif.set1\", true, true, true).size();",
                "     final int set2Count =",
                "-         readEntries(outputDir, \"output.ldif.set2\", true, true).size();",
                "+         readEntries(outputDir, \"output.ldif.set2\", true, true, true).size();",
                "     final int set3Count =",
                "-         readEntries(outputDir, \"output.ldif.set3\", true, true).size();",
                "+         readEntries(outputDir, \"output.ldif.set3\", true, true, true).size();",
                "     final int set4Count =",
                "-         readEntries(outputDir, \"output.ldif.set4\", true, true).size();",
                "+         readEntries(outputDir, \"output.ldif.set4\", true, true, true).size();",
                "@@ -3416,3 +3434,4 @@ public final class SplitLDIFTestCase",
                "     assertEquals(",
                "-         readEntries(outputDir, \"output.ldif.outside-split\", true, true).size(),",
                "+         readEntries(outputDir, \"output.ldif.outside-split\", true, true,",
                "+              false).size(),",
                "          2);",
                "@@ -3427,9 +3446,9 @@ public final class SplitLDIFTestCase",
                "     final int set1Count =",
                "-         readEntries(outputDir, \"output.ldif.set1\", true, true).size();",
                "+         readEntries(outputDir, \"output.ldif.set1\", true, true, false).size();",
                "     final int set2Count =",
                "-         readEntries(outputDir, \"output.ldif.set2\", true, true).size();",
                "+         readEntries(outputDir, \"output.ldif.set2\", true, true, false).size();",
                "     final int set3Count =",
                "-         readEntries(outputDir, \"output.ldif.set3\", true, true).size();",
                "+         readEntries(outputDir, \"output.ldif.set3\", true, true, false).size();",
                "     final int set4Count =",
                "-         readEntries(outputDir, \"output.ldif.set4\", true, true).size();",
                "+         readEntries(outputDir, \"output.ldif.set4\", true, true, false).size();",
                "@@ -3521,3 +3540,3 @@ public final class SplitLDIFTestCase",
                "   {",
                "-    return readEntries(dir, filename, true, false);",
                "+    return readEntries(dir, filename, true, false, false);",
                "   }",
                "@@ -3537,2 +3556,3 @@ public final class SplitLDIFTestCase",
                "    * @param  isCompressed  Indicates whether the input file is compressed.",
                "+   * @param  isEncrypted   Indicates whether the input file is encrypted.",
                "    *",
                "@@ -3545,3 +3565,4 @@ public final class SplitLDIFTestCase",
                "                                                final boolean checkParent,",
                "-                                               final boolean isCompressed)",
                "+                                               final boolean isCompressed,",
                "+                                               final boolean isEncrypted)",
                "           throws Exception",
                "@@ -3550,13 +3571,18 @@ public final class SplitLDIFTestCase",
                "-    final LDIFReader r;",
                "     final File f = new File(dir, filename);",
                "-    if (isCompressed)",
                "+",
                "+    InputStream inputStream = new FileInputStream(f);",
                "+    if (isEncrypted)",
                "     {",
                "-      r = new LDIFReader(new GZIPInputStream(new FileInputStream(f)));",
                "+      inputStream =",
                "+           new PassphraseEncryptedInputStream(\"passphrase\", inputStream);",
                "     }",
                "-    else",
                "+",
                "+    if (isCompressed)",
                "     {",
                "-      r = new LDIFReader(f);",
                "+      inputStream = new GZIPInputStream(inputStream);",
                "     }",
                "+    final LDIFReader r = new LDIFReader(inputStream);",
                "+",
                "     final TreeMap<DN,Entry> m = new TreeMap<DN,Entry>();",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtilsTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtilsTestCase.java",
                "new file mode 100644",
                "index 00000000..787a6ca3",
                "--- /dev/null",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtilsTestCase.java",
                "@@ -0,0 +1,1728 @@",
                "+/*",
                "+ * Copyright 2018 Ping Identity Corporation",
                "+ * All Rights Reserved.",
                "+ */",
                "+/*",
                "+ * Copyright (C) 2018 Ping Identity Corporation",
                "+ *",
                "+ * This program is free software; you can redistribute it and/or modify",
                "+ * it under the terms of the GNU General Public License (GPLv2 only)",
                "+ * or the terms of the GNU Lesser General Public License (LGPLv2.1 only)",
                "+ * as published by the Free Software Foundation.",
                "+ *",
                "+ * This program is distributed in the hope that it will be useful,",
                "+ * but WITHOUT ANY WARRANTY; without even the implied warranty of",
                "+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
                "+ * GNU General Public License for more details.",
                "+ *",
                "+ * You should have received a copy of the GNU General Public License",
                "+ * along with this program; if not, see <http://www.gnu.org/licenses>.",
                "+ */",
                "+package com.unboundid.ldap.sdk.unboundidds.tools;",
                "+",
                "+",
                "+",
                "+import java.io.BufferedReader;",
                "+import java.io.ByteArrayInputStream;",
                "+import java.io.ByteArrayOutputStream;",
                "+import java.io.File;",
                "+import java.io.FileInputStream;",
                "+import java.io.FileOutputStream;",
                "+import java.io.IOException;",
                "+import java.io.InputStream;",
                "+import java.io.InputStreamReader;",
                "+import java.io.PrintStream;",
                "+import java.util.Arrays;",
                "+import java.util.Collections;",
                "+import java.util.zip.GZIPOutputStream;",
                "+",
                "+import org.testng.annotations.Test;",
                "+",
                "+import com.unboundid.ldap.sdk.Entry;",
                "+import com.unboundid.ldap.sdk.LDAPException;",
                "+import com.unboundid.ldap.sdk.LDAPSDKTestCase;",
                "+import com.unboundid.ldif.LDIFReader;",
                "+import com.unboundid.ldif.LDIFWriter;",
                "+import com.unboundid.util.LDAPSDKUsageException;",
                "+import com.unboundid.util.NullOutputStream;",
                "+import com.unboundid.util.ObjectPair;",
                "+import com.unboundid.util.PassphraseEncryptedOutputStream;",
                "+import com.unboundid.util.PasswordReader;",
                "+import com.unboundid.util.StaticUtils;",
                "+",
                "+",
                "+",
                "+/**",
                "+ * This class provides a set of test cases for the {@code ToolUtils} class.",
                "+ */",
                "+public final class ToolUtilsTestCase",
                "+       extends LDAPSDKTestCase",
                "+{",
                "+  /**",
                "+   * A print stream that can be used to suppress all output.",
                "+   */",
                "+  private static final PrintStream SUPPRESS_OUTPUT =",
                "+       NullOutputStream.getPrintStream();",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code readEncryptionPassphraseFromFile} method when the file is",
                "+   * valid.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testReadEncryptionPassphraseFromValidFile()",
                "+         throws Exception",
                "+  {",
                "+    final String passphrase = \"ThisIsThePassphrase\";",
                "+    final File passphraseFile = createTempFile(passphrase);",
                "+",
                "+    assertEquals(ToolUtils.readEncryptionPassphraseFromFile(passphraseFile),",
                "+         passphrase);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code readEncryptionPassphraseFromFile} method when the file is",
                "+   * {@code null}.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testReadEncryptionPassphraseFromNullFile()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.readEncryptionPassphraseFromFile(null);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code readEncryptionPassphraseFromFile} method when the file is",
                "+   * missing.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPException.class })",
                "+  public void testReadEncryptionPassphraseFromMissingFile()",
                "+         throws Exception",
                "+  {",
                "+    final File missingFile = createTempFile();",
                "+    assertTrue(missingFile.delete());",
                "+",
                "+    ToolUtils.readEncryptionPassphraseFromFile(missingFile);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code readEncryptionPassphraseFromFile} method when the file",
                "+   * exists but is not a file.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPException.class })",
                "+  public void testReadEncryptionPassphraseFromFileNotFile()",
                "+         throws Exception",
                "+  {",
                "+    final File directory = createTempDir();",
                "+",
                "+    ToolUtils.readEncryptionPassphraseFromFile(directory);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code readEncryptionPassphraseFromFile} method when the file is",
                "+   * empty.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPException.class })",
                "+  public void testReadEncryptionPassphraseFromEmptyFile()",
                "+         throws Exception",
                "+  {",
                "+    final File emptyFile = createTempFile();",
                "+",
                "+    ToolUtils.readEncryptionPassphraseFromFile(emptyFile);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code readEncryptionPassphraseFromFile} method when the file",
                "+   * contains a single empty line.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPException.class })",
                "+  public void testReadEncryptionPassphraseFromEmptyPassphraseFile()",
                "+         throws Exception",
                "+  {",
                "+    final File emptyPassphraseFile = createTempFile(\"\");",
                "+",
                "+    ToolUtils.readEncryptionPassphraseFromFile(emptyPassphraseFile);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code readEncryptionPassphraseFromFile} method when the file",
                "+   * contains a single empty line.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPException.class })",
                "+  public void testReadEncryptionPassphraseFromMultiLineFile()",
                "+         throws Exception",
                "+  {",
                "+    final File multiLineFile = createTempFile(\"line1\", \"line2\");",
                "+",
                "+    ToolUtils.readEncryptionPassphraseFromFile(multiLineFile);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code promptForEncryptionPassphrase} method when it is provided",
                "+   * with a {@code null} output stream.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testPromptForEncryptionPassphraseNullOutputStream()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.promptForEncryptionPassphrase(false, true, null, SUPPRESS_OUTPUT);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code promptForEncryptionPassphrase} method when it is provided",
                "+   * with a {@code null} error stream.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testPromptForEncryptionPassphraseNullErrorStream()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.promptForEncryptionPassphrase(false, true, SUPPRESS_OUTPUT, null);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code promptForEncryptionPassphrase} method when it allows an",
                "+   * empty passphrase and does not require confirmation, when an empty",
                "+   * passphrase was provided.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testPromptForEncryptionPassphraseAllowEmptyNoConfirm()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      PasswordReader.setTestReaderLines(\"\");",
                "+",
                "+      assertEquals(",
                "+           ToolUtils.promptForEncryptionPassphrase(true, false, SUPPRESS_OUTPUT,",
                "+                SUPPRESS_OUTPUT),",
                "+           \"\");",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code promptForEncryptionPassphrase} method when it allows an",
                "+   * empty passphrase and requires confirmation, when an empty passphrase was",
                "+   * provided and successfully confirmed on the first try.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testPromptForEncryptionPassphraseAllowEmptyWithConfirmOnFirstTry()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      PasswordReader.setTestReaderLines(\"\", \"\");",
                "+",
                "+      assertEquals(",
                "+           ToolUtils.promptForEncryptionPassphrase(true, true, SUPPRESS_OUTPUT,",
                "+                SUPPRESS_OUTPUT),",
                "+           \"\");",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code promptForEncryptionPassphrase} method when it allows an",
                "+   * empty passphrase and requires confirmation, when an empty passphrase was",
                "+   * provided but requires multiple attempts to be confirmed.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testPromptForEncryptionPassphraseAllowEmptyWithConfirmRetry()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      PasswordReader.setTestReaderLines(\"\", \"wrong\", \"\", \"\");",
                "+",
                "+      assertEquals(",
                "+           ToolUtils.promptForEncryptionPassphrase(true, true, SUPPRESS_OUTPUT,",
                "+                SUPPRESS_OUTPUT),",
                "+           \"\");",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code promptForEncryptionPassphrase} method when it allows an",
                "+   * empty passphrase and does not require confirmation, when a non-empty",
                "+   * passphrase was provided.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testPromptForEncryptionPassphraseAllowEmptyNotEmptyNoConfirm()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      final String passphrase = \"ThisIsThePassphrase\";",
                "+      PasswordReader.setTestReaderLines(passphrase);",
                "+",
                "+      assertEquals(",
                "+           ToolUtils.promptForEncryptionPassphrase(true, false, SUPPRESS_OUTPUT,",
                "+                SUPPRESS_OUTPUT),",
                "+           passphrase);",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code promptForEncryptionPassphrase} method when it allows an",
                "+   * empty passphrase and requires confirmation, when a non-empty",
                "+   * passphrase was provided and is successfully confirmed on the first try.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testPromptForEncryptionPassphraseAllowEmptyNotEmptyConfirmFirst()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      final String passphrase = \"ThisIsThePassphrase\";",
                "+      PasswordReader.setTestReaderLines(passphrase, passphrase);",
                "+",
                "+      assertEquals(",
                "+           ToolUtils.promptForEncryptionPassphrase(true, true, SUPPRESS_OUTPUT,",
                "+                SUPPRESS_OUTPUT),",
                "+           passphrase);",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code promptForEncryptionPassphrase} method when it allows an",
                "+   * empty passphrase and requires confirmation, when a non-empty",
                "+   * passphrase was provided but requires multiple attempts to confirm it.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testPromptForEncryptionPassphraseAllowEmptyNotEmptyConfirmRetry()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      final String passphrase = \"ThisIsThePassphrase\";",
                "+      PasswordReader.setTestReaderLines(passphrase, \"wrong\", passphrase,",
                "+           passphrase);",
                "+",
                "+      assertEquals(",
                "+           ToolUtils.promptForEncryptionPassphrase(true, true, SUPPRESS_OUTPUT,",
                "+                SUPPRESS_OUTPUT),",
                "+           passphrase);",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code promptForEncryptionPassphrase} method when does not allow",
                "+   * an empty passphrase and does not require confirmation, and a non-empty",
                "+   * passphrase was provided on the first attempt.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testPromptForEncryptionPassphraseDoNotAllowEmptyNoConfirmNoRetry()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      final String passphrase = \"ThisIsThePassphrase\";",
                "+      PasswordReader.setTestReaderLines(passphrase);",
                "+",
                "+      assertEquals(",
                "+           ToolUtils.promptForEncryptionPassphrase(false, false,",
                "+                SUPPRESS_OUTPUT, SUPPRESS_OUTPUT),",
                "+           passphrase);",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code promptForEncryptionPassphrase} method when does not allow",
                "+   * an empty passphrase and does not require confirmation, and a non-empty",
                "+   * passphrase was provided on a subsequent attempt.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testPromptForEncryptionPassphraseDoNotAllowEmptyNoConfirmOnRetry()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      final String passphrase = \"ThisIsThePassphrase\";",
                "+      PasswordReader.setTestReaderLines(\"\", \"\", passphrase);",
                "+",
                "+      assertEquals(",
                "+           ToolUtils.promptForEncryptionPassphrase(false, false,",
                "+                SUPPRESS_OUTPUT, SUPPRESS_OUTPUT),",
                "+           passphrase);",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code promptForEncryptionPassphrase} method when does not allow",
                "+   * an empty passphrase and requires confirmation, and a non-empty passphrase",
                "+   * was provided and successfully confirmed on the first attempt.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testPromptForEncryptionPassphraseDoNotAllowEmptyConfirmNoRetry()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      final String passphrase = \"ThisIsThePassphrase\";",
                "+      PasswordReader.setTestReaderLines(passphrase, passphrase);",
                "+",
                "+      assertEquals(",
                "+           ToolUtils.promptForEncryptionPassphrase(false, true,",
                "+                SUPPRESS_OUTPUT, SUPPRESS_OUTPUT),",
                "+           passphrase);",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code promptForEncryptionPassphrase} method when does not allow",
                "+   * an empty passphrase and requires confirmation, and a non-empty passphrase",
                "+   * was provided and successfully confirmed on a subsequent attempt.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testPromptForEncryptionPassphraseDoNotAllowEmptyConfirmOnRetry()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      final String passphrase = \"ThisIsThePassphrase\";",
                "+      PasswordReader.setTestReaderLines(passphrase, \"wrong\", \"\", passphrase,",
                "+           passphrase);",
                "+",
                "+      assertEquals(",
                "+           ToolUtils.promptForEncryptionPassphrase(false, true,",
                "+                SUPPRESS_OUTPUT, SUPPRESS_OUTPUT),",
                "+           passphrase);",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrap} method with a {@code null} {@code PrintStream}.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testWrapNullPrintStream()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.wrap(\"message\", null);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrap} method with a {@code null} message.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWrapNullMessage()",
                "+         throws Exception",
                "+  {",
                "+    final ByteArrayOutputStream byteArrayOutputStream =",
                "+         new ByteArrayOutputStream();",
                "+    final PrintStream printStream = new PrintStream(byteArrayOutputStream);",
                "+",
                "+    ToolUtils.wrap(null, printStream);",
                "+",
                "+    printStream.close();",
                "+    assertEquals(byteArrayOutputStream.toByteArray(), StaticUtils.EOL_BYTES);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrap} method with an empty message.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWrapEmptyMessage()",
                "+         throws Exception",
                "+  {",
                "+    final ByteArrayOutputStream byteArrayOutputStream =",
                "+         new ByteArrayOutputStream();",
                "+    final PrintStream printStream = new PrintStream(byteArrayOutputStream);",
                "+",
                "+    ToolUtils.wrap(\"\", printStream);",
                "+",
                "+    printStream.close();",
                "+    assertEquals(byteArrayOutputStream.toByteArray(), StaticUtils.EOL_BYTES);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrap} method with a short message.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWrapShortMessage()",
                "+         throws Exception",
                "+  {",
                "+    final ByteArrayOutputStream byteArrayOutputStream =",
                "+         new ByteArrayOutputStream();",
                "+    final PrintStream printStream = new PrintStream(byteArrayOutputStream);",
                "+",
                "+    ToolUtils.wrap(\"short\", printStream);",
                "+",
                "+    printStream.close();",
                "+",
                "+    assertEquals(StaticUtils.toUTF8String(byteArrayOutputStream.toByteArray()),",
                "+         \"short\" + StaticUtils.EOL);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrap} method with a long message.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWrapLongMessage()",
                "+         throws Exception",
                "+  {",
                "+    final String longMessage = \"This is a very long message that should get \" +",
                "+         \"wrapped because it is a very long message for the purpose of \" +",
                "+         \"testing the wrapping functionality. Not like a gift wrap, or a \" +",
                "+         \"musical rap, but more like word wrap. Actually, it's exactly like \" +",
                "+         \"word wrapping, because that's what it is. I suppose that I could \" +",
                "+         \"have called the method wordWrapNotGiftWrapOrMusicalRap, but that \" +",
                "+         \"would have been unnecessary and overly verbose. But I think that \" +",
                "+         \"this message is long enough now.\";",
                "+",
                "+    final ByteArrayOutputStream byteArrayOutputStream =",
                "+         new ByteArrayOutputStream();",
                "+    final PrintStream printStream = new PrintStream(byteArrayOutputStream);",
                "+",
                "+    ToolUtils.wrap(longMessage, printStream);",
                "+",
                "+    printStream.close();",
                "+",
                "+    final StringBuilder reconstructedMessageBuffer = new StringBuilder();",
                "+",
                "+    int numLines = 0;",
                "+    final byte[] outputBytes = byteArrayOutputStream.toByteArray();",
                "+    final BufferedReader reader = new BufferedReader(new InputStreamReader(",
                "+         new ByteArrayInputStream(outputBytes)));",
                "+    while (true)",
                "+    {",
                "+      final String line = reader.readLine();",
                "+      if (line == null)",
                "+      {",
                "+        break;",
                "+      }",
                "+",
                "+      if (reconstructedMessageBuffer.length() > 0)",
                "+      {",
                "+        reconstructedMessageBuffer.append(' ');",
                "+      }",
                "+      reconstructedMessageBuffer.append(line);",
                "+",
                "+      numLines++;",
                "+    }",
                "+",
                "+    assertEquals(reconstructedMessageBuffer.toString(), longMessage);",
                "+    assertTrue((numLines > 1),",
                "+         \"wrapped message:\" + StaticUtils.EOL +",
                "+              StaticUtils.toUTF8String(outputBytes));",
                "+",
                "+    assertTrue(",
                "+         StaticUtils.toUTF8String(outputBytes).endsWith(StaticUtils.EOL));",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrapPrompt} method with a {@code null}",
                "+   * {@code PrintStream}.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testWrapPromptNullPrintStream()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.wrapPrompt(\"message\", true, null);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrapPrompt} method with a {@code null} message.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testWrapPromptNullMessage()",
                "+         throws Exception",
                "+  {",
                "+    final ByteArrayOutputStream byteArrayOutputStream =",
                "+         new ByteArrayOutputStream();",
                "+    final PrintStream printStream = new PrintStream(byteArrayOutputStream);",
                "+",
                "+    ToolUtils.wrapPrompt(null, true, printStream);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrapPrompt} method with a an empty message.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testWrapPromptEmptyMessage()",
                "+         throws Exception",
                "+  {",
                "+    final ByteArrayOutputStream byteArrayOutputStream =",
                "+         new ByteArrayOutputStream();",
                "+    final PrintStream printStream = new PrintStream(byteArrayOutputStream);",
                "+",
                "+    ToolUtils.wrapPrompt(\"\", true, printStream);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrapPrompt} method with a short message that does not have",
                "+   * a trailing space and no trailing space should be added.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWrapPromptShortMessageWithoutTrailingSpaceDoNotAddSpace()",
                "+         throws Exception",
                "+  {",
                "+    final ByteArrayOutputStream byteArrayOutputStream =",
                "+         new ByteArrayOutputStream();",
                "+    final PrintStream printStream = new PrintStream(byteArrayOutputStream);",
                "+",
                "+    ToolUtils.wrapPrompt(\"short\", false, printStream);",
                "+",
                "+    printStream.close();",
                "+",
                "+    assertEquals(StaticUtils.toUTF8String(byteArrayOutputStream.toByteArray()),",
                "+         \"short\");",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrapPrompt} method with a short message that does not have",
                "+   * a trailing space and a trailing space should be added.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWrapPromptShortMessageWithoutTrailingSpaceAddSpace()",
                "+         throws Exception",
                "+  {",
                "+    final ByteArrayOutputStream byteArrayOutputStream =",
                "+         new ByteArrayOutputStream();",
                "+    final PrintStream printStream = new PrintStream(byteArrayOutputStream);",
                "+",
                "+    ToolUtils.wrapPrompt(\"short\", true, printStream);",
                "+",
                "+    printStream.close();",
                "+",
                "+    assertEquals(StaticUtils.toUTF8String(byteArrayOutputStream.toByteArray()),",
                "+         \"short \");",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrapPrompt} method with a short message that has a",
                "+   * trailing space and no trailing space should be added.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWrapPromptShortMessageWithTrailingSpaceDoNotAddSpace()",
                "+         throws Exception",
                "+  {",
                "+    final ByteArrayOutputStream byteArrayOutputStream =",
                "+         new ByteArrayOutputStream();",
                "+    final PrintStream printStream = new PrintStream(byteArrayOutputStream);",
                "+",
                "+    ToolUtils.wrapPrompt(\"short \", false, printStream);",
                "+",
                "+    printStream.close();",
                "+",
                "+    assertEquals(StaticUtils.toUTF8String(byteArrayOutputStream.toByteArray()),",
                "+         \"short \");",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrapPrompt} method with a short message that has a",
                "+   * trailing space and a trailing space should be added.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWrapPromptShortMessageWithTrailingSpaceAddSpace()",
                "+         throws Exception",
                "+  {",
                "+    final ByteArrayOutputStream byteArrayOutputStream =",
                "+         new ByteArrayOutputStream();",
                "+    final PrintStream printStream = new PrintStream(byteArrayOutputStream);",
                "+",
                "+    ToolUtils.wrapPrompt(\"short \", true, printStream);",
                "+",
                "+    printStream.close();",
                "+",
                "+    assertEquals(StaticUtils.toUTF8String(byteArrayOutputStream.toByteArray()),",
                "+         \"short \");",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrapPrompt} method with a long message when no trailing",
                "+   * space should be added.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWrapPromptLongMessageDoNotAddSpace()",
                "+         throws Exception",
                "+  {",
                "+    final String longMessage = \"This is a very long message that should get \" +",
                "+         \"wrapped because it is a very long message for the purpose of \" +",
                "+         \"testing the wrapping functionality. Not like a gift wrap, or a \" +",
                "+         \"musical rap, but more like word wrap. Actually, it's exactly like \" +",
                "+         \"word wrapping, because that's what it is. I suppose that I could \" +",
                "+         \"have called the method wordWrapNotGiftWrapOrMusicalRap, but that \" +",
                "+         \"would have been unnecessary and overly verbose. But I think that \" +",
                "+         \"this message is long enough now.\";",
                "+",
                "+    final ByteArrayOutputStream byteArrayOutputStream =",
                "+         new ByteArrayOutputStream();",
                "+    final PrintStream printStream = new PrintStream(byteArrayOutputStream);",
                "+",
                "+    ToolUtils.wrapPrompt(longMessage, false, printStream);",
                "+",
                "+    printStream.close();",
                "+",
                "+    final StringBuilder reconstructedMessageBuffer = new StringBuilder();",
                "+",
                "+    int numLines = 0;",
                "+    final byte[] outputBytes = byteArrayOutputStream.toByteArray();",
                "+    final BufferedReader reader = new BufferedReader(new InputStreamReader(",
                "+         new ByteArrayInputStream(outputBytes)));",
                "+    while (true)",
                "+    {",
                "+      final String line = reader.readLine();",
                "+      if (line == null)",
                "+      {",
                "+        break;",
                "+      }",
                "+",
                "+      if (reconstructedMessageBuffer.length() > 0)",
                "+      {",
                "+        reconstructedMessageBuffer.append(' ');",
                "+      }",
                "+      reconstructedMessageBuffer.append(line);",
                "+",
                "+      numLines++;",
                "+    }",
                "+",
                "+    assertEquals(reconstructedMessageBuffer.toString(), longMessage);",
                "+    assertTrue((numLines > 1),",
                "+         \"wrapped message:\" + StaticUtils.EOL +",
                "+              StaticUtils.toUTF8String(outputBytes));",
                "+",
                "+    assertFalse(",
                "+         StaticUtils.toUTF8String(outputBytes).endsWith(StaticUtils.EOL));",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code wrapPrompt} method with a long message when a trailing",
                "+   * space should be added.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testWrapPromptLongMessageAddSpace()",
                "+         throws Exception",
                "+  {",
                "+    final String longMessage = \"This is a very long message that should get \" +",
                "+         \"wrapped because it is a very long message for the purpose of \" +",
                "+         \"testing the wrapping functionality. Not like a gift wrap, or a \" +",
                "+         \"musical rap, but more like word wrap. Actually, it's exactly like \" +",
                "+         \"word wrapping, because that's what it is. I suppose that I could \" +",
                "+         \"have called the method wordWrapNotGiftWrapOrMusicalRap, but that \" +",
                "+         \"would have been unnecessary and overly verbose. But I think that \" +",
                "+         \"this message is long enough now.\";",
                "+",
                "+    final ByteArrayOutputStream byteArrayOutputStream =",
                "+         new ByteArrayOutputStream();",
                "+    final PrintStream printStream = new PrintStream(byteArrayOutputStream);",
                "+",
                "+    ToolUtils.wrapPrompt(longMessage, true, printStream);",
                "+",
                "+    printStream.close();",
                "+",
                "+    final StringBuilder reconstructedMessageBuffer = new StringBuilder();",
                "+",
                "+    int numLines = 0;",
                "+    final byte[] outputBytes = byteArrayOutputStream.toByteArray();",
                "+    final BufferedReader reader = new BufferedReader(new InputStreamReader(",
                "+         new ByteArrayInputStream(outputBytes)));",
                "+    while (true)",
                "+    {",
                "+      final String line = reader.readLine();",
                "+      if (line == null)",
                "+      {",
                "+        break;",
                "+      }",
                "+",
                "+      if (reconstructedMessageBuffer.length() > 0)",
                "+      {",
                "+        reconstructedMessageBuffer.append(' ');",
                "+      }",
                "+      reconstructedMessageBuffer.append(line);",
                "+",
                "+      numLines++;",
                "+    }",
                "+",
                "+    assertEquals(reconstructedMessageBuffer.toString(), longMessage + ' ');",
                "+    assertTrue((numLines > 1),",
                "+         \"wrapped message:\" + StaticUtils.EOL +",
                "+              StaticUtils.toUTF8String(outputBytes));",
                "+",
                "+    assertFalse(",
                "+         StaticUtils.toUTF8String(outputBytes).endsWith(StaticUtils.EOL));",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with a {@code null} set",
                "+   * of files.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetInputStreamForLDIFFilesNullFiles()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.getInputStreamForLDIFFiles(null, null, SUPPRESS_OUTPUT,",
                "+         SUPPRESS_OUTPUT);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with an empty set of",
                "+   * files.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetInputStreamForLDIFFilesEmptyFiles()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.getInputStreamForLDIFFiles(Collections.<File>emptyList(), null,",
                "+         SUPPRESS_OUTPUT, SUPPRESS_OUTPUT);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with a {@code null}",
                "+   * output stream.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetInputStreamForLDIFFilesNullOutputStream()",
                "+         throws Exception",
                "+  {",
                "+    final File testFile = createTempFile();",
                "+",
                "+    ToolUtils.getInputStreamForLDIFFiles(Collections.singletonList(testFile),",
                "+         null, null, SUPPRESS_OUTPUT);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with a {@code null}",
                "+   * error stream.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetInputStreamForLDIFFilesNullErrorStream()",
                "+         throws Exception",
                "+  {",
                "+    final File testFile = createTempFile();",
                "+",
                "+    ToolUtils.getInputStreamForLDIFFiles(Collections.singletonList(testFile),",
                "+         null, SUPPRESS_OUTPUT, null);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with a single file that",
                "+   * is neither encrypted nor compressed.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testGetInputStreamForLDIFFilesOneFileNotEncryptedNotCompressed()",
                "+         throws Exception",
                "+  {",
                "+    final Entry testEntry = new Entry(",
                "+         \"dn: dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: domain\",",
                "+         \"dc: example\");",
                "+",
                "+    final File testFile = createTempFile(testEntry.toLDIF());",
                "+",
                "+    final ObjectPair<InputStream,String> p =",
                "+         ToolUtils.getInputStreamForLDIFFiles(",
                "+              Collections.singletonList(testFile), null, SUPPRESS_OUTPUT,",
                "+              SUPPRESS_OUTPUT);",
                "+",
                "+    final InputStream inputStream = p.getFirst();",
                "+    assertNotNull(inputStream);",
                "+",
                "+    final String passphrase = p.getSecond();",
                "+    assertNull(passphrase);",
                "+",
                "+    final LDIFReader ldifReader = new LDIFReader(inputStream);",
                "+    assertEquals(ldifReader.readEntry(), testEntry);",
                "+    assertNull(ldifReader.readEntry());",
                "+    ldifReader.close();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with a single file that",
                "+   * is compressed but not encrypted.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testGetInputStreamForLDIFFilesOneFileNotEncryptedCompressed()",
                "+         throws Exception",
                "+  {",
                "+    final Entry testEntry = new Entry(",
                "+         \"dn: dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: domain\",",
                "+         \"dc: example\");",
                "+",
                "+    final File testFile = createTempFile(testEntry.toLDIF());",
                "+    assertTrue(testFile.delete());",
                "+",
                "+    final LDIFWriter ldifWriter = new LDIFWriter(new GZIPOutputStream(",
                "+         new FileOutputStream(testFile)));",
                "+    ldifWriter.writeEntry(testEntry);",
                "+    ldifWriter.close();",
                "+",
                "+    final ObjectPair<InputStream,String> p =",
                "+         ToolUtils.getInputStreamForLDIFFiles(",
                "+              Collections.singletonList(testFile), null, SUPPRESS_OUTPUT,",
                "+              SUPPRESS_OUTPUT);",
                "+",
                "+    final InputStream inputStream = p.getFirst();",
                "+    assertNotNull(inputStream);",
                "+",
                "+    final String passphrase = p.getSecond();",
                "+    assertNull(passphrase);",
                "+",
                "+    final LDIFReader ldifReader = new LDIFReader(inputStream);",
                "+    assertEquals(ldifReader.readEntry(), testEntry);",
                "+    assertNull(ldifReader.readEntry());",
                "+    ldifReader.close();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with a single file that",
                "+   * is encrypted but not compressed.  The correct passphrase will be",
                "+   * provided as an argument rather than obtained via prompt.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testGetInputStreamForLDIFFilesOneFileEncryptedNotCompressed1()",
                "+         throws Exception",
                "+  {",
                "+    final Entry testEntry = new Entry(",
                "+         \"dn: dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: domain\",",
                "+         \"dc: example\");",
                "+",
                "+    final File testFile = createTempFile(testEntry.toLDIF());",
                "+    assertTrue(testFile.delete());",
                "+",
                "+    final String passphrase = \"ThisIsThePassphrase\";",
                "+    final LDIFWriter ldifWriter = new LDIFWriter(",
                "+         new PassphraseEncryptedOutputStream(\"ThisIsThePassphrase\",",
                "+              new FileOutputStream(testFile)));",
                "+    ldifWriter.writeEntry(testEntry);",
                "+    ldifWriter.close();",
                "+",
                "+    final ObjectPair<InputStream,String> p =",
                "+         ToolUtils.getInputStreamForLDIFFiles(",
                "+              Collections.singletonList(testFile), passphrase, SUPPRESS_OUTPUT,",
                "+              SUPPRESS_OUTPUT);",
                "+",
                "+    final InputStream inputStream = p.getFirst();",
                "+    assertNotNull(inputStream);",
                "+",
                "+    assertNotNull(p.getSecond());",
                "+    assertEquals(p.getSecond(), passphrase);",
                "+",
                "+    final LDIFReader ldifReader = new LDIFReader(inputStream);",
                "+    assertEquals(ldifReader.readEntry(), testEntry);",
                "+    assertNull(ldifReader.readEntry());",
                "+    ldifReader.close();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with a single file that",
                "+   * is encrypted but not compressed.  The wrong passphrase will be",
                "+   * provided as an argument rather than obtained via prompt.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { IOException.class })",
                "+  public void testGetInputStreamForLDIFFilesOneFileEncryptedNotCompressed2()",
                "+         throws Exception",
                "+  {",
                "+    final Entry testEntry = new Entry(",
                "+         \"dn: dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: domain\",",
                "+         \"dc: example\");",
                "+",
                "+    final File testFile = createTempFile(testEntry.toLDIF());",
                "+    assertTrue(testFile.delete());",
                "+",
                "+    final LDIFWriter ldifWriter = new LDIFWriter(",
                "+         new PassphraseEncryptedOutputStream(\"ThisIsThePassphrase\",",
                "+              new FileOutputStream(testFile)));",
                "+    ldifWriter.writeEntry(testEntry);",
                "+    ldifWriter.close();",
                "+",
                "+    final ObjectPair<InputStream,String> p =",
                "+         ToolUtils.getInputStreamForLDIFFiles(",
                "+              Collections.singletonList(testFile), \"wrong\", SUPPRESS_OUTPUT,",
                "+              SUPPRESS_OUTPUT);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with a single file that",
                "+   * is encrypted but not compressed.  The correct passphrase will be provided",
                "+   * interactively, and the correct passphrase will be provided on the first",
                "+   * try.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testGetInputStreamForLDIFFilesOneFileEncryptedNotCompressed3()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      final String passphrase = \"ThisIsThePassphrase\";",
                "+      PasswordReader.setTestReaderLines(passphrase);",
                "+",
                "+      final Entry testEntry = new Entry(",
                "+           \"dn: dc=example,dc=com\",",
                "+           \"objectClass: top\",",
                "+           \"objectClass: domain\",",
                "+           \"dc: example\");",
                "+",
                "+      final File testFile = createTempFile(testEntry.toLDIF());",
                "+      assertTrue(testFile.delete());",
                "+",
                "+      final LDIFWriter ldifWriter = new LDIFWriter(",
                "+           new PassphraseEncryptedOutputStream(passphrase,",
                "+                new FileOutputStream(testFile)));",
                "+      ldifWriter.writeEntry(testEntry);",
                "+      ldifWriter.close();",
                "+",
                "+      final ObjectPair<InputStream,String> p =",
                "+           ToolUtils.getInputStreamForLDIFFiles(",
                "+                Collections.singletonList(testFile), null, SUPPRESS_OUTPUT,",
                "+                SUPPRESS_OUTPUT);",
                "+",
                "+      final InputStream inputStream = p.getFirst();",
                "+      assertNotNull(inputStream);",
                "+",
                "+      assertNotNull(p.getSecond());",
                "+      assertEquals(p.getSecond(), passphrase);",
                "+",
                "+      final LDIFReader ldifReader = new LDIFReader(inputStream);",
                "+      assertEquals(ldifReader.readEntry(), testEntry);",
                "+      assertNull(ldifReader.readEntry());",
                "+      ldifReader.close();",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with a single file that",
                "+   * is encrypted but not compressed.  The correct passphrase will be provided",
                "+   * interactively, and the correct passphrase will be provided on the second",
                "+   * try.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testGetInputStreamForLDIFFilesOneFileEncryptedNotCompressed4()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      final String passphrase = \"ThisIsThePassphrase\";",
                "+      PasswordReader.setTestReaderLines(\"wrong\", passphrase);",
                "+",
                "+      final Entry testEntry = new Entry(",
                "+           \"dn: dc=example,dc=com\",",
                "+           \"objectClass: top\",",
                "+           \"objectClass: domain\",",
                "+           \"dc: example\");",
                "+",
                "+      final File testFile = createTempFile(testEntry.toLDIF());",
                "+      assertTrue(testFile.delete());",
                "+",
                "+      final LDIFWriter ldifWriter = new LDIFWriter(",
                "+           new PassphraseEncryptedOutputStream(passphrase,",
                "+                new FileOutputStream(testFile)));",
                "+      ldifWriter.writeEntry(testEntry);",
                "+      ldifWriter.close();",
                "+",
                "+      final ObjectPair<InputStream,String> p =",
                "+           ToolUtils.getInputStreamForLDIFFiles(",
                "+                Collections.singletonList(testFile), null, SUPPRESS_OUTPUT,",
                "+                SUPPRESS_OUTPUT);",
                "+",
                "+      final InputStream inputStream = p.getFirst();",
                "+      assertNotNull(inputStream);",
                "+",
                "+      assertNotNull(p.getSecond());",
                "+      assertEquals(p.getSecond(), passphrase);",
                "+",
                "+      final LDIFReader ldifReader = new LDIFReader(inputStream);",
                "+      assertEquals(ldifReader.readEntry(), testEntry);",
                "+      assertNull(ldifReader.readEntry());",
                "+      ldifReader.close();",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with a single file that",
                "+   * is both encrypted and compressed.  The correct passphrase will be provided",
                "+   * non-interactively.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testGetInputStreamForLDIFFilesOneFileEncryptedCompressed()",
                "+         throws Exception",
                "+  {",
                "+    final Entry testEntry = new Entry(",
                "+         \"dn: dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: domain\",",
                "+         \"dc: example\");",
                "+",
                "+    final File testFile = createTempFile(testEntry.toLDIF());",
                "+    assertTrue(testFile.delete());",
                "+",
                "+    final String passphrase = \"ThisIsThePassphrase\";",
                "+    final LDIFWriter ldifWriter = new LDIFWriter(new GZIPOutputStream(",
                "+         new PassphraseEncryptedOutputStream(\"ThisIsThePassphrase\",",
                "+              new FileOutputStream(testFile))));",
                "+    ldifWriter.writeEntry(testEntry);",
                "+    ldifWriter.close();",
                "+",
                "+    final ObjectPair<InputStream,String> p =",
                "+         ToolUtils.getInputStreamForLDIFFiles(",
                "+              Collections.singletonList(testFile), passphrase, SUPPRESS_OUTPUT,",
                "+              SUPPRESS_OUTPUT);",
                "+",
                "+    final InputStream inputStream = p.getFirst();",
                "+    assertNotNull(inputStream);",
                "+",
                "+    assertNotNull(p.getSecond());",
                "+    assertEquals(p.getSecond(), passphrase);",
                "+",
                "+    final LDIFReader ldifReader = new LDIFReader(inputStream);",
                "+    assertEquals(ldifReader.readEntry(), testEntry);",
                "+    assertNull(ldifReader.readEntry());",
                "+    ldifReader.close();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with multiple files",
                "+   * that have a mix of encryption and compression characteristics.  All",
                "+   * encrypted files will use the same passphrase, and that passphrase will be",
                "+   * provided rather than obtained via prompt.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testGetInputStreamForLDIFFilesMultipleFiles1()",
                "+         throws Exception",
                "+  {",
                "+    final String passphrase = \"ThisIsThePassphrase\";",
                "+",
                "+    final Entry testEntry1 = new Entry(",
                "+         \"dn: dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: domain\",",
                "+         \"dc: example\");",
                "+    final File testFile1 = createTempFile(testEntry1.toLDIF());",
                "+",
                "+    final Entry testEntry2 = new Entry(",
                "+         \"dn: ou=foo,dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: organizationalUnit\",",
                "+         \"ou: foo\");",
                "+    final File testFile2 = createTempFile();",
                "+    assertTrue(testFile2.delete());",
                "+    LDIFWriter ldifWriter = new LDIFWriter(new GZIPOutputStream(",
                "+         new FileOutputStream(testFile2)));",
                "+    ldifWriter.writeEntry(testEntry2);",
                "+    ldifWriter.close();",
                "+",
                "+    final Entry testEntry3 = new Entry(",
                "+         \"dn: ou=bar,dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: organizationalUnit\",",
                "+         \"ou: bar\");",
                "+    final File testFile3 = createTempFile();",
                "+    assertTrue(testFile3.delete());",
                "+    ldifWriter = new LDIFWriter(new PassphraseEncryptedOutputStream(passphrase,",
                "+         new FileOutputStream(testFile3)));",
                "+    ldifWriter.writeEntry(testEntry3);",
                "+    ldifWriter.close();",
                "+",
                "+    final Entry testEntry4 = new Entry(",
                "+         \"dn: ou=baz,dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: organizationalUnit\",",
                "+         \"ou: baz\");",
                "+    final File testFile4 = createTempFile();",
                "+    assertTrue(testFile4.delete());",
                "+    ldifWriter = new LDIFWriter(new GZIPOutputStream(",
                "+         new PassphraseEncryptedOutputStream(passphrase,",
                "+              new FileOutputStream(testFile4))));",
                "+    ldifWriter.writeEntry(testEntry4);",
                "+    ldifWriter.close();",
                "+",
                "+    final ObjectPair<InputStream,String> p =",
                "+         ToolUtils.getInputStreamForLDIFFiles(",
                "+              Arrays.asList(testFile1, testFile2, testFile3, testFile4),",
                "+              passphrase, SUPPRESS_OUTPUT, SUPPRESS_OUTPUT);",
                "+",
                "+    final InputStream inputStream = p.getFirst();",
                "+    assertNotNull(inputStream);",
                "+",
                "+    assertNotNull(p.getSecond());",
                "+    assertEquals(p.getSecond(), passphrase);",
                "+",
                "+    final LDIFReader ldifReader = new LDIFReader(inputStream);",
                "+    assertEquals(ldifReader.readEntry(), testEntry1);",
                "+    assertEquals(ldifReader.readEntry(), testEntry2);",
                "+    assertEquals(ldifReader.readEntry(), testEntry3);",
                "+    assertEquals(ldifReader.readEntry(), testEntry4);",
                "+    assertNull(ldifReader.readEntry());",
                "+    ldifReader.close();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with multiple files",
                "+   * that have a mix of encryption and compression characteristics. The",
                "+   * encrypted files will use different passphrases, and the passphrase will",
                "+   * be provided rather than obtained via prompt, so the attempt to obtain the",
                "+   * input stream will fail.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { IOException.class })",
                "+  public void testGetInputStreamForLDIFFilesMultipleFiles2()",
                "+         throws Exception",
                "+  {",
                "+    final Entry testEntry1 = new Entry(",
                "+         \"dn: dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: domain\",",
                "+         \"dc: example\");",
                "+    final File testFile1 = createTempFile(testEntry1.toLDIF());",
                "+",
                "+    final Entry testEntry2 = new Entry(",
                "+         \"dn: ou=foo,dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: organizationalUnit\",",
                "+         \"ou: foo\");",
                "+    final File testFile2 = createTempFile();",
                "+    assertTrue(testFile2.delete());",
                "+    LDIFWriter ldifWriter = new LDIFWriter(new GZIPOutputStream(",
                "+         new FileOutputStream(testFile2)));",
                "+    ldifWriter.writeEntry(testEntry2);",
                "+    ldifWriter.close();",
                "+",
                "+    final Entry testEntry3 = new Entry(",
                "+         \"dn: ou=bar,dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: organizationalUnit\",",
                "+         \"ou: bar\");",
                "+    final File testFile3 = createTempFile();",
                "+    assertTrue(testFile3.delete());",
                "+    ldifWriter = new LDIFWriter(new PassphraseEncryptedOutputStream(",
                "+         \"ThisIsTheFirstPassphrase\",",
                "+         new FileOutputStream(testFile3)));",
                "+    ldifWriter.writeEntry(testEntry3);",
                "+    ldifWriter.close();",
                "+",
                "+    final Entry testEntry4 = new Entry(",
                "+         \"dn: ou=baz,dc=example,dc=com\",",
                "+         \"objectClass: top\",",
                "+         \"objectClass: organizationalUnit\",",
                "+         \"ou: baz\");",
                "+    final File testFile4 = createTempFile();",
                "+    assertTrue(testFile4.delete());",
                "+    ldifWriter = new LDIFWriter(new GZIPOutputStream(",
                "+         new PassphraseEncryptedOutputStream(\"ThisIsTheSecondPassphrase\",",
                "+              new FileOutputStream(testFile4))));",
                "+    ldifWriter.writeEntry(testEntry4);",
                "+    ldifWriter.close();",
                "+",
                "+    final ObjectPair<InputStream,String> p =",
                "+         ToolUtils.getInputStreamForLDIFFiles(",
                "+              Arrays.asList(testFile1, testFile2, testFile3, testFile4),",
                "+              \"ThisIsTheFirstPassphrase\", SUPPRESS_OUTPUT, SUPPRESS_OUTPUT);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getInputStreamForLDIFFiles} method with multiple files",
                "+   * that have a mix of encryption and compression characteristics. The",
                "+   * encrypted files will use different passphrases, and the passphrases will be",
                "+   * provided via prompt so the data should be readable.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testGetInputStreamForLDIFFilesMultipleFiles3()",
                "+         throws Exception",
                "+  {",
                "+    try",
                "+    {",
                "+      final String passphrase1 = \"ThisIsTheFirstPassphrase\";",
                "+      final String passphrase2 = \"ThisIsTheSecondPassphrase\";",
                "+      PasswordReader.setTestReaderLines(passphrase1, \"wrong\", passphrase2);",
                "+",
                "+      final Entry testEntry1 = new Entry(",
                "+           \"dn: dc=example,dc=com\",",
                "+           \"objectClass: top\",",
                "+           \"objectClass: domain\",",
                "+           \"dc: example\");",
                "+      final File testFile1 = createTempFile(testEntry1.toLDIF());",
                "+",
                "+      final Entry testEntry2 = new Entry(",
                "+           \"dn: ou=foo,dc=example,dc=com\",",
                "+           \"objectClass: top\",",
                "+           \"objectClass: organizationalUnit\",",
                "+           \"ou: foo\");",
                "+      final File testFile2 = createTempFile();",
                "+      assertTrue(testFile2.delete());",
                "+      LDIFWriter ldifWriter = new LDIFWriter(new GZIPOutputStream(",
                "+           new FileOutputStream(testFile2)));",
                "+      ldifWriter.writeEntry(testEntry2);",
                "+      ldifWriter.close();",
                "+",
                "+      final Entry testEntry3 = new Entry(",
                "+           \"dn: ou=bar,dc=example,dc=com\",",
                "+           \"objectClass: top\",",
                "+           \"objectClass: organizationalUnit\",",
                "+           \"ou: bar\");",
                "+      final File testFile3 = createTempFile();",
                "+      assertTrue(testFile3.delete());",
                "+      ldifWriter = new LDIFWriter(new PassphraseEncryptedOutputStream(",
                "+           passphrase1, new FileOutputStream(testFile3)));",
                "+      ldifWriter.writeEntry(testEntry3);",
                "+      ldifWriter.close();",
                "+",
                "+      final Entry testEntry4 = new Entry(",
                "+           \"dn: ou=baz,dc=example,dc=com\",",
                "+           \"objectClass: top\",",
                "+           \"objectClass: organizationalUnit\",",
                "+           \"ou: baz\");",
                "+      final File testFile4 = createTempFile();",
                "+      assertTrue(testFile4.delete());",
                "+      ldifWriter = new LDIFWriter(new GZIPOutputStream(",
                "+           new PassphraseEncryptedOutputStream(passphrase1,",
                "+                new FileOutputStream(testFile4))));",
                "+      ldifWriter.writeEntry(testEntry4);",
                "+      ldifWriter.close();",
                "+",
                "+      final ObjectPair<InputStream,String> p =",
                "+           ToolUtils.getInputStreamForLDIFFiles(",
                "+                Arrays.asList(testFile1, testFile2, testFile3, testFile4), null,",
                "+                SUPPRESS_OUTPUT, SUPPRESS_OUTPUT);",
                "+",
                "+      final InputStream inputStream = p.getFirst();",
                "+      assertNotNull(inputStream);",
                "+",
                "+      assertNotNull(p.getSecond());",
                "+      assertEquals(p.getSecond(), passphrase1);",
                "+",
                "+      final LDIFReader ldifReader = new LDIFReader(inputStream);",
                "+      assertEquals(ldifReader.readEntry(), testEntry1);",
                "+      assertEquals(ldifReader.readEntry(), testEntry2);",
                "+      assertEquals(ldifReader.readEntry(), testEntry3);",
                "+      assertEquals(ldifReader.readEntry(), testEntry4);",
                "+      assertNull(ldifReader.readEntry());",
                "+      ldifReader.close();",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getPossiblyGZIPCompressedInputStream} with a",
                "+   * {@code null} input stream.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetPossiblyGZIPCompressedInputStreamNullStream()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.getPossiblyGZIPCompressedInputStream(null);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getPossiblyGZIPCompressedInputStream} with an input stream",
                "+   * that is not compressed.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testGetPossiblyGZIPCompressedInputStreamNotCompressed()",
                "+         throws Exception",
                "+  {",
                "+    final File notCompressedFile = createTempFile(\"this is not compressed\");",
                "+",
                "+    final InputStream inputStream =",
                "+         ToolUtils.getPossiblyGZIPCompressedInputStream(",
                "+              new FileInputStream(notCompressedFile));",
                "+    assertNotNull(inputStream);",
                "+",
                "+    final BufferedReader reader =",
                "+         new BufferedReader(new InputStreamReader(inputStream));",
                "+    assertEquals(reader.readLine(), \"this is not compressed\");",
                "+    assertNull(reader.readLine());",
                "+    reader.close();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getPossiblyGZIPCompressedInputStream} with an input stream",
                "+   * that is compressed.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testGetPossiblyGZIPCompressedInputStreamCompressed()",
                "+         throws Exception",
                "+  {",
                "+    final File compressedFile = createTempFile();",
                "+    assertTrue(compressedFile.delete());",
                "+",
                "+    final PrintStream printStream = new PrintStream(new GZIPOutputStream(",
                "+         new FileOutputStream(compressedFile)));",
                "+    printStream.println(\"this is compressed\");",
                "+    printStream.close();",
                "+",
                "+    final InputStream inputStream =",
                "+         ToolUtils.getPossiblyGZIPCompressedInputStream(",
                "+              new FileInputStream(compressedFile));",
                "+    assertNotNull(inputStream);",
                "+",
                "+    final BufferedReader reader =",
                "+         new BufferedReader(new InputStreamReader(inputStream));",
                "+    assertEquals(reader.readLine(), \"this is compressed\");",
                "+    assertNull(reader.readLine());",
                "+    reader.close();",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getPossiblyPassphraseEncryptedInputStream} with a",
                "+   * {@code null} input stream.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetPossiblyPassphraseEncryptedInputStreamNullInputStream()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.getPossiblyPassphraseEncryptedInputStream(null, (char[]) null,",
                "+         false, \"Enter the passphrase\", \"Wrong passphrase\", SUPPRESS_OUTPUT,",
                "+         SUPPRESS_OUTPUT);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getPossiblyPassphraseEncryptedInputStream} with a",
                "+   * {@code null} passphrase prompt.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetPossiblyPassphraseEncryptedInputStreamNullPrompt()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.getPossiblyPassphraseEncryptedInputStream(",
                "+         new ByteArrayInputStream(StaticUtils.NO_BYTES), (char[]) null, false,",
                "+         null, \"Wrong passphrase\", SUPPRESS_OUTPUT, SUPPRESS_OUTPUT);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getPossiblyPassphraseEncryptedInputStream} with an empty",
                "+   * passphrase prompt.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetPossiblyPassphraseEncryptedInputStreamEmptyPrompt()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.getPossiblyPassphraseEncryptedInputStream(",
                "+         new ByteArrayInputStream(StaticUtils.NO_BYTES), (char[]) null, false,",
                "+         \"\", \"Wrong passphrase\", SUPPRESS_OUTPUT, SUPPRESS_OUTPUT);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getPossiblyPassphraseEncryptedInputStream} with a",
                "+   * {@code null} passphrase error.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetPossiblyPassphraseEncryptedInputStreamNullError()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.getPossiblyPassphraseEncryptedInputStream(",
                "+         new ByteArrayInputStream(StaticUtils.NO_BYTES), (char[]) null, false,",
                "+         \"Enter the passphrase\", null, SUPPRESS_OUTPUT, SUPPRESS_OUTPUT);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getPossiblyPassphraseEncryptedInputStream} with an empty",
                "+   * passphrase error.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetPossiblyPassphraseEncryptedInputStreamEmptyError()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.getPossiblyPassphraseEncryptedInputStream(",
                "+         new ByteArrayInputStream(StaticUtils.NO_BYTES), (char[]) null, false,",
                "+         \"Enter the passphrase\", \"\", SUPPRESS_OUTPUT, SUPPRESS_OUTPUT);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getPossiblyPassphraseEncryptedInputStream} with a",
                "+   * {@code null} output stream.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetPossiblyPassphraseEncryptedInputStreamNullOutputStream()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.getPossiblyPassphraseEncryptedInputStream(",
                "+         new ByteArrayInputStream(StaticUtils.NO_BYTES), (char[]) null,",
                "+         false, \"Enter the passphrase\", \"Wrong passphrase\", null,",
                "+         SUPPRESS_OUTPUT);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code getPossiblyPassphraseEncryptedInputStream} with a",
                "+   * {@code null} error stream.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(expectedExceptions = { LDAPSDKUsageException.class })",
                "+  public void testGetPossiblyPassphraseEncryptedInputStreamNullErrorStream()",
                "+         throws Exception",
                "+  {",
                "+    ToolUtils.getPossiblyPassphraseEncryptedInputStream(",
                "+         new ByteArrayInputStream(StaticUtils.NO_BYTES), (char[]) null,",
                "+         false, \"Enter the passphrase\", \"Wrong passphrase\", SUPPRESS_OUTPUT,",
                "+         null);",
                "+  }",
                "+}"
            ],
            "changed_files": [
                "docs/release-notes.html",
                "messages/unboundid-ldapsdk-tools.properties",
                "messages/unboundid-ldapsdk-transformations.properties",
                "messages/unboundid-ldapsdk-util.properties",
                "src/com/unboundid/ldap/sdk/examples/ValidateLDIF.java",
                "src/com/unboundid/ldap/sdk/transformations/TransformLDIF.java",
                "src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                "src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPModify.java",
                "src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearch.java",
                "src/com/unboundid/ldap/sdk/unboundidds/tools/SplitLDIF.java",
                "src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java",
                "src/com/unboundid/ldif/LDIFReader.java",
                "src/com/unboundid/util/AggregateInputStream.java",
                "src/com/unboundid/util/PasswordReader.java",
                "src/com/unboundid/util/StaticUtils.java",
                "tests/unit/src/com/unboundid/ldap/sdk/examples/ValidateLDIFTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/transformations/TransformLDIFTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLogTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPModifyTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearchTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/SplitLDIFTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtilsTestCase.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: UnboundID, SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: src/com/unboundid/ldap/sdk/examples/ValidateLDIF.java, src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java, src/com/unboundid/util/StaticUtils.java, src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearch.java, tests/unit/src/com/unboundid/ldap/sdk/transformations/TransformLDIFTestCase.java, messages/unboundid-ldapsdk-util.properties, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPSearchTestCase.java, messages/unboundid-ldapsdk-transformations.properties, messages/unboundid-ldapsdk-tools.properties, src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPModify.java, src/com/unboundid/util/AggregateInputStream.java, tests/unit/src/com/unboundid/ldap/sdk/examples/ValidateLDIFTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLogTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtilsTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/SplitLDIFTestCase.java, src/com/unboundid/ldif/LDIFReader.java, src/com/unboundid/util/PasswordReader.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/LDAPModifyTestCase.java, src/com/unboundid/ldap/sdk/unboundidds/tools/SplitLDIF.java, src/com/unboundid/ldap/sdk/transformations/TransformLDIF.java, src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: provide, access, apply, user",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid, access, password",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "c61aeb3f795677492ba46360bef41dfeb6326bf0",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1519976200,
            "hunks": 35,
            "message": "Add encryption support to summarize-access-log Updated the summarize-access-log tool to add support for encrypted log files.  The passphrase used to generate the encryption key can be provided interactively or read from a file.",
            "diff": [
                "diff --git a/docs/release-notes.html b/docs/release-notes.html",
                "index 04ecc3a2..849cf620 100644",
                "--- a/docs/release-notes.html",
                "+++ b/docs/release-notes.html",
                "@@ -85,2 +85,9 @@ ${TARGET=\"offline\"}                <br>",
                "+                <li>",
                "+                  Updated the <tt>summarize-access-log</tt> tool to add support for encrypted log",
                "+                  files.  The passphrase used to generate the encryption key can be provided",
                "+                  interactively or read from a file.",
                "+                  <br><br>",
                "+                </li>",
                "+",
                "                 <li>",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java b/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                "index 1fea8141..f4df06d7 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                "@@ -24,4 +24,7 @@ package com.unboundid.ldap.sdk.unboundidds.examples;",
                "+import java.io.BufferedReader;",
                " import java.io.File;",
                " import java.io.FileInputStream;",
                "+import java.io.FileReader;",
                "+import java.io.InputStream;",
                " import java.io.InputStreamReader;",
                "@@ -32,2 +35,3 @@ import java.text.DecimalFormat;",
                " import java.util.ArrayList;",
                "+import java.util.Arrays;",
                " import java.util.HashMap;",
                "@@ -43,2 +47,3 @@ import java.util.zip.GZIPInputStream;",
                " import com.unboundid.ldap.sdk.Filter;",
                "+import com.unboundid.ldap.sdk.LDAPException;",
                " import com.unboundid.ldap.sdk.ResultCode;",
                "@@ -65,4 +70,7 @@ import com.unboundid.ldap.sdk.unboundidds.logs.UnbindRequestAccessLogMessage;",
                " import com.unboundid.util.CommandLineTool;",
                "+import com.unboundid.util.Debug;",
                " import com.unboundid.util.NotMutable;",
                " import com.unboundid.util.ObjectPair;",
                "+import com.unboundid.util.PassphraseEncryptedInputStream;",
                "+import com.unboundid.util.PasswordReader;",
                " import com.unboundid.util.ReverseComparator;",
                "@@ -73,2 +81,3 @@ import com.unboundid.util.args.ArgumentParser;",
                " import com.unboundid.util.args.BooleanArgument;",
                "+import com.unboundid.util.args.FileArgument;",
                "@@ -140,3 +149,3 @@ public final class SummarizeAccessLog",
                "    */",
                "-  private static final long serialVersionUID = -1211445611798245343L;",
                "+  private static final long serialVersionUID = 7189168366509887130L;",
                "@@ -151,2 +160,6 @@ public final class SummarizeAccessLog",
                "+  // Arguments used to specify the encryption passphrase.",
                "+  private BooleanArgument promptForEncryptionPassphrase;",
                "+  private FileArgument    encryptionPassphraseFile;",
                "+",
                "   // The decimal format that will be used for this class.",
                "@@ -537,6 +550,43 @@ public final class SummarizeAccessLog",
                "     // Add an argument that makes it possible to read a compressed log file.",
                "-    final String description = \"Indicates that the log file is compressed..\";",
                "+    String description = \"Indicates that the log file is compressed.\";",
                "     isCompressed = new BooleanArgument('c', \"isCompressed\", description);",
                "     isCompressed.addLongIdentifier(\"is-compressed\", true);",
                "+    isCompressed.addLongIdentifier(\"compressed\", true);",
                "     parser.addArgument(isCompressed);",
                "+",
                "+",
                "+    // Add an argument that indicates that the tool should prompt for an",
                "+    // encryption passphrase.",
                "+    description = \"Indicates that the log file is encrypted and that the \" +",
                "+         \"tool should interactively prompt for the encryption passphrase.\";",
                "+    promptForEncryptionPassphrase = new BooleanArgument(null,",
                "+         \"promptForEncryptionPassphrase\", 1, description);",
                "+    promptForEncryptionPassphrase.addLongIdentifier(",
                "+         \"prompt-for-encryption-passphrase\", true);",
                "+    promptForEncryptionPassphrase.addLongIdentifier(",
                "+         \"promptForEncryptionPassword\", true);",
                "+    promptForEncryptionPassphrase.addLongIdentifier(",
                "+         \"prompt-for-encryption-password\", true);",
                "+    parser.addArgument(promptForEncryptionPassphrase);",
                "+",
                "+",
                "+    // Add an argument that indicates that the tool should read the encryption",
                "+    // passphrase from a file.",
                "+    description = \"Indicates that the log file is encrypted and that the \" +",
                "+         \"encryption passphrase is contained in the specified file.\";",
                "+    encryptionPassphraseFile = new FileArgument(null,",
                "+         \"encryptionPassphraseFile\", false, 1, null, description, true, true,",
                "+         true, false);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryption-passphrase-file\",",
                "+         true);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryptionPasswordFile\", true);",
                "+    encryptionPassphraseFile.addLongIdentifier(\"encryption-password-file\",",
                "+         true);",
                "+    parser.addArgument(encryptionPassphraseFile);",
                "+",
                "+",
                "+     // Ensure that the --promptForEncryptionPassphrase and",
                "+    // --encryptionPassphraseFile arguments cannot be used together.",
                "+    parser.addExclusiveArgumentSet(promptForEncryptionPassphrase,",
                "+         encryptionPassphraseFile);",
                "   }",
                "@@ -578,2 +628,66 @@ public final class SummarizeAccessLog",
                "   {",
                "+    String encryptionPassphrase = null;",
                "+    if (promptForEncryptionPassphrase.isPresent())",
                "+    {",
                "+      while (true)",
                "+      {",
                "+        getOut().print(\"Enter the encryption passphrase: \");",
                "+",
                "+        final char[] pwChars;",
                "+        try",
                "+        {",
                "+          pwChars = PasswordReader.readPasswordChars();",
                "+        }",
                "+        catch (final LDAPException le)",
                "+        {",
                "+          Debug.debugException(le);",
                "+          err(\"Unable to read the encryption passphrase entered at the \" +",
                "+               \"prompt:  \" + getExceptionMessage(le));",
                "+          return le.getResultCode();",
                "+        }",
                "+",
                "+        if ((pwChars == null) || (pwChars.length == 0))",
                "+        {",
                "+          err();",
                "+          err(\"The encryption passphrase must not be empty.\");",
                "+          err();",
                "+          continue;",
                "+        }",
                "+",
                "+        encryptionPassphrase = new String(pwChars);",
                "+        Arrays.fill(pwChars, '\\u0000');",
                "+        break;",
                "+      }",
                "+    }",
                "+    else if (encryptionPassphraseFile.isPresent())",
                "+    {",
                "+      try (FileReader fileReader =",
                "+                new FileReader(encryptionPassphraseFile.getValue());",
                "+           BufferedReader bufferedReader = new BufferedReader(fileReader))",
                "+      {",
                "+        encryptionPassphrase = bufferedReader.readLine();",
                "+        if (encryptionPassphrase == null)",
                "+        {",
                "+          err(\"The encryption passphrase file is empty.\");",
                "+          return ResultCode.PARAM_ERROR;",
                "+        }",
                "+        else if (bufferedReader.readLine() != null)",
                "+        {",
                "+          err(\"The encryption passphrase file has multiple lines  It must \" +",
                "+               \"contain exactly one line.\");",
                "+          return ResultCode.PARAM_ERROR;",
                "+        }",
                "+        else if (encryptionPassphrase.isEmpty())",
                "+        {",
                "+          err(\"The encryption passphrase is empty.\");",
                "+          return ResultCode.PARAM_ERROR;",
                "+        }",
                "+      }",
                "+      catch (final Exception e)",
                "+      {",
                "+        Debug.debugException(e);",
                "+      }",
                "+    }",
                "+",
                "+",
                "     long logLines = 0L;",
                "@@ -583,21 +697,42 @@ public final class SummarizeAccessLog",
                "       out(\"Examining access log \", f.getAbsolutePath());",
                "-      final AccessLogReader reader;",
                "+      AccessLogReader reader = null;",
                "+      InputStream inputStream = null;",
                "       try",
                "       {",
                "-        if (isCompressed.isPresent())",
                "+        inputStream = new FileInputStream(f);",
                "+",
                "+        if (encryptionPassphrase != null)",
                "         {",
                "-          reader = new AccessLogReader(new InputStreamReader(",
                "-               new GZIPInputStream(new FileInputStream(f))));",
                "+          inputStream = new PassphraseEncryptedInputStream(",
                "+               encryptionPassphrase, inputStream);",
                "         }",
                "-        else",
                "+",
                "+        if (isCompressed.isPresent())",
                "         {",
                "-          reader = new AccessLogReader(f);",
                "+          inputStream = new GZIPInputStream(inputStream);",
                "         }",
                "+",
                "+        reader = new AccessLogReader(new InputStreamReader(inputStream));",
                "       }",
                "-      catch (final IOException ioe)",
                "+      catch (final Exception e)",
                "       {",
                "+        Debug.debugException(e);",
                "         err(\"Unable to open access log file \", f.getAbsolutePath(), \":  \",",
                "-            getExceptionMessage(ioe));",
                "+            getExceptionMessage(e));",
                "         return ResultCode.LOCAL_ERROR;",
                "       }",
                "+      finally",
                "+      {",
                "+        if ((reader == null) && (inputStream != null))",
                "+        {",
                "+          try",
                "+          {",
                "+            inputStream.close();",
                "+          }",
                "+          catch (final Exception e)",
                "+          {",
                "+            Debug.debugException(e);",
                "+          }",
                "+        }",
                "+      }",
                "@@ -615,2 +750,3 @@ public final class SummarizeAccessLog",
                "         {",
                "+          Debug.debugException(ioe);",
                "           err(\"Error reading from access log file \", f.getAbsolutePath(),",
                "@@ -621,2 +757,3 @@ public final class SummarizeAccessLog",
                "         {",
                "+          Debug.debugException(le);",
                "           err(\"Encountered an error while attempting to parse a line in\" +",
                "@@ -710,3 +847,7 @@ public final class SummarizeAccessLog",
                "         reader.close();",
                "-      } catch (final Exception e) {}",
                "+      }",
                "+      catch (final Exception e)",
                "+      {",
                "+        Debug.debugException(e);",
                "+      }",
                "       logDurationMillis += (stopTime - startTime);",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLogTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLogTestCase.java",
                "index ae5be95c..a007a1f3 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLogTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLogTestCase.java",
                "@@ -24,4 +24,7 @@ package com.unboundid.ldap.sdk.unboundidds.examples;",
                "+import java.io.BufferedReader;",
                "+import java.io.ByteArrayInputStream;",
                " import java.io.File;",
                " import java.io.FileOutputStream;",
                "+import java.io.InputStreamReader;",
                " import java.io.PrintStream;",
                "@@ -38,2 +41,6 @@ import com.unboundid.ldap.sdk.LDAPSDKTestCase;",
                " import com.unboundid.ldap.sdk.ResultCode;",
                "+import com.unboundid.util.ByteStringBuffer;",
                "+import com.unboundid.util.PassphraseEncryptedOutputStream;",
                "+import com.unboundid.util.PasswordReader;",
                "+import com.unboundid.util.StaticUtils;",
                "@@ -53,2 +60,3 @@ public class SummarizeAccessLogTestCase",
                "   private File compressedFile;",
                "+  private File encryptedFile;",
                "@@ -428,9 +436,28 @@ public class SummarizeAccessLogTestCase",
                "     compressedFile = createTempFile();",
                "-    final PrintStream ps = new PrintStream(new GZIPOutputStream(",
                "-         new FileOutputStream(compressedFile)));",
                "-    for (final String s : lines)",
                "+    try (final FileOutputStream fileOutputStream =",
                "+              new FileOutputStream(compressedFile);",
                "+         final GZIPOutputStream gzipOutputStream =",
                "+              new GZIPOutputStream(fileOutputStream);",
                "+         final PrintStream printStream = new PrintStream(gzipOutputStream))",
                "     {",
                "-      ps.println(s);",
                "+      for (final String s : lines)",
                "+      {",
                "+        printStream.println(s);",
                "+      }",
                "+    }",
                "+",
                "+    encryptedFile = createTempFile();",
                "+    try (final FileOutputStream fileOutputStream =",
                "+              new FileOutputStream(encryptedFile);",
                "+         final PassphraseEncryptedOutputStream encryptedOutputStream =",
                "+              new PassphraseEncryptedOutputStream(\"password\", fileOutputStream);",
                "+         final GZIPOutputStream gzipOutputStream =",
                "+              new GZIPOutputStream(encryptedOutputStream);",
                "+         final PrintStream printStream = new PrintStream(gzipOutputStream))",
                "+    {",
                "+      for (final String s : lines)",
                "+      {",
                "+        printStream.println(s);",
                "+      }",
                "     }",
                "-    ps.close();",
                "   }",
                "@@ -544,2 +571,218 @@ public class SummarizeAccessLogTestCase",
                "+  /**",
                "+   * Provides test coverage for the summarize-access-log tool with an encrypted",
                "+   * file when the correct encryption passphrase is entered via an interactive",
                "+   * prompt.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testEncryptedFileWithPromptCorrect()",
                "+         throws Exception",
                "+  {",
                "+    final String[] args =",
                "+    {",
                "+      \"--isCompressed\",",
                "+      \"--promptForEncryptionPassphrase\",",
                "+      encryptedFile.getAbsolutePath()",
                "+    };",
                "+",
                "+    final ByteStringBuffer buffer = new ByteStringBuffer();",
                "+    buffer.append(StaticUtils.EOL_BYTES);",
                "+    buffer.append(\"password\");",
                "+    buffer.append(StaticUtils.EOL_BYTES);",
                "+",
                "+    final ByteArrayInputStream in =",
                "+         new ByteArrayInputStream(buffer.toByteArray());",
                "+    final BufferedReader passwordReader =",
                "+         new BufferedReader(new InputStreamReader(in));",
                "+",
                "+    try",
                "+    {",
                "+      PasswordReader.setTestReader(passwordReader);",
                "+",
                "+      final ResultCode rc = SummarizeAccessLog.main(args, null, null);",
                "+      assertEquals(rc, ResultCode.SUCCESS);",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Provides test coverage for the summarize-access-log tool with an encrypted",
                "+   * file when an incorrect encryption passphrase is entered via an interactive",
                "+   * prompt.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testEncryptedFileWithPromptWrongPassphrase()",
                "+         throws Exception",
                "+  {",
                "+    final String[] args =",
                "+    {",
                "+      \"--isCompressed\",",
                "+      \"--promptForEncryptionPassphrase\",",
                "+      encryptedFile.getAbsolutePath()",
                "+    };",
                "+",
                "+    final ByteStringBuffer buffer = new ByteStringBuffer();",
                "+    buffer.append(StaticUtils.EOL_BYTES);",
                "+    buffer.append(\"wrong\");",
                "+    buffer.append(StaticUtils.EOL_BYTES);",
                "+",
                "+    final ByteArrayInputStream in =",
                "+         new ByteArrayInputStream(buffer.toByteArray());",
                "+    final BufferedReader passwordReader =",
                "+         new BufferedReader(new InputStreamReader(in));",
                "+",
                "+    try",
                "+    {",
                "+      PasswordReader.setTestReader(passwordReader);",
                "+",
                "+      final ResultCode rc = SummarizeAccessLog.main(args, null, null);",
                "+      assertFalse(rc == ResultCode.SUCCESS);",
                "+    }",
                "+    finally",
                "+    {",
                "+      PasswordReader.setTestReader(null);",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Provides test coverage for the summarize-access-log tool with an encrypted",
                "+   * file when the correct encryption passphrase is provided in a valid file.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testEncryptedFileWithValidFile()",
                "+         throws Exception",
                "+  {",
                "+    final File passphraseFile = createTempFile(\"password\");",
                "+",
                "+    final String[] args =",
                "+    {",
                "+      \"--isCompressed\",",
                "+      \"--encryptionPassphraseFile\", passphraseFile.getAbsolutePath(),",
                "+      encryptedFile.getAbsolutePath()",
                "+    };",
                "+",
                "+    final ResultCode rc = SummarizeAccessLog.main(args, null, null);",
                "+    assertEquals(rc, ResultCode.SUCCESS);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Provides test coverage for the summarize-access-log tool with an encrypted",
                "+   * file when the wrong encryption passphrase is provided in an otherwise-valid",
                "+   * file.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testEncryptedFileWithFileContainingWrongPassword()",
                "+         throws Exception",
                "+  {",
                "+    final File passphraseFile = createTempFile(\"wrong\");",
                "+",
                "+    final String[] args =",
                "+    {",
                "+      \"--isCompressed\",",
                "+      \"--encryptionPassphraseFile\", passphraseFile.getAbsolutePath(),",
                "+      encryptedFile.getAbsolutePath()",
                "+    };",
                "+",
                "+    final ResultCode rc = SummarizeAccessLog.main(args, null, null);",
                "+    assertFalse(rc == ResultCode.SUCCESS);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Provides test coverage for the summarize-access-log tool with an encrypted",
                "+   * file when the encryption passphrase is provided in an empty file.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testEncryptedFileWithEmptyFile()",
                "+         throws Exception",
                "+  {",
                "+    final File emptyFile = createTempFile();",
                "+",
                "+    final String[] args =",
                "+    {",
                "+      \"--isCompressed\",",
                "+      \"--encryptionPassphraseFile\", emptyFile.getAbsolutePath(),",
                "+      encryptedFile.getAbsolutePath()",
                "+    };",
                "+",
                "+    final ResultCode rc = SummarizeAccessLog.main(args, null, null);",
                "+    assertEquals(rc, ResultCode.PARAM_ERROR);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Provides test coverage for the summarize-access-log tool with an encrypted",
                "+   * file when the encryption passphrase is provided in a file that contains",
                "+   * multiple lines.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testEncryptedFileWithMultiLineFile()",
                "+         throws Exception",
                "+  {",
                "+    final File multiLineFile = createTempFile(",
                "+         \"password\",",
                "+         \"password\");",
                "+",
                "+    final String[] args =",
                "+    {",
                "+      \"--isCompressed\",",
                "+      \"--encryptionPassphraseFile\", multiLineFile.getAbsolutePath(),",
                "+      encryptedFile.getAbsolutePath()",
                "+    };",
                "+",
                "+    final ResultCode rc = SummarizeAccessLog.main(args, null, null);",
                "+    assertEquals(rc, ResultCode.PARAM_ERROR);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Provides test coverage for the summarize-access-log tool with an encrypted",
                "+   * file when the encryption passphrase is provided in a file that contains",
                "+   * only a single blank line.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testEncryptedFileWithSingleBlankLine()",
                "+         throws Exception",
                "+  {",
                "+    final File fileWithSingleBlankLine = createTempFile(\"\");",
                "+",
                "+    final String[] args =",
                "+    {",
                "+      \"--isCompressed\",",
                "+      \"--encryptionPassphraseFile\", fileWithSingleBlankLine.getAbsolutePath(),",
                "+      encryptedFile.getAbsolutePath()",
                "+    };",
                "+",
                "+    final ResultCode rc = SummarizeAccessLog.main(args, null, null);",
                "+    assertEquals(rc, ResultCode.PARAM_ERROR);",
                "+  }",
                "+",
                "+",
                "+",
                "   /**"
            ],
            "changed_files": [
                "docs/release-notes.html",
                "src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLogTestCase.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: tests/unit/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLogTestCase.java, src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: provide, access",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid, access",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "8c77d1efea2f9de611b71e935e02efaeee207050",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1520890805,
            "hunks": 120,
            "message": "Make a number of format string fixes Fixed a number of cases in which the arguments provided to a message format string did not align with the arguments expected for that string.  This includes: * Attempts to format messages with too few arguments * Attempts to format messages with a non-numeric argument when a   numeric argument was expected * Cases in which single quotation marks were silently dropped   because of a quirk in the way that Java sometimes handles them in   format strings The build process and unit test framework has been updated to help catch these kinds of problems in the future.",
            "diff": [
                "diff --git a/build-src/messages/com/unboundid/buildtools/messages/GenerateMessages.java b/build-src/messages/com/unboundid/buildtools/messages/GenerateMessages.java",
                "index 7552e4bc..06d67c29 100644",
                "--- a/build-src/messages/com/unboundid/buildtools/messages/GenerateMessages.java",
                "+++ b/build-src/messages/com/unboundid/buildtools/messages/GenerateMessages.java",
                "@@ -353,2 +353,22 @@ public class GenerateMessages",
                "         w(\"  /**\");",
                "+        w(\"   * The name of the properties file containing the default\");",
                "+        w(\"   * message strings.\");",
                "+        w(\"   */\");",
                "+        w(\"  static final String PROPERTIES_FILE_NAME =\");",
                "+        w(\"       \\\"\" + propertiesFileName + \"\\\";\");",
                "+        w();",
                "+        w();",
                "+        w();",
                "+        w(\"  /**\");",
                "+        w(\"   * Indicates whether the unit tests are currently running.\");",
                "+        w(\"   */\");",
                "+        w(\"  private static final boolean IS_WITHIN_UNIT_TESTS =\");",
                "+        w(\"       Boolean.getBoolean(\" +",
                "+             \"\\\"com.unboundid.ldap.sdk.RunningUnitTests\\\") ||\");",
                "+        w(\"       Boolean.getBoolean(\" +",
                "+             \"\\\"com.unboundid.directory.server.RunningUnitTests\\\");\");",
                "+        w();",
                "+        w();",
                "+        w();",
                "+        w(\"  /**\");",
                "         w(\"   * The resource bundle that will be used to load the properties \",",
                "@@ -428,3 +448,3 @@ public class GenerateMessages",
                "         w(\"      {\");",
                "-        w(\"        return defaultText;\");",
                "+        w(\"        s = defaultText;\");",
                "         w(\"      }\");",
                "@@ -443,2 +463,21 @@ public class GenerateMessages",
                "         w(\"    }\");",
                "+        w();",
                "+        w(\"    if (IS_WITHIN_UNIT_TESTS &&\");",
                "+        w(\"        (s.contains(\\\"{0}\\\") || s.contains(\\\"{0,number,0}\\\") ||\");",
                "+        w(\"         s.contains(\\\"{1}\\\") || s.contains(\\\"{1,number,0}\\\") ||\");",
                "+        w(\"         s.contains(\\\"{2}\\\") || s.contains(\\\"{2,number,0}\\\") ||\");",
                "+        w(\"         s.contains(\\\"{3}\\\") || s.contains(\\\"{3,number,0}\\\") ||\");",
                "+        w(\"         s.contains(\\\"{4}\\\") || s.contains(\\\"{4,number,0}\\\") ||\");",
                "+        w(\"         s.contains(\\\"{5}\\\") || s.contains(\\\"{5,number,0}\\\") ||\");",
                "+        w(\"         s.contains(\\\"{6}\\\") || s.contains(\\\"{6,number,0}\\\") ||\");",
                "+        w(\"         s.contains(\\\"{7}\\\") || s.contains(\\\"{7,number,0}\\\") ||\");",
                "+        w(\"         s.contains(\\\"{8}\\\") || s.contains(\\\"{8,number,0}\\\") ||\");",
                "+        w(\"         s.contains(\\\"{9}\\\") || s.contains(\\\"{9,number,0}\\\") ||\");",
                "+        w(\"         s.contains(\\\"{10}\\\") ||  s.contains(\\\"{10,number,0}\\\")))\");",
                "+        w(\"    {\");",
                "+        w(\"         throw new IllegalArgumentException(\");",
                "+        w(\"              \\\"Message \\\" + getClass().getName() + '.' + name() +\");",
                "+        w(\"                   \\\" contains an un-replaced token:  \\\" + s);\");",
                "+        w(\"    }\");",
                "+        w();",
                "         w(\"    return s;\");",
                "@@ -482,6 +521,40 @@ public class GenerateMessages",
                "         w(\"    }\");",
                "+        w();",
                "+        w(\"    final String formattedMessage;\");",
                "         w(\"    synchronized (f)\");",
                "         w(\"    {\");",
                "-        w(\"      return f.format(args);\");",
                "+        w(\"      formattedMessage = f.format(args);\");",
                "         w(\"    }\");",
                "+        w();",
                "+        w(\"    if (IS_WITHIN_UNIT_TESTS &&\");",
                "+        w(\"        (formattedMessage.contains(\\\"{0}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{0,number,01}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{1}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{1,number,0}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{2}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{2,number,0}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{3}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{3,number,0}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{4}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{4,number,0}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{5}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{5,number,0}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{6}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{6,number,0}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{7}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{7,number,0}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{8}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{8,number,0}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{9}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{9,number,0}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{10}\\\") ||\");",
                "+        w(\"         formattedMessage.contains(\\\"{10,number,0}\\\")))\");",
                "+        w(\"    {\");",
                "+        w(\"         throw new IllegalArgumentException(\");",
                "+        w(\"              \\\"Message \\\" + getClass().getName() + '.' + name() +\");",
                "+        w(\"                   \\\" contains an un-replaced token:  \\\" +\" +",
                "+             \" formattedMessage);\");",
                "+        w(\"    }\");",
                "+        w();",
                "+        w(\"    return f.format(args);\");",
                "         w(\"  }\");",
                "@@ -501,3 +574,24 @@ public class GenerateMessages",
                "         w(\"  {\");",
                "-        w(\"    return get();\");",
                "+        w(\"    String s = MESSAGE_STRINGS.get(this);\");",
                "+        w(\"    if (s == null)\");",
                "+        w(\"    {\");",
                "+        w(\"      if (RESOURCE_BUNDLE == null)\");",
                "+        w(\"      {\");",
                "+        w(\"        s = defaultText;\");",
                "+        w(\"      }\");",
                "+        w(\"      else\");",
                "+        w(\"      {\");",
                "+        w(\"        try\");",
                "+        w(\"        {\");",
                "+        w(\"          s = RESOURCE_BUNDLE.getString(name());\");",
                "+        w(\"        }\");",
                "+        w(\"        catch (final Exception e)\");",
                "+        w(\"        {\");",
                "+        w(\"          s = defaultText;\");",
                "+        w(\"        }\");",
                "+        w(\"        MESSAGE_STRINGS.putIfAbsent(this, s);\");",
                "+        w(\"      }\");",
                "+        w(\"    }\");",
                "+        w();",
                "+        w(\"    return s;\");",
                "         w(\"  }\");",
                "diff --git a/build.xml b/build.xml",
                "index f29bbe73..6b88a913 100644",
                "--- a/build.xml",
                "+++ b/build.xml",
                "@@ -831,2 +831,3 @@",
                "       <jvmarg value=\"-Demma.coverage.out.merge=false\" />",
                "+      <jvmarg value=\"-Dcom.unboundid.ldap.sdk.RunningUnitTests=true\" />",
                "       <jvmarg value=\"-Dbasedir=${basedir}\" />",
                "diff --git a/docs/release-notes.html b/docs/release-notes.html",
                "index 33861126..81f0d251 100644",
                "--- a/docs/release-notes.html",
                "+++ b/docs/release-notes.html",
                "@@ -125,2 +125,9 @@ ${TARGET=\"offline\"}                <br>",
                "                 </li>",
                "+",
                "+                <li>",
                "+                  Fixed a number of cases in which there was a mismatch between the arguments",
                "+                  provided to a message format string and the arguments expected by that format",
                "+                  string.  Unit tests have been added to help prevent this from recurring.",
                "+                  <br><br>",
                "+                </li>",
                "               </ul>",
                "diff --git a/messages/unboundid-ldapsdk-asn1.properties b/messages/unboundid-ldapsdk-asn1.properties",
                "index 001d46cd..03d16c75 100644",
                "--- a/messages/unboundid-ldapsdk-asn1.properties",
                "+++ b/messages/unboundid-ldapsdk-asn1.properties",
                "@@ -183,3 +183,3 @@ ERR_PRINTABLE_STRING_DECODE_VALUE_NOT_PRINTABLE=Unable to create an ASN.1 \\",
                "   printable string may contain ASCII characters from the following set:  all \\",
                "-  uppercase and lowercase letters, all digits, space, apostophe, open and \\",
                "+  uppercase and lowercase letters, all digits, space, apostrophe, open and \\",
                "   close parentheses, plus sign, minus sign, comma, period, forward slash, \\",
                "diff --git a/messages/unboundid-ldapsdk-cert.properties b/messages/unboundid-ldapsdk-cert.properties",
                "index 453a7a8a..ce72e55c 100644",
                "--- a/messages/unboundid-ldapsdk-cert.properties",
                "+++ b/messages/unboundid-ldapsdk-cert.properties",
                "@@ -126,3 +126,4 @@ ERR_CERT_VERIFY_SIGNATURE_CANNOT_GET_SIGNATURE_VERIFIER=Unable verify the \\",
                " ERR_CERT_VERIFY_SIGNATURE_CANNOT_INIT_SIGNATURE_VERIFIER=Unable to initialize \\",
                "-  the ''{0}'' signature verifier with the issuer certificate's public key:  {1}",
                "+  the ''{0}'' signature verifier with the issuer certificate''s public key:  \\",
                "+  {1}",
                " ERR_CERT_VERIFY_SIGNATURE_NOT_VALID=ERROR:  Certificate ''{0}'' has an \\",
                "@@ -190,3 +191,3 @@ ERR_CSR_VERIFY_SIGNATURE_CANNOT_GET_PUBLIC_KEY=Unable to verify the \\",
                "   certificate signing request signature because an error occurred while \\",
                "-  attempting to parse the request's public key:  {0}",
                "+  attempting to parse the request''s public key:  {0}",
                " ERR_CSR_VERIFY_SIGNATURE_CANNOT_GET_SIGNATURE_VERIFIER=Unable to verify the \\",
                "@@ -197,3 +198,3 @@ ERR_CSR_VERIFY_SIGNATURE_CANNOT_INIT_SIGNATURE_VERIFIER=Unable to verify the \\",
                "   certificate signing request signature because an error occurred while \\",
                "-  attempting to initialize the ''{0}'' signature verifier with the request's \\",
                "+  attempting to initialize the ''{0}'' signature verifier with the request''s \\",
                "   public key:  {1}",
                "@@ -763,5 +764,5 @@ INFO_MANAGE_CERTS_SC_GEN_CERT_ARG_DAYS_VALID_DESC=The number of days that \\",
                " INFO_MANAGE_CERTS_SC_GEN_CERT_ARG_VALIDITY_START_TIME_DESC=The time that the \\",
                "-  certificate's validity window should start (that is, the 'notBefore' \\",
                "+  certificate''s validity window should start (that is, the ''notBefore'' \\",
                "   value).  If this is not provided, then the current time will be used.  If a \\",
                "-  value is given, it should be in the form 'YYYYMMDDhhmmss' (for example, \\",
                "+  value is given, it should be in the form ''YYYYMMDDhhmmss'' (for example, \\",
                "   ''{0}'').  Timestamp values are assumed to be in the local time zone.",
                "@@ -1207,6 +1208,7 @@ INFO_MANAGE_CERTS_SC_SIGN_CSR_ARG_DAYS_VALID_DESC=The number of days that \\",
                " INFO_MANAGE_CERTS_SC_SIGN_CSR_ARG_VALIDITY_START_TIME_DESC=The time that the \\",
                "-  signed certificate's validity window should start (that is, the 'notBefore' \\",
                "-  value).  If this is not provided, then the current time will be used.  If a \\",
                "-  value is given, it should be in the form 'YYYYMMDDhhmmss' (for example, \\",
                "-  ''{0}'').  Timestamp values are assumed to be in the local time zone.",
                "+  signed certificate''s validity window should start (that is, the \\",
                "+  ''notBefore'' value).  If this is not provided, then the current time will \\",
                "+  be used.  If a value is given, it should be in the form ''YYYYMMDDhhmmss'' \\",
                "+  (for example, ''{0}'').  Timestamp values are assumed to be in the local \\",
                "+  time zone.",
                " INFO_MANAGE_CERTS_SC_SIGN_CSR_ARG_SIG_ALG_DESC=The name of the algorithm to \\",
                "@@ -1596,7 +1598,7 @@ INFO_MANAGE_CERTS_SC_TRUST_SERVER_ARG_VERBOSE_DESC=Display verbose \\",
                " INFO_MANAGE_CERTS_SC_TRUST_SERVER_EXAMPLE_1=Establishes a secure connection \\",
                "-  to the server ds.example.com on port 636 and adds that server's certificate \\",
                "-  chain to the ''{0}'' keystore with a base alias of 'ds.example.com:636'.  \\",
                "-  The tool will display verbose information about the certificate chain \\",
                "-  presented by the server, and will interactively prompt about whether to \\",
                "-  trust that chain.",
                "+  to the server ds.example.com on port 636 and adds that server''s \\",
                "+  certificate chain to the ''{0}'' keystore with a base alias of \\",
                "+  ''ds.example.com:636''.  The tool will display verbose information about \\",
                "+  the certificate chain presented by the server, and will interactively \\",
                "+  prompt about whether to trust that chain.",
                " INFO_MANAGE_CERTS_SC_TRUST_SERVER_EXAMPLE_2=Establishes a non-secure \\",
                "@@ -1604,5 +1606,5 @@ INFO_MANAGE_CERTS_SC_TRUST_SERVER_EXAMPLE_2=Establishes a non-secure \\",
                "   extended operation to transition to a secure connection.  It will then add \\",
                "-  the server's issuer certificates to the ''{0}'' keystore with a base alias \\",
                "-  of 'ds-start-tls-cert'.  The tool will trust the certificate chain without \\",
                "-  any confirmation from the user.",
                "+  the server''s issuer certificates to the ''{0}'' keystore with a base alias \\",
                "+  of ''ds-start-tls-cert''.  The tool will trust the certificate chain \\",
                "+  without any confirmation from the user.",
                " INFO_MANAGE_CERTS_SC_CHECK_USABILITY_DESC=Examines a keystore to determine \\",
                "diff --git a/messages/unboundid-ldapsdk-json.properties b/messages/unboundid-ldapsdk-json.properties",
                "index 18ed82ee..1a0b6480 100644",
                "--- a/messages/unboundid-ldapsdk-json.properties",
                "+++ b/messages/unboundid-ldapsdk-json.properties",
                "@@ -194,3 +194,3 @@ ERR_OBJECT_READER_INVALID_UTF_8_BYTE_IN_STREAM=Invalid data read from the \\",
                "   input stream {0,number,0} bytes into the JSON object:  non-ASCII byte \\",
                "-  ''{0}'' encountered in the middle of a JSON string is not a valid first \\",
                "+  ''{1}'' encountered in the middle of a JSON string is not a valid first \\",
                "   byte for a multi-byte UTF-8 character.",
                "diff --git a/messages/unboundid-ldapsdk-listener.properties b/messages/unboundid-ldapsdk-listener.properties",
                "index 31948522..db8fc362 100644",
                "--- a/messages/unboundid-ldapsdk-listener.properties",
                "+++ b/messages/unboundid-ldapsdk-listener.properties",
                "@@ -48,5 +48,5 @@ ERR_MEM_HANDLER_NULL_BASE_DN=Unable to use the null DN as a base DN for the \\",
                "   in-memory request handler.",
                "-ERR_MEM_HANDLER_CHANGELOG_BASE_DN=Unable to use the ''{0}'' as a base DN for \\",
                "-  the in-memory request handler because it conflicts with the base DN used \\",
                "-  for changelog entries.",
                "+ERR_MEM_HANDLER_CHANGELOG_BASE_DN=Unable to use ''{0}'' as a base DN for the \\",
                "+  in-memory request handler because it conflicts with the base DN used for \\",
                "+  changelog entries.",
                " ERR_MEM_HANDLER_SCHEMA_BASE_DN=Unable to use a DN at or below the subschema \\",
                "diff --git a/src/com/unboundid/ldap/listener/InMemoryRequestHandler.java b/src/com/unboundid/ldap/listener/InMemoryRequestHandler.java",
                "index 13bebd18..7e187e7e 100644",
                "--- a/src/com/unboundid/ldap/listener/InMemoryRequestHandler.java",
                "+++ b/src/com/unboundid/ldap/listener/InMemoryRequestHandler.java",
                "@@ -317,3 +317,3 @@ public final class InMemoryRequestHandler",
                "       throw new LDAPException(ResultCode.PARAM_ERROR,",
                "-           ERR_MEM_HANDLER_CHANGELOG_BASE_DN.get());",
                "+           ERR_MEM_HANDLER_CHANGELOG_BASE_DN.get(changeLogBaseDN));",
                "     }",
                "@@ -439,3 +439,3 @@ public final class InMemoryRequestHandler",
                "       throw new LDAPException(ResultCode.PARAM_ERROR,",
                "-           ERR_MEM_HANDLER_SCHEMA_BASE_DN.get());",
                "+           ERR_MEM_HANDLER_SCHEMA_BASE_DN.get(subschemaSubentryDN));",
                "     }",
                "diff --git a/src/com/unboundid/ldap/matchingrules/IntegerMatchingRule.java b/src/com/unboundid/ldap/matchingrules/IntegerMatchingRule.java",
                "index bbf2a843..b68eaa64 100644",
                "--- a/src/com/unboundid/ldap/matchingrules/IntegerMatchingRule.java",
                "+++ b/src/com/unboundid/ldap/matchingrules/IntegerMatchingRule.java",
                "@@ -379,3 +379,3 @@ public final class IntegerMatchingRule",
                "               throw new LDAPException(ResultCode.INVALID_ATTRIBUTE_SYNTAX,",
                "-                                      ERR_INTEGER_INVALID_CHARACTER.get());",
                "+                   ERR_INTEGER_INVALID_CHARACTER.get(i));",
                "             }",
                "@@ -428,3 +428,3 @@ public final class IntegerMatchingRule",
                "             throw new LDAPException(ResultCode.INVALID_ATTRIBUTE_SYNTAX,",
                "-                                    ERR_INTEGER_INVALID_CHARACTER.get());",
                "+                 ERR_INTEGER_INVALID_CHARACTER.get(i));",
                "           }",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JSONObjectFilter.java b/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JSONObjectFilter.java",
                "index edd13648..fe828aa5 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JSONObjectFilter.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JSONObjectFilter.java",
                "@@ -929,2 +929,46 @@ public abstract class JSONObjectFilter",
                "+  /**",
                "+   * Creates a string representation of the provided field path.  The path will",
                "+   * be constructed by using the JSON value representations of the field paths",
                "+   * (with each path element surrounded by quotation marks and including any",
                "+   * appropriate escaping) and using the period as a delimiter between each",
                "+   * path element.",
                "+   *",
                "+   * @param  fieldPath  The field path to process.",
                "+   *",
                "+   * @return  A string representation of the provided field path.",
                "+   */",
                "+  static String fieldPathToName(final List<String> fieldPath)",
                "+  {",
                "+    if (fieldPath == null)",
                "+    {",
                "+      return \"null\";",
                "+    }",
                "+    else if (fieldPath.isEmpty())",
                "+    {",
                "+      return \"\";",
                "+    }",
                "+    else if (fieldPath.size() == 1)",
                "+    {",
                "+      return new JSONString(fieldPath.get(0)).toString();",
                "+    }",
                "+    else",
                "+    {",
                "+      final StringBuilder buffer = new StringBuilder();",
                "+      for (final String pathElement : fieldPath)",
                "+      {",
                "+        if (buffer.length() > 0)",
                "+        {",
                "+          buffer.append('.');",
                "+        }",
                "+",
                "+        new JSONString(pathElement).toString(buffer);",
                "+      }",
                "+",
                "+      return buffer.toString();",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/RegularExpressionJSONObjectFilter.java b/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/RegularExpressionJSONObjectFilter.java",
                "index 4a33c742..e75dffa6 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/RegularExpressionJSONObjectFilter.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/RegularExpressionJSONObjectFilter.java",
                "@@ -639,3 +639,3 @@ public final class RegularExpressionJSONObjectFilter",
                "                 String.valueOf(filterObject), FIELD_REGULAR_EXPRESSION,",
                "-                StaticUtils.getExceptionMessage(e)),",
                "+                fieldPathToName(fieldPath), StaticUtils.getExceptionMessage(e)),",
                "            e);",
                "diff --git a/src/com/unboundid/util/StaticUtils.java b/src/com/unboundid/util/StaticUtils.java",
                "index ec678909..8ad619e2 100644",
                "--- a/src/com/unboundid/util/StaticUtils.java",
                "+++ b/src/com/unboundid/util/StaticUtils.java",
                "@@ -103,2 +103,11 @@ public final class StaticUtils",
                "+  /**",
                "+   * Indicates whether the unit tests are currently running.",
                "+   */",
                "+  private static final boolean IS_WITHIN_UNIT_TESTS =",
                "+       Boolean.getBoolean(\"com.unboundid.ldap.sdk.RunningUnitTests\") ||",
                "+       Boolean.getBoolean(\"com.unboundid.directory.server.RunningUnitTests\");",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -3074,2 +3083,16 @@ public final class StaticUtils",
                "   }",
                "+",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Indicates whether the unit tests are currently running in this JVM.",
                "+   *",
                "+   * @return  {@code true} if the unit tests are currently running, or",
                "+   *          {@code false} if not.",
                "+   */",
                "+  public static boolean isWithinUnitTest()",
                "+  {",
                "+    return IS_WITHIN_UNIT_TESTS;",
                "+  }",
                " }",
                "diff --git a/src/com/unboundid/util/json/JSONObjectReader.java b/src/com/unboundid/util/json/JSONObjectReader.java",
                "index 29df4bd3..5cba49d4 100644",
                "--- a/src/com/unboundid/util/json/JSONObjectReader.java",
                "+++ b/src/com/unboundid/util/json/JSONObjectReader.java",
                "@@ -537,3 +537,3 @@ public final class JSONObjectReader",
                "       {",
                "-        throw new JSONException(ERR_OBJECT_UNESCAPED_CONTROL_CHAR.get(",
                "+        throw new JSONException(ERR_OBJECT_READER_UNESCAPED_CONTROL_CHAR.get(",
                "              currentObjectBytes.length(), byteToCharString(byteRead)));",
                "diff --git a/src/com/unboundid/util/json/SecurityOptions.java b/src/com/unboundid/util/json/SecurityOptions.java",
                "index 03b2a17d..4d3b6d18 100644",
                "--- a/src/com/unboundid/util/json/SecurityOptions.java",
                "+++ b/src/com/unboundid/util/json/SecurityOptions.java",
                "@@ -350,3 +350,4 @@ final class SecurityOptions",
                "             throw new LDAPException(ResultCode.PARAM_ERROR,",
                "-                 ERR_SECURITY_OPTIONS_INVALID_TS_TYPE.get(trustStoreType));",
                "+                 ERR_SECURITY_OPTIONS_INVALID_TS_TYPE.get(",
                "+                      FIELD_TRUST_STORE_TYPE, trustStoreType));",
                "           }",
                "diff --git a/src/com/unboundid/util/ssl/PromptTrustManagerProcessor.java b/src/com/unboundid/util/ssl/PromptTrustManagerProcessor.java",
                "index c39fbcd5..87912ff1 100644",
                "--- a/src/com/unboundid/util/ssl/PromptTrustManagerProcessor.java",
                "+++ b/src/com/unboundid/util/ssl/PromptTrustManagerProcessor.java",
                "@@ -146,3 +146,4 @@ final class PromptTrustManagerProcessor",
                "                ((currentTime - chain[i].getNotAfterTime()) / 1000.0d));",
                "-          warningMessages.add(WARN_PROMPT_PROCESSOR_CERT_EXPIRED.get(identifier,",
                "+          warningMessages.add(WARN_PROMPT_PROCESSOR_CERT_EXPIRED.get(",
                "+               identifier, String.valueOf(chain[i].getSubjectDN()),",
                "                formatDate(chain[i].getNotAfterDate()),",
                "@@ -155,3 +156,4 @@ final class PromptTrustManagerProcessor",
                "           warningMessages.add(WARN_PROMPT_PROCESSOR_CERT_NOT_YET_VALID.get(",
                "-               identifier, formatDate(chain[i].getNotBeforeDate()),",
                "+               identifier, String.valueOf(chain[i].getSubjectDN()),",
                "+               formatDate(chain[i].getNotBeforeDate()),",
                "                StaticUtils.secondsToHumanReadableDuration(",
                "diff --git a/src/com/unboundid/util/ssl/cert/ManageCertificates.java b/src/com/unboundid/util/ssl/cert/ManageCertificates.java",
                "index 5a16aede..7ee27448 100644",
                "--- a/src/com/unboundid/util/ssl/cert/ManageCertificates.java",
                "+++ b/src/com/unboundid/util/ssl/cert/ManageCertificates.java",
                "@@ -1111,3 +1111,3 @@ public final class ManageCertificates",
                "          },",
                "-         INFO_MANAGE_CERTS_SC_IMPORT_CERT_EXAMPLE_1.get());",
                "+         INFO_MANAGE_CERTS_SC_IMPORT_CERT_EXAMPLE_1.get(\"server-cert.crt\"));",
                "     importCertExamples.put(",
                "@@ -1430,3 +1430,4 @@ public final class ManageCertificates",
                "          INFO_MANAGE_CERTS_PLACEHOLDER_TIMESTAMP.get(),",
                "-         INFO_MANAGE_CERTS_SC_GEN_CERT_ARG_VALIDITY_START_TIME_DESC.get());",
                "+         INFO_MANAGE_CERTS_SC_GEN_CERT_ARG_VALIDITY_START_TIME_DESC.get(",
                "+              \"20180102123456\"));",
                "     genCertNotBefore.addLongIdentifier(\"validityStartTime\", true);",
                "@@ -2409,3 +2410,4 @@ public final class ManageCertificates",
                "          INFO_MANAGE_CERTS_PLACEHOLDER_TIMESTAMP.get(),",
                "-         INFO_MANAGE_CERTS_SC_SIGN_CSR_ARG_VALIDITY_START_TIME_DESC.get());",
                "+         INFO_MANAGE_CERTS_SC_SIGN_CSR_ARG_VALIDITY_START_TIME_DESC.get(",
                "+              \"20180102123456\"));",
                "     signCSRNotBefore.addLongIdentifier(\"validityStartTime\", true);",
                "@@ -2735,3 +2737,4 @@ public final class ManageCertificates",
                "          },",
                "-         INFO_MANAGE_CERTS_SC_SIGN_CSR_EXAMPLE_1.get());",
                "+         INFO_MANAGE_CERTS_SC_SIGN_CSR_EXAMPLE_1.get(",
                "+              getPlatformSpecificPath(\"config\", \"keystore\")));",
                "     signCSRExamples.put(",
                "@@ -2752,3 +2755,4 @@ public final class ManageCertificates",
                "          },",
                "-         INFO_MANAGE_CERTS_SC_SIGN_CSR_EXAMPLE_2.get());",
                "+         INFO_MANAGE_CERTS_SC_SIGN_CSR_EXAMPLE_2.get(",
                "+              getPlatformSpecificPath(\"config\", \"keystore\")));",
                "@@ -3492,3 +3496,4 @@ public final class ManageCertificates",
                "          },",
                "-         INFO_MANAGE_CERTS_SC_TRUST_SERVER_EXAMPLE_1.get());",
                "+         INFO_MANAGE_CERTS_SC_TRUST_SERVER_EXAMPLE_1.get(",
                "+              getPlatformSpecificPath(\"config\", \"keystore\")));",
                "     trustServerExamples.put(",
                "@@ -3507,3 +3512,4 @@ public final class ManageCertificates",
                "          },",
                "-         INFO_MANAGE_CERTS_SC_TRUST_SERVER_EXAMPLE_2.get());",
                "+         INFO_MANAGE_CERTS_SC_TRUST_SERVER_EXAMPLE_2.get(",
                "+              getPlatformSpecificPath(\"config\", \"keystore\")));",
                "@@ -3606,3 +3612,4 @@ public final class ManageCertificates",
                "          },",
                "-         INFO_MANAGE_CERTS_SC_CHECK_USABILITY_EXAMPLE_1.get());",
                "+         INFO_MANAGE_CERTS_SC_CHECK_USABILITY_EXAMPLE_1.get(",
                "+              getPlatformSpecificPath(\"config\", \"keystore\")));",
                "diff --git a/src/com/unboundid/util/ssl/cert/PKCS10CertificateSigningRequest.java b/src/com/unboundid/util/ssl/cert/PKCS10CertificateSigningRequest.java",
                "index 193e735a..6621fea0 100644",
                "--- a/src/com/unboundid/util/ssl/cert/PKCS10CertificateSigningRequest.java",
                "+++ b/src/com/unboundid/util/ssl/cert/PKCS10CertificateSigningRequest.java",
                "@@ -505,3 +505,3 @@ public final class PKCS10CertificateSigningRequest",
                "                      ERR_CSR_DECODE_CANNOT_PARSE_EXT_ATTR.get(",
                "-                          StaticUtils.getExceptionMessage(e)),",
                "+                          p.getFirst(), StaticUtils.getExceptionMessage(e)),",
                "                      e);",
                "diff --git a/tests/unit/src/com/unboundid/asn1/ASN1MessagesTestCase.java b/tests/unit/src/com/unboundid/asn1/ASN1MessagesTestCase.java",
                "index 6245a3e2..7610a4e0 100644",
                "--- a/tests/unit/src/com/unboundid/asn1/ASN1MessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/asn1/ASN1MessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.asn1;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -51,3 +53,6 @@ public class ASN1MessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -63,2 +68,58 @@ public class ASN1MessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final ASN1Messages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/listener/ListenerMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/listener/ListenerMessagesTestCase.java",
                "index ea1189d9..f5487361 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/listener/ListenerMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/listener/ListenerMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.listener;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class ListenerMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class ListenerMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final ListenerMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/listener/interceptor/InterceptorMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/listener/interceptor/InterceptorMessagesTestCase.java",
                "index 0b34558c..dd10dc1c 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/listener/interceptor/InterceptorMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/listener/interceptor/InterceptorMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.listener.interceptor;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class InterceptorMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,59 @@ public class InterceptorMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(",
                "+                   final InterceptorMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/matchingrules/MatchingRuleMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/matchingrules/MatchingRuleMessagesTestCase.java",
                "index 3102feac..b5dea13a 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/matchingrules/MatchingRuleMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/matchingrules/MatchingRuleMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.matchingrules;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -51,3 +53,6 @@ public class MatchingRuleMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -63,2 +68,59 @@ public class MatchingRuleMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(",
                "+                   final MatchingRuleMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/protocol/ProtocolMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/protocol/ProtocolMessagesTestCase.java",
                "index 6b62efd7..da60c794 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/protocol/ProtocolMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/protocol/ProtocolMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.protocol;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class ProtocolMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class ProtocolMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final ProtocolMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/LDAPMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/LDAPMessagesTestCase.java",
                "index f811081a..ce528886 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/LDAPMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/LDAPMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -51,3 +53,6 @@ public class LDAPMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -63,2 +68,58 @@ public class LDAPMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final LDAPMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/controls/ControlMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/controls/ControlMessagesTestCase.java",
                "index dcee479c..12552cdb 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/controls/ControlMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/controls/ControlMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.controls;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class ControlMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class ControlMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final ControlMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/experimental/ExperimentalMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/experimental/ExperimentalMessagesTestCase.java",
                "index 60e88f32..15dde8ae 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/experimental/ExperimentalMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/experimental/ExperimentalMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.experimental;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class ExperimentalMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,59 @@ public class ExperimentalMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(",
                "+                   final ExperimentalMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/extensions/ExtOpMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/extensions/ExtOpMessagesTestCase.java",
                "index 10a4db7f..9a4300dc 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/extensions/ExtOpMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/extensions/ExtOpMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.extensions;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class ExtOpMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class ExtOpMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final ExtOpMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/persist/PersistMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/persist/PersistMessagesTestCase.java",
                "index 71805636..8e8c415f 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/persist/PersistMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/persist/PersistMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.persist;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class PersistMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class PersistMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final PersistMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/schema/SchemaMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/schema/SchemaMessagesTestCase.java",
                "index ebee574a..8620ef39 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/schema/SchemaMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/schema/SchemaMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.schema;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class SchemaMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class SchemaMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final SchemaMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/transformations/TransformationMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/transformations/TransformationMessagesTestCase.java",
                "index 2bd6a975..1d6a5b7e 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/transformations/TransformationMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/transformations/TransformationMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.transformations;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class TransformationMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,59 @@ public class TransformationMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(",
                "+                   final TransformationMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/UnboundIDDSMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/UnboundIDDSMessagesTestCase.java",
                "index 1e0e90f2..c6d1de77 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/UnboundIDDSMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/UnboundIDDSMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.unboundidds;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class UnboundIDDSMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,59 @@ public class UnboundIDDSMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(",
                "+                   final UnboundIDDSMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/controls/ControlMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/controls/ControlMessagesTestCase.java",
                "index b15786b1..c77e4e11 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/controls/ControlMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/controls/ControlMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.unboundidds.controls;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class ControlMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class ControlMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final ControlMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/extensions/ExtOpMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/extensions/ExtOpMessagesTestCase.java",
                "index 2d6c3972..ebf4bd31 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/extensions/ExtOpMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/extensions/ExtOpMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.unboundidds.extensions;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class ExtOpMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class ExtOpMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final ExtOpMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JFMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JFMessagesTestCase.java",
                "index 4858e83c..7da85c43 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JFMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JFMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.unboundidds.jsonfilter;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class JFMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class JFMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final JFMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JSONObjectFilterTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JSONObjectFilterTestCase.java",
                "index 76ae2964..37f3b6c7 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JSONObjectFilterTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JSONObjectFilterTestCase.java",
                "@@ -836,2 +836,35 @@ public final class JSONObjectFilterTestCase",
                "   }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the {@code fieldPathToName} method.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testFieldPathToName()",
                "+         throws Exception",
                "+  {",
                "+    assertNotNull(JSONObjectFilter.fieldPathToName(null));",
                "+    assertEquals(JSONObjectFilter.fieldPathToName(null), \"null\");",
                "+",
                "+    assertNotNull(",
                "+         JSONObjectFilter.fieldPathToName(Collections.<String>emptyList()));",
                "+    assertEquals(",
                "+         JSONObjectFilter.fieldPathToName(Collections.<String>emptyList()),",
                "+         \"\");",
                "+",
                "+    assertNotNull(",
                "+         JSONObjectFilter.fieldPathToName(Collections.singletonList(\"foo\")));",
                "+    assertEquals(",
                "+         JSONObjectFilter.fieldPathToName(Collections.singletonList(\"foo\")),",
                "+         \"\\\"foo\\\"\");",
                "+",
                "+    assertNotNull(",
                "+         JSONObjectFilter.fieldPathToName(Arrays.asList(\"foo\", \"bar\")));",
                "+    assertEquals(",
                "+         JSONObjectFilter.fieldPathToName(Arrays.asList(\"foo\", \"bar\")),",
                "+         \"\\\"foo\\\".\\\"bar\\\"\");",
                "+  }",
                " }",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/logs/LogMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/logs/LogMessagesTestCase.java",
                "index 0d0d36e0..fd4ab86f 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/logs/LogMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/logs/LogMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.unboundidds.logs;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class LogMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class LogMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final LogMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/monitors/MonitorMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/monitors/MonitorMessagesTestCase.java",
                "index c2a7da87..4a6eee97 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/monitors/MonitorMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/monitors/MonitorMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.unboundidds.monitors;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class MonitorMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class MonitorMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final MonitorMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/TaskMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/TaskMessagesTestCase.java",
                "index 5abc54cf..e95b0941 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/TaskMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/TaskMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.unboundidds.tasks;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class TaskMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class TaskMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final TaskMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolMessagesTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolMessagesTestCase.java",
                "index 9a761344..e4e44786 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldap.sdk.unboundidds.tools;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class ToolMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class ToolMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final ToolMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/ldif/LDIFMessagesTestCase.java b/tests/unit/src/com/unboundid/ldif/LDIFMessagesTestCase.java",
                "index 95c2de62..808e80b5 100644",
                "--- a/tests/unit/src/com/unboundid/ldif/LDIFMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldif/LDIFMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.ldif;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -51,3 +53,6 @@ public class LDIFMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -63,2 +68,58 @@ public class LDIFMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final LDIFMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/util/UtilityMessagesTestCase.java b/tests/unit/src/com/unboundid/util/UtilityMessagesTestCase.java",
                "index 94dbac5c..67dff740 100644",
                "--- a/tests/unit/src/com/unboundid/util/UtilityMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/util/UtilityMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.util;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -51,3 +53,6 @@ public class UtilityMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -63,2 +68,58 @@ public class UtilityMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final UtilityMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/util/args/ArgsMessagesTestCase.java b/tests/unit/src/com/unboundid/util/args/ArgsMessagesTestCase.java",
                "index 84410064..a7bd4904 100644",
                "--- a/tests/unit/src/com/unboundid/util/args/ArgsMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/util/args/ArgsMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.util.args;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class ArgsMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class ArgsMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final ArgsMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/util/json/JSONMessagesTestCase.java b/tests/unit/src/com/unboundid/util/json/JSONMessagesTestCase.java",
                "index 94c14ded..72237682 100644",
                "--- a/tests/unit/src/com/unboundid/util/json/JSONMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/util/json/JSONMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.util.json;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class JSONMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class JSONMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final JSONMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/util/ssl/SSLMessagesTestCase.java b/tests/unit/src/com/unboundid/util/ssl/SSLMessagesTestCase.java",
                "index 13188479..c1c49ff0 100644",
                "--- a/tests/unit/src/com/unboundid/util/ssl/SSLMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/util/ssl/SSLMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.util.ssl;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -51,3 +53,6 @@ public class SSLMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -63,2 +68,58 @@ public class SSLMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final SSLMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "diff --git a/tests/unit/src/com/unboundid/util/ssl/cert/CertMessagesTestCase.java b/tests/unit/src/com/unboundid/util/ssl/cert/CertMessagesTestCase.java",
                "index 9d948d93..f520d545 100644",
                "--- a/tests/unit/src/com/unboundid/util/ssl/cert/CertMessagesTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/util/ssl/cert/CertMessagesTestCase.java",
                "@@ -24,2 +24,4 @@ package com.unboundid.util.ssl.cert;",
                "+import java.util.ArrayList;",
                "+",
                " import org.testng.annotations.DataProvider;",
                "@@ -53,3 +55,6 @@ public class CertMessagesTestCase",
                "-    assertNotNull(m.get());",
                "+    try",
                "+    {",
                "+      m.get();",
                "+    } catch (final Exception e) {}",
                "@@ -65,2 +70,58 @@ public class CertMessagesTestCase",
                "+  /**",
                "+   * Tests to ensure that message format strings are generated properly without",
                "+   * any exceptions when provided with an expected set of arguments.",
                "+   *",
                "+   * @param  m  The message key for which to make the determination.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test(dataProvider = \"messageKeys\")",
                "+  public void testMessageGetWithArgsWithoutException(final CertMessages m)",
                "+         throws Exception",
                "+  {",
                "+    final String formatString = m.toString();",
                "+",
                "+    final ArrayList<Object> argList = new ArrayList<>(20);",
                "+    for (int i=0; i < 20; i++)",
                "+    {",
                "+      final boolean hasToken;",
                "+      if (formatString.contains(\"{\" + i + '}'))",
                "+      {",
                "+        argList.add(\"arg\" + i);",
                "+        hasToken = true;",
                "+      }",
                "+      else if (formatString.contains(\"{\" + i + \",number,\"))",
                "+      {",
                "+        argList.add(i);",
                "+        hasToken = true;",
                "+      }",
                "+      else",
                "+      {",
                "+        hasToken = false;",
                "+      }",
                "+",
                "+      if (hasToken && ((argList.size() - 1) != i))",
                "+      {",
                "+        fail(\"CertMessages.\" + m.name() + \" has a format string that \" +",
                "+             \"contains {\" + i + \"} without {\" + (i-1) + \"}:  \" +",
                "+             m.toString());",
                "+      }",
                "+    }",
                "+",
                "+    if (argList.isEmpty())",
                "+    {",
                "+      assertNotNull(m.get());",
                "+    }",
                "+    else",
                "+    {",
                "+      final Object[] argArray = new Object[argList.size()];",
                "+      argList.toArray(argArray);",
                "+",
                "+      assertNotNull(m.get(argArray));",
                "+    }",
                "+  }",
                "+",
                "+",
                "+",
                "   /**"
            ],
            "changed_files": [
                "build-src/messages/com/unboundid/buildtools/messages/GenerateMessages.java",
                "build.xml",
                "docs/release-notes.html",
                "messages/unboundid-ldapsdk-asn1.properties",
                "messages/unboundid-ldapsdk-cert.properties",
                "messages/unboundid-ldapsdk-json.properties",
                "messages/unboundid-ldapsdk-listener.properties",
                "src/com/unboundid/ldap/listener/InMemoryRequestHandler.java",
                "src/com/unboundid/ldap/matchingrules/IntegerMatchingRule.java",
                "src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JSONObjectFilter.java",
                "src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/RegularExpressionJSONObjectFilter.java",
                "src/com/unboundid/util/StaticUtils.java",
                "src/com/unboundid/util/json/JSONObjectReader.java",
                "src/com/unboundid/util/json/SecurityOptions.java",
                "src/com/unboundid/util/ssl/PromptTrustManagerProcessor.java",
                "src/com/unboundid/util/ssl/cert/ManageCertificates.java",
                "src/com/unboundid/util/ssl/cert/PKCS10CertificateSigningRequest.java",
                "tests/unit/src/com/unboundid/asn1/ASN1MessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/listener/ListenerMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/listener/interceptor/InterceptorMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/matchingrules/MatchingRuleMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/protocol/ProtocolMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/LDAPMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/controls/ControlMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/experimental/ExperimentalMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/extensions/ExtOpMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/persist/PersistMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/schema/SchemaMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/transformations/TransformationMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/UnboundIDDSMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/controls/ControlMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/extensions/ExtOpMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JFMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JSONObjectFilterTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/logs/LogMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/monitors/MonitorMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/TaskMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolMessagesTestCase.java",
                "tests/unit/src/com/unboundid/ldif/LDIFMessagesTestCase.java",
                "tests/unit/src/com/unboundid/util/UtilityMessagesTestCase.java",
                "tests/unit/src/com/unboundid/util/args/ArgsMessagesTestCase.java",
                "tests/unit/src/com/unboundid/util/json/JSONMessagesTestCase.java",
                "tests/unit/src/com/unboundid/util/ssl/SSLMessagesTestCase.java",
                "tests/unit/src/com/unboundid/util/ssl/cert/CertMessagesTestCase.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: UnboundID, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: tests/unit/src/com/unboundid/ldap/sdk/LDAPMessagesTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolMessagesTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/monitors/MonitorMessagesTestCase.java, build-src/messages/com/unboundid/buildtools/messages/GenerateMessages.java, src/com/unboundid/util/StaticUtils.java, src/com/unboundid/util/ssl/PromptTrustManagerProcessor.java, tests/unit/src/com/unboundid/ldap/sdk/extensions/ExtOpMessagesTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/persist/PersistMessagesTestCase.java, tests/unit/src/com/unboundid/asn1/ASN1MessagesTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/controls/ControlMessagesTestCase.java, messages/unboundid-ldapsdk-listener.properties, src/com/unboundid/ldap/matchingrules/IntegerMatchingRule.java, src/com/unboundid/util/json/JSONObjectReader.java, tests/unit/src/com/unboundid/ldap/listener/ListenerMessagesTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/extensions/ExtOpMessagesTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/schema/SchemaMessagesTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/TaskMessagesTestCase.java, src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/RegularExpressionJSONObjectFilter.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JFMessagesTestCase.java, src/com/unboundid/util/ssl/cert/ManageCertificates.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JSONObjectFilterTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/controls/ControlMessagesTestCase.java, src/com/unboundid/ldap/sdk/unboundidds/jsonfilter/JSONObjectFilter.java, tests/unit/src/com/unboundid/util/UtilityMessagesTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/experimental/ExperimentalMessagesTestCase.java, tests/unit/src/com/unboundid/util/json/JSONMessagesTestCase.java, messages/unboundid-ldapsdk-cert.properties, tests/unit/src/com/unboundid/ldap/sdk/transformations/TransformationMessagesTestCase.java, tests/unit/src/com/unboundid/ldap/listener/interceptor/InterceptorMessagesTestCase.java, tests/unit/src/com/unboundid/util/ssl/SSLMessagesTestCase.java, tests/unit/src/com/unboundid/ldap/matchingrules/MatchingRuleMessagesTestCase.java, tests/unit/src/com/unboundid/util/ssl/cert/CertMessagesTestCase.java, messages/unboundid-ldapsdk-asn1.properties, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/logs/LogMessagesTestCase.java, src/com/unboundid/ldap/listener/InMemoryRequestHandler.java, tests/unit/src/com/unboundid/util/args/ArgsMessagesTestCase.java, src/com/unboundid/util/json/SecurityOptions.java, tests/unit/src/com/unboundid/ldif/LDIFMessagesTestCase.java, src/com/unboundid/util/ssl/cert/PKCS10CertificateSigningRequest.java, messages/unboundid-ldapsdk-json.properties, tests/unit/src/com/unboundid/ldap/protocol/ProtocolMessagesTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/UnboundIDDSMessagesTestCase.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: provide, process",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid, control, process",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "2e650241797fe6d32e8c45acc18839ef20bca798",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1520630933,
            "hunks": 4,
            "message": "Update ToolUtils.promptForEncryptionPassphrase Added a new ToolUtils.promptForEncryptionPassphrase variant that allows the requester to provide the initial and confirmation prompts that should be presented to the user.  The previous version of the method, using hard-coded prompts, is still available.",
            "diff": [
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java b/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java",
                "index 66da4ebe..6ccea923 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java",
                "@@ -224,2 +224,53 @@ public final class ToolUtils",
                "   {",
                "+    return promptForEncryptionPassphrase(allowEmpty, confirm,",
                "+         INFO_TOOL_UTILS_ENCRYPTION_PW_PROMPT.get(),",
                "+         INFO_TOOL_UTILS_ENCRYPTION_PW_CONFIRM.get(), out, err);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Interactively prompts the user for an encryption passphrase.",
                "+   *",
                "+   * @param  allowEmpty     Indicates whether the encryption passphrase is",
                "+   *                        allowed to be empty.  If this is {@code false}, then",
                "+   *                        the user will be re-prompted for the passphrase if",
                "+   *                        the value they enter is empty.",
                "+   * @param  confirm        Indicates whether the user will asked to confirm the",
                "+   *                        passphrase.  If this is {@code true}, then the user",
                "+   *                        will have to enter the same passphrase twice.  If",
                "+   *                        this is {@code false}, then the user will only be",
                "+   *                        prompted once.",
                "+   * @param  initialPrompt  The initial prompt that will be presented to the",
                "+   *                        user.  It must not be {@code null} or empty.",
                "+   * @param  confirmPrompt  The prompt that will be presented to the user when",
                "+   *                        asked to confirm the passphrase.  It may be",
                "+   *                        {@code null} only if {@code confirm} is",
                "+   *                        {@code false}.",
                "+   * @param  out            The {@code PrintStream} that will be used for",
                "+   *                        standard output.  It must not be {@code null}.",
                "+   * @param  err            The {@code PrintStream} that will be used for",
                "+   *                        standard error.  It must not be {@code null}.",
                "+   *",
                "+   * @return  The encryption passphrase provided by the user.",
                "+   *",
                "+   * @throws  LDAPException  If a problem is encountered while trying to obtain",
                "+   *                         the passphrase from the user.",
                "+   */",
                "+  public static String promptForEncryptionPassphrase(final boolean allowEmpty,",
                "+                            final boolean confirm,",
                "+                            final CharSequence initialPrompt,",
                "+                            final CharSequence confirmPrompt,",
                "+                            final PrintStream out, final PrintStream err)",
                "+          throws LDAPException",
                "+  {",
                "+    Validator.ensureTrue(",
                "+         ((initialPrompt != null) && (initialPrompt.length() > 0)),",
                "+         \"TestUtils.promptForEncryptionPassphrase.initialPrompt must not be \" +",
                "+              \"null or empty.\");",
                "+    Validator.ensureTrue(",
                "+         ((! confirm) ||",
                "+              ((confirmPrompt != null) && (confirmPrompt.length() > 0))),",
                "+         \"TestUtils.promptForEncryptionPassphrase.confirmPrompt must not be \" +",
                "+              \"null or empty when confirm is true.\");",
                "     Validator.ensureTrue((out != null),",
                "@@ -236,3 +287,3 @@ public final class ToolUtils",
                "       {",
                "-        wrapPrompt(INFO_TOOL_UTILS_ENCRYPTION_PW_PROMPT.get(), true, out);",
                "+        wrapPrompt(initialPrompt, true, out);",
                "@@ -255,3 +306,3 @@ public final class ToolUtils",
                "         {",
                "-          wrapPrompt(INFO_TOOL_UTILS_ENCRYPTION_PW_CONFIRM.get(), true, out);",
                "+          wrapPrompt(confirmPrompt, true, out);",
                "@@ -904,3 +955,4 @@ public final class ToolUtils",
                "         promptedPassphrase =",
                "-             promptForEncryptionPassphrase(false, false, out, err);",
                "+             promptForEncryptionPassphrase(false, false, passphrasePrompt, null,",
                "+                  out, err);",
                "       }"
            ],
            "changed_files": [
                "src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: provide, version, user",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "fea8795993b30ed7e98111c923bb0cb2b1542fb6",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1519770406,
            "hunks": 143,
            "message": "Update task support for new attributes Updated the LDAP SDK's support for UnboundID/Ping Identity server tasks to include support for new attributes that have recently been introduced in the backup, restore, export, and import tasks.",
            "diff": [
                "diff --git a/messages/unboundid-ldapsdk-task.properties b/messages/unboundid-ldapsdk-task.properties",
                "index 30184575..0f4d9b9d 100644",
                "--- a/messages/unboundid-ldapsdk-task.properties",
                "+++ b/messages/unboundid-ldapsdk-task.properties",
                "@@ -140,2 +140,9 @@ INFO_DESCRIPTION_ENCRYPT_BACKUP=Indicates whether the contents of the backup \\",
                "   should be encrypted.",
                "+INFO_DISPLAY_NAME_ENCRYPTION_PASSPHRASE_FILE=Encryption Passphrase File",
                "+INFO_DESCRIPTION_ENCRYPTION_PASSPHRASE_FILE=The path to a file containing the \\",
                "+  passphrase to use to generate the encryption key.",
                "+INFO_DISPLAY_NAME_ENCRYPTION_SETTINGS_DEFINITION_ID=Encryption Settings \\",
                "+  Definition ID",
                "+INFO_DESCRIPTION_ENCRYPTION_SETTINGS_DEFINITION_ID=The identifier for the \\",
                "+  encryption settings definition that to use to generate the encryption key.",
                " INFO_DISPLAY_NAME_HASH=Calculate Hash",
                "@@ -143,2 +150,11 @@ INFO_DESCRIPTION_HASH_BACKUP=Indicates whether to calculate a hash of the \\",
                "   backup contents, which can be used to verify the integrity of the backup.",
                "+INFO_DISPLAY_NAME_BACKUP_MAX_MEGABYTES_PER_SECOND=Maximum Megabytes Per Second",
                "+INFO_DESCRIPTION_BACKUP_MAX_MEGABYTES_PER_SECOND=The maximum backup rate in \\",
                "+  megabytes per second at which the backup should be written.",
                "+INFO_DISPLAY_NAME_BACKUP_RETAIN_AGE=Retain Previous Backup Age",
                "+INFO_DESCRIPTION_BACKUP_RETAIN_AGE=The minimum age of previous backups that \\",
                "+  should be retained.",
                "+INFO_DISPLAY_NAME_BACKUP_RETAIN_COUNT=Retain Previous Backup Count",
                "+INFO_DESCRIPTION_BACKUP_RETAIN_COUNT=The minimum number of previous backups \\",
                "+  that should be retained.",
                " INFO_DISPLAY_NAME_SIGN_HASH=Sign Hash",
                "@@ -208,2 +224,5 @@ INFO_DESCRIPTION_SIGN_EXPORT=Indicates whether to include a digital signature \\",
                "   been altered.",
                "+INFO_DISPLAY_NAME_EXPORT_MAX_MEGABYTES_PER_SECOND=Maximum Megabytes Per Second",
                "+INFO_DESCRIPTION_EXPORT_MAX_MEGABYTES_PER_SECOND=The maximum backup rate in \\",
                "+  megabytes per second at which the backup should be written.",
                " INFO_DESCRIPTION_BACKEND_ID_IMPORT=The backend ID of the backend into which \\",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/tasks/BackupTask.java b/src/com/unboundid/ldap/sdk/unboundidds/tasks/BackupTask.java",
                "index 4a67cf4a..69df2ee9 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/tasks/BackupTask.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/tasks/BackupTask.java",
                "@@ -38,2 +38,3 @@ import com.unboundid.util.ThreadSafety;",
                " import com.unboundid.util.ThreadSafetyLevel;",
                "+import com.unboundid.util.args.DurationArgument;",
                "@@ -82,2 +83,10 @@ import static com.unboundid.util.Validator.*;",
                "  *       prevent anyone from tampering with it.</LI>",
                "+ *   <LI>The path to a file containing a passphrase to use to generate the",
                "+ *       encryption key.</LI>",
                "+ *   <LI>The ID of the encryption settings definition to use to generate the",
                "+ *       encryption key.</LI>",
                "+ *   <LI>The maximum rate in megabytes per second at which the backup should be",
                "+ *       written.</LI>",
                "+ *   <LI>The minimum number of previous full backups to retain.</LI>",
                "+ *   <LI>The minimum age of previous full backups to retain.</LI>",
                "  * </UL>",
                "@@ -145,2 +154,21 @@ public final class BackupTask",
                "+  /**",
                "+   * The name of the attribute used to specify the path to a file that contains",
                "+   * the passphrase to use to generate the encryption key.",
                "+   */",
                "+  private static final String ATTR_ENCRYPTION_PASSPHRASE_FILE =",
                "+       \"ds-task-backup-encryption-passphrase-file\";",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * The name of the attribute used to specify the path to a file that contains",
                "+   * the ID of the encryption settings definition to use to generate the",
                "+   * encryption key.",
                "+   */",
                "+  private static final String ATTR_ENCRYPTION_SETTINGS_DEFINITION_ID =",
                "+       \"ds-task-backup-encryption-settings-definition-id\";",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -170,2 +198,29 @@ public final class BackupTask",
                "+  /**",
                "+   * The name of the attribute used to specify the maximum backup write rate in",
                "+   * megabytes per second.",
                "+   */",
                "+  private static final String ATTR_MAX_MEGABYTES_PER_SECOND =",
                "+       \"ds-task-backup-max-megabytes-per-second\";",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * The name of the attribute used to specify the minimum age of previous full",
                "+   * backups to retain.",
                "+   */",
                "+  private static final String ATTR_RETAIN_PREVIOUS_FULL_BACKUP_AGE =",
                "+       \"ds-task-backup-retain-previous-full-backup-age\";",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * The name of the attribute used to specify the number of previous full",
                "+   * backups to retain.",
                "+   */",
                "+  private static final String ATTR_RETAIN_PREVIOUS_FULL_BACKUP_COUNT =",
                "+       \"ds-task-backup-retain-previous-full-backup-count\";",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -190,5 +245,5 @@ public final class BackupTask",
                "        new TaskProperty(ATTR_BACKUP_DIRECTORY,",
                "-                        INFO_DISPLAY_NAME_BACKUP_DIRECTORY.get(),",
                "-                        INFO_DESCRIPTION_BACKUP_DIRECTORY_BACKUP.get(),",
                "-                        String.class, true, false, false);",
                "+            INFO_DISPLAY_NAME_BACKUP_DIRECTORY.get(),",
                "+            INFO_DESCRIPTION_BACKUP_DIRECTORY_BACKUP.get(),",
                "+            String.class, true, false, false);",
                "@@ -201,4 +256,4 @@ public final class BackupTask",
                "        new TaskProperty(ATTR_BACKEND_ID, INFO_DISPLAY_NAME_BACKEND_ID.get(),",
                "-                        INFO_DESCRIPTION_BACKEND_ID_BACKUP.get(), String.class,",
                "-                        false, true, false);",
                "+            INFO_DESCRIPTION_BACKEND_ID_BACKUP.get(), String.class, false, true,",
                "+            false);",
                "@@ -211,4 +266,4 @@ public final class BackupTask",
                "        new TaskProperty(ATTR_BACKUP_ID, INFO_DISPLAY_NAME_BACKUP_ID.get(),",
                "-                        INFO_DESCRIPTION_BACKUP_ID_BACKUP.get(), String.class,",
                "-                        false, false, true);",
                "+            INFO_DESCRIPTION_BACKUP_ID_BACKUP.get(), String.class, false, false,",
                "+            true);",
                "@@ -221,4 +276,4 @@ public final class BackupTask",
                "        new TaskProperty(ATTR_INCREMENTAL, INFO_DISPLAY_NAME_INCREMENTAL.get(),",
                "-                        INFO_DESCRIPTION_INCREMENTAL.get(), Boolean.class,",
                "-                        false, false, false);",
                "+            INFO_DESCRIPTION_INCREMENTAL.get(), Boolean.class, false, false,",
                "+            false);",
                "@@ -231,5 +286,5 @@ public final class BackupTask",
                "        new TaskProperty(ATTR_INCREMENTAL_BASE_ID,",
                "-                        INFO_DISPLAY_NAME_INCREMENTAL_BASE_ID.get(),",
                "-                        INFO_DESCRIPTION_INCREMENTAL_BASE_ID.get(),",
                "-                        String.class, false, false, true);",
                "+            INFO_DISPLAY_NAME_INCREMENTAL_BASE_ID.get(),",
                "+            INFO_DESCRIPTION_INCREMENTAL_BASE_ID.get(), String.class, false,",
                "+            false, true);",
                "@@ -242,4 +297,4 @@ public final class BackupTask",
                "        new TaskProperty(ATTR_COMPRESS, INFO_DISPLAY_NAME_COMPRESS.get(),",
                "-                        INFO_DESCRIPTION_COMPRESS_BACKUP.get(), Boolean.class,",
                "-                        false, false, false);",
                "+            INFO_DESCRIPTION_COMPRESS_BACKUP.get(), Boolean.class, false, false,",
                "+            false);",
                "@@ -252,4 +307,27 @@ public final class BackupTask",
                "        new TaskProperty(ATTR_ENCRYPT, INFO_DISPLAY_NAME_ENCRYPT.get(),",
                "-                        INFO_DESCRIPTION_ENCRYPT_BACKUP.get(), Boolean.class,",
                "-                        false, false, false);",
                "+            INFO_DESCRIPTION_ENCRYPT_BACKUP.get(), Boolean.class, false, false,",
                "+            false);",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * The task property that will be used for the encryption passphrase file.",
                "+   */",
                "+  private static final TaskProperty PROPERTY_ENCRYPTION_PASSPHRASE_FILE =",
                "+       new TaskProperty(ATTR_ENCRYPTION_PASSPHRASE_FILE,",
                "+            INFO_DISPLAY_NAME_ENCRYPTION_PASSPHRASE_FILE.get(),",
                "+            INFO_DESCRIPTION_ENCRYPTION_PASSPHRASE_FILE.get(),",
                "+            String.class, false, false, true);",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * The task property that will be used for the encryption settings definition",
                "+   * ID.",
                "+   */",
                "+  private static final TaskProperty PROPERTY_ENCRYPTION_SETTINGS_DEFINITION_ID =",
                "+       new TaskProperty(ATTR_ENCRYPTION_SETTINGS_DEFINITION_ID,",
                "+            INFO_DISPLAY_NAME_ENCRYPTION_SETTINGS_DEFINITION_ID.get(),",
                "+            INFO_DESCRIPTION_ENCRYPTION_SETTINGS_DEFINITION_ID.get(),",
                "+            String.class, false, false, true);",
                "@@ -262,4 +340,4 @@ public final class BackupTask",
                "        new TaskProperty(ATTR_HASH, INFO_DISPLAY_NAME_HASH.get(),",
                "-                        INFO_DESCRIPTION_HASH_BACKUP.get(), Boolean.class,",
                "-                        false, false, false);",
                "+            INFO_DESCRIPTION_HASH_BACKUP.get(), Boolean.class, false, false,",
                "+            false);",
                "@@ -272,5 +350,40 @@ public final class BackupTask",
                "        new TaskProperty(ATTR_SIGN_HASH, INFO_DISPLAY_NAME_SIGN_HASH.get(),",
                "-                        INFO_DESCRIPTION_SIGN_HASH_BACKUP.get(), Boolean.class,",
                "-                        false, false, false);",
                "+            INFO_DESCRIPTION_SIGN_HASH_BACKUP.get(), Boolean.class, false,",
                "+            false, false);",
                "+",
                "+",
                "+  /**",
                "+   * The task property that will be used for the maximum write rate in megabytes",
                "+   * per second.",
                "+   */",
                "+  private static final TaskProperty PROPERTY_MAX_MEGABYTES_PER_SECOND =",
                "+       new TaskProperty(ATTR_MAX_MEGABYTES_PER_SECOND,",
                "+            INFO_DISPLAY_NAME_BACKUP_MAX_MEGABYTES_PER_SECOND.get(),",
                "+            INFO_DESCRIPTION_BACKUP_MAX_MEGABYTES_PER_SECOND.get(),",
                "+            Long.class, false, false, true);",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * The task property that will be used for the retain previous full backup",
                "+   * age.",
                "+   */",
                "+  private static final TaskProperty PROPERTY_RETAIN_PREVIOUS_FULL_BACKUP_AGE =",
                "+       new TaskProperty(ATTR_RETAIN_PREVIOUS_FULL_BACKUP_AGE,",
                "+            INFO_DISPLAY_NAME_BACKUP_RETAIN_AGE.get(),",
                "+            INFO_DESCRIPTION_BACKUP_RETAIN_AGE.get(),",
                "+            String.class, false, false, true);",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * The task property that will be used for the retain previous full backup",
                "+   * count.",
                "+   */",
                "+  private static final TaskProperty PROPERTY_RETAIN_PREVIOUS_FULL_BACKUP_COUNT =",
                "+       new TaskProperty(ATTR_RETAIN_PREVIOUS_FULL_BACKUP_COUNT,",
                "+            INFO_DISPLAY_NAME_BACKUP_RETAIN_COUNT.get(),",
                "+            INFO_DESCRIPTION_BACKUP_RETAIN_COUNT.get(),",
                "+            Long.class, false, false, true);",
                "@@ -281,3 +394,3 @@ public final class BackupTask",
                "    */",
                "-  private static final long serialVersionUID = 8680226715226034105L;",
                "+  private static final long serialVersionUID = 2637190942057174423L;",
                "@@ -300,2 +413,8 @@ public final class BackupTask",
                "+  // The maximum backup write rate in megabytes per second.",
                "+  private final Integer maxMegabytesPerSecond;",
                "+",
                "+  // The retain previous full backup count.",
                "+  private final Integer retainPreviousFullBackupCount;",
                "+",
                "   // The backend IDs of the backends to back up.",
                "@@ -309,2 +428,10 @@ public final class BackupTask",
                "+  // The path to a file containing the passphrase to use to generate the",
                "+  // encryption key.",
                "+  private final String encryptionPassphraseFile;",
                "+",
                "+  // The identifier for the encryption settings definition to use to generate",
                "+  // the encryption key.",
                "+  private final String encryptionSettingsDefinitionID;",
                "+",
                "   // The backup ID of the backup to use as the base for the incremental backup.",
                "@@ -312,2 +439,5 @@ public final class BackupTask",
                "+  // The retain previous full backup age.",
                "+  private final String retainPreviousFullBackupAge;",
                "+",
                "@@ -322,11 +452,16 @@ public final class BackupTask",
                "   {",
                "-    compress          = false;",
                "-    encrypt           = false;",
                "-    hash              = false;",
                "-    signHash          = false;",
                "-    incremental       = false;",
                "-    backendIDs        = null;",
                "-    backupDirectory   = null;",
                "-    backupID          = null;",
                "+    compress = false;",
                "+    encrypt = false;",
                "+    hash = false;",
                "+    signHash = false;",
                "+    incremental = false;",
                "+    maxMegabytesPerSecond = null;",
                "+    retainPreviousFullBackupCount = null;",
                "+    backendIDs = null;",
                "+    backupDirectory = null;",
                "+    backupID = null;",
                "+    encryptionPassphraseFile = null;",
                "+    encryptionSettingsDefinitionID = null;",
                "     incrementalBaseID = null;",
                "+    retainPreviousFullBackupAge = null;",
                "   }",
                "@@ -426,2 +561,112 @@ public final class BackupTask",
                "                     final List<String> notifyOnError)",
                "+  {",
                "+    this(taskID, backupDirectory, backendIDs, backupID, incremental,",
                "+         incrementalBaseID, compress, encrypt, null, null, hash, signHash,",
                "+         null, null, null, scheduledStartTime, dependencyIDs,",
                "+         failedDependencyAction, notifyOnCompletion, notifyOnError);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new restore task with the provided information.",
                "+   *",
                "+   * @param  taskID                          The task ID to use for this task.",
                "+   *                                         If it is {@code null} then a UUID",
                "+   *                                         will be generated for use as the",
                "+   *                                         task ID.",
                "+   * @param  backupDirectory                 The path to the directory on the",
                "+   *                                         server into which the backup should",
                "+   *                                         be written.  If a single backend is",
                "+   *                                         to be archived, then this should be",
                "+   *                                         the path to the specific backup",
                "+   *                                         directory for that backend.  If",
                "+   *                                         multiple backends are to be",
                "+   *                                         archived, then this should be the",
                "+   *                                         parent of the directories for each",
                "+   *                                         of the backends.  It must not be",
                "+   *                                         {@code null}.",
                "+   * @param  backendIDs                      A list of the backend IDs of the",
                "+   *                                         backends to archive.  It may be",
                "+   *                                         {@code null} or empty if all",
                "+   *                                         supported backends should be",
                "+   *                                         archived.",
                "+   * @param  backupID                        The backup ID to use for this",
                "+   *                                         backup.  It may be {@code null} to",
                "+   *                                         indicate that the server should",
                "+   *                                         generate the backup ID.",
                "+   * @param  incremental                     Indicates whether to perform an",
                "+   *                                         incremental backup rather than a",
                "+   *                                         full backup.",
                "+   * @param  incrementalBaseID               The backup ID of the existing",
                "+   *                                         backup on which to base the",
                "+   *                                         incremental backup.  It may be",
                "+   *                                         {@code null} if this is not an",
                "+   *                                         incremental backup or if it should",
                "+   *                                         be based on the most recent backup.",
                "+   * @param  compress                        Indicates whether the backup should",
                "+   *                                         be compressed.",
                "+   * @param  encrypt                         Indicates whether the backup should",
                "+   *                                         be encrypted.",
                "+   * @param  encryptionPassphraseFile        The path to a file containing the",
                "+   *                                         passphrase to use to generate the",
                "+   *                                         encryption key.  It amy be",
                "+   *                                         {@code null} if the backup is not",
                "+   *                                         to be encrypted, or if the key",
                "+   *                                         should be obtained in some other",
                "+   *                                         way.",
                "+   * @param  encryptionSettingsDefinitionID  The ID of the encryption settings",
                "+   *                                         definition use to generate the",
                "+   *                                         encryption key.  It may be",
                "+   *                                         {@code null} if the backup is not",
                "+   *                                         to be encrypted, or if the key",
                "+   *                                         should be obtained in some other",
                "+   *                                         way.",
                "+   * @param  hash                            Indicates whether to generate a",
                "+   *                                         hash of the backup contents.",
                "+   * @param  signHash                        Indicates whether to sign the hash",
                "+   *                                         of the backup contents.",
                "+   * @param  maxMegabytesPerSecond           The maximum rate in megabytes per",
                "+   *                                         second at which the backup should",
                "+   *                                         be written.",
                "+   * @param  retainPreviousFullBackupCount   The minimum number of previous",
                "+   *                                         backups to retain.",
                "+   * @param  retainPreviousFullBackupAge     A string representation of the",
                "+   *                                         minimum age of previous backups to",
                "+   *                                         retain.  The age should be",
                "+   *                                         formatted in the same way as values",
                "+   *                                         for the {@link DurationArgument}",
                "+   *                                         class.",
                "+   * @param  scheduledStartTime              The time that this task should",
                "+   *                                         start running.",
                "+   * @param  dependencyIDs                   The list of task IDs that will be",
                "+   *                                         required to complete before this",
                "+   *                                         task will be eligible to start.",
                "+   * @param  failedDependencyAction          Indicates what action should be",
                "+   *                                         taken if any of the dependencies",
                "+   *                                         for this task do not complete",
                "+   *                                         successfully.",
                "+   * @param  notifyOnCompletion              The list of e-mail addresses of",
                "+   *                                         individuals that should be notified",
                "+   *                                         when this task completes.",
                "+   * @param  notifyOnError                   The list of e-mail addresses of",
                "+   *                                         individuals that should be notified",
                "+   *                                         if this task does not complete",
                "+   *                                         successfully.",
                "+   */",
                "+  public BackupTask(final String taskID, final String backupDirectory,",
                "+                    final List<String> backendIDs, final String backupID,",
                "+                    final boolean incremental, final String incrementalBaseID,",
                "+                    final boolean compress, final boolean encrypt,",
                "+                    final String encryptionPassphraseFile,",
                "+                    final String encryptionSettingsDefinitionID,",
                "+                    final boolean hash, final boolean signHash,",
                "+                    final Integer maxMegabytesPerSecond,",
                "+                    final Integer retainPreviousFullBackupCount,",
                "+                    final String retainPreviousFullBackupAge,",
                "+                    final Date scheduledStartTime,",
                "+                    final List<String> dependencyIDs,",
                "+                    final FailedDependencyAction failedDependencyAction,",
                "+                    final List<String> notifyOnCompletion,",
                "+                    final List<String> notifyOnError)",
                "   {",
                "@@ -433,10 +678,15 @@ public final class BackupTask",
                "-    this.backupDirectory   = backupDirectory;",
                "-    this.backupID          = backupID;",
                "-    this.incremental       = incremental;",
                "+    this.backupDirectory = backupDirectory;",
                "+    this.backupID = backupID;",
                "+    this.incremental = incremental;",
                "     this.incrementalBaseID = incrementalBaseID;",
                "-    this.compress          = compress;",
                "-    this.encrypt           = encrypt;",
                "-    this.hash              = hash;",
                "-    this.signHash          = signHash;",
                "+    this.compress = compress;",
                "+    this.encrypt = encrypt;",
                "+    this.encryptionPassphraseFile = encryptionPassphraseFile;",
                "+    this.encryptionSettingsDefinitionID = encryptionSettingsDefinitionID;",
                "+    this.hash = hash;",
                "+    this.signHash = signHash;",
                "+    this.maxMegabytesPerSecond = maxMegabytesPerSecond;",
                "+    this.retainPreviousFullBackupCount = retainPreviousFullBackupCount;",
                "+    this.retainPreviousFullBackupAge = retainPreviousFullBackupAge;",
                "@@ -501,2 +751,12 @@ public final class BackupTask",
                "+    // Get the path to the encryption passphrase file.  It may be absent.",
                "+    encryptionPassphraseFile =",
                "+         entry.getAttributeValue(ATTR_ENCRYPTION_PASSPHRASE_FILE);",
                "+",
                "+",
                "+    // Get the encryption settings definition ID.  It may be absent.",
                "+    encryptionSettingsDefinitionID =",
                "+         entry.getAttributeValue(ATTR_ENCRYPTION_SETTINGS_DEFINITION_ID);",
                "+",
                "+",
                "     // Determine whether to hash the backup.  It may be absent.",
                "@@ -507,2 +767,17 @@ public final class BackupTask",
                "     signHash = parseBooleanValue(entry, ATTR_SIGN_HASH, false);",
                "+",
                "+",
                "+    // Get the maximum write rate in megabytes per second.  It may be absent.",
                "+    maxMegabytesPerSecond =",
                "+         entry.getAttributeValueAsInteger(ATTR_MAX_MEGABYTES_PER_SECOND);",
                "+",
                "+",
                "+    // Get the retain previous full backup count.  It may be absent.",
                "+    retainPreviousFullBackupCount = entry.getAttributeValueAsInteger(",
                "+         ATTR_RETAIN_PREVIOUS_FULL_BACKUP_COUNT);",
                "+",
                "+",
                "+    // Get the retain previous full backup age.  It may be absent.",
                "+    retainPreviousFullBackupAge = entry.getAttributeValue(",
                "+         ATTR_RETAIN_PREVIOUS_FULL_BACKUP_AGE);",
                "   }",
                "@@ -526,11 +801,16 @@ public final class BackupTask",
                "-    boolean  c     = false;",
                "-    boolean  e     = false;",
                "-    boolean  h     = false;",
                "-    boolean  i     = false;",
                "-    boolean  s     = false;",
                "-    String   bDir  = null;",
                "-    String   bkID  = null;",
                "-    String   incID = null;",
                "-    String[] beIDs = StaticUtils.NO_STRINGS;",
                "+    boolean  c           = false;",
                "+    boolean  e           = false;",
                "+    boolean  h           = false;",
                "+    boolean  i           = false;",
                "+    boolean  s           = false;",
                "+    Integer  maxMB       = null;",
                "+    Integer  retainCount = null;",
                "+    String   bDir        = null;",
                "+    String   bkID        = null;",
                "+    String   incID       = null;",
                "+    String   encID       = null;",
                "+    String   encPWFile   = null;",
                "+    String   retainAge   = null;",
                "+    String[] beIDs       = StaticUtils.NO_STRINGS;",
                "@@ -571,2 +851,11 @@ public final class BackupTask",
                "       }",
                "+      else if (attrName.equalsIgnoreCase(ATTR_ENCRYPTION_PASSPHRASE_FILE))",
                "+      {",
                "+        encPWFile = parseString(p, values, encPWFile);",
                "+      }",
                "+      else if (attrName.equalsIgnoreCase(",
                "+           ATTR_ENCRYPTION_SETTINGS_DEFINITION_ID))",
                "+      {",
                "+        encID = parseString(p, values, encID);",
                "+      }",
                "       else if (attrName.equalsIgnoreCase(ATTR_HASH))",
                "@@ -579,2 +868,31 @@ public final class BackupTask",
                "       }",
                "+      else if (attrName.equalsIgnoreCase(ATTR_MAX_MEGABYTES_PER_SECOND))",
                "+      {",
                "+        final Long maxMBLong = parseLong(p, values, null);",
                "+        if (maxMBLong == null)",
                "+        {",
                "+          maxMB = null;",
                "+        }",
                "+        else",
                "+        {",
                "+          maxMB = maxMBLong.intValue();",
                "+        }",
                "+      }",
                "+      else if (attrName.equalsIgnoreCase(",
                "+           ATTR_RETAIN_PREVIOUS_FULL_BACKUP_COUNT))",
                "+      {",
                "+        final Long retainCountLong = parseLong(p, values, null);",
                "+        if (retainCountLong == null)",
                "+        {",
                "+          retainCount = null;",
                "+        }",
                "+        else",
                "+        {",
                "+          retainCount = retainCountLong.intValue();",
                "+        }",
                "+      }",
                "+      else if (attrName.equalsIgnoreCase(ATTR_RETAIN_PREVIOUS_FULL_BACKUP_AGE))",
                "+      {",
                "+        retainAge = parseString(p, values, retainAge);",
                "+      }",
                "     }",
                "@@ -587,11 +905,16 @@ public final class BackupTask",
                "-    backupDirectory   = bDir;",
                "-    backendIDs        = Arrays.asList(beIDs);",
                "-    backupID          = bkID;",
                "-    incremental       = i;",
                "+    backupDirectory = bDir;",
                "+    backendIDs = Arrays.asList(beIDs);",
                "+    backupID = bkID;",
                "+    incremental = i;",
                "     incrementalBaseID = incID;",
                "-    compress          = c;",
                "-    encrypt           = e;",
                "-    hash              = h;",
                "-    signHash          = s;",
                "+    compress = c;",
                "+    encrypt = e;",
                "+    encryptionPassphraseFile = encPWFile;",
                "+    encryptionSettingsDefinitionID = encID;",
                "+    hash = h;",
                "+    signHash = s;",
                "+    maxMegabytesPerSecond = maxMB;",
                "+    retainPreviousFullBackupCount = retainCount;",
                "+    retainPreviousFullBackupAge = retainAge;",
                "   }",
                "@@ -736,2 +1059,34 @@ public final class BackupTask",
                "+  /**",
                "+   * Retrieves the path to a file that contains the passphrase to use to",
                "+   * generate the encryption key.",
                "+   *",
                "+   * @return  The path to a file that contains the passphrase to use to",
                "+   *          generate the encryption key, or {@code null} if the backup should",
                "+   *          not be encrypted or if the encryption key should be obtained",
                "+   *          through some other means.",
                "+   */",
                "+  public String getEncryptionPassphraseFile()",
                "+  {",
                "+    return encryptionPassphraseFile;",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the identifier of the encryption settings definition to use to",
                "+   * generate the encryption key.",
                "+   *",
                "+   * @return  The identifier of the encryption settings definition to use to",
                "+   *          generate the encryption key, or {@code null} if the backup should",
                "+   *          not be encrypted or if the encryption key should be obtained",
                "+   *          through some other means.",
                "+   */",
                "+  public String getEncryptionSettingsDefinitionID()",
                "+  {",
                "+    return encryptionSettingsDefinitionID;",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -762,2 +1117,49 @@ public final class BackupTask",
                "+  /**",
                "+   * Retrieves the maximum rate, in megabytes per second, at which the backup",
                "+   * should be written.",
                "+   *",
                "+   * @return  The maximum rate, in megabytes per second, at which the backup",
                "+   *          should be written, or {@code null} if the writing should not be",
                "+   *          rate limited.",
                "+   */",
                "+  public Integer getMaxMegabytesPerSecond()",
                "+  {",
                "+    return maxMegabytesPerSecond;",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the minimum number of previous full backups that should be",
                "+   * retained if the new backup is created successfully.",
                "+   *",
                "+   * @return  The minimum number of previous full backups that should be",
                "+   *          retained if the new backup is created successfully, or",
                "+   *          {@code null} if no backups should be removed or if the backup age",
                "+   *          should be the only retention criteria.",
                "+   */",
                "+  public Integer getRetainPreviousFullBackupCount()",
                "+  {",
                "+    return retainPreviousFullBackupCount;",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves a string representation of the minimum age of previous full",
                "+   * backups that should be retained if the new backup is created successfully.",
                "+   *",
                "+   * @return  A string representation fo the minimum age of previous full",
                "+   *          backups that should be retained if the new backup is created",
                "+   *          successfully, or {@code null} if no backups should be removed or",
                "+   *          if the backup count should be the only retention criteria.",
                "+   */",
                "+  public String getRetainPreviousFullBackupAge()",
                "+  {",
                "+    return retainPreviousFullBackupAge;",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -779,3 +1181,3 @@ public final class BackupTask",
                "   {",
                "-    final ArrayList<Attribute> attrs = new ArrayList<Attribute>(9);",
                "+    final ArrayList<Attribute> attrs = new ArrayList<Attribute>(20);",
                "@@ -807,2 +1209,32 @@ public final class BackupTask",
                "+    if (encryptionPassphraseFile != null)",
                "+    {",
                "+      attrs.add(new Attribute(ATTR_ENCRYPTION_PASSPHRASE_FILE,",
                "+           encryptionPassphraseFile));",
                "+    }",
                "+",
                "+    if (encryptionSettingsDefinitionID != null)",
                "+    {",
                "+      attrs.add(new Attribute(ATTR_ENCRYPTION_SETTINGS_DEFINITION_ID,",
                "+           encryptionSettingsDefinitionID));",
                "+    }",
                "+",
                "+    if (maxMegabytesPerSecond != null)",
                "+    {",
                "+      attrs.add(new Attribute(ATTR_MAX_MEGABYTES_PER_SECOND,",
                "+           String.valueOf(maxMegabytesPerSecond)));",
                "+    }",
                "+",
                "+    if (retainPreviousFullBackupCount != null)",
                "+    {",
                "+      attrs.add(new Attribute(ATTR_RETAIN_PREVIOUS_FULL_BACKUP_COUNT,",
                "+           String.valueOf(retainPreviousFullBackupCount)));",
                "+    }",
                "+",
                "+    if (retainPreviousFullBackupAge != null)",
                "+    {",
                "+      attrs.add(new Attribute(ATTR_RETAIN_PREVIOUS_FULL_BACKUP_AGE,",
                "+           retainPreviousFullBackupAge));",
                "+    }",
                "+",
                "     return attrs;",
                "@@ -826,4 +1258,9 @@ public final class BackupTask",
                "          PROPERTY_ENCRYPT,",
                "+         PROPERTY_ENCRYPTION_PASSPHRASE_FILE,",
                "+         PROPERTY_ENCRYPTION_SETTINGS_DEFINITION_ID,",
                "          PROPERTY_HASH,",
                "-         PROPERTY_SIGN_HASH);",
                "+         PROPERTY_SIGN_HASH,",
                "+         PROPERTY_MAX_MEGABYTES_PER_SECOND,",
                "+         PROPERTY_RETAIN_PREVIOUS_FULL_BACKUP_COUNT,",
                "+         PROPERTY_RETAIN_PREVIOUS_FULL_BACKUP_AGE);",
                "@@ -879,2 +1316,25 @@ public final class BackupTask",
                "+    if (encryptionPassphraseFile == null)",
                "+    {",
                "+      props.put(PROPERTY_ENCRYPTION_PASSPHRASE_FILE, Collections.emptyList());",
                "+    }",
                "+    else",
                "+    {",
                "+      props.put(PROPERTY_ENCRYPTION_PASSPHRASE_FILE,",
                "+         Collections.<Object>unmodifiableList(Arrays.asList(",
                "+              encryptionPassphraseFile)));",
                "+    }",
                "+",
                "+    if (encryptionSettingsDefinitionID == null)",
                "+    {",
                "+      props.put(PROPERTY_ENCRYPTION_SETTINGS_DEFINITION_ID,",
                "+           Collections.emptyList());",
                "+    }",
                "+    else",
                "+    {",
                "+      props.put(PROPERTY_ENCRYPTION_SETTINGS_DEFINITION_ID,",
                "+         Collections.<Object>unmodifiableList(Arrays.asList(",
                "+              encryptionSettingsDefinitionID)));",
                "+    }",
                "+",
                "     props.put(PROPERTY_HASH,",
                "@@ -885,2 +1345,37 @@ public final class BackupTask",
                "+    if (maxMegabytesPerSecond == null)",
                "+    {",
                "+      props.put(PROPERTY_MAX_MEGABYTES_PER_SECOND, Collections.emptyList());",
                "+    }",
                "+    else",
                "+    {",
                "+      props.put(PROPERTY_MAX_MEGABYTES_PER_SECOND,",
                "+         Collections.<Object>unmodifiableList(Arrays.asList(",
                "+              maxMegabytesPerSecond.longValue())));",
                "+    }",
                "+",
                "+    if (retainPreviousFullBackupCount == null)",
                "+    {",
                "+      props.put(PROPERTY_RETAIN_PREVIOUS_FULL_BACKUP_COUNT,",
                "+           Collections.emptyList());",
                "+    }",
                "+    else",
                "+    {",
                "+      props.put(PROPERTY_RETAIN_PREVIOUS_FULL_BACKUP_COUNT,",
                "+         Collections.<Object>unmodifiableList(Arrays.asList(",
                "+              retainPreviousFullBackupCount.longValue())));",
                "+    }",
                "+",
                "+    if (retainPreviousFullBackupAge == null)",
                "+    {",
                "+      props.put(PROPERTY_RETAIN_PREVIOUS_FULL_BACKUP_AGE,",
                "+           Collections.emptyList());",
                "+    }",
                "+    else",
                "+    {",
                "+      props.put(PROPERTY_RETAIN_PREVIOUS_FULL_BACKUP_AGE,",
                "+         Collections.<Object>unmodifiableList(Arrays.asList(",
                "+              retainPreviousFullBackupAge)));",
                "+    }",
                "+",
                "     props.putAll(super.getTaskPropertyValues());",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/tasks/ExportTask.java b/src/com/unboundid/ldap/sdk/unboundidds/tasks/ExportTask.java",
                "index 7856917a..2e546ca1 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/tasks/ExportTask.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/tasks/ExportTask.java",
                "@@ -88,2 +88,8 @@ import static com.unboundid.util.Validator.*;",
                "  *       as it is written.</LI>",
                "+ *   <LI>The path to a file containing a passphrase to use to generate the",
                "+ *       encryption key.</LI>",
                "+ *   <LI>The ID of the encryption settings definition to use to generate the",
                "+ *       encryption key.</LI>",
                "+ *   <LI>The maximum rate in megabytes per second at which the LDIF file should",
                "+ *       be written.</LI>",
                "  * </UL>",
                "@@ -137,2 +143,21 @@ public final class ExportTask",
                "+  /**",
                "+   * The name of the attribute used to specify the path to a file that contains",
                "+   * the passphrase to use to generate the encryption key.",
                "+   */",
                "+  private static final String ATTR_ENCRYPTION_PASSPHRASE_FILE =",
                "+       \"ds-task-export-encryption-passphrase-file\";",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * The name of the attribute used to specify the path to a file that contains",
                "+   * the ID of the encryption settings definition to use to generate the",
                "+   * encryption key.",
                "+   */",
                "+  private static final String ATTR_ENCRYPTION_SETTINGS_DEFINITION_ID =",
                "+       \"ds-task-export-encryption-settings-definition-id\";",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -199,2 +224,11 @@ public final class ExportTask",
                "+  /**",
                "+   * The name of the attribute used to specify the maximum LDIF write rate in",
                "+   * megabytes per second.",
                "+   */",
                "+  private static final String ATTR_MAX_MEGABYTES_PER_SECOND =",
                "+       \"ds-task-export-max-megabytes-per-second\";",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -349,2 +383,25 @@ public final class ExportTask",
                "+  /**",
                "+   * The task property that will be used for the encryption passphrase file.",
                "+   */",
                "+  private static final TaskProperty PROPERTY_ENCRYPTION_PASSPHRASE_FILE =",
                "+       new TaskProperty(ATTR_ENCRYPTION_PASSPHRASE_FILE,",
                "+            INFO_DISPLAY_NAME_ENCRYPTION_PASSPHRASE_FILE.get(),",
                "+            INFO_DESCRIPTION_ENCRYPTION_PASSPHRASE_FILE.get(),",
                "+            String.class, false, false, true);",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * The task property that will be used for the encryption settings definition",
                "+   * ID.",
                "+   */",
                "+  private static final TaskProperty PROPERTY_ENCRYPTION_SETTINGS_DEFINITION_ID =",
                "+       new TaskProperty(ATTR_ENCRYPTION_SETTINGS_DEFINITION_ID,",
                "+            INFO_DISPLAY_NAME_ENCRYPTION_SETTINGS_DEFINITION_ID.get(),",
                "+            INFO_DESCRIPTION_ENCRYPTION_SETTINGS_DEFINITION_ID.get(),",
                "+            String.class, false, false, true);",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -359,2 +416,14 @@ public final class ExportTask",
                "+  /**",
                "+   * The task property that will be used for the maximum write rate in megabytes",
                "+   * per second.",
                "+   */",
                "+  private static final TaskProperty PROPERTY_MAX_MEGABYTES_PER_SECOND =",
                "+       new TaskProperty(ATTR_MAX_MEGABYTES_PER_SECOND,",
                "+            INFO_DISPLAY_NAME_EXPORT_MAX_MEGABYTES_PER_SECOND.get(),",
                "+            INFO_DESCRIPTION_EXPORT_MAX_MEGABYTES_PER_SECOND.get(),",
                "+            Long.class, false, false, true);",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -362,3 +431,3 @@ public final class ExportTask",
                "    */",
                "-  private static final long serialVersionUID = 5489855404880345160L;",
                "+  private static final long serialVersionUID = -6807534587873728959L;",
                "@@ -381,2 +450,5 @@ public final class ExportTask",
                "+  // The maximum write rate in megabytes per second.",
                "+  private final Integer maxMegabytesPerSecond;",
                "+",
                "   // The set of attributes to exclude from the export.",
                "@@ -402,2 +474,10 @@ public final class ExportTask",
                "+  // The path to a file containing the passphrase to use to generate the",
                "+  // encryption key.",
                "+  private final String encryptionPassphraseFile;",
                "+",
                "+  // The identifier for the encryption settings definition to use to generate",
                "+  // the encryption key.",
                "+  private final String encryptionSettingsDefinitionID;",
                "+",
                "   // The path to the LDIF file to generate.",
                "@@ -415,15 +495,18 @@ public final class ExportTask",
                "   {",
                "-    appendToLDIF      = false;",
                "-    compress          = false;",
                "-    encrypt           = false;",
                "-    sign              = false;",
                "-    wrapColumn        = -1;",
                "+    appendToLDIF = false;",
                "+    compress = false;",
                "+    encrypt = false;",
                "+    sign = false;",
                "+    wrapColumn = -1;",
                "+    maxMegabytesPerSecond = null;",
                "+    encryptionPassphraseFile = null;",
                "+    encryptionSettingsDefinitionID = null;",
                "     excludeAttributes = null;",
                "-    excludeBranches   = null;",
                "-    excludeFilters    = null;",
                "+    excludeBranches = null;",
                "+    excludeFilters = null;",
                "     includeAttributes = null;",
                "-    includeBranches   = null;",
                "-    includeFilters    = null;",
                "-    backendID         = null;",
                "-    ldifFile          = null;",
                "+    includeBranches = null;",
                "+    includeFilters = null;",
                "+    backendID = null;",
                "+    ldifFile = null;",
                "   }",
                "@@ -531,2 +614,124 @@ public final class ExportTask",
                "                     final List<String> notifyOnError)",
                "+  {",
                "+    this(taskID, backendID, ldifFile, appendToLDIF, includeBranches,",
                "+         excludeBranches, includeFilters, excludeFilters, includeAttributes,",
                "+         excludeAttributes, wrapColumn, compress, encrypt, null, null, sign,",
                "+         null, scheduledStartTime, dependencyIDs, failedDependencyAction,",
                "+         notifyOnCompletion, notifyOnError);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new export task with the provided information.",
                "+   *",
                "+   * @param  taskID                          The task ID to use for this task.",
                "+   *                                         If it is {@code null} then a UUID",
                "+   *                                         will be generated for use as the",
                "+   *                                         task ID.",
                "+   * @param  backendID                       The backend ID of the backend to be",
                "+   *                                         exported.  It must not be",
                "+   *                                         {@code null}.",
                "+   * @param  ldifFile                        The path to the LDIF file to be",
                "+   *                                         written.  It may be an absolute",
                "+   *                                         path or one that is relative to the",
                "+   *                                         server root.  It must not be",
                "+   *                                         {@code null}.",
                "+   * @param  appendToLDIF                    Indicates whether to an append to",
                "+   *                                         any existing file rather than",
                "+   *                                         overwriting it.",
                "+   * @param  includeBranches                 The set of base DNs of entries to",
                "+   *                                         include in the export.  It may be",
                "+   *                                         {@code null} or empty if no entries",
                "+   *                                         should be excluded based on their",
                "+   *                                         location.",
                "+   * @param  excludeBranches                 The set of base DNs of entries to",
                "+   *                                         exclude from the export.  It may be",
                "+   *                                         {@code null} or empty if no entries",
                "+   *                                         should be excluded based on their",
                "+   *                                         location.",
                "+   * @param  includeFilters                  The set of filters to use to match",
                "+   *                                         entries that should be included in",
                "+   *                                         the export.  It may be {@code null}",
                "+   *                                         or empty if no entries should be",
                "+   *                                         excluded based on their content.",
                "+   * @param  excludeFilters                  The set of filters to use to match",
                "+   *                                         entries that should be excluded",
                "+   *                                         from the export.  It may be",
                "+   *                                         {@code null} or empty if no entries",
                "+   *                                         should be excluded based on their",
                "+   *                                         content.",
                "+   * @param  includeAttributes               The set of attributes that should",
                "+   *                                         be included in exported entries.",
                "+   *                                         It may be {@code null} or empty if",
                "+   *                                         all attributes should be included.",
                "+   * @param  excludeAttributes               The set of attributes that should",
                "+   *                                         be excluded from exported entries.",
                "+   *                                         It may be {@code null} or empty if",
                "+   *                                         no attributes should be excluded.",
                "+   * @param  wrapColumn                      The column at which long lines",
                "+   *                                         should be wrapped.  It may be less",
                "+   *                                         than or equal to zero to indicate",
                "+   *                                         that long lines should not be",
                "+   *                                         wrapped.",
                "+   * @param  compress                        Indicates whether the LDIF data",
                "+   *                                         should be compressed as it is",
                "+   *                                         written.",
                "+   * @param  encrypt                         Indicates whether the LDIF data",
                "+   *                                         should be encrypted as it is",
                "+   *                                         written.",
                "+   * @param  encryptionPassphraseFile        The path to a file containing the",
                "+   *                                         passphrase to use to generate the",
                "+   *                                         encryption key.  It amy be",
                "+   *                                         {@code null} if the LDIF file is",
                "+   *                                         not to be encrypted, or if the key",
                "+   *                                         should be obtained in some other",
                "+   *                                         way.",
                "+   * @param  encryptionSettingsDefinitionID  The ID of the encryption settings",
                "+   *                                         definition use to generate the",
                "+   *                                         encryption key.  It may be",
                "+   *                                         {@code null} if the LDIF file is",
                "+   *                                         not to be encrypted, or if the key",
                "+   *                                         should be obtained in some other",
                "+   *                                         way.",
                "+   * @param  sign                            Indicates whether to include a",
                "+   *                                         signed hash of the content in the",
                "+   *                                         exported data.",
                "+   * @param  maxMegabytesPerSecond           The maximum rate in megabytes per",
                "+   *                                         second at which the LDIF file",
                "+   *                                         should be written.",
                "+   * @param  scheduledStartTime              The time that this task should",
                "+   *                                         start running.",
                "+   * @param  dependencyIDs                   The list of task IDs that will be",
                "+   *                                         required to complete before this",
                "+   *                                         task will be eligible to start.",
                "+   * @param  failedDependencyAction          Indicates what action should be",
                "+   *                                         taken if any of the dependencies",
                "+   *                                         for this task do not complete",
                "+   *                                         successfully.",
                "+   * @param  notifyOnCompletion              The list of e-mail addresses of",
                "+   *                                         individuals that should be notified",
                "+   *                                         when this task completes.",
                "+   * @param  notifyOnError                   The list of e-mail addresses of",
                "+   *                                         individuals that should be notified",
                "+   *                                         if this task does not complete",
                "+   *                                         successfully.",
                "+   */",
                "+  public ExportTask(final String taskID, final String backendID,",
                "+                    final String ldifFile, final boolean appendToLDIF,",
                "+                    final List<String> includeBranches,",
                "+                    final List<String> excludeBranches,",
                "+                    final List<String> includeFilters,",
                "+                    final List<String> excludeFilters,",
                "+                    final List<String> includeAttributes,",
                "+                    final List<String> excludeAttributes, final int wrapColumn,",
                "+                    final boolean compress, final boolean encrypt,",
                "+                    final String encryptionPassphraseFile,",
                "+                    final String encryptionSettingsDefinitionID,",
                "+                    final boolean sign, final Integer maxMegabytesPerSecond,",
                "+                    final Date scheduledStartTime,",
                "+                    final List<String> dependencyIDs,",
                "+                    final FailedDependencyAction failedDependencyAction,",
                "+                    final List<String> notifyOnCompletion,",
                "+                    final List<String> notifyOnError)",
                "   {",
                "@@ -538,9 +743,12 @@ public final class ExportTask",
                "-    this.backendID    = backendID;",
                "-    this.ldifFile     = ldifFile;",
                "+    this.backendID = backendID;",
                "+    this.ldifFile = ldifFile;",
                "     this.appendToLDIF = appendToLDIF;",
                "-    this.wrapColumn   = wrapColumn;",
                "-    this.compress     = compress;",
                "-    this.encrypt      = encrypt;",
                "-    this.sign         = sign;",
                "+    this.wrapColumn = wrapColumn;",
                "+    this.compress = compress;",
                "+    this.encrypt = encrypt;",
                "+    this.encryptionPassphraseFile = encryptionPassphraseFile;",
                "+    this.encryptionSettingsDefinitionID = encryptionSettingsDefinitionID;",
                "+    this.sign = sign;",
                "+    this.maxMegabytesPerSecond = maxMegabytesPerSecond;",
                "@@ -692,4 +900,19 @@ public final class ExportTask",
                "+    // Get the path to the encryption passphrase file.  It may be absent.",
                "+    encryptionPassphraseFile =",
                "+         entry.getAttributeValue(ATTR_ENCRYPTION_PASSPHRASE_FILE);",
                "+",
                "+",
                "+    // Get the encryption settings definition ID.  It may be absent.",
                "+    encryptionSettingsDefinitionID =",
                "+         entry.getAttributeValue(ATTR_ENCRYPTION_SETTINGS_DEFINITION_ID);",
                "+",
                "+",
                "     // Get the sign flag.  It may be absent.",
                "     sign = parseBooleanValue(entry, ATTR_SIGN, false);",
                "+",
                "+",
                "+    // Get the maximum write rate in megabytes per second.  It may be absent.",
                "+    maxMegabytesPerSecond =",
                "+         entry.getAttributeValueAsInteger(ATTR_MAX_MEGABYTES_PER_SECOND);",
                "   }",
                "@@ -713,15 +936,18 @@ public final class ExportTask",
                "-    boolean  a  = false;",
                "-    boolean  c  = false;",
                "-    boolean  e  = false;",
                "-    boolean  s  = false;",
                "-    long     w  = 0;",
                "-    String   b  = null;",
                "-    String   l  = null;",
                "-    String[] eA = StaticUtils.NO_STRINGS;",
                "-    String[] eB = StaticUtils.NO_STRINGS;",
                "-    String[] eF = StaticUtils.NO_STRINGS;",
                "-    String[] iA = StaticUtils.NO_STRINGS;",
                "-    String[] iB = StaticUtils.NO_STRINGS;",
                "-    String[] iF = StaticUtils.NO_STRINGS;",
                "+    boolean  a         = false;",
                "+    boolean  c         = false;",
                "+    boolean  e         = false;",
                "+    boolean  s         = false;",
                "+    Integer  maxMB     = null;",
                "+    long     w         = 0;",
                "+    String   b         = null;",
                "+    String   encID     = null;",
                "+    String   encPWFile = null;",
                "+    String   l         = null;",
                "+    String[] eA        = StaticUtils.NO_STRINGS;",
                "+    String[] eB        = StaticUtils.NO_STRINGS;",
                "+    String[] eF        = StaticUtils.NO_STRINGS;",
                "+    String[] iA        = StaticUtils.NO_STRINGS;",
                "+    String[] iB        = StaticUtils.NO_STRINGS;",
                "+    String[] iF        = StaticUtils.NO_STRINGS;",
                "@@ -782,2 +1008,11 @@ public final class ExportTask",
                "       }",
                "+      else if (attrName.equalsIgnoreCase(ATTR_ENCRYPTION_PASSPHRASE_FILE))",
                "+      {",
                "+        encPWFile = parseString(p, values, encPWFile);",
                "+      }",
                "+      else if (attrName.equalsIgnoreCase(",
                "+           ATTR_ENCRYPTION_SETTINGS_DEFINITION_ID))",
                "+      {",
                "+        encID = parseString(p, values, encID);",
                "+      }",
                "       else if (attrName.equalsIgnoreCase(ATTR_SIGN))",
                "@@ -786,2 +1021,14 @@ public final class ExportTask",
                "       }",
                "+      else if (attrName.equalsIgnoreCase(ATTR_MAX_MEGABYTES_PER_SECOND))",
                "+      {",
                "+        final Long maxMBLong = parseLong(p, values, null);",
                "+        if (maxMBLong == null)",
                "+        {",
                "+          maxMB = null;",
                "+        }",
                "+        else",
                "+        {",
                "+          maxMB = maxMBLong.intValue();",
                "+        }",
                "+      }",
                "     }",
                "@@ -800,15 +1047,18 @@ public final class ExportTask",
                "-    backendID         = b;",
                "-    ldifFile          = l;",
                "-    appendToLDIF      = a;",
                "+    backendID = b;",
                "+    ldifFile = l;",
                "+    appendToLDIF = a;",
                "     includeAttributes = Collections.unmodifiableList(Arrays.asList(iA));",
                "     excludeAttributes = Collections.unmodifiableList(Arrays.asList(eA));",
                "-    includeBranches   = Collections.unmodifiableList(Arrays.asList(iB));",
                "-    excludeBranches   = Collections.unmodifiableList(Arrays.asList(eB));",
                "-    includeFilters    = Collections.unmodifiableList(Arrays.asList(iF));",
                "-    excludeFilters    = Collections.unmodifiableList(Arrays.asList(eF));",
                "-    wrapColumn        = (int) w;",
                "-    compress          = c;",
                "-    encrypt           = e;",
                "-    sign              = s;",
                "+    includeBranches = Collections.unmodifiableList(Arrays.asList(iB));",
                "+    excludeBranches = Collections.unmodifiableList(Arrays.asList(eB));",
                "+    includeFilters = Collections.unmodifiableList(Arrays.asList(iF));",
                "+    excludeFilters = Collections.unmodifiableList(Arrays.asList(eF));",
                "+    wrapColumn = (int) w;",
                "+    compress = c;",
                "+    encrypt = e;",
                "+    encryptionPassphraseFile = encPWFile;",
                "+    encryptionSettingsDefinitionID = encID;",
                "+    sign = s;",
                "+    maxMegabytesPerSecond = maxMB;",
                "   }",
                "@@ -1010,2 +1260,34 @@ public final class ExportTask",
                "+  /**",
                "+   * Retrieves the path to a file that contains the passphrase to use to",
                "+   * generate the encryption key.",
                "+   *",
                "+   * @return  The path to a file that contains the passphrase to use to",
                "+   *          generate the encryption key, or {@code null} if the LDIF file",
                "+   *          should not be encrypted or if the encryption key should be",
                "+   *          obtained through some other means.",
                "+   */",
                "+  public String getEncryptionPassphraseFile()",
                "+  {",
                "+    return encryptionPassphraseFile;",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Retrieves the identifier of the encryption settings definition to use to",
                "+   * generate the encryption key.",
                "+   *",
                "+   * @return  The identifier of the encryption settings definition to use to",
                "+   *          generate the encryption key, or {@code null} if the LDIF file",
                "+   *          should not be encrypted or if the encryption key should be",
                "+   *          obtained through some other means.",
                "+   */",
                "+  public String getEncryptionSettingsDefinitionID()",
                "+  {",
                "+    return encryptionSettingsDefinitionID;",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -1023,2 +1305,17 @@ public final class ExportTask",
                "+  /**",
                "+   * Retrieves the maximum rate, in megabytes per second, at which the LDIF file",
                "+   * should be written.",
                "+   *",
                "+   * @return  The maximum rate, in megabytes per second, at which the LDIF file",
                "+   *          should be written, or {@code null} if the writing should not be",
                "+   *          rate limited.",
                "+   */",
                "+  public Integer getMaxMegabytesPerSecond()",
                "+  {",
                "+    return maxMegabytesPerSecond;",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -1040,3 +1337,3 @@ public final class ExportTask",
                "   {",
                "-    final ArrayList<Attribute> attrs = new ArrayList<Attribute>(13);",
                "+    final ArrayList<Attribute> attrs = new ArrayList<Attribute>(20);",
                "@@ -1084,2 +1381,20 @@ public final class ExportTask",
                "+    if (encryptionPassphraseFile != null)",
                "+    {",
                "+      attrs.add(new Attribute(ATTR_ENCRYPTION_PASSPHRASE_FILE,",
                "+           encryptionPassphraseFile));",
                "+    }",
                "+",
                "+    if (encryptionSettingsDefinitionID != null)",
                "+    {",
                "+      attrs.add(new Attribute(ATTR_ENCRYPTION_SETTINGS_DEFINITION_ID,",
                "+           encryptionSettingsDefinitionID));",
                "+    }",
                "+",
                "+    if (maxMegabytesPerSecond != null)",
                "+    {",
                "+      attrs.add(new Attribute(ATTR_MAX_MEGABYTES_PER_SECOND,",
                "+           String.valueOf(maxMegabytesPerSecond)));",
                "+    }",
                "+",
                "     return attrs;",
                "@@ -1108,3 +1423,6 @@ public final class ExportTask",
                "          PROPERTY_ENCRYPT,",
                "-         PROPERTY_SIGN);",
                "+         PROPERTY_ENCRYPTION_PASSPHRASE_FILE,",
                "+         PROPERTY_ENCRYPTION_SETTINGS_DEFINITION_ID,",
                "+         PROPERTY_SIGN,",
                "+         PROPERTY_MAX_MEGABYTES_PER_SECOND);",
                "@@ -1162,2 +1480,25 @@ public final class ExportTask",
                "+    if (encryptionPassphraseFile == null)",
                "+    {",
                "+      props.put(PROPERTY_ENCRYPTION_PASSPHRASE_FILE, Collections.emptyList());",
                "+    }",
                "+    else",
                "+    {",
                "+      props.put(PROPERTY_ENCRYPTION_PASSPHRASE_FILE,",
                "+         Collections.<Object>unmodifiableList(Arrays.asList(",
                "+              encryptionPassphraseFile)));",
                "+    }",
                "+",
                "+    if (encryptionSettingsDefinitionID == null)",
                "+    {",
                "+      props.put(PROPERTY_ENCRYPTION_SETTINGS_DEFINITION_ID,",
                "+           Collections.emptyList());",
                "+    }",
                "+    else",
                "+    {",
                "+      props.put(PROPERTY_ENCRYPTION_SETTINGS_DEFINITION_ID,",
                "+         Collections.<Object>unmodifiableList(Arrays.asList(",
                "+              encryptionSettingsDefinitionID)));",
                "+    }",
                "+",
                "     props.put(PROPERTY_SIGN,",
                "@@ -1165,2 +1506,13 @@ public final class ExportTask",
                "+    if (maxMegabytesPerSecond == null)",
                "+    {",
                "+      props.put(PROPERTY_MAX_MEGABYTES_PER_SECOND, Collections.emptyList());",
                "+    }",
                "+    else",
                "+    {",
                "+      props.put(PROPERTY_MAX_MEGABYTES_PER_SECOND,",
                "+         Collections.<Object>unmodifiableList(Arrays.asList(",
                "+              maxMegabytesPerSecond.longValue())));",
                "+    }",
                "+",
                "     props.putAll(super.getTaskPropertyValues());",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/tasks/ImportTask.java b/src/com/unboundid/ldap/sdk/unboundidds/tasks/ImportTask.java",
                "index 33b08f36..08a3ddb6 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/tasks/ImportTask.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/tasks/ImportTask.java",
                "@@ -96,2 +96,4 @@ import static com.unboundid.util.Validator.*;",
                "  *       that is imported.</LI>",
                "+ *   <LI>The path to a file containing a passphrase to use to generate the",
                "+ *       encryption key.</LI>",
                "  * </UL>",
                "@@ -138,2 +140,11 @@ public final class ImportTask",
                "+  /**",
                "+   * The name of the attribute used to specify the path to a file that contains",
                "+   * the passphrase to use to generate the encryption key.",
                "+   */",
                "+  private static final String ATTR_ENCRYPTION_PASSPHRASE_FILE =",
                "+       \"ds-task-import-encryption-passphrase-file\";",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -423,2 +434,13 @@ public final class ImportTask",
                "+  /**",
                "+   * The task property that will be used for the encryption passphrase file.",
                "+   */",
                "+  private static final TaskProperty PROPERTY_ENCRYPTION_PASSPHRASE_FILE =",
                "+       new TaskProperty(ATTR_ENCRYPTION_PASSPHRASE_FILE,",
                "+            INFO_DISPLAY_NAME_ENCRYPTION_PASSPHRASE_FILE.get(),",
                "+            INFO_DESCRIPTION_ENCRYPTION_PASSPHRASE_FILE.get(),",
                "+            String.class, false, false, true);",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -455,3 +477,3 @@ public final class ImportTask",
                "    */",
                "-  private static final long serialVersionUID = -8451067488894354839L;",
                "+  private static final long serialVersionUID = 9114913680318281750L;",
                "@@ -508,2 +530,6 @@ public final class ImportTask",
                "+  // The path to a file containing the passphrase to use to generate the",
                "+  // encryption key.",
                "+  private final String encryptionPassphraseFile;",
                "+",
                "   // The path to the reject file to write.",
                "@@ -521,19 +547,20 @@ public final class ImportTask",
                "   {",
                "-    append               = false;",
                "-    clearBackend         = false;",
                "-    isCompressed         = false;",
                "-    isEncrypted          = false;",
                "-    overwriteRejects     = false;",
                "-    replaceExisting      = false;",
                "+    append = false;",
                "+    clearBackend = false;",
                "+    isCompressed = false;",
                "+    isEncrypted = false;",
                "+    overwriteRejects = false;",
                "+    replaceExisting = false;",
                "     skipSchemaValidation = false;",
                "-    stripTrailingSpaces  = false;",
                "-    excludeAttributes    = null;",
                "-    excludeBranches      = null;",
                "-    excludeFilters       = null;",
                "-    includeAttributes    = null;",
                "-    includeBranches      = null;",
                "-    includeFilters       = null;",
                "-    ldifFiles            = null;",
                "-    backendID            = null;",
                "-    rejectFile           = null;",
                "+    stripTrailingSpaces = false;",
                "+    encryptionPassphraseFile = null;",
                "+    excludeAttributes = null;",
                "+    excludeBranches = null;",
                "+    excludeFilters = null;",
                "+    includeAttributes = null;",
                "+    includeBranches = null;",
                "+    includeFilters = null;",
                "+    ldifFiles = null;",
                "+    backendID = null;",
                "+    rejectFile = null;",
                "   }",
                "@@ -790,2 +817,130 @@ public final class ImportTask",
                "                     final List<String> notifyOnError)",
                "+  {",
                "+    this(taskID, ldifFiles, backendID, append, replaceExisting, rejectFile,",
                "+         overwriteRejects, clearBackend, includeBranches, excludeBranches,",
                "+         includeFilters, excludeFilters, includeAttributes, excludeAttributes,",
                "+         isCompressed, isEncrypted, null, skipSchemaValidation,",
                "+         stripTrailingSpaces, scheduledStartTime, dependencyIDs,",
                "+         failedDependencyAction, notifyOnCompletion, notifyOnError);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new import task with the provided information.",
                "+   *",
                "+   * @param  taskID                    The task ID to use for this task.  If it",
                "+   *                                   is {@code null} then a UUID will be",
                "+   *                                   generated for use as the task ID.",
                "+   * @param  ldifFiles                 The paths to the LDIF file containing the",
                "+   *                                   data to be imported.  The paths may be",
                "+   *                                   either absolute or relative to the server",
                "+   *                                   install root.  It must not be",
                "+   *                                   {@code null} or empty.",
                "+   * @param  backendID                 The backend ID of the backend into which",
                "+   *                                   the data should be imported.  It may be",
                "+   *                                   {@code null} only if one or more include",
                "+   *                                   branches was specified.",
                "+   * @param  append                    Indicates whether to append to the",
                "+   *                                   existing data rather than overwriting it.",
                "+   * @param  replaceExisting           Indicates whether to replace existing",
                "+   *                                   entries when appending to the database.",
                "+   * @param  rejectFile                The path to a file into which",
                "+   *                                   information will be written about",
                "+   *                                   rejected entries.  It may be {@code null}",
                "+   *                                   if no reject file is to be maintained.",
                "+   * @param  overwriteRejects          Indicates whether to overwrite an",
                "+   *                                   existing rejects file rather than",
                "+   *                                   appending to it.",
                "+   * @param  clearBackend              Indicates whether to clear data below all",
                "+   *                                   base DNs in the backend.  It must be",
                "+   *                                   {@code true} if the backend was specified",
                "+   *                                   using a backend ID and no include",
                "+   *                                   branches are specified and {@code append}",
                "+   *                                   is {@code false}.  If include branches",
                "+   *                                   were specified, or if data is being",
                "+   *                                   appended to the backend, then it may be",
                "+   *                                   either {@code true} or {@code false}.",
                "+   * @param  includeBranches           The set of base DNs below which to import",
                "+   *                                   the data.  It may be {@code null} or",
                "+   *                                   empty if a backend ID was specified and",
                "+   *                                   data should be imported below all base",
                "+   *                                   DNs defined in the backend.  Otherwise,",
                "+   *                                   at least one include branch must be",
                "+   *                                   provided, and any data not under one of",
                "+   *                                   the include branches will be excluded",
                "+   *                                   from the import.  All include branches",
                "+   *                                   must be within the scope of the same",
                "+   *                                   backend.",
                "+   * @param  excludeBranches           The set of base DNs to exclude from the",
                "+   *                                   import.  It may be {@code null} or empty",
                "+   *                                   if no data is to be excluded based on its",
                "+   *                                   location.",
                "+   * @param  includeFilters            The set of filters to use to determine",
                "+   *                                   which entries should be included in the",
                "+   *                                   import.  It may be {@code null} or empty",
                "+   *                                   if no data is to be excluded based on its",
                "+   *                                   content.",
                "+   * @param  excludeFilters            The set of filters to use to determine",
                "+   *                                   which entries should be excluded from the",
                "+   *                                   import.  It may be {@code null} or empty",
                "+   *                                   if no data is to be excluded based on its",
                "+   *                                   content.",
                "+   * @param  includeAttributes         The set of attributes to include in the",
                "+   *                                   entries being imported.  It may be",
                "+   *                                   {@code null} or empty if no attributes",
                "+   *                                   should be excluded from the import.",
                "+   * @param  excludeAttributes         The set of attributes to exclude from the",
                "+   *                                   entries being imported.  It may be",
                "+   *                                   {@code null} or empty if no attributes",
                "+   *                                   should be excluded from the import.",
                "+   * @param  isCompressed              Indicates whether the data in the LDIF",
                "+   *                                   file(s) is compressed.",
                "+   * @param  isEncrypted               Indicates whether the data in the LDIF",
                "+   *                                   file(s) is encrypted.",
                "+   * @param  encryptionPassphraseFile  The path to a file containing the",
                "+   *                                   passphrase to use to generate the",
                "+   *                                   encryption key.  It amy be {@code null}",
                "+   *                                   if the backup is not to be encrypted, or",
                "+   *                                   if the key should be obtained in some",
                "+   *                                   other way.",
                "+   * @param  skipSchemaValidation      Indicates whether to skip schema",
                "+   *                                   validation during the import.",
                "+   * @param  stripTrailingSpaces       Indicates whether to strip illegal",
                "+   *                                   trailing spaces found in LDIF records",
                "+   *                                   rather than rejecting those records.",
                "+   * @param  scheduledStartTime        The time that this task should start",
                "+   *                                   running.",
                "+   * @param  dependencyIDs             The list of task IDs that will be",
                "+   *                                   required to complete before this task",
                "+   *                                   will be eligible to start.",
                "+   * @param  failedDependencyAction    Indicates what action should be taken if",
                "+   *                                   any of the dependencies for this task do",
                "+   *                                   not complete successfully.",
                "+   * @param  notifyOnCompletion        The list of e-mail addresses of",
                "+   *                                   individuals that should be notified when",
                "+   *                                   this task completes.",
                "+   * @param  notifyOnError             The list of e-mail addresses of",
                "+   *                                   individuals that should be notified if",
                "+   *                                   this task does not complete successfully.",
                "+   */",
                "+  public ImportTask(final String taskID, final List<String> ldifFiles,",
                "+                    final String backendID, final boolean append,",
                "+                    final boolean replaceExisting, final String rejectFile,",
                "+                    final boolean overwriteRejects, final boolean clearBackend,",
                "+                    final List<String> includeBranches,",
                "+                    final List<String> excludeBranches,",
                "+                    final List<String> includeFilters,",
                "+                    final List<String> excludeFilters,",
                "+                    final List<String> includeAttributes,",
                "+                    final List<String> excludeAttributes,",
                "+                    final boolean isCompressed, final boolean isEncrypted,",
                "+                    final String encryptionPassphraseFile,",
                "+                    final boolean skipSchemaValidation,",
                "+                    final boolean stripTrailingSpaces,",
                "+                    final Date scheduledStartTime,",
                "+                    final List<String> dependencyIDs,",
                "+                    final FailedDependencyAction failedDependencyAction,",
                "+                    final List<String> notifyOnCompletion,",
                "+                    final List<String> notifyOnError)",
                "   {",
                "@@ -803,13 +958,14 @@ public final class ImportTask",
                "-    this.ldifFiles            = Collections.unmodifiableList(ldifFiles);",
                "-    this.backendID            = backendID;",
                "-    this.append               = append;",
                "-    this.replaceExisting      = replaceExisting;",
                "-    this.rejectFile           = rejectFile;",
                "-    this.overwriteRejects     = overwriteRejects;",
                "-    this.clearBackend         = clearBackend;",
                "-    this.isCompressed         = isCompressed;",
                "-    this.isEncrypted          = isEncrypted;",
                "+    this.ldifFiles = Collections.unmodifiableList(ldifFiles);",
                "+    this.backendID = backendID;",
                "+    this.append = append;",
                "+    this.replaceExisting = replaceExisting;",
                "+    this.rejectFile = rejectFile;",
                "+    this.overwriteRejects = overwriteRejects;",
                "+    this.clearBackend = clearBackend;",
                "+    this.isCompressed = isCompressed;",
                "+    this.isEncrypted = isEncrypted;",
                "+    this.encryptionPassphraseFile = encryptionPassphraseFile;",
                "     this.skipSchemaValidation = skipSchemaValidation;",
                "-    this.stripTrailingSpaces  = stripTrailingSpaces;",
                "+    this.stripTrailingSpaces = stripTrailingSpaces;",
                "@@ -954,2 +1110,7 @@ public final class ImportTask",
                "+    // Get the path to the encryption passphrase file.  It may be absent.",
                "+    encryptionPassphraseFile =",
                "+         entry.getAttributeValue(ATTR_ENCRYPTION_PASSPHRASE_FILE);",
                "+",
                "+",
                "     // Get the skipSchemaValidation flag.  It may be absent.",
                "@@ -990,2 +1151,3 @@ public final class ImportTask",
                "     String   b  = null;",
                "+    String   pF = null;",
                "     String   rF = null;",
                "@@ -1066,2 +1228,6 @@ public final class ImportTask",
                "       }",
                "+      else if (attrName.equalsIgnoreCase(ATTR_ENCRYPTION_PASSPHRASE_FILE))",
                "+      {",
                "+        pF = parseString(p, values, pF);",
                "+      }",
                "       else if (attrName.equalsIgnoreCase(ATTR_SKIP_SCHEMA_VALIDATION))",
                "@@ -1089,19 +1255,20 @@ public final class ImportTask",
                "-    backendID            = b;",
                "-    ldifFiles            = Collections.unmodifiableList(Arrays.asList(l));",
                "-    append               = a;",
                "-    replaceExisting      = r;",
                "-    rejectFile           = rF;",
                "-    overwriteRejects     = o;",
                "-    clearBackend         = cB;",
                "-    includeAttributes    = Collections.unmodifiableList(Arrays.asList(iA));",
                "-    excludeAttributes    = Collections.unmodifiableList(Arrays.asList(eA));",
                "-    includeBranches      = Collections.unmodifiableList(Arrays.asList(iB));",
                "-    excludeBranches      = Collections.unmodifiableList(Arrays.asList(eB));",
                "-    includeFilters       = Collections.unmodifiableList(Arrays.asList(iF));",
                "-    excludeFilters       = Collections.unmodifiableList(Arrays.asList(eF));",
                "-    isCompressed         = c;",
                "-    isEncrypted          = e;",
                "+    backendID = b;",
                "+    ldifFiles = Collections.unmodifiableList(Arrays.asList(l));",
                "+    append = a;",
                "+    replaceExisting = r;",
                "+    rejectFile = rF;",
                "+    overwriteRejects = o;",
                "+    clearBackend = cB;",
                "+    includeAttributes = Collections.unmodifiableList(Arrays.asList(iA));",
                "+    excludeAttributes = Collections.unmodifiableList(Arrays.asList(eA));",
                "+    includeBranches = Collections.unmodifiableList(Arrays.asList(iB));",
                "+    excludeBranches = Collections.unmodifiableList(Arrays.asList(eB));",
                "+    includeFilters = Collections.unmodifiableList(Arrays.asList(iF));",
                "+    excludeFilters = Collections.unmodifiableList(Arrays.asList(eF));",
                "+    isCompressed = c;",
                "+    isEncrypted = e;",
                "+    encryptionPassphraseFile = pF;",
                "     skipSchemaValidation = ss;",
                "-    stripTrailingSpaces  = st;",
                "+    stripTrailingSpaces = st;",
                "   }",
                "@@ -1349,2 +1516,18 @@ public final class ImportTask",
                "+  /**",
                "+   * Retrieves the path to a file that contains the passphrase to use to",
                "+   * generate the encryption key.",
                "+   *",
                "+   * @return  The path to a file that contains the passphrase to use to",
                "+   *          generate the encryption key, or {@code null} if the LDIF file is",
                "+   *          not encrypted or if the encryption key should be obtained through",
                "+   *          some other means.",
                "+   */",
                "+  public String getEncryptionPassphraseFile()",
                "+  {",
                "+    return encryptionPassphraseFile;",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -1395,3 +1578,3 @@ public final class ImportTask",
                "   {",
                "-    final ArrayList<Attribute> attrs = new ArrayList<Attribute>(16);",
                "+    final ArrayList<Attribute> attrs = new ArrayList<Attribute>(20);",
                "@@ -1455,2 +1638,8 @@ public final class ImportTask",
                "+    if (encryptionPassphraseFile != null)",
                "+    {",
                "+      attrs.add(new Attribute(ATTR_ENCRYPTION_PASSPHRASE_FILE,",
                "+           encryptionPassphraseFile));",
                "+    }",
                "+",
                "     return attrs;",
                "@@ -1482,2 +1671,3 @@ public final class ImportTask",
                "          PROPERTY_IS_ENCRYPTED,",
                "+         PROPERTY_ENCRYPTION_PASSPHRASE_FILE,",
                "          PROPERTY_SKIP_SCHEMA_VALIDATION,",
                "@@ -1564,2 +1754,13 @@ public final class ImportTask",
                "+    if (encryptionPassphraseFile == null)",
                "+    {",
                "+      props.put(PROPERTY_ENCRYPTION_PASSPHRASE_FILE, Collections.emptyList());",
                "+    }",
                "+    else",
                "+    {",
                "+      props.put(PROPERTY_ENCRYPTION_PASSPHRASE_FILE,",
                "+         Collections.<Object>unmodifiableList(Arrays.asList(",
                "+              encryptionPassphraseFile)));",
                "+    }",
                "+",
                "     props.put(PROPERTY_SKIP_SCHEMA_VALIDATION,",
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/tasks/RestoreTask.java b/src/com/unboundid/ldap/sdk/unboundidds/tasks/RestoreTask.java",
                "index 074cb9d9..97ae235f 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/tasks/RestoreTask.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/tasks/RestoreTask.java",
                "@@ -68,2 +68,4 @@ import static com.unboundid.util.Validator.*;",
                "  *       considers it valid, etc.).</LI>",
                "+ *   <LI>The path to a file containing a passphrase to use to generate the",
                "+ *       encryption key.</LI>",
                "  * </UL>",
                "@@ -102,2 +104,11 @@ public final class RestoreTask",
                "+  /**",
                "+   * The name of the attribute used to specify the path to a file that contains",
                "+   * the passphrase to use to generate the encryption key.",
                "+   */",
                "+  private static final String ATTR_ENCRYPTION_PASSPHRASE_FILE =",
                "+       \"ds-task-restore-encryption-passphrase-file\";",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -139,2 +150,13 @@ public final class RestoreTask",
                "+  /**",
                "+   * The task property that will be used for the encryption passphrase file.",
                "+   */",
                "+  private static final TaskProperty PROPERTY_ENCRYPTION_PASSPHRASE_FILE =",
                "+       new TaskProperty(ATTR_ENCRYPTION_PASSPHRASE_FILE,",
                "+            INFO_DISPLAY_NAME_ENCRYPTION_PASSPHRASE_FILE.get(),",
                "+            INFO_DESCRIPTION_ENCRYPTION_PASSPHRASE_FILE.get(),",
                "+            String.class, false, false, true);",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -152,3 +174,3 @@ public final class RestoreTask",
                "    */",
                "-  private static final long serialVersionUID = -196339437379274643L;",
                "+  private static final long serialVersionUID = -8441221098187125379L;",
                "@@ -162,2 +184,6 @@ public final class RestoreTask",
                "+  // The path to a file containing the passphrase to use to generate the",
                "+  // encryption key.",
                "+  private final String encryptionPassphraseFile;",
                "+",
                "   // The backup ID of the backup to restore.",
                "@@ -175,5 +201,6 @@ public final class RestoreTask",
                "   {",
                "-    verifyOnly      = false;",
                "+    verifyOnly = false;",
                "     backupDirectory = null;",
                "-    backupID        = null;",
                "+    backupID = null;",
                "+    encryptionPassphraseFile = null;",
                "   }",
                "@@ -247,2 +274,56 @@ public final class RestoreTask",
                "                      final List<String> notifyOnError)",
                "+  {",
                "+    this(taskID, backupDirectory, backupID, verifyOnly, null,",
                "+         scheduledStartTime, dependencyIDs, failedDependencyAction,",
                "+         notifyOnCompletion, notifyOnError);",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Creates a new restore task with the provided information.",
                "+   *",
                "+   * @param  taskID                    The task ID to use for this task.  If it",
                "+   *                                   is {@code null} then a UUID will be",
                "+   *                                   generated for use as the task ID.",
                "+   * @param  backupDirectory           The path to the directory on the server",
                "+   *                                   containing the backup to restore.  It may",
                "+   *                                   be an absolute path or relative to the",
                "+   *                                   server root directory.  It must not be",
                "+   *                                   {@code null}.",
                "+   * @param  backupID                  The backup ID of the backup to restore.",
                "+   *                                   If this is {@code null} then the most",
                "+   *                                   recent backup in the specified backup",
                "+   *                                   directory will be restored.",
                "+   * @param  verifyOnly                Indicates whether to only verify the",
                "+   *                                   backup without restoring it.",
                "+   * @param  encryptionPassphraseFile  The path to a file containing the",
                "+   *                                   passphrase to use to generate the",
                "+   *                                   encryption key.  It amy be {@code null}",
                "+   *                                   if the backup is not to be encrypted, or",
                "+   *                                   if the key should be obtained in some",
                "+   *                                   other way.",
                "+   * @param  scheduledStartTime        The time that this task should start",
                "+   *                                   running.",
                "+   * @param  dependencyIDs             The list of task IDs that will be",
                "+   *                                   required to complete before this task",
                "+   *                                   will be eligible to start.",
                "+   * @param  failedDependencyAction    Indicates what action should be taken if",
                "+   *                                   any of the dependencies for this task do",
                "+   *                                   not complete successfully.",
                "+   * @param  notifyOnCompletion        The list of e-mail addresses of",
                "+   *                                   individuals that should be notified when",
                "+   *                                   this task completes.",
                "+   * @param  notifyOnError             The list of e-mail addresses of",
                "+   *                                   individuals that should be notified if",
                "+   *                                   this task does not complete successfully.",
                "+   */",
                "+  public RestoreTask(final String taskID, final String backupDirectory,",
                "+                     final String backupID, final boolean verifyOnly,",
                "+                     final String encryptionPassphraseFile,",
                "+                     final Date scheduledStartTime,",
                "+                     final List<String> dependencyIDs,",
                "+                     final FailedDependencyAction failedDependencyAction,",
                "+                     final List<String> notifyOnCompletion,",
                "+                     final List<String> notifyOnError)",
                "   {",
                "@@ -255,4 +336,5 @@ public final class RestoreTask",
                "     this.backupDirectory = backupDirectory;",
                "-    this.backupID        = backupID;",
                "-    this.verifyOnly      = verifyOnly;",
                "+    this.backupID = backupID;",
                "+    this.verifyOnly = verifyOnly;",
                "+    this.encryptionPassphraseFile = encryptionPassphraseFile;",
                "   }",
                "@@ -290,2 +372,7 @@ public final class RestoreTask",
                "     verifyOnly = parseBooleanValue(entry, ATTR_VERIFY_ONLY, false);",
                "+",
                "+",
                "+    // Get the path to the encryption passphrase file.  It may be absent.",
                "+    encryptionPassphraseFile =",
                "+         entry.getAttributeValue(ATTR_ENCRYPTION_PASSPHRASE_FILE);",
                "   }",
                "@@ -311,2 +398,3 @@ public final class RestoreTask",
                "     String  b = null;",
                "+    String  f = null;",
                "     String  i = null;",
                "@@ -332,2 +420,6 @@ public final class RestoreTask",
                "       }",
                "+      else if (attrName.equalsIgnoreCase(ATTR_ENCRYPTION_PASSPHRASE_FILE))",
                "+      {",
                "+        f = parseString(p, values, f);",
                "+      }",
                "     }",
                "@@ -341,4 +433,5 @@ public final class RestoreTask",
                "     backupDirectory = b;",
                "-    backupID        = i;",
                "-    verifyOnly      = v;",
                "+    backupID = i;",
                "+    verifyOnly = v;",
                "+    encryptionPassphraseFile = f;",
                "   }",
                "@@ -411,2 +504,18 @@ public final class RestoreTask",
                "+  /**",
                "+   * Retrieves the path to a file that contains the passphrase to use to",
                "+   * generate the encryption key.",
                "+   *",
                "+   * @return  The path to a file that contains the passphrase to use to",
                "+   *          generate the encryption key, or {@code null} if the backup is",
                "+   *          not encrypted or if the encryption key should be obtained through",
                "+   *          some other means.",
                "+   */",
                "+  public String getEncryptionPassphraseFile()",
                "+  {",
                "+    return encryptionPassphraseFile;",
                "+  }",
                "+",
                "+",
                "+",
                "   /**",
                "@@ -428,3 +537,3 @@ public final class RestoreTask",
                "   {",
                "-    final ArrayList<Attribute> attrs = new ArrayList<Attribute>(3);",
                "+    final ArrayList<Attribute> attrs = new ArrayList<Attribute>(10);",
                "@@ -438,2 +547,8 @@ public final class RestoreTask",
                "+    if (encryptionPassphraseFile != null)",
                "+    {",
                "+      attrs.add(new Attribute(ATTR_ENCRYPTION_PASSPHRASE_FILE,",
                "+           encryptionPassphraseFile));",
                "+    }",
                "+",
                "     return attrs;",
                "@@ -452,3 +567,4 @@ public final class RestoreTask",
                "          PROPERTY_BACKUP_ID,",
                "-         PROPERTY_VERIFY_ONLY);",
                "+         PROPERTY_VERIFY_ONLY,",
                "+         PROPERTY_ENCRYPTION_PASSPHRASE_FILE);",
                "@@ -484,2 +600,13 @@ public final class RestoreTask",
                "+    if (encryptionPassphraseFile == null)",
                "+    {",
                "+      props.put(PROPERTY_ENCRYPTION_PASSPHRASE_FILE, Collections.emptyList());",
                "+    }",
                "+    else",
                "+    {",
                "+      props.put(PROPERTY_ENCRYPTION_PASSPHRASE_FILE,",
                "+         Collections.<Object>unmodifiableList(Arrays.asList(",
                "+              encryptionPassphraseFile)));",
                "+    }",
                "+",
                "     props.putAll(super.getTaskPropertyValues());",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/BackupTaskTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/BackupTaskTestCase.java",
                "index 81bdf7b0..f08985dd 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/BackupTaskTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/BackupTaskTestCase.java",
                "@@ -83,2 +83,6 @@ public class BackupTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "+    assertNull(t.getEncryptionSettingsDefinitionID());",
                "+",
                "     assertFalse(t.hash());",
                "@@ -87,2 +91,8 @@ public class BackupTaskTestCase",
                "+    assertNull(t.getMaxMegabytesPerSecond());",
                "+",
                "+    assertNull(t.getRetainPreviousFullBackupCount());",
                "+",
                "+    assertNull(t.getRetainPreviousFullBackupAge());",
                "+",
                "     assertNotNull(t.getAdditionalObjectClasses());",
                "@@ -134,2 +144,6 @@ public class BackupTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "+    assertNull(t.getEncryptionSettingsDefinitionID());",
                "+",
                "     assertFalse(t.hash());",
                "@@ -138,2 +152,8 @@ public class BackupTaskTestCase",
                "+    assertNull(t.getMaxMegabytesPerSecond());",
                "+",
                "+    assertNull(t.getRetainPreviousFullBackupCount());",
                "+",
                "+    assertNull(t.getRetainPreviousFullBackupAge());",
                "+",
                "     assertNotNull(t.getAdditionalObjectClasses());",
                "@@ -213,2 +233,6 @@ public class BackupTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "+    assertNull(t.getEncryptionSettingsDefinitionID());",
                "+",
                "     assertTrue(t.hash());",
                "@@ -217,2 +241,88 @@ public class BackupTaskTestCase",
                "+    assertNull(t.getMaxMegabytesPerSecond());",
                "+",
                "+    assertNull(t.getRetainPreviousFullBackupCount());",
                "+",
                "+    assertNull(t.getRetainPreviousFullBackupAge());",
                "+",
                "+    assertNotNull(t.getAdditionalObjectClasses());",
                "+    assertEquals(t.getAdditionalObjectClasses().size(), 1);",
                "+    assertEquals(t.getAdditionalObjectClasses().get(0),",
                "+                 \"ds-task-backup\");",
                "+",
                "+    assertNotNull(t.getAdditionalAttributes());",
                "+    assertFalse(t.getAdditionalAttributes().isEmpty());",
                "+",
                "+    assertNotNull(t.createTaskEntry());",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the second constructor with valid values for all arguments.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testConstructor2bAll()",
                "+         throws Exception",
                "+  {",
                "+    List<String> backendIDs = Arrays.asList(\"userRoot\", \"adminRoot\");",
                "+    List<String> dependencyIDs = Arrays.asList(\"dep1\", \"dep2\");",
                "+    List<String> notifyOnCompletion = Arrays.asList(\"peon@example.com\");",
                "+    List<String> notifyOnError = Arrays.asList(\"admin@example.com\");",
                "+",
                "+    Date d = new Date();",
                "+",
                "+    BackupTask t = new BackupTask(\"foo\", \"bak\", backendIDs, \"baz\", true, \"bar\",",
                "+         true, true, \"passphrase.txt\", \"definition\", true, true, 100, 5,",
                "+         \"3 days\", d, dependencyIDs, FailedDependencyAction.CANCEL,",
                "+         notifyOnCompletion, notifyOnError);",
                "+",
                "+    assertNotNull(t);",
                "+",
                "+    assertEquals(t.getTaskClassName(),",
                "+                 \"com.unboundid.directory.server.tasks.BackupTask\");",
                "+",
                "+    assertNotNull(t.getBackupDirectory());",
                "+    assertEquals(t.getBackupDirectory(), \"bak\");",
                "+",
                "+    assertNotNull(t.getBackendIDs());",
                "+    assertEquals(t.getBackendIDs().size(), 2);",
                "+    assertEquals(t.getBackendIDs().get(0), \"userRoot\");",
                "+    assertEquals(t.getBackendIDs().get(1), \"adminRoot\");",
                "+",
                "+    assertFalse(t.backupAll());",
                "+",
                "+    assertNotNull(t.getBackupID());",
                "+    assertEquals(t.getBackupID(), \"baz\");",
                "+",
                "+    assertTrue(t.incremental());",
                "+",
                "+    assertNotNull(t.getIncrementalBaseID());",
                "+    assertEquals(t.getIncrementalBaseID(), \"bar\");",
                "+",
                "+    assertTrue(t.compress());",
                "+",
                "+    assertTrue(t.encrypt());",
                "+",
                "+    assertNotNull(t.getEncryptionPassphraseFile());",
                "+    assertEquals(t.getEncryptionPassphraseFile(), \"passphrase.txt\");",
                "+",
                "+    assertNotNull(t.getEncryptionSettingsDefinitionID());",
                "+    assertEquals(t.getEncryptionSettingsDefinitionID(), \"definition\");",
                "+",
                "+    assertTrue(t.hash());",
                "+",
                "+    assertTrue(t.signHash());",
                "+",
                "+    assertNotNull(t.getMaxMegabytesPerSecond());",
                "+    assertEquals(t.getMaxMegabytesPerSecond().intValue(), 100);",
                "+",
                "+    assertNotNull(t.getRetainPreviousFullBackupCount());",
                "+    assertEquals(t.getRetainPreviousFullBackupCount().intValue(), 5);",
                "+",
                "+    assertNotNull(t.getRetainPreviousFullBackupAge());",
                "+    assertEquals(t.getRetainPreviousFullBackupAge(), \"3 days\");",
                "+",
                "     assertNotNull(t.getAdditionalObjectClasses());",
                "@@ -267,2 +377,6 @@ public class BackupTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "+    assertNull(t.getEncryptionSettingsDefinitionID());",
                "+",
                "     assertTrue(t.hash());",
                "@@ -271,2 +385,8 @@ public class BackupTaskTestCase",
                "+    assertNull(t.getMaxMegabytesPerSecond());",
                "+",
                "+    assertNull(t.getRetainPreviousFullBackupCount());",
                "+",
                "+    assertNull(t.getRetainPreviousFullBackupAge());",
                "+",
                "     assertNotNull(t.getAdditionalObjectClasses());",
                "@@ -369,2 +489,7 @@ public class BackupTaskTestCase",
                "                   \"ds-task-backup-sign-hash: true\",",
                "+                  \"ds-task-backup-encryption-settings-passphrase-file: pw.txt\",",
                "+                  \"ds-task-backup-encryption-settings-definition-id: def\",",
                "+                  \"ds-task-backup-max-megabytes-per-second: 100\",",
                "+                  \"ds-task-backup-retain-previous-full-backup-count: 5\",",
                "+                  \"ds-task-backup-retain-previous-full-backup-age: 3 days\",",
                "                   \"ds-task-scheduled-start-time: 20080101000000Z\",",
                "@@ -586,2 +711,10 @@ public class BackupTaskTestCase",
                "       }",
                "+      else if (name.equals(\"ds-task-backup-encryption-passphrase-file\"))",
                "+      {",
                "+        properties.put(p, Arrays.<Object>asList(\"passphrase.txt\"));",
                "+      }",
                "+      else if (name.equals(\"ds-task-backup-encryption-settings-definition-id\"))",
                "+      {",
                "+        properties.put(p, Arrays.<Object>asList(\"definition\"));",
                "+      }",
                "       else if (name.equals(\"ds-task-backup-hash\"))",
                "@@ -594,2 +727,14 @@ public class BackupTaskTestCase",
                "       }",
                "+      else if (name.equals(\"ds-task-backup-max-megabytes-per-second\"))",
                "+      {",
                "+        properties.put(p, Arrays.<Object>asList(Long.valueOf(100)));",
                "+      }",
                "+      else if (name.equals(\"ds-task-backup-retain-previous-full-backup-count\"))",
                "+      {",
                "+        properties.put(p, Arrays.<Object>asList(Long.valueOf(5)));",
                "+      }",
                "+      else if (name.equals(\"ds-task-backup-retain-previous-full-backup-age\"))",
                "+      {",
                "+        properties.put(p, Arrays.<Object>asList(\"3 days\"));",
                "+      }",
                "       else if (name.equals(\"ds-task-backup-incremental\"))",
                "@@ -626,2 +771,8 @@ public class BackupTaskTestCase",
                "+    assertNotNull(t.getEncryptionPassphraseFile());",
                "+    assertEquals(t.getEncryptionPassphraseFile(), \"passphrase.txt\");",
                "+",
                "+    assertNotNull(t.getEncryptionSettingsDefinitionID());",
                "+    assertEquals(t.getEncryptionSettingsDefinitionID(), \"definition\");",
                "+",
                "     assertTrue(t.hash());",
                "@@ -630,2 +781,11 @@ public class BackupTaskTestCase",
                "+    assertNotNull(t.getMaxMegabytesPerSecond());",
                "+    assertEquals(t.getMaxMegabytesPerSecond().intValue(), 100);",
                "+",
                "+    assertNotNull(t.getRetainPreviousFullBackupCount());",
                "+    assertEquals(t.getRetainPreviousFullBackupCount().intValue(), 5);",
                "+",
                "+    assertNotNull(t.getRetainPreviousFullBackupAge());",
                "+    assertEquals(t.getRetainPreviousFullBackupAge(), \"3 days\");",
                "+",
                "     Map<TaskProperty,List<Object>> props = t.getTaskPropertyValues();",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/ExportTaskTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/ExportTaskTestCase.java",
                "index 775e0f97..02341e35 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/ExportTaskTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/ExportTaskTestCase.java",
                "@@ -97,4 +97,10 @@ public class ExportTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "+    assertNull(t.getEncryptionSettingsDefinitionID());",
                "+",
                "     assertFalse(t.sign());",
                "+    assertNull(t.getMaxMegabytesPerSecond());",
                "+",
                "     assertNotNull(t.getAdditionalObjectClasses());",
                "@@ -214,4 +220,107 @@ public class ExportTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "+    assertNull(t.getEncryptionSettingsDefinitionID());",
                "+",
                "+    assertTrue(t.sign());",
                "+",
                "+    assertNull(t.getMaxMegabytesPerSecond());",
                "+",
                "+    assertNotNull(t.getAdditionalObjectClasses());",
                "+    assertEquals(t.getAdditionalObjectClasses().size(), 1);",
                "+    assertEquals(t.getAdditionalObjectClasses().get(0),",
                "+                 \"ds-task-export\");",
                "+",
                "+    assertNotNull(t.getAdditionalAttributes());",
                "+    assertFalse(t.getAdditionalAttributes().isEmpty());",
                "+",
                "+    assertNotNull(t.createTaskEntry());",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the second constructor with valid values for all arguments.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testConstructor2bAll()",
                "+         throws Exception",
                "+  {",
                "+    List<String> includeBranches = Arrays.asList(\"dc=example,dc=com\");",
                "+    List<String> excludeBranches = Arrays.asList(\"ou=local,dc=example,dc=com\");",
                "+    List<String> includeFilters = Arrays.asList(\"(objectClass=person)\");",
                "+    List<String> excludeFilters = Arrays.asList(\"(objectClass=localPerson)\");",
                "+    List<String> includeAttrs = Arrays.asList(\"cn\", \"sn\");",
                "+    List<String> excludeAttrs = Arrays.asList(\"userPassword\");",
                "+    List<String> dependencyIDs = Arrays.asList(\"dep1\", \"dep2\");",
                "+    List<String> notifyOnCompletion = Arrays.asList(\"peon@example.com\");",
                "+    List<String> notifyOnError = Arrays.asList(\"admin@example.com\");",
                "+",
                "+    Date d = new Date();",
                "+",
                "+    ExportTask t = new ExportTask(\"foo\", \"userRoot\", \"data.ldif\", false,",
                "+         includeBranches, excludeBranches, includeFilters, excludeFilters,",
                "+         includeAttrs, excludeAttrs, 80, true, true, \"passphrase.txt\",",
                "+         \"definition\", true, 100, d, dependencyIDs,",
                "+         FailedDependencyAction.CANCEL, notifyOnCompletion, notifyOnError);",
                "+",
                "+    assertNotNull(t);",
                "+",
                "+    assertEquals(t.getTaskClassName(),",
                "+                 \"com.unboundid.directory.server.tasks.ExportTask\");",
                "+",
                "+    assertNotNull(t.getBackendID());",
                "+    assertEquals(t.getBackendID(), \"userRoot\");",
                "+",
                "+    assertNotNull(t.getLDIFFile());",
                "+    assertEquals(t.getLDIFFile(), \"data.ldif\");",
                "+",
                "+    assertFalse(t.appendToLDIF());",
                "+",
                "+    assertNotNull(t.getIncludeBranches());",
                "+    assertEquals(t.getIncludeBranches().size(), 1);",
                "+    assertEquals(new DN(t.getIncludeBranches().get(0)),",
                "+                 new DN(\"dc=example,dc=com\"));",
                "+",
                "+    assertNotNull(t.getExcludeBranches());",
                "+    assertEquals(t.getExcludeBranches().size(), 1);",
                "+    assertEquals(new DN(t.getExcludeBranches().get(0)),",
                "+                 new DN(\"ou=local,dc=example,dc=com\"));",
                "+",
                "+    assertNotNull(t.getIncludeFilters());",
                "+    assertEquals(t.getIncludeFilters().size(), 1);",
                "+    assertEquals(t.getIncludeFilters().get(0), \"(objectClass=person)\");",
                "+",
                "+    assertNotNull(t.getExcludeFilters());",
                "+    assertEquals(t.getExcludeFilters().size(), 1);",
                "+    assertEquals(t.getExcludeFilters().get(0), \"(objectClass=localPerson)\");",
                "+",
                "+    assertNotNull(t.getIncludeAttributes());",
                "+    assertEquals(t.getIncludeAttributes().size(), 2);",
                "+    assertEquals(t.getIncludeAttributes().get(0), \"cn\");",
                "+    assertEquals(t.getIncludeAttributes().get(1), \"sn\");",
                "+",
                "+    assertNotNull(t.getExcludeAttributes());",
                "+    assertEquals(t.getExcludeAttributes().size(), 1);",
                "+    assertEquals(t.getExcludeAttributes().get(0), \"userPassword\");",
                "+",
                "+    assertEquals(t.getWrapColumn(), 80);",
                "+",
                "+    assertTrue(t.compress());",
                "+",
                "+    assertTrue(t.encrypt());",
                "+",
                "+    assertNotNull(t.getEncryptionPassphraseFile());",
                "+    assertEquals(t.getEncryptionPassphraseFile(), \"passphrase.txt\");",
                "+",
                "+    assertNotNull(t.getEncryptionSettingsDefinitionID());",
                "+    assertEquals(t.getEncryptionSettingsDefinitionID(), \"definition\");",
                "+",
                "     assertTrue(t.sign());",
                "+    assertNotNull(t.getMaxMegabytesPerSecond());",
                "+    assertEquals(t.getMaxMegabytesPerSecond().intValue(), 100);",
                "+",
                "     assertNotNull(t.getAdditionalObjectClasses());",
                "@@ -294,4 +403,10 @@ public class ExportTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "+    assertNull(t.getEncryptionSettingsDefinitionID());",
                "+",
                "     assertTrue(t.sign());",
                "+    assertNull(t.getMaxMegabytesPerSecond());",
                "+",
                "     assertNotNull(t.getAdditionalObjectClasses());",
                "@@ -406,2 +521,5 @@ public class ExportTaskTestCase",
                "                   \"ds-task-export-encrypt-ldif: false\",",
                "+                  \"ds-task-export-encryption-settings-passphrase-file: pw.txt\",",
                "+                  \"ds-task-export-encryption-settings-definition-id: def\",",
                "+                  \"ds-task-export-max-megabytes-per-second: 100\",",
                "                   \"ds-task-export-sign-hash: true\",",
                "@@ -638,2 +756,10 @@ public class ExportTaskTestCase",
                "       }",
                "+      else if (name.equals(\"ds-task-export-encryption-passphrase-file\"))",
                "+      {",
                "+        properties.put(p, Arrays.<Object>asList(\"passphrase.txt\"));",
                "+      }",
                "+      else if (name.equals(\"ds-task-export-encryption-settings-definition-id\"))",
                "+      {",
                "+        properties.put(p, Arrays.<Object>asList(\"definition\"));",
                "+      }",
                "       else if (name.equals(\"ds-task-export-sign-hash\"))",
                "@@ -642,2 +768,6 @@ public class ExportTaskTestCase",
                "       }",
                "+      else if (name.equals(\"ds-task-export-max-megabytes-per-second\"))",
                "+      {",
                "+        properties.put(p, Arrays.<Object>asList(Long.valueOf(100)));",
                "+      }",
                "       else if (name.equals(\"ds-task-export-include-attribute\"))",
                "@@ -708,4 +838,13 @@ public class ExportTaskTestCase",
                "+    assertNotNull(t.getEncryptionPassphraseFile());",
                "+    assertEquals(t.getEncryptionPassphraseFile(), \"passphrase.txt\");",
                "+",
                "+    assertNotNull(t.getEncryptionSettingsDefinitionID());",
                "+    assertEquals(t.getEncryptionSettingsDefinitionID(), \"definition\");",
                "+",
                "     assertTrue(t.sign());",
                "+    assertNotNull(t.getMaxMegabytesPerSecond());",
                "+    assertEquals(t.getMaxMegabytesPerSecond().intValue(), 100);",
                "+",
                "     Map<TaskProperty,List<Object>> props = t.getTaskPropertyValues();",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/ImportTaskTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/ImportTaskTestCase.java",
                "index 366b50ee..e6f32aeb 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/ImportTaskTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/ImportTaskTestCase.java",
                "@@ -103,2 +103,4 @@ public class ImportTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "     assertFalse(t.skipSchemaValidation());",
                "@@ -233,2 +235,4 @@ public class ImportTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "     assertTrue(t.skipSchemaValidation());",
                "@@ -391,2 +395,107 @@ public class ImportTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "+    assertTrue(t.skipSchemaValidation());",
                "+",
                "+    assertTrue(t.stripTrailingSpaces());",
                "+",
                "+    assertNotNull(t.getAdditionalObjectClasses());",
                "+    assertEquals(t.getAdditionalObjectClasses().size(), 1);",
                "+    assertEquals(t.getAdditionalObjectClasses().get(0),",
                "+                 \"ds-task-import\");",
                "+",
                "+    assertNotNull(t.getAdditionalAttributes());",
                "+    assertFalse(t.getAdditionalAttributes().isEmpty());",
                "+",
                "+    assertNotNull(t.createTaskEntry());",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the third constructor with valid values for all arguments.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testConstructor3bAll()",
                "+         throws Exception",
                "+  {",
                "+    List<String> ldifFiles = Arrays.asList(\"bar\", \"baz\");",
                "+    List<String> includeBranches = Arrays.asList(\"dc=example,dc=com\");",
                "+    List<String> excludeBranches = Arrays.asList(\"ou=local,dc=example,dc=com\");",
                "+    List<String> includeFilters = Arrays.asList(\"(objectClass=person)\");",
                "+    List<String> excludeFilters = Arrays.asList(\"(objectClass=localPerson)\");",
                "+    List<String> includeAttrs = Arrays.asList(\"cn\", \"sn\");",
                "+    List<String> excludeAttrs = Arrays.asList(\"userPassword\");",
                "+    List<String> dependencyIDs = Arrays.asList(\"dep1\", \"dep2\");",
                "+    List<String> notifyOnCompletion = Arrays.asList(\"peon@example.com\");",
                "+    List<String> notifyOnError = Arrays.asList(\"admin@example.com\");",
                "+",
                "+    Date d = new Date();",
                "+",
                "+    ImportTask t = new ImportTask(\"foo\", ldifFiles, \"userRoot\", false, false,",
                "+         \"rejects.ldif\", true, true, includeBranches, excludeBranches,",
                "+         includeFilters, excludeFilters, includeAttrs, excludeAttrs, true, true,",
                "+         \"passphrase.txt\", true, true, d, dependencyIDs,",
                "+         FailedDependencyAction.CANCEL, notifyOnCompletion, notifyOnError);",
                "+",
                "+    assertNotNull(t);",
                "+",
                "+    assertEquals(t.getTaskClassName(),",
                "+                 \"com.unboundid.directory.server.tasks.ImportTask\");",
                "+",
                "+    assertNotNull(t.getLDIFFiles());",
                "+    assertEquals(t.getLDIFFiles().size(), 2);",
                "+    assertEquals(t.getLDIFFiles().get(0), \"bar\");",
                "+    assertEquals(t.getLDIFFiles().get(1), \"baz\");",
                "+",
                "+    assertNotNull(t.getBackendID());",
                "+    assertEquals(t.getBackendID(), \"userRoot\");",
                "+",
                "+    assertFalse(t.append());",
                "+",
                "+    assertFalse(t.replaceExistingEntries());",
                "+",
                "+    assertNotNull(t.getRejectFile());",
                "+    assertEquals(t.getRejectFile(), \"rejects.ldif\");",
                "+",
                "+    assertTrue(t.overwriteRejectFile());",
                "+",
                "+    assertTrue(t.clearBackend());",
                "+",
                "+    assertNotNull(t.getIncludeBranches());",
                "+    assertEquals(t.getIncludeBranches().size(), 1);",
                "+    assertEquals(new DN(t.getIncludeBranches().get(0)),",
                "+                 new DN(\"dc=example,dc=com\"));",
                "+",
                "+    assertNotNull(t.getExcludeBranches());",
                "+    assertEquals(t.getExcludeBranches().size(), 1);",
                "+    assertEquals(new DN(t.getExcludeBranches().get(0)),",
                "+                 new DN(\"ou=local,dc=example,dc=com\"));",
                "+",
                "+    assertNotNull(t.getIncludeFilters());",
                "+    assertEquals(t.getIncludeFilters().size(), 1);",
                "+    assertEquals(t.getIncludeFilters().get(0), \"(objectClass=person)\");",
                "+",
                "+    assertNotNull(t.getExcludeFilters());",
                "+    assertEquals(t.getExcludeFilters().size(), 1);",
                "+    assertEquals(t.getExcludeFilters().get(0), \"(objectClass=localPerson)\");",
                "+",
                "+    assertNotNull(t.getIncludeAttributes());",
                "+    assertEquals(t.getIncludeAttributes().size(), 2);",
                "+    assertEquals(t.getIncludeAttributes().get(0), \"cn\");",
                "+    assertEquals(t.getIncludeAttributes().get(1), \"sn\");",
                "+",
                "+    assertNotNull(t.getExcludeAttributes());",
                "+    assertEquals(t.getExcludeAttributes().size(), 1);",
                "+    assertEquals(t.getExcludeAttributes().get(0), \"userPassword\");",
                "+",
                "+    assertTrue(t.isCompressed());",
                "+",
                "+    assertTrue(t.isEncrypted());",
                "+",
                "+    assertNotNull(t.getEncryptionPassphraseFile());",
                "+    assertEquals(t.getEncryptionPassphraseFile(), \"passphrase.txt\");",
                "+",
                "     assertTrue(t.skipSchemaValidation());",
                "@@ -510,2 +619,3 @@ public class ImportTaskTestCase",
                "                   \"ds-task-import-is-encrypted: false\",",
                "+                  \"ds-task-import-encryption-passphrase-file: passphrase.txt\",",
                "                   \"ds-task-import-backend-id: userRoot\",",
                "@@ -794,2 +904,6 @@ public class ImportTaskTestCase",
                "       }",
                "+      else if (name.equals(\"ds-task-import-encryption-passphrase-file\"))",
                "+      {",
                "+        properties.put(p, Arrays.<Object>asList(\"passphrase.txt\"));",
                "+      }",
                "       else if (name.equals(\"ds-task-import-is-compressed\"))",
                "@@ -861,2 +975,5 @@ public class ImportTaskTestCase",
                "+    assertNotNull(t.getEncryptionPassphraseFile());",
                "+    assertEquals(t.getEncryptionPassphraseFile(), \"passphrase.txt\");",
                "+",
                "     assertTrue(t.skipSchemaValidation());",
                "diff --git a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/RestoreTaskTestCase.java b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/RestoreTaskTestCase.java",
                "index 3622f819..a210a7d4 100644",
                "--- a/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/RestoreTaskTestCase.java",
                "+++ b/tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/RestoreTaskTestCase.java",
                "@@ -71,2 +71,4 @@ public class RestoreTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "     assertNotNull(t.getAdditionalObjectClasses());",
                "@@ -107,2 +109,4 @@ public class RestoreTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "     assertNotNull(t.getAdditionalObjectClasses());",
                "@@ -167,2 +171,53 @@ public class RestoreTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "+    assertNotNull(t.getAdditionalObjectClasses());",
                "+    assertEquals(t.getAdditionalObjectClasses().size(), 1);",
                "+    assertEquals(t.getAdditionalObjectClasses().get(0),",
                "+                 \"ds-task-restore\");",
                "+",
                "+    assertNotNull(t.getAdditionalAttributes());",
                "+    assertFalse(t.getAdditionalAttributes().isEmpty());",
                "+",
                "+    assertNotNull(t.createTaskEntry());",
                "+  }",
                "+",
                "+",
                "+",
                "+  /**",
                "+   * Tests the second constructor with valid values for all arguments.",
                "+   *",
                "+   * @throws  Exception  If an unexpected problem occurs.",
                "+   */",
                "+  @Test()",
                "+  public void testConstructor2bAll()",
                "+         throws Exception",
                "+  {",
                "+    List<String> dependencyIDs = Arrays.asList(\"dep1\", \"dep2\");",
                "+    List<String> notifyOnCompletion = Arrays.asList(\"peon@example.com\");",
                "+    List<String> notifyOnError = Arrays.asList(\"admin@example.com\");",
                "+",
                "+    Date d = new Date();",
                "+",
                "+    RestoreTask t = new RestoreTask(\"foo\", \"bak/userRoot\", \"my-backup\", false,",
                "+                                    \"passphrase.txt\", d, dependencyIDs,",
                "+                                    FailedDependencyAction.CANCEL,",
                "+                                    notifyOnCompletion, notifyOnError);",
                "+",
                "+    assertNotNull(t);",
                "+",
                "+    assertEquals(t.getTaskClassName(),",
                "+                 \"com.unboundid.directory.server.tasks.RestoreTask\");",
                "+",
                "+    assertNotNull(t.getBackupDirectory());",
                "+    assertEquals(t.getBackupDirectory(), \"bak/userRoot\");",
                "+",
                "+    assertNotNull(t.getBackupID());",
                "+    assertEquals(t.getBackupID(), \"my-backup\");",
                "+",
                "+    assertFalse(t.verifyOnly());",
                "+",
                "+    assertNotNull(t.getEncryptionPassphraseFile());",
                "+    assertEquals(t.getEncryptionPassphraseFile(), \"passphrase.txt\");",
                "+",
                "     assertNotNull(t.getAdditionalObjectClasses());",
                "@@ -204,2 +259,4 @@ public class RestoreTaskTestCase",
                "+    assertNull(t.getEncryptionPassphraseFile());",
                "+",
                "     assertNotNull(t.getAdditionalObjectClasses());",
                "@@ -291,2 +348,3 @@ public class RestoreTaskTestCase",
                "                   \"ds-verify-only: false\",",
                "+                  \"ds-task-restore-encryption-passphrase-file: passphrase.txt\",",
                "                   \"ds-task-scheduled-start-time: 20080101000000Z\",",
                "@@ -434,2 +492,6 @@ public class RestoreTaskTestCase",
                "       }",
                "+      else if (name.equals(\"ds-task-restore-encryption-passphrase-file\"))",
                "+      {",
                "+        properties.put(p, Arrays.<Object>asList(\"passphrase.txt\"));",
                "+      }",
                "     }",
                "@@ -446,2 +508,5 @@ public class RestoreTaskTestCase",
                "+    assertNotNull(t.getEncryptionPassphraseFile());",
                "+    assertEquals(t.getEncryptionPassphraseFile(), \"passphrase.txt\");",
                "+",
                "     Map<TaskProperty,List<Object>> props = t.getTaskPropertyValues();"
            ],
            "changed_files": [
                "messages/unboundid-ldapsdk-task.properties",
                "src/com/unboundid/ldap/sdk/unboundidds/tasks/BackupTask.java",
                "src/com/unboundid/ldap/sdk/unboundidds/tasks/ExportTask.java",
                "src/com/unboundid/ldap/sdk/unboundidds/tasks/ImportTask.java",
                "src/com/unboundid/ldap/sdk/unboundidds/tasks/RestoreTask.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/BackupTaskTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/ExportTaskTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/ImportTaskTestCase.java",
                "tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/RestoreTaskTestCase.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "RELEVANT_WORDS_IN_MESSAGE",
                    "message": "The commit message contains some relevant words: LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: messages/unboundid-ldapsdk-task.properties, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/RestoreTaskTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/ExportTaskTestCase.java, src/com/unboundid/ldap/sdk/unboundidds/tasks/BackupTask.java, src/com/unboundid/ldap/sdk/unboundidds/tasks/RestoreTask.java, src/com/unboundid/ldap/sdk/unboundidds/tasks/ExportTask.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/BackupTaskTestCase.java, tests/unit/src/com/unboundid/ldap/sdk/unboundidds/tasks/ImportTaskTestCase.java, src/com/unboundid/ldap/sdk/unboundidds/tasks/ImportTask.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: server, unboundid",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "900ff848697325daee950b8cd5370b9faddd1065",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1520446090,
            "hunks": 2,
            "message": "Minor update in ToolUtils Updated ToolUtils to change the method signature for the server's getPassphraseForEncryptionSettingsID method that LDAP SDK tools may try to invoke via reflection in certain cases.",
            "diff": [
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java b/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java",
                "index 05ca3e79..66da4ebe 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java",
                "@@ -101,3 +101,4 @@ public final class ToolUtils",
                "       m = serverStaticUtilsClass.getMethod(",
                "-           \"getPassphraseForEncryptionSettingsID\", String.class);",
                "+           \"getPassphraseForEncryptionSettingsID\", String.class,",
                "+           PrintStream.class, PrintStream.class);",
                "     }",
                "@@ -869,3 +870,3 @@ public final class ToolUtils",
                "              GET_PASSPHRASE_FOR_ENCRYPTION_SETTINGS_ID_METHOD.invoke(null,",
                "-                  streamHeaderShell.getKeyIdentifier());",
                "+                  streamHeaderShell.getKeyIdentifier(), out, err);",
                "         if ((passphraseObject != null) && (passphraseObject instanceof String))"
            ],
            "changed_files": [
                "src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "RELEVANT_WORDS_IN_MESSAGE",
                    "message": "The commit message contains some relevant words: SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: src/com/unboundid/ldap/sdk/unboundidds/tools/ToolUtils.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: server",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "f1145920cdb5aae526cf2833190051f9aecf9e18",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1520381560,
            "hunks": 1,
            "message": "Update the SourceForge discussion forum URL Updated the LDAP SDK documentation to point to the correct URL for the SourceForge discussion forums.  The SourceForge site recently got a makeover, and it looks like this URL got changed in the process.",
            "diff": [
                "diff --git a/docs/ldapsdk-faq.html b/docs/ldapsdk-faq.html",
                "index 980998ce..a7292df6 100644",
                "--- a/docs/ldapsdk-faq.html",
                "+++ b/docs/ldapsdk-faq.html",
                "@@ -448,3 +448,3 @@ ${TARGET=\"offline\"}                <br>",
                "                 <li>",
                "-                  Use the <a href=\"http://sourceforge.net/forum/forum.php?forum_id=1001257\">online",
                "+                  Use the <a href=\"https://sourceforge.net/p/ldap-sdk/discussion/1001257/\">online",
                "                   discussion forum</a>"
            ],
            "changed_files": [
                "docs/ldapsdk-faq.html"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "RELEVANT_WORDS_IN_MESSAGE",
                    "message": "The commit message contains some relevant words: SDK, LDAP",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: docs/ldapsdk-faq.html",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: process",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "58a46d047642b51cc138fb4481b4f65ff7dbb9cf",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1520894196,
            "hunks": 2,
            "message": "Fix an OS-specific issue in ToolInvocationLogger Updated the ToolInvocationLogger to fix a problem that could cause an error message to be printed when trying to create a file on Windows system using POSIX file permissions.",
            "diff": [
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolInvocationLogger.java b/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolInvocationLogger.java",
                "index 9983f65c..d97a9af8 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolInvocationLogger.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/tools/ToolInvocationLogger.java",
                "@@ -692,8 +692,16 @@ public final class ToolInvocationLogger",
                "-    final Set<PosixFilePermission> filePermissionsSet = EnumSet.of(",
                "-            PosixFilePermission.OWNER_READ,   // Grant owner read access.",
                "-            PosixFilePermission.OWNER_WRITE); // Grant owner write access.",
                "-",
                "-    final FileAttribute<Set<PosixFilePermission>> filePermissionsAttribute=",
                "-            PosixFilePermissions.asFileAttribute(filePermissionsSet);",
                "+    final FileAttribute<?>[] fileAttributes;",
                "+    if (StaticUtils.isWindows())",
                "+    {",
                "+      fileAttributes = new FileAttribute<?>[0];",
                "+    }",
                "+    else",
                "+    {",
                "+      final Set<PosixFilePermission> filePermissionsSet = EnumSet.of(",
                "+              PosixFilePermission.OWNER_READ,   // Grant owner read access.",
                "+              PosixFilePermission.OWNER_WRITE); // Grant owner write access.",
                "+      final FileAttribute<Set<PosixFilePermission>> filePermissionsAttribute =",
                "+              PosixFilePermissions.asFileAttribute(filePermissionsSet);",
                "+      fileAttributes = new FileAttribute<?>[] { filePermissionsAttribute };",
                "+    }",
                "@@ -701,3 +709,3 @@ public final class ToolInvocationLogger",
                "               FileChannel.open(logFile.toPath(), openOptionsSet,",
                "-                   filePermissionsAttribute))",
                "+                   fileAttributes))",
                "     {"
            ],
            "changed_files": [
                "src/com/unboundid/ldap/sdk/unboundidds/tools/ToolInvocationLogger.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: src/com/unboundid/ldap/sdk/unboundidds/tools/ToolInvocationLogger.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: issue",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "41df75887cd26ee936d4d1e824ee1da77ed77e6d",
            "repository": "https://github.com/pingidentity/ldapsdk",
            "timestamp": 1520538239,
            "hunks": 3,
            "message": "Better summarize-access-log encryption support Updated the summarize-access-log tool to improve support for examining log files that the server currently has open.  An encrypted log file that the server still has open is unlikely to be fully decryptable because the file won't end with a valid properly-padded block.  This commit adds a message that explains the error, and then proceeds with an attempt to summarize the log content that it was able to read successfully.",
            "diff": [
                "diff --git a/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java b/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                "index 0accdfa8..5b6e1fc6 100644",
                "--- a/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                "+++ b/src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                "@@ -42,2 +42,3 @@ import java.util.concurrent.atomic.AtomicLong;",
                " import java.util.zip.GZIPInputStream;",
                "+import javax.crypto.BadPaddingException;",
                "@@ -700,3 +701,18 @@ public final class SummarizeAccessLog",
                "               \":  \", getExceptionMessage(ioe));",
                "-          return ResultCode.LOCAL_ERROR;",
                "+",
                "+          if ((ioe.getCause() != null) &&",
                "+               (ioe.getCause() instanceof BadPaddingException))",
                "+          {",
                "+            err(\"This error is likely because the log is encrypted and the \" +",
                "+                 \"server still has the log file open.  It is recommended \" +",
                "+                 \"that you only try to examine encrypted logs after they \" +",
                "+                 \"have been rotated.  You can use the rotate-log tool to \" +",
                "+                 \"force a rotation at any time.  Attempting to proceed with \" +",
                "+                 \"just the data that was successfully read.\");",
                "+            break;",
                "+          }",
                "+          else",
                "+          {",
                "+            return ResultCode.LOCAL_ERROR;",
                "+          }",
                "         }",
                "@@ -809,2 +825,6 @@ public final class SummarizeAccessLog",
                "         millisToHumanReadableDuration(logDurationMillis));",
                "+    if (logLines == 0)",
                "+    {",
                "+      return ResultCode.SUCCESS;",
                "+    }"
            ],
            "changed_files": [
                "src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "4.0.10",
                "4.0.11",
                "4.0.12",
                "4.0.13",
                "4.0.14",
                "4.0.5",
                "4.0.6",
                "4.0.7",
                "4.0.8",
                "4.0.9",
                "5.0.0",
                "5.0.1",
                "5.1.0",
                "5.1.1",
                "5.1.2",
                "5.1.3",
                "5.1.4",
                "6.0.0",
                "6.0.1",
                "6.0.10",
                "6.0.11",
                "6.0.2",
                "6.0.3",
                "6.0.4",
                "6.0.5",
                "6.0.6",
                "6.0.7",
                "6.0.8",
                "6.0.9",
                "7.0.0",
                "7.0.1"
            ],
            "matched_rules": [
                {
                    "id": "CHANGES_RELEVANT_FILES",
                    "message": "The commit changes some relevant files: src/com/unboundid/ldap/sdk/unboundidds/examples/SummarizeAccessLog.java",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: server, access, commit",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: unboundid, access",
                    "relevance": 4
                }
            ]
        }
    ]
}
