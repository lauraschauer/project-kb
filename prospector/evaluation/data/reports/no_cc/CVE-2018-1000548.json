{
    "advisory_record": {
        "cve_id": "CVE-2018-1000548",
        "description": "Umlet version < 14.3 contains a XML External Entity (XXE) vulnerability in File parsing that can result in disclosure of confidential data, denial of service, server side request forgery. This attack appear to be exploitable via Specially crafted UXF file. This vulnerability appears to have been fixed in 14.3.",
        "reserved_timestamp": 1524700800,
        "published_timestamp": 1530028800,
        "updated_timestamp": 1530028621,
        "repository_url": null,
        "references": {
            "": 71,
            "https://github.com/umlet/umlet/issues/500": 3,
            "http://0dd.zone/2018/04/23/UMLet-XXE/": 2,
            "https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax": 2,
            "commit::e1c4cc6ae692cc8d1c367460dbf79343e996f9bd": 2,
            "https://github.com/features/actions": 1,
            "https://github.com/features/packages": 1,
            "https://github.com/features/security": 1,
            "https://github.com/features/codespaces": 1,
            "https://github.com/features/copilot": 1,
            "https://github.com/features/code-review": 1,
            "https://github.com/features/issues": 1,
            "https://github.com/features/discussions": 1,
            "https://github.com/features": 1,
            "https://docs.github.com": 1,
            "https://skills.github.com": 1,
            "https://github.blog": 1,
            "https://github.com/enterprise": 1,
            "https://github.com/team": 1,
            "https://github.com/enterprise/startups": 1,
            "https://github.com/solutions/industries/healthcare": 1,
            "https://github.com/solutions/industries/financial-services": 1,
            "https://github.com/solutions/industries/manufacturing": 1,
            "https://github.com/solutions/ci-cd": 1,
            "https://github.com/solutions/devops": 1,
            "https://github.com/solutions/devsecops": 1,
            "https://resources.github.com/learn/pathways": 1,
            "https://resources.github.com": 1,
            "https://github.com/customer-stories": 1,
            "https://partner.github.com": 1,
            "https://github.com/readme": 1,
            "https://github.com/topics": 1,
            "https://github.com/trending": 1,
            "https://github.com/collections": 1,
            "https://github.com/enterprise/advanced-security": 1,
            "https://github.com/pricing": 1,
            "https://docs.github.com/terms": 1,
            "https://docs.github.com/privacy": 1,
            "https://github.com/umlet/umlet/blob/79c4e46b103126c35da8ad474e6c8a7fe20437e0/umlet-swing/src/main/java/com/baselet/diagram/io/DiagramFileHandler.java#L252": 1,
            "commit::79c4e46b103126c35da8ad474e6c8a7fe20437e0": 1,
            "https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#JAXP_DocumentBuilderFactory.2C_SAXParserFactory_and_DOM4J": 1,
            "https://stackoverflow.com/a/10838805": 1,
            "https://0dd.zone/2018/04/23/UMLet-XXE/": 1,
            "https://github.com": 1,
            "https://docs.github.com/site-policy/github-terms/github-terms-of-service": 1,
            "https://docs.github.com/site-policy/privacy-policies/github-privacy-statement": 1,
            "https://github.com/security": 1,
            "https://www.githubstatus.com/": 1,
            "https://docs.github.com/": 1,
            "https://support.github.com?tags=dotcom-footer": 1
        },
        "affected_products": [
            "External",
            "UXF",
            "XXE",
            "n/a",
            "Entity",
            "XML"
        ],
        "versions": {
            "status": "affected",
            "version": "n/a"
        },
        "files": [
            "XML",
            "UXF",
            "XXE"
        ],
        "keywords": [
            "parse",
            "appear",
            "file",
            "denial",
            "datum",
            "result",
            "request",
            "forgery",
            "version",
            "service",
            "server",
            "contain",
            "disclosure",
            "entity",
            "side",
            "vulnerability",
            "external",
            "craft",
            "attack"
        ],
        "files_extension": [],
        "has_fixing_commit": true
    },
    "commits": [
        {
            "commit_id": "e1c4cc6ae692cc8d1c367460dbf79343e996f9bd",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1523001650,
            "hunks": 8,
            "message": "#500 secure xml parsing; new cfg secure_xml_processing",
            "diff": [
                "diff --git a/umlet-swing/src/main/java/com/baselet/control/config/Config.java b/umlet-swing/src/main/java/com/baselet/control/config/Config.java",
                "index b6099de4..bf94dfe3 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/control/config/Config.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/control/config/Config.java",
                "@@ -49,2 +49,3 @@ public class Config {",
                " \tprivate boolean start_maximized = false;",
                "+\tprivate boolean secureXmlProcessing = true;",
                " \tprivate String defaultFontFamily = Font.SANS_SERIF;",
                "@@ -165,2 +166,10 @@ public class Config {",
                "+\tpublic boolean isSecureXmlProcessing() {",
                "+\t\treturn secureXmlProcessing;",
                "+\t}",
                "+",
                "+\tpublic void setSecureXmlProcessing(boolean secureXmlProcessing) {",
                "+\t\tthis.secureXmlProcessing = secureXmlProcessing;",
                "+\t}",
                "+",
                " \tpublic int getPrintPadding() {",
                "diff --git a/umlet-swing/src/main/java/com/baselet/control/config/handler/ConfigHandler.java b/umlet-swing/src/main/java/com/baselet/control/config/handler/ConfigHandler.java",
                "index c4168bca..2aa05bb3 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/control/config/handler/ConfigHandler.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/control/config/handler/ConfigHandler.java",
                "@@ -41,2 +41,3 @@ public class ConfigHandler {",
                " \tprivate static final String CHECK_FOR_UPDATES = \"check_for_updates\";",
                "+\tprivate static final String SECURE_XML_PROCESSING = \"secure_xml_processing\";",
                " \tprivate static final String OPEN_FILE_HOME = \"open_file_home\";",
                "@@ -95,2 +96,3 @@ public class ConfigHandler {",
                " \t\tcfg.setCheckForUpdates(getBoolProperty(props, CHECK_FOR_UPDATES, cfg.isCheckForUpdates()));",
                "+\t\tcfg.setSecureXmlProcessing(getBoolProperty(props, SECURE_XML_PROCESSING, cfg.isSecureXmlProcessing()));",
                " \t\tcfg.setOpenFileHome(getStringProperty(props, OPEN_FILE_HOME, cfg.getOpenFileHome()));",
                "@@ -164,2 +166,3 @@ public class ConfigHandler {",
                " \t\t\tprops.setProperty(CHECK_FOR_UPDATES, Boolean.toString(cfg.isCheckForUpdates()));",
                "+\t\t\tprops.setProperty(SECURE_XML_PROCESSING, Boolean.toString(cfg.isSecureXmlProcessing()));",
                " \t\t\tprops.setProperty(OPEN_FILE_HOME, cfg.getOpenFileHome());",
                "diff --git a/umlet-swing/src/main/java/com/baselet/diagram/io/DiagramFileHandler.java b/umlet-swing/src/main/java/com/baselet/diagram/io/DiagramFileHandler.java",
                "index 2ff3b171..c23bc2a6 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/diagram/io/DiagramFileHandler.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/diagram/io/DiagramFileHandler.java",
                "@@ -20,2 +20,3 @@ import javax.swing.JOptionPane;",
                " import javax.swing.filechooser.FileFilter;",
                "+import javax.xml.XMLConstants;",
                " import javax.xml.parsers.DocumentBuilder;",
                "@@ -248,3 +249,11 @@ public class DiagramFileHandler {",
                " \t\ttry {",
                "-\t\t\tSAXParser parser = SAXParserFactory.newInstance().newSAXParser();",
                "+\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();",
                "+\t\t\tif (Config.getInstance().isSecureXmlProcessing()) {",
                "+\t\t\t\t// use secure xml processing (see https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#JAXP_DocumentBuilderFactory.2C_SAXParserFactory_and_DOM4J)",
                "+\t\t\t\tspf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);",
                "+\t\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);",
                "+\t\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);",
                "+\t\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);",
                "+\t\t\t}",
                "+\t\t\tSAXParser parser = spf.newSAXParser();",
                " \t\t\tFileInputStream input = new FileInputStream(file);",
                "@@ -255,3 +264,2 @@ public class DiagramFileHandler {",
                " \t\t\tlog.error(\"Cannot open the file: \" + file.getAbsolutePath(), e);",
                "-",
                " \t\t}"
            ],
            "changed_files": [
                "umlet-swing/src/main/java/com/baselet/control/config/Config.java",
                "umlet-swing/src/main/java/com/baselet/control/config/handler/ConfigHandler.java",
                "umlet-swing/src/main/java/com/baselet/diagram/io/DiagramFileHandler.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {
                "500": ""
            },
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": [
                {
                    "id": "XREF_GH",
                    "message": "The commit and the advisory (including referenced pages) mention the same github issue: 500",
                    "relevance": 32
                },
                {
                    "id": "COMMIT_IN_REFERENCE",
                    "message": "This commit is mentioned 2 times in the references.",
                    "relevance": 64
                },
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: XML, XXE",
                    "relevance": 8
                },
                {
                    "id": "SEC_KEYWORDS_IN_MESSAGE",
                    "message": "The commit message contains some security-related keywords: secure",
                    "relevance": 4
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: file",
                    "relevance": 4
                },
                {
                    "id": "GITHUB_ISSUE_IN_MESSAGE",
                    "message": "The commit message references some github issue: 500",
                    "relevance": 2
                }
            ]
        },
        {
            "commit_id": "79c4e46b103126c35da8ad474e6c8a7fe20437e0",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479547779,
            "hunks": 35,
            "message": "seq aio classes moved",
            "diff": [
                "diff --git a/umlet-elements/src/main/findbugs/findbugs-exclude.xml b/umlet-elements/src/main/findbugs/findbugs-exclude.xml",
                "index cb2f3b03..e1cd050d 100644",
                "--- a/umlet-elements/src/main/findbugs/findbugs-exclude.xml",
                "+++ b/umlet-elements/src/main/findbugs/findbugs-exclude.xml",
                "@@ -2,3 +2,3 @@",
                "   <Match>",
                "-    <Package name=\"~com.baselet.element.facet.specific.sequence_aio.gen.*\" />",
                "+    <Package name=\"~com.baselet.element.sequence_aio.gen.facet.specific.*\" />",
                "   </Match>",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/elementnew/uml/SequenceAllInOne.java b/umlet-elements/src/main/java/com/baselet/element/elementnew/uml/SequenceAllInOne.java",
                "index 537eae01..c84df961 100644",
                "--- a/umlet-elements/src/main/java/com/baselet/element/elementnew/uml/SequenceAllInOne.java",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/elementnew/uml/SequenceAllInOne.java",
                "@@ -13,3 +13,3 @@ import com.baselet.element.facet.common.FontSizeFacet;",
                " import com.baselet.element.facet.customdrawings.CustomDrawingFacet;",
                "-import com.baselet.element.facet.specific.sequence_aio.SequenceAllInOneFacet;",
                "+import com.baselet.element.sequence_aio.facet.SequenceAllInOneFacet;",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/CombinedFragment.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/CombinedFragment.java",
                "new file mode 100644",
                "index 00000000..596db6a6",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/CombinedFragment.java",
                "@@ -0,0 +1,328 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.ArrayList;",
                "+import java.util.Arrays;",
                "+import java.util.Collection;",
                "+import java.util.Deque;",
                "+import java.util.HashMap;",
                "+import java.util.Iterator;",
                "+import java.util.LinkedList;",
                "+import java.util.Map;",
                "+",
                "+import com.baselet.control.basics.Line1D;",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.control.enums.AlignHorizontal;",
                "+import com.baselet.control.enums.AlignVertical;",
                "+import com.baselet.control.enums.LineType;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.diagram.draw.TextSplitter;",
                "+",
                "+/**",
                "+ * Draws a combined fragment.",
                "+ * The border starts at the top of the start tick and ends at the bottom of the end tick + half of the tick y padding.",
                "+ *",
                "+ */",
                "+public class CombinedFragment implements LifelineSpanningTickSpanningOccurrence, Container {",
                "+",
                "+\t/** how much space is between the header and the first constraint */",
                "+\tprivate static final double HEADER_CONSTRAINT_PADDING = 5;",
                "+\tprivate static final double CONSTRAINT_Y_PADDING = 2;",
                "+\tprivate static final double COMBINED_FRAGMENT_HORIZONTAL_BORDER_PADDING = 7;",
                "+\tprivate static final double COMBINED_FRAGMENT_VERTICAL_BORDER_PADDING = 7;",
                "+",
                "+\tprivate final Lifeline[] coveredLifelines;",
                "+\t/** first tick which is in the combined fragment, contains the operator and the InteractionConstraint of the first operand */",
                "+\tprivate final int startTick;",
                "+\tprivate final String[] operatorLines;",
                "+\tprivate final Deque<Operand> operands;",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @param coveredLifelines the lifelines which are covered by this combined fragment",
                "+\t * @param startTick",
                "+\t * @param operator can be multiple lines (but only \\n is allowed)",
                "+\t */",
                "+\tpublic CombinedFragment(Lifeline[] coveredLifelines, int startTick, String operator) {",
                "+\t\tsuper();",
                "+\t\tthis.coveredLifelines = Arrays.copyOf(coveredLifelines, coveredLifelines.length);",
                "+\t\tthis.startTick = startTick;",
                "+\t\toperatorLines = operator.split(\"\\n\");",
                "+\t\toperands = new LinkedList<CombinedFragment.Operand>();",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Lifeline getFirstLifeline() {",
                "+\t\treturn coveredLifelines[0];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Lifeline getLastLifeline() {",
                "+\t\treturn coveredLifelines[coveredLifelines.length - 1];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic int getStartTick() {",
                "+\t\treturn startTick;",
                "+\t}",
                "+",
                "+\t// public void setEndTick(int endTick) {",
                "+\t// this.endTick = endTick;",
                "+\t// }",
                "+",
                "+\t/**",
                "+\t * the last tick which lies in the combined fragment",
                "+\t */",
                "+\t@Override",
                "+\tpublic int getEndTick() {",
                "+\t\tif (operands.isEmpty()) {",
                "+\t\t\treturn startTick;",
                "+\t\t}",
                "+\t\treturn operands.getLast().endTick;",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * Adds an operand to the combined fragement.",
                "+\t * @param startTick",
                "+\t * @param endTick",
                "+\t */",
                "+\tpublic void addOperand(int startTick, int endTick) {",
                "+\t\tif (operands.size() == 0 && this.startTick != startTick) {",
                "+\t\t\tthrow new IllegalArgumentException(\"The start tick of the first operand must be equal to the start tick of the combined fragment\");",
                "+\t\t}",
                "+\t\toperands.add(new Operand(startTick, endTick));",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * Adds an operand with an interaction constraint to the combined fragment.",
                "+\t * @param startTick",
                "+\t * @param endTick",
                "+\t * @param text",
                "+\t * @param constraintLifeline",
                "+\t * @throws SequenceDiagramCheckedException  if the lifeline already contains an occurrence at the startTick or",
                "+\t * if the lifeline is not created on start and the startTick is prior in time to the create tick",
                "+\t */",
                "+\tpublic void addOperand(int startTick, int endTick, String text, Lifeline constraintLifeline) throws SequenceDiagramCheckedException {",
                "+\t\tif (operands.size() == 0 && this.startTick != startTick) {",
                "+\t\t\tthrow new IllegalArgumentException(\"The start tick of the first operand must be equal to the start tick of the combined fragment\");",
                "+\t\t}",
                "+\t\toperands.add(new Operand(startTick, endTick, text, constraintLifeline));",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic void draw(DrawHandler drawHandler, DrawingInfo drawingInfo) {",
                "+\t\t// draw operand lines, the pentagon and the first operand",
                "+\t\tdrawOperandLines(drawHandler, drawingInfo);",
                "+\t\tPointDouble[] rectangle = new PointDouble[] {",
                "+\t\t\t\tnew PointDouble(drawingInfo.getHorizontalStart(this),",
                "+\t\t\t\t\t\tdrawingInfo.getVerticalStart(this)),",
                "+\t\t\t\tnew PointDouble(drawingInfo.getHorizontalEnd(this),",
                "+\t\t\t\t\t\tdrawingInfo.getVerticalStart(this)),",
                "+\t\t\t\tnew PointDouble(drawingInfo.getHorizontalEnd(this),",
                "+\t\t\t\t\t\tdrawingInfo.getVerticalEnd(this)),",
                "+\t\t\t\tnew PointDouble(drawingInfo.getHorizontalStart(this),",
                "+\t\t\t\t\t\tdrawingInfo.getVerticalEnd(this)),",
                "+\t\t\t\tnull",
                "+\t\t};",
                "+\t\trectangle[4] = rectangle[0];",
                "+\t\tdrawHandler.drawLines(rectangle);",
                "+\t\tCollection<Line1D> slopeNotPermittedAreas = new ArrayList<Line1D>(coveredLifelines.length);",
                "+\t\tfor (Lifeline ll : coveredLifelines) {",
                "+\t\t\tif (ll.getLifelineLeftPartWidth(startTick) > 0) {",
                "+\t\t\t\tdouble llCenter = drawingInfo.getHDrawingInfo(ll).getHorizontalCenter();",
                "+\t\t\t\tslopeNotPermittedAreas.add(new Line1D(llCenter - ll.getLifelineLeftPartWidth(startTick),",
                "+\t\t\t\t\t\tllCenter + ll.getLifelineRightPartWidth(startTick)));",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tPointDouble headerSize = PentagonDrawingHelper.draw(drawHandler, operatorLines,",
                "+\t\t\t\tdrawingInfo.getWidth(this), rectangle[0], slopeNotPermittedAreas);",
                "+",
                "+\t\t// add interruptions for all affected lifelines",
                "+\t\tdouble endOfHeadX = drawingInfo.getHorizontalStart(this) + headerSize.x;",
                "+\t\tfor (Lifeline ll : coveredLifelines) {",
                "+\t\t\tif (drawingInfo.getHDrawingInfo(ll).getHorizontalCenter() - ll.getLifelineLeftPartWidth(startTick) <= endOfHeadX) {",
                "+\t\t\t\tdrawingInfo.getDrawingInfo(ll).addInterruptedArea(new Line1D(rectangle[0].y, rectangle[0].y + headerSize.y));",
                "+\t\t\t}",
                "+\t\t\telse {",
                "+\t\t\t\t// we traverse the lifelines from left to right, therfore after the first ll which is not covered we can stop",
                "+\t\t\t\tbreak;",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\t// draw operand and add the interrupted area",
                "+\t\tif (operands.size() > 0 && operands.getFirst().constraint != null) {",
                "+\t\t\tOperand firstOperand = operands.getFirst();",
                "+\t\t\tOperand.InteractionConstraint firstIntConst = firstOperand.constraint;",
                "+\t\t\tdouble constraintTopY = drawingInfo.getVerticalStart(this) + headerSize.y + HEADER_CONSTRAINT_PADDING;",
                "+\t\t\tdouble constraintBottomY = drawingInfo.getVerticalEnd(startTick);",
                "+",
                "+\t\t\tdouble textHeight = TextSplitter.getSplitStringHeight(firstIntConst.textLines,",
                "+\t\t\t\t\tdrawingInfo.getHDrawingInfo(firstIntConst.affectedLifeline).getSymmetricWidth(startTick), drawHandler);",
                "+\t\t\ttextHeight += CONSTRAINT_Y_PADDING * 2;",
                "+\t\t\tconstraintTopY += (constraintBottomY - constraintTopY - textHeight) / 2;",
                "+\t\t\tTextSplitter.drawText(drawHandler, firstIntConst.textLines,",
                "+\t\t\t\t\tdrawingInfo.getHDrawingInfo(firstIntConst.affectedLifeline).getSymmetricHorizontalStart(startTick),",
                "+\t\t\t\t\tconstraintTopY,",
                "+\t\t\t\t\tdrawingInfo.getHDrawingInfo(firstIntConst.affectedLifeline).getSymmetricWidth(startTick),",
                "+\t\t\t\t\ttextHeight, AlignHorizontal.CENTER, AlignVertical.CENTER);",
                "+\t\t\tdrawingInfo.getDrawingInfo(firstIntConst.affectedLifeline).addInterruptedArea(",
                "+\t\t\t\t\tnew Line1D(constraintTopY, constraintTopY + textHeight));",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tprivate void drawOperandLines(DrawHandler drawHandler, DrawingInfo drawingInfo) {",
                "+\t\tIterator<Operand> operandIter = operands.iterator();",
                "+\t\tif (operandIter.hasNext()) {",
                "+\t\t\toperandIter.next(); // skip first operand",
                "+\t\t}",
                "+\t\tdrawHandler.setLineType(LineType.DASHED);",
                "+\t\twhile (operandIter.hasNext()) {",
                "+\t\t\tOperand op = operandIter.next();",
                "+\t\t\tdrawHandler.drawLine(drawingInfo.getHorizontalStart(this),",
                "+\t\t\t\t\tdrawingInfo.getVerticalStart(op.startTick) - drawingInfo.getTickVerticalPadding() / 2.0,",
                "+\t\t\t\t\tdrawingInfo.getHorizontalEnd(this),",
                "+\t\t\t\t\tdrawingInfo.getVerticalStart(op.startTick) - drawingInfo.getTickVerticalPadding() / 2.0);",
                "+\t\t}",
                "+\t\tdrawHandler.setLineType(LineType.SOLID);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getOverallMinWidth(DrawHandler drawHandler, double lifelineHorizontalPadding) {",
                "+\t\t// we only need to calculate the minimum width of the pentagon and the first operand,",
                "+\t\t// other operands are handled as LifelineOccurrence. Add the width of the execution specification of the last",
                "+\t\t// lifeline as buffere because in rare cases the slope could \"jump\" over it (to avoid that the slope is in the ExecSpec)",
                "+\t\t// add the border padding so nested combined fragments look nice",
                "+\t\tdouble minWidth = PentagonDrawingHelper.getMinimumWidth(drawHandler, operatorLines);",
                "+\t\tif (operands.size() > 0 && operands.getFirst().constraint != null) {",
                "+\t\t\tdouble constraintMinWidth = operands.getFirst().constraint.getMinWidth(drawHandler) * coveredLifelines.length + (coveredLifelines.length - 1) * lifelineHorizontalPadding;",
                "+\t\t\tminWidth = Math.max(minWidth, constraintMinWidth);",
                "+\t\t}",
                "+\t\treturn minWidth + getLastLifeline().getLifelineLeftPartWidth(startTick) + getLastLifeline().getLifelineRightPartWidth(startTick);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Map<Integer, Double> getEveryAdditionalYHeight(DrawHandler drawHandler, HorizontalDrawingInfo hInfo, double defaultTickHeight) {",
                "+\t\tMap<Integer, Double> ret = new HashMap<Integer, Double>();",
                "+",
                "+\t\t// we only need to calculate the pentagon + the first operand/InteractionConstrain because",
                "+\t\t// the separating lines are too thin to make a difference and the other operands are",
                "+\t\t// handled as LifelineOccurrence",
                "+\t\tdouble headerHeight = PentagonDrawingHelper.getHeight(drawHandler, operatorLines, hInfo.getWidth(this));",
                "+\t\theaderHeight -= COMBINED_FRAGMENT_VERTICAL_BORDER_PADDING; // head draws into the padding",
                "+\t\tif (operands.size() > 0 && operands.getFirst().constraint != null) {",
                "+\t\t\theaderHeight += HEADER_CONSTRAINT_PADDING;",
                "+\t\t\theaderHeight += TextSplitter.getSplitStringHeight(operands.getFirst().constraint.textLines,",
                "+\t\t\t\t\thInfo.getHDrawingInfo(operands.getFirst().constraint.affectedLifeline).getSymmetricWidth(startTick),",
                "+\t\t\t\t\tdrawHandler);",
                "+\t\t\theaderHeight += CONSTRAINT_Y_PADDING * 2;",
                "+\t\t}",
                "+\t\tif (headerHeight > defaultTickHeight) {",
                "+\t\t\tret.put(startTick, headerHeight - defaultTickHeight);",
                "+\t\t}",
                "+\t\treturn ret;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic ContainerPadding getPaddingInformation() {",
                "+\t\treturn new ContainerPadding(this, COMBINED_FRAGMENT_HORIZONTAL_BORDER_PADDING,",
                "+\t\t\t\tCOMBINED_FRAGMENT_HORIZONTAL_BORDER_PADDING,",
                "+\t\t\t\tCOMBINED_FRAGMENT_VERTICAL_BORDER_PADDING,",
                "+\t\t\t\tCOMBINED_FRAGMENT_VERTICAL_BORDER_PADDING);",
                "+\t}",
                "+",
                "+\tprivate class Operand {",
                "+\t\tprivate final int startTick;",
                "+\t\tprivate final int endTick;",
                "+",
                "+\t\tprivate final InteractionConstraint constraint;",
                "+",
                "+\t\tpublic Operand(int startTick, int endTick) {",
                "+\t\t\tsuper();",
                "+\t\t\tthis.startTick = startTick;",
                "+\t\t\tthis.endTick = endTick;",
                "+\t\t\tconstraint = null;",
                "+\t\t}",
                "+",
                "+\t\t/**",
                "+\t\t *",
                "+\t\t * @param startTick",
                "+\t\t * @param endTick",
                "+\t\t * @param text",
                "+\t\t * @param constraintLifeline",
                "+\t\t * @throws SequenceDiagramCheckedException if the lifeline already contains an occurrence at the startTick or",
                "+\t\t * if the lifeline is not created on start and the startTick is prior in time to the create tick",
                "+\t\t */",
                "+\t\tpublic Operand(int startTick, int endTick, String text, Lifeline constraintLifeline) throws SequenceDiagramCheckedException {",
                "+\t\t\tsuper();",
                "+\t\t\tthis.startTick = startTick;",
                "+\t\t\tthis.endTick = endTick;",
                "+\t\t\tconstraint = new InteractionConstraint(text, constraintLifeline);",
                "+\t\t}",
                "+",
                "+\t\tpublic boolean isFirstOperand() {",
                "+\t\t\treturn operands.getFirst() == this;",
                "+\t\t}",
                "+",
                "+\t\tpublic boolean isLastOperand() {",
                "+\t\t\treturn operands.getLast() == this;",
                "+\t\t}",
                "+",
                "+\t\t/**",
                "+\t\t * Represents an interaction constraint of an operand of a combined fragment.",
                "+\t\t * The drawing and calculation of the height for the interaction constraint",
                "+\t\t * of the first operand is handled by the combined fragment because the",
                "+\t\t * positioning of it is tightly coupled with the operator drawing.",
                "+\t\t *",
                "+\t\t */",
                "+\t\tprivate class InteractionConstraint implements LifelineOccurrence {",
                "+",
                "+\t\t\tprivate final String[] textLines;",
                "+\t\t\tprivate final Lifeline affectedLifeline;",
                "+",
                "+\t\t\t/**",
                "+\t\t\t * @param constraintText the constraint without the square brackets",
                "+\t\t\t * @param affectedLifeline the lifeline on which the constraint should be placed",
                "+\t\t\t * @throws SequenceDiagramCheckedException if the lifeline already contains an occurrence at the {@link Operand#startTick} or",
                "+\t\t\t * if the lifeline is not created on start and the {@link Operand#startTick} is prior in time to the create tick",
                "+\t\t\t */",
                "+\t\t\tpublic InteractionConstraint(String constraintText, Lifeline affectedLifeline) throws SequenceDiagramCheckedException {",
                "+\t\t\t\tsuper();",
                "+\t\t\t\ttextLines = ('[' + constraintText + ']').split(\"\\n\");",
                "+\t\t\t\tthis.affectedLifeline = affectedLifeline;",
                "+\t\t\t\taffectedLifeline.addLifelineOccurrenceAtTick(this, startTick);",
                "+\t\t\t}",
                "+",
                "+\t\t\t@Override",
                "+\t\t\tpublic Line1D draw(DrawHandler drawHandler, PointDouble topLeft, PointDouble size) {",
                "+\t\t\t\tif (isFirstOperand()) {",
                "+\t\t\t\t\t// first operand is handled by the combined fragment",
                "+\t\t\t\t\treturn null;",
                "+\t\t\t\t}",
                "+\t\t\t\telse {",
                "+\t\t\t\t\tdouble textHeight = TextSplitter.getSplitStringHeight(textLines, size.x, drawHandler);",
                "+\t\t\t\t\tLine1D interruptedArea = new Line1D(topLeft.y + (size.y - textHeight) / 2 - CONSTRAINT_Y_PADDING,",
                "+\t\t\t\t\t\t\ttopLeft.y + (size.y - textHeight) / 2 + textHeight + CONSTRAINT_Y_PADDING);",
                "+\t\t\t\t\tTextSplitter.drawText(drawHandler, textLines, topLeft.x, interruptedArea.getLow() + CONSTRAINT_Y_PADDING,",
                "+\t\t\t\t\t\t\tsize.x, textHeight, AlignHorizontal.CENTER, AlignVertical.CENTER);",
                "+\t\t\t\t\treturn interruptedArea;",
                "+\t\t\t\t}",
                "+\t\t\t}",
                "+",
                "+\t\t\t@Override",
                "+\t\t\tpublic double getMinWidth(DrawHandler drawHandler) {",
                "+\t\t\t\treturn TextSplitter.getTextMinWidth(textLines, drawHandler);",
                "+\t\t\t}",
                "+",
                "+\t\t\t@Override",
                "+\t\t\tpublic double getAdditionalYHeight(DrawHandler drawHandler, PointDouble size) {",
                "+\t\t\t\tif (isFirstOperand()) {",
                "+\t\t\t\t\t// first operand is handled by the combined fragment",
                "+\t\t\t\t\treturn -1;",
                "+\t\t\t\t}",
                "+\t\t\t\telse {",
                "+\t\t\t\t\treturn TextSplitter.getSplitStringHeight(textLines, size.x, drawHandler) + CONSTRAINT_Y_PADDING * 2 - size.y;",
                "+\t\t\t\t}",
                "+\t\t\t}",
                "+",
                "+\t\t}",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Container.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Container.java",
                "new file mode 100644",
                "index 00000000..ff8fb905",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Container.java",
                "@@ -0,0 +1,12 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+public interface Container {",
                "+",
                "+\tint getStartTick();",
                "+",
                "+\tint getEndTick();",
                "+",
                "+\tLifeline getFirstLifeline();",
                "+",
                "+\tLifeline getLastLifeline();",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Continuation.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Continuation.java",
                "new file mode 100644",
                "index 00000000..60727519",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Continuation.java",
                "@@ -0,0 +1,86 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.Arrays;",
                "+import java.util.HashMap;",
                "+import java.util.Map;",
                "+",
                "+import com.baselet.control.basics.Line1D;",
                "+import com.baselet.control.enums.AlignHorizontal;",
                "+import com.baselet.control.enums.AlignVertical;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.diagram.draw.TextSplitter;",
                "+",
                "+public class Continuation implements LifelineSpanningTickSpanningOccurrence {",
                "+\t/** the width of the ellipse which builds the left and right border (no text is drawn in this) */",
                "+\tprivate static final double ROUND_PART_WIDTH = 20;",
                "+\t/** the space between the text and the border line */",
                "+\tprivate static final double VERTICAL_BORDER_PADDING = 5;",
                "+",
                "+\tprivate final int tick;",
                "+\tprivate final String[] textLines;",
                "+\tprivate final Lifeline[] coveredLifelines;",
                "+",
                "+\tpublic Continuation(int tick, String text, Lifeline[] coveredLifelines) {",
                "+\t\tsuper();",
                "+\t\tthis.tick = tick;",
                "+\t\ttextLines = text.split(\"\\n\");",
                "+\t\tthis.coveredLifelines = Arrays.copyOf(coveredLifelines, coveredLifelines.length);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Lifeline getFirstLifeline() {",
                "+\t\treturn coveredLifelines[0];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Lifeline getLastLifeline() {",
                "+\t\treturn coveredLifelines[coveredLifelines.length - 1];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic void draw(DrawHandler drawHandler, DrawingInfo drawingInfo) {",
                "+\t\tdouble width = drawingInfo.getSymmetricWidth(getFirstLifeline(), getLastLifeline(), tick);",
                "+\t\tdouble height = TextSplitter.getSplitStringHeight(textLines, width - ROUND_PART_WIDTH * 2, drawHandler) + VERTICAL_BORDER_PADDING * 2;",
                "+\t\tdouble topY = drawingInfo.getVerticalStart(tick);",
                "+\t\ttopY += (drawingInfo.getTickHeight(tick) - height) / 2;",
                "+\t\tdouble leftX = drawingInfo.getHDrawingInfo(getFirstLifeline()).getSymmetricHorizontalStart(tick);",
                "+",
                "+\t\tdrawHandler.drawArc(leftX, topY, ROUND_PART_WIDTH * 2, height, 90, 180, true);",
                "+\t\twidth = width - ROUND_PART_WIDTH * 2;",
                "+\t\tdrawHandler.drawArc(leftX + width, topY, ROUND_PART_WIDTH * 2, height, 270, 180, true);",
                "+\t\tdrawHandler.drawLine(leftX + ROUND_PART_WIDTH, topY, leftX + width + ROUND_PART_WIDTH, topY);",
                "+\t\tdrawHandler.drawLine(leftX + ROUND_PART_WIDTH, topY + height, leftX + width + ROUND_PART_WIDTH, topY + height);",
                "+\t\tTextSplitter.drawText(drawHandler, textLines, leftX + ROUND_PART_WIDTH, topY, width, height,",
                "+\t\t\t\tAlignHorizontal.CENTER, AlignVertical.CENTER);",
                "+",
                "+\t\tfor (Lifeline ll : coveredLifelines) {",
                "+\t\t\tdrawingInfo.getDrawingInfo(ll).addInterruptedArea(new Line1D(topY, topY + height));",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getOverallMinWidth(DrawHandler drawHandler, double lifelineHorizontalPadding) {",
                "+\t\treturn TextSplitter.getTextMinWidth(textLines, drawHandler) + ROUND_PART_WIDTH * 2;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Map<Integer, Double> getEveryAdditionalYHeight(DrawHandler drawHandler,",
                "+\t\t\tHorizontalDrawingInfo hInfo, double defaultTickHeight",
                "+\t// Line1D[] lifelinesHorizontalSpanning, double tickHeight",
                "+\t) {",
                "+\t\tMap<Integer, Double> ret = new HashMap<Integer, Double>();",
                "+\t\tdouble neededHeight = TextSplitter.getSplitStringHeight(textLines,",
                "+\t\t\t\thInfo.getSymmetricWidth(getFirstLifeline(), getLastLifeline(), tick) - ROUND_PART_WIDTH * 2,",
                "+\t\t\t\tdrawHandler) + VERTICAL_BORDER_PADDING * 2;",
                "+\t\tif (neededHeight > defaultTickHeight) {",
                "+\t\t\tret.put(tick, neededHeight - defaultTickHeight);",
                "+\t\t}",
                "+\t\treturn ret;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic ContainerPadding getPaddingInformation() {",
                "+\t\treturn null;",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Coregion.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Coregion.java",
                "new file mode 100644",
                "index 00000000..a62e8e0f",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Coregion.java",
                "@@ -0,0 +1,81 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import com.baselet.control.basics.Line1D;",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+",
                "+/**",
                "+ * <pre>",
                "+ * getLifelineLeftPartWidth",
                "+ *        +--+",
                "+ *            getLifelineRightPartWidth",
                "+ *           +------+",
                "+ *",
                "+ *           |",
                "+ *        +--+--+",
                "+ *        |     |",
                "+ *        |   +-+---+",
                "+ *        |   |     |",
                "+ * +-------------------+",
                "+ * |      |   |     |  |  height",
                "+ * |      |   |     |  |",
                "+ * +      |   +-+---+  +",
                "+ *        |     |",
                "+ *        +--+--+",
                "+ *           |",
                "+ * +--+             +--+",
                "+ * gap               gap",
                "+ *",
                "+ *</pre>",
                "+ */",
                "+public class Coregion implements LifelineOccurrence {",
                "+",
                "+\tprivate static final double COREGION_GAP_LIFELINE = 10;",
                "+\tprivate static final double COREGION_HEIGHT = 10;",
                "+",
                "+\tprivate final Lifeline correspondingLifeline;",
                "+\tprivate final int tick;",
                "+\tprivate final boolean start;",
                "+",
                "+\t/**",
                "+\t * @param lifeline on which the Coregion is specified",
                "+\t * @param start if true then it is the beginning of a Coregion, otherwise it is the end of a Coregion",
                "+\t */",
                "+\tpublic Coregion(Lifeline lifeline, int tick, boolean start) {",
                "+\t\tcorrespondingLifeline = lifeline;",
                "+\t\tthis.tick = tick;",
                "+\t\tthis.start = start;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Line1D draw(DrawHandler drawHandler, PointDouble topLeft, PointDouble size) {",
                "+\t\tPointDouble topLeftCoregion = new PointDouble(topLeft.x + size.x / 2.0 - getWidth() / 2.0, topLeft.y + size.y / 2.0 - COREGION_HEIGHT / 2.0);",
                "+\t\tif (isStart()) {",
                "+\t\t\tdrawHandler.drawLine(topLeftCoregion.x, topLeftCoregion.y, topLeftCoregion.x + getWidth(), topLeftCoregion.y); // horizontal line",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tdrawHandler.drawLine(topLeftCoregion.x, topLeftCoregion.y + COREGION_HEIGHT, topLeftCoregion.x + getWidth(), topLeftCoregion.y + COREGION_HEIGHT); // horizontal line",
                "+\t\t}",
                "+\t\tdrawHandler.drawLine(topLeftCoregion.x, topLeftCoregion.y, topLeftCoregion.x, topLeftCoregion.y + COREGION_HEIGHT); // left vertical line",
                "+\t\tdrawHandler.drawLine(topLeftCoregion.x + getWidth(), topLeftCoregion.y, topLeftCoregion.x + getWidth(), topLeftCoregion.y + COREGION_HEIGHT); // right vertical line",
                "+\t\treturn null;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getMinWidth(DrawHandler drawHandler) {",
                "+\t\treturn getWidth();",
                "+\t}",
                "+",
                "+\tpublic double getWidth() {",
                "+\t\treturn correspondingLifeline.getLifelineRightPartWidth(tick) * 2 + COREGION_GAP_LIFELINE * 2;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getAdditionalYHeight(DrawHandler drawHandler, PointDouble size) {",
                "+\t\treturn COREGION_HEIGHT - size.y;",
                "+\t}",
                "+",
                "+\tpublic boolean isStart() {",
                "+\t\treturn start;",
                "+\t}",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/DrawingInfo.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/DrawingInfo.java",
                "new file mode 100644",
                "index 00000000..cd6fdb86",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/DrawingInfo.java",
                "@@ -0,0 +1,10 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+/**",
                "+ * Interface for the drawing information of a whole diagram.",
                "+ */",
                "+public interface DrawingInfo extends HorizontalDrawingInfo, VerticalDrawingInfo {",
                "+",
                "+\tpublic LifelineDrawingInfo getDrawingInfo(Lifeline lifeline);",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/DrawingInfoImpl.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/DrawingInfoImpl.java",
                "new file mode 100644",
                "index 00000000..dd946355",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/DrawingInfoImpl.java",
                "@@ -0,0 +1,244 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import com.baselet.control.basics.Line1D;",
                "+import com.baselet.control.basics.SortedMergedLine1DList;",
                "+",
                "+public class DrawingInfoImpl implements DrawingInfo {",
                "+",
                "+\t// private final LifelineHorizontalDrawingInfo[] horizontalDrawingInfos;",
                "+\tprivate final HorizontalDrawingInfo horizontalDrawingInfo;",
                "+\tprivate final SortedMergedLine1DList[] interruptedAreas;",
                "+\tprivate final VerticalDrawingInfo verticalDrawingInfo;",
                "+",
                "+\tpublic DrawingInfoImpl(HorizontalDrawingInfo horizontalDrawingInfo, VerticalDrawingInfo verticalDrawingInfo,",
                "+\t\t\tint lifelineCount) {",
                "+\t\tsuper();",
                "+\t\tthis.horizontalDrawingInfo = horizontalDrawingInfo;",
                "+\t\tinterruptedAreas = new SortedMergedLine1DList[lifelineCount];",
                "+\t\tfor (int i = 0; i < interruptedAreas.length; i++) {",
                "+\t\t\tinterruptedAreas[i] = new SortedMergedLine1DList();",
                "+\t\t}",
                "+\t\tthis.verticalDrawingInfo = verticalDrawingInfo;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic LifelineDrawingInfo getDrawingInfo(Lifeline lifeline) {",
                "+\t\treturn new LifelineDrawingInfoProxy(lifeline);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic LifelineHorizontalDrawingInfo getHDrawingInfo(Lifeline lifeline) {",
                "+\t\treturn horizontalDrawingInfo.getHDrawingInfo(lifeline);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getSymmetricWidth(Lifeline ll1, Lifeline ll2, int tick) {",
                "+\t\treturn horizontalDrawingInfo.getSymmetricWidth(ll1, ll2, tick);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getHorizontalStart(Container container) {",
                "+\t\treturn horizontalDrawingInfo.getHorizontalStart(container);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getHorizontalEnd(Container container) {",
                "+\t\treturn horizontalDrawingInfo.getHorizontalEnd(container);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getWidth(Container container) {",
                "+\t\treturn horizontalDrawingInfo.getWidth(container);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getDiagramHorizontalStart() {",
                "+\t\treturn horizontalDrawingInfo.getDiagramHorizontalStart();",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getDiagramHorizontalEnd() {",
                "+\t\treturn horizontalDrawingInfo.getDiagramHorizontalEnd();",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getDiagramWidth() {",
                "+\t\treturn horizontalDrawingInfo.getDiagramWidth();",
                "+\t}",
                "+",
                "+\tprivate SortedMergedLine1DList getInterruptedAreas(int lifelineIndex) {",
                "+\t\treturn interruptedAreas[lifelineIndex];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalHeadStart() {",
                "+\t\treturn verticalDrawingInfo.getVerticalHeadStart();",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalHeadEnd() {",
                "+\t\treturn verticalDrawingInfo.getVerticalHeadEnd();",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getHeadHeight() {",
                "+\t\treturn verticalDrawingInfo.getHeadHeight();",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalStart(int tick) {",
                "+\t\treturn verticalDrawingInfo.getVerticalStart(tick);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalEnd(int tick) {",
                "+\t\treturn verticalDrawingInfo.getVerticalEnd(tick);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalCenter(int tick) {",
                "+\t\treturn verticalDrawingInfo.getVerticalCenter(tick);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getTickHeight(int tick) {",
                "+\t\treturn verticalDrawingInfo.getTickHeight(tick);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getTickVerticalPadding() {",
                "+\t\treturn verticalDrawingInfo.getTickVerticalPadding();",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalStart(Container container) {",
                "+\t\treturn verticalDrawingInfo.getVerticalStart(container);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalEnd(Container container) {",
                "+\t\treturn verticalDrawingInfo.getVerticalEnd(container);",
                "+\t}",
                "+",
                "+\tprivate class LifelineDrawingInfoProxy implements LifelineDrawingInfo {",
                "+",
                "+\t\tprivate final Lifeline lifeline;",
                "+",
                "+\t\tpublic LifelineDrawingInfoProxy(Lifeline lifeline) {",
                "+\t\t\tsuper();",
                "+\t\t\tthis.lifeline = lifeline;",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getHorizontalStart() {",
                "+\t\t\treturn getHDrawingInfo(lifeline).getHorizontalStart();",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getHorizontalEnd() {",
                "+\t\t\treturn getHDrawingInfo(lifeline).getHorizontalEnd();",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getHorizontalStart(int tick) {",
                "+\t\t\treturn getHDrawingInfo(lifeline).getHorizontalStart(tick);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getHorizontalEnd(int tick) {",
                "+\t\t\treturn getHDrawingInfo(lifeline).getHorizontalEnd(tick);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getHorizontalCenter() {",
                "+\t\t\treturn getHDrawingInfo(lifeline).getHorizontalCenter();",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getWidth() {",
                "+\t\t\treturn getHDrawingInfo(lifeline).getWidth();",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getWidth(int tick) {",
                "+\t\t\treturn getHDrawingInfo(lifeline).getWidth(tick);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getSymmetricHorizontalStart(int tick) {",
                "+\t\t\treturn getHDrawingInfo(lifeline).getSymmetricHorizontalStart(tick);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getSymmetricHorizontalEnd(int tick) {",
                "+\t\t\treturn getHDrawingInfo(lifeline).getSymmetricHorizontalEnd(tick);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getSymmetricWidth(int tick) {",
                "+\t\t\treturn getHDrawingInfo(lifeline).getSymmetricWidth(tick);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getVerticalHeadStart() {",
                "+\t\t\treturn verticalDrawingInfo.getVerticalHeadStart();",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getVerticalHeadEnd() {",
                "+\t\t\treturn verticalDrawingInfo.getVerticalHeadEnd();",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getHeadHeight() {",
                "+\t\t\treturn verticalDrawingInfo.getHeadHeight();",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getVerticalStart(int tick) {",
                "+\t\t\treturn verticalDrawingInfo.getVerticalStart(tick);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getVerticalEnd(int tick) {",
                "+\t\t\treturn verticalDrawingInfo.getVerticalEnd(tick);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getVerticalCenter(int tick) {",
                "+\t\t\treturn verticalDrawingInfo.getVerticalCenter(tick);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getTickHeight(int tick) {",
                "+\t\t\treturn verticalDrawingInfo.getTickHeight(tick);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getTickVerticalPadding() {",
                "+\t\t\treturn verticalDrawingInfo.getTickVerticalPadding();",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic SortedMergedLine1DList getInterruptedAreas() {",
                "+\t\t\treturn DrawingInfoImpl.this.getInterruptedAreas(lifeline.getIndex());",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic void addInterruptedArea(Line1D llInterruption) {",
                "+\t\t\tgetInterruptedAreas().add(llInterruption);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getVerticalStart(Container container) {",
                "+\t\t\treturn verticalDrawingInfo.getVerticalStart(container);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getVerticalEnd(Container container) {",
                "+\t\t\treturn verticalDrawingInfo.getVerticalStart(container);",
                "+\t\t}",
                "+",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/ExecutionSpecification.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/ExecutionSpecification.java",
                "new file mode 100644",
                "index 00000000..433b2174",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/ExecutionSpecification.java",
                "@@ -0,0 +1,35 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+public class ExecutionSpecification {",
                "+",
                "+\tprivate int startTick;",
                "+\t/** the last tick on which it is active */",
                "+\tprivate int endTick;",
                "+",
                "+\tpublic ExecutionSpecification(int startTick, int endTick) {",
                "+\t\tsuper();",
                "+\t\tthis.startTick = startTick;",
                "+\t\tthis.endTick = endTick;",
                "+\t}",
                "+",
                "+\tpublic int getStartTick() {",
                "+\t\treturn startTick;",
                "+\t}",
                "+",
                "+\tpublic void setStartTick(int start) {",
                "+\t\tstartTick = start;",
                "+\t}",
                "+",
                "+\tpublic int getEndTick() {",
                "+\t\treturn endTick;",
                "+\t}",
                "+",
                "+\tpublic void setEndTick(int end) {",
                "+\t\tendTick = end;",
                "+\t}",
                "+",
                "+\tpublic boolean enclosesTick(int tick)",
                "+\t{",
                "+\t\treturn startTick <= tick && tick <= endTick;",
                "+\t}",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/GateMessage.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/GateMessage.java",
                "new file mode 100644",
                "index 00000000..5b967633",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/GateMessage.java",
                "@@ -0,0 +1,117 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.Map;",
                "+",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.control.enums.LineType;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.diagram.draw.TextSplitter;",
                "+import com.baselet.element.relation.helper.RelationDrawer.ArrowEndType;",
                "+",
                "+public class GateMessage extends Message {",
                "+",
                "+\t/** true if the sender is a gate */",
                "+\tprivate final boolean sendGate;",
                "+",
                "+\tprivate final boolean dockToLeftBorder;",
                "+",
                "+\tprivate GateMessage(Lifeline from, Lifeline to, int sendTick, String text, ArrowType arrowType, LineType lineType,",
                "+\t\t\tboolean sendGate, boolean dockToLeftBorder) {",
                "+\t\tsuper(from, to, 0, sendTick, text, arrowType, lineType);",
                "+\t\tthis.sendGate = sendGate;",
                "+\t\tthis.dockToLeftBorder = dockToLeftBorder;",
                "+\t}",
                "+",
                "+\tpublic static GateMessage createSendGateMessage(Lifeline receiver, int sendTick, String text, ArrowType arrowType,",
                "+\t\t\tLineType lineType, Lifeline leftMostLifeline, Lifeline rightMostLifeline) {",
                "+\t\tif (Math.abs(receiver.getIndex() - leftMostLifeline.getIndex()) <= Math.abs(receiver.getIndex() - rightMostLifeline.getIndex())) {",
                "+\t\t\treturn new GateMessage(leftMostLifeline, receiver, sendTick, text, arrowType, lineType, true, true);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\treturn new GateMessage(rightMostLifeline, receiver, sendTick, text, arrowType, lineType, true, false);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tpublic static GateMessage createReceiveGateMessage(Lifeline sender, int sendTick, String text, ArrowType arrowType,",
                "+\t\t\tLineType lineType, Lifeline leftMostLifeline, Lifeline rightMostLifeline) {",
                "+\t\tif (Math.abs(sender.getIndex() - leftMostLifeline.getIndex()) < Math.abs(sender.getIndex() - rightMostLifeline.getIndex())) {",
                "+\t\t\treturn new GateMessage(sender, leftMostLifeline, sendTick, text, arrowType, lineType, false, true);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\treturn new GateMessage(sender, rightMostLifeline, sendTick, text, arrowType, lineType, false, false);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tprotected double getSendX(HorizontalDrawingInfo hDrawingInfo) {",
                "+\t\tif (sendGate) {",
                "+\t\t\tif (dockToLeftBorder) {",
                "+\t\t\t\treturn hDrawingInfo.getDiagramHorizontalStart();",
                "+\t\t\t}",
                "+\t\t\telse {",
                "+\t\t\t\treturn hDrawingInfo.getDiagramHorizontalEnd();",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\treturn super.getSendX(hDrawingInfo);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tprotected double getReceiveX(HorizontalDrawingInfo hDrawingInfo) {",
                "+\t\tif (sendGate) {",
                "+\t\t\treturn super.getReceiveX(hDrawingInfo);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tif (dockToLeftBorder) {",
                "+\t\t\t\treturn hDrawingInfo.getDiagramHorizontalStart();",
                "+\t\t\t}",
                "+\t\t\telse {",
                "+\t\t\t\treturn hDrawingInfo.getDiagramHorizontalEnd();",
                "+\t\t\t}",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tprotected void drawSelfMessage(DrawHandler drawHandler, PointDouble send, PointDouble receive, ArrowEndType arrowEndType, boolean fillArrow, DrawingInfo hInfo) {",
                "+\t\tsuper.drawNormalMessage(drawHandler, send, receive, arrowEndType, fillArrow, hInfo);",
                "+\t\t// draw the self messages as normal messages because these message aren't real self messages",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getOverallMinWidth(DrawHandler drawHandler, double lifelineHorizontalPadding) {",
                "+\t\tdouble executionSpecWidth = !sendGate ? Math.abs(getSendCenterXOffset()) : Math.abs(getReceiveCenterXOffset());",
                "+\t\tdouble neededWidth = executionSpecWidth + TextSplitter.getTextMinWidth(textLines, drawHandler)",
                "+\t\t\t\t\t\t\t\t+ LIFELINE_TEXT_PADDING * 2;",
                "+\t\tif (from == to) {",
                "+\t\t\treturn neededWidth * 2;",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tint affectedLifelineCount = getLastLifeline().getIndex() - getFirstLifeline().getIndex();",
                "+\t\t\tdouble padding = lifelineHorizontalPadding * affectedLifelineCount;",
                "+\t\t\treturn (neededWidth - padding) * (affectedLifelineCount + 1) / (affectedLifelineCount + 0.5);",
                "+\t\t}",
                "+\t};",
                "+",
                "+\t@Override",
                "+\tprotected void getEveryAdditionalYHeightSelfMessage(DrawHandler drawHandler, HorizontalDrawingInfo hInfo, double defaultTickHeight, Map<Integer, Double> ret) {",
                "+\t\tsuper.getEveryAdditionalYHeightNormalMessage(drawHandler, hInfo, defaultTickHeight, ret);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic OccurrenceSpecification sendOccurrenceSpecification() {",
                "+\t\tif (sendGate) {",
                "+\t\t\tthrow new IllegalStateException(\"This GateMessage was created with an sender gate, and a gate has no associated occurrence specification.\");",
                "+\t\t}",
                "+\t\treturn super.sendOccurrenceSpecification();",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic OccurrenceSpecification receiveOccurrenceSpecification() {",
                "+\t\tif (!sendGate) {",
                "+\t\t\tthrow new IllegalStateException(\"This GateMessage was created with an receiver gate, and a gate has no associated occurrence specification.\");",
                "+\t\t}",
                "+\t\treturn super.receiveOccurrenceSpecification();",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/GeneralOrdering.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/GeneralOrdering.java",
                "new file mode 100644",
                "index 00000000..3d714e3f",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/GeneralOrdering.java",
                "@@ -0,0 +1,65 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.Arrays;",
                "+import java.util.HashMap;",
                "+import java.util.Map;",
                "+",
                "+import com.baselet.control.basics.geom.Line;",
                "+import com.baselet.control.enums.LineType;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.element.relation.helper.RelationDrawer;",
                "+import com.baselet.element.relation.helper.RelationDrawer.ArrowEndType;",
                "+",
                "+public class GeneralOrdering implements LifelineSpanningTickSpanningOccurrence {",
                "+",
                "+\tprivate final Lifeline[] coveredLifelines;",
                "+\tprivate final OccurrenceSpecification earlierOccurrence;",
                "+\tprivate final OccurrenceSpecification laterOccurrence;",
                "+",
                "+\tpublic GeneralOrdering(OccurrenceSpecification earlierOccurrence, OccurrenceSpecification laterOccurrence, Lifeline[] coveredLifelines) {",
                "+\t\tif (coveredLifelines.length < 2) {",
                "+\t\t\tthrow new IllegalArgumentException(\"A GeneralOrdering must affect two different lifelines.\");",
                "+\t\t}",
                "+\t\tthis.coveredLifelines = Arrays.copyOf(coveredLifelines, coveredLifelines.length);",
                "+\t\tthis.earlierOccurrence = earlierOccurrence;",
                "+\t\tthis.laterOccurrence = laterOccurrence;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Lifeline getFirstLifeline() {",
                "+\t\treturn coveredLifelines[0];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Lifeline getLastLifeline() {",
                "+\t\treturn coveredLifelines[coveredLifelines.length - 1];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic void draw(DrawHandler drawHandler, DrawingInfo drawingInfo) {",
                "+\t\tLineType oldLt = drawHandler.getLineType();",
                "+\t\tdrawHandler.setLineType(LineType.DASHED);",
                "+\t\tLine line = new Line(earlierOccurrence.getPosition(drawingInfo), laterOccurrence.getPosition(drawingInfo));",
                "+\t\tdrawHandler.drawLine(line);",
                "+\t\tdrawHandler.setLineType(oldLt);",
                "+\t\tRelationDrawer.drawArrowToLine(line.getCenter(), drawHandler, line, false, ArrowEndType.NORMAL, false, false);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getOverallMinWidth(DrawHandler drawHandler, double lifelineHorizontalPadding) {",
                "+\t\t// only the size of the arrow is needed, which is multiplied by 3 to have some padding",
                "+\t\treturn RelationDrawer.ARROW_LENGTH * 3;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Map<Integer, Double> getEveryAdditionalYHeight(DrawHandler drawHandler, HorizontalDrawingInfo hInfo,",
                "+\t\t\tdouble defaultTickHeight) {",
                "+\t\t// since it is only a line with an arrow in the middle we assume that we don't need any further space",
                "+\t\treturn new HashMap<Integer, Double>();",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic ContainerPadding getPaddingInformation() {",
                "+\t\treturn null;",
                "+\t}",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/HorizontalDrawingInfo.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/HorizontalDrawingInfo.java",
                "new file mode 100644",
                "index 00000000..3999972e",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/HorizontalDrawingInfo.java",
                "@@ -0,0 +1,39 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+/**",
                "+ * Interface for the drawing information of a whole diagram.",
                "+ */",
                "+public interface HorizontalDrawingInfo {",
                "+",
                "+\tpublic LifelineHorizontalDrawingInfo getHDrawingInfo(Lifeline lifeline);",
                "+",
                "+\t/**",
                "+\t * Returns the distance between the starting point of the lifeline which starts first and the end point of the",
                "+\t * other.",
                "+\t * I.e. with no loss of generality {@code ll1.getIndex() <= ll2.getIndex()} then",
                "+\t * <pre>",
                "+\t * {@code",
                "+\t * getHDrawingInfo(ll1).getSymmetricHorizontalEnd(tick)",
                "+\t * -getHDrawingInfo(ll2).getSymmetricHorizontalStart(tick)",
                "+\t * }",
                "+\t * </pre>",
                "+\t * is returned.",
                "+\t * @param ll1",
                "+\t * @param ll2",
                "+\t * @param tick",
                "+\t * @return the symmetric width which is spanned by the two lifelines at the given tick",
                "+\t */",
                "+\tpublic double getSymmetricWidth(Lifeline ll1, Lifeline ll2, int tick);",
                "+",
                "+\tpublic double getHorizontalStart(Container container);",
                "+",
                "+\tpublic double getHorizontalEnd(Container container);",
                "+",
                "+\tpublic double getWidth(Container container);",
                "+",
                "+\tpublic double getDiagramHorizontalStart();",
                "+",
                "+\tpublic double getDiagramHorizontalEnd();",
                "+",
                "+\tpublic double getDiagramWidth();",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/HorizontalDrawingInfoImpl.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/HorizontalDrawingInfoImpl.java",
                "new file mode 100644",
                "index 00000000..c2981e87",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/HorizontalDrawingInfoImpl.java",
                "@@ -0,0 +1,179 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.Collection;",
                "+import java.util.HashMap;",
                "+import java.util.Iterator;",
                "+import java.util.LinkedList;",
                "+import java.util.Map;",
                "+import java.util.PriorityQueue;",
                "+import java.util.Queue;",
                "+",
                "+import com.baselet.element.sequence_aio.facet.LifelineSpanningTickSpanningOccurrence.ContainerPadding;",
                "+import com.baselet.element.sequence_aio.facet.SequenceDiagram.DoubleConverter;",
                "+",
                "+public class HorizontalDrawingInfoImpl implements HorizontalDrawingInfo {",
                "+",
                "+\tprivate final double diagramStart;",
                "+\tprivate final double diagramWidth;",
                "+\tprivate final LifelineHorizontalDrawingInfo[] horizontalDrawingInfos;",
                "+\tprivate final Map<Container, Double> containerLeftPadding;",
                "+\tprivate final Map<Container, Double> containerRightPadding;",
                "+",
                "+\t/**",
                "+\t * Calculates the actual lifeline and diagram width.",
                "+\t * @param diagramStart left most point were the diagram can draw",
                "+\t * @param diagramMinWidth",
                "+\t * @param widthConverter used to adjust the calculated width (should only increase the width!)",
                "+\t * @param lifelineWidth width of a single lifeline without any paddings",
                "+\t * @param lifelineXPadding padding between two lifelines or a lifeline and the diagram border",
                "+\t * @param lifelineCount",
                "+\t * @param lastTick",
                "+\t * @param paddings",
                "+\t */",
                "+\tpublic HorizontalDrawingInfoImpl(double diagramStart, double diagramMinWidth, DoubleConverter widthConverter,",
                "+\t\t\tdouble lifelineWidth, double lifelineXPadding, int lifelineCount, int lastTick, Collection<ContainerPadding> paddings) {",
                "+\t\tcontainerLeftPadding = new HashMap<Container, Double>((int) (paddings.size() / 0.7));",
                "+\t\tcontainerRightPadding = new HashMap<Container, Double>((int) (paddings.size() / 0.7));",
                "+\t\thorizontalDrawingInfos = new LifelineHorizontalDrawingInfo[lifelineCount];",
                "+\t\tthis.diagramStart = diagramStart;",
                "+\t\t// calculate the padding information and the maximum padding",
                "+\t\tdouble maxPadding = 0;",
                "+\t\tdouble[][] leftPaddings = new double[lifelineCount][];",
                "+\t\tdouble[][] rightPaddings = new double[lifelineCount][];",
                "+\t\tfor (int i = 0; i < lifelineCount; i++) {",
                "+\t\t\tPaddingInfo paddingInfo = getPaddings(i, true, lastTick, paddings);",
                "+\t\t\tleftPaddings[i] = paddingInfo.paddings;",
                "+\t\t\tmaxPadding = Math.max(maxPadding, paddingInfo.maxPadding);",
                "+\t\t\tpaddingInfo = getPaddings(i, false, lastTick, paddings);",
                "+\t\t\trightPaddings[i] = paddingInfo.paddings;",
                "+\t\t\tmaxPadding = Math.max(maxPadding, paddingInfo.maxPadding);",
                "+\t\t}",
                "+\t\tlifelineWidth += maxPadding * 2; // add the padding because it is not included in the lifeline width",
                "+",
                "+\t\tdouble diagramWidth = lifelineWidth * lifelineCount + lifelineXPadding * (lifelineCount + 1);",
                "+\t\tif (diagramWidth < diagramMinWidth) {",
                "+\t\t\tdiagramWidth = diagramMinWidth;",
                "+\t\t\tif (lifelineCount > 0) {",
                "+\t\t\t\tlifelineWidth = (diagramWidth - lifelineXPadding * (lifelineCount + 1)) / lifelineCount;",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\t// adjust the width with the width converter",
                "+\t\tdiagramWidth = widthConverter.convert(diagramWidth);",
                "+",
                "+\t\tdouble lifelineHeadLeftStart = (diagramWidth",
                "+\t\t\t\t- (lifelineWidth * lifelineCount + lifelineXPadding * (lifelineCount - 1))",
                "+\t\t\t\t) / 2.0;",
                "+",
                "+\t\tthis.diagramWidth = diagramWidth;",
                "+\t\tfor (int i = 0; i < horizontalDrawingInfos.length; i++) {",
                "+\t\t\thorizontalDrawingInfos[i] = new LifelineHorizontalDrawingInfoImpl(",
                "+\t\t\t\t\tleftPaddings[i],",
                "+\t\t\t\t\trightPaddings[i],",
                "+\t\t\t\t\tlifelineHeadLeftStart + (lifelineWidth + lifelineXPadding) * i,",
                "+\t\t\t\t\tlifelineHeadLeftStart + (lifelineWidth + lifelineXPadding) * i + lifelineWidth);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tprivate PaddingInfo getPaddings(int lifelineId, boolean left, int lastTick, Collection<ContainerPadding> allPaddings) {",
                "+\t\tdouble[] lifelinePaddings = new double[lastTick + 2];",
                "+\t\t// define 1 queue for starting of padding intervals, and the other for the ending of the intervals",
                "+\t\tQueue<ContainerPadding> paddingQueueStart = new PriorityQueue<ContainerPadding>(5,",
                "+\t\t\t\tContainerPadding.getContainerStartTickLifelineAscComparator());",
                "+\t\tLinkedList<ContainerPadding> paddingListEnd = new LinkedList<ContainerPadding>();",
                "+",
                "+\t\tfor (ContainerPadding cp : allPaddings) {",
                "+\t\t\tif (left && cp.getContainer().getFirstLifeline().getIndex() == lifelineId && cp.getLeftPadding() > 0) {",
                "+\t\t\t\tpaddingQueueStart.add(cp);",
                "+\t\t\t}",
                "+\t\t\telse if (!left && cp.getContainer().getLastLifeline().getIndex() == lifelineId && cp.getRightPadding() > 0) {",
                "+\t\t\t\tpaddingQueueStart.add(cp);",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tdouble maxPadding = 0;",
                "+\t\tfor (int tick = 0; tick < lifelinePaddings.length; tick++) {",
                "+\t\t\t// insert paddings that start at the current tick at the right place (endTick asc) and remove them.",
                "+\t\t\twhile (paddingQueueStart.peek() != null && paddingQueueStart.peek().getContainer().getStartTick() == tick) {",
                "+\t\t\t\tpaddingListEnd.addLast(paddingQueueStart.poll());",
                "+\t\t\t}",
                "+\t\t\tIterator<ContainerPadding> endIter = paddingListEnd.iterator();",
                "+\t\t\twhile (endIter.hasNext()) {",
                "+\t\t\t\tContainerPadding paddingInterval = endIter.next();",
                "+\t\t\t\tif (left) {",
                "+\t\t\t\t\tif (!containerLeftPadding.containsKey(paddingInterval.getContainer())) {",
                "+\t\t\t\t\t\tcontainerLeftPadding.put(paddingInterval.getContainer(), lifelinePaddings[tick]);",
                "+\t\t\t\t\t}",
                "+\t\t\t\t\tlifelinePaddings[tick] += paddingInterval.getLeftPadding();",
                "+\t\t\t\t}",
                "+\t\t\t\telse {",
                "+\t\t\t\t\tif (!containerRightPadding.containsKey(paddingInterval.getContainer())) {",
                "+\t\t\t\t\t\tcontainerRightPadding.put(paddingInterval.getContainer(), lifelinePaddings[tick]);",
                "+\t\t\t\t\t}",
                "+\t\t\t\t\tlifelinePaddings[tick] += paddingInterval.getRightPadding();",
                "+\t\t\t\t}",
                "+\t\t\t\tif (paddingInterval.getContainer().getEndTick() == tick) {",
                "+\t\t\t\t\tendIter.remove();",
                "+\t\t\t\t}",
                "+\t\t\t}",
                "+\t\t\tmaxPadding = Math.max(maxPadding, lifelinePaddings[tick]);",
                "+\t\t}",
                "+\t\treturn new PaddingInfo(lifelinePaddings, maxPadding);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic LifelineHorizontalDrawingInfo getHDrawingInfo(Lifeline lifeline) {",
                "+\t\treturn horizontalDrawingInfos[lifeline.getIndex()];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getSymmetricWidth(Lifeline ll1, Lifeline ll2, int tick) {",
                "+\t\tif (ll1.getIndex() <= ll2.getIndex()) {",
                "+\t\t\treturn getHDrawingInfo(ll2).getSymmetricHorizontalEnd(tick)",
                "+\t\t\t\t\t- getHDrawingInfo(ll1).getSymmetricHorizontalStart(tick);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\treturn getHDrawingInfo(ll1).getSymmetricHorizontalEnd(tick)",
                "+\t\t\t\t\t- getHDrawingInfo(ll2).getSymmetricHorizontalStart(tick);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getHorizontalStart(Container container) {",
                "+\t\treturn getHDrawingInfo(container.getFirstLifeline()).getHorizontalStart() + containerLeftPadding.get(container);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getHorizontalEnd(Container container) {",
                "+\t\treturn getHDrawingInfo(container.getLastLifeline()).getHorizontalEnd() - containerRightPadding.get(container);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getWidth(Container container) {",
                "+\t\treturn getHorizontalEnd(container) - getHorizontalStart(container);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getDiagramHorizontalStart() {",
                "+\t\treturn diagramStart;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getDiagramHorizontalEnd() {",
                "+\t\treturn diagramStart + diagramWidth;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getDiagramWidth() {",
                "+\t\treturn diagramWidth;",
                "+\t}",
                "+",
                "+\tprivate static class PaddingInfo {",
                "+\t\tprivate final double[] paddings;",
                "+\t\tprivate final double maxPadding;",
                "+",
                "+\t\tpublic PaddingInfo(double[] paddings, double maxPadding) {",
                "+\t\t\tsuper();",
                "+\t\t\tthis.paddings = paddings;",
                "+\t\t\tthis.maxPadding = maxPadding;",
                "+\t\t}",
                "+\t}",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/InteractionUse.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/InteractionUse.java",
                "new file mode 100644",
                "index 00000000..ec712e8b",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/InteractionUse.java",
                "@@ -0,0 +1,88 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.Arrays;",
                "+import java.util.HashMap;",
                "+import java.util.Map;",
                "+",
                "+import com.baselet.control.basics.Line1D;",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.control.enums.AlignHorizontal;",
                "+import com.baselet.control.enums.AlignVertical;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.diagram.draw.TextSplitter;",
                "+",
                "+public class InteractionUse implements LifelineSpanningTickSpanningOccurrence {",
                "+",
                "+\tprivate static final double TEXT_X_PADDING = 5;",
                "+\tprivate static final double TEXT_Y_PADDING = 5;",
                "+\tprivate static final double HEADER_BOTTOM_PADDING = 4;",
                "+\tprivate static final String[] HEADER_TEXT = new String[] { \"ref\" };",
                "+",
                "+\tprivate final int tick;",
                "+\tprivate final String[] textLines;",
                "+\tprivate final Lifeline[] coveredLifelines;",
                "+",
                "+\tpublic InteractionUse(int tick, String text, Lifeline[] coveredLifelines) {",
                "+\t\tsuper();",
                "+\t\tthis.tick = tick;",
                "+\t\ttextLines = text.split(\"\\n\");",
                "+\t\tthis.coveredLifelines = Arrays.copyOf(coveredLifelines, coveredLifelines.length);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Lifeline getFirstLifeline() {",
                "+\t\treturn coveredLifelines[0];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Lifeline getLastLifeline() {",
                "+\t\treturn coveredLifelines[coveredLifelines.length - 1];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic void draw(DrawHandler drawHandler, DrawingInfo drawingInfo) {",
                "+\t\tdouble width = drawingInfo.getSymmetricWidth(getFirstLifeline(), getLastLifeline(), tick);",
                "+\t\tdouble height = getHeight(drawHandler, width);",
                "+\t\tdouble topY = drawingInfo.getVerticalStart(tick) + (drawingInfo.getTickHeight(tick) - height) / 2;",
                "+\t\tPointDouble topLeft = new PointDouble(",
                "+\t\t\t\tdrawingInfo.getHDrawingInfo(getFirstLifeline()).getSymmetricHorizontalStart(tick), topY);",
                "+",
                "+\t\tdrawHandler.drawRectangle(topLeft.x, topLeft.y, width, height);",
                "+\t\tPointDouble pentagonSize = PentagonDrawingHelper.draw(drawHandler, HEADER_TEXT, width, topLeft);",
                "+\t\tTextSplitter.drawText(drawHandler, textLines, topLeft.x + pentagonSize.x + TEXT_X_PADDING,",
                "+\t\t\t\ttopLeft.y, width - (pentagonSize.x + TEXT_X_PADDING) * 2, height,",
                "+\t\t\t\tAlignHorizontal.CENTER, AlignVertical.CENTER);",
                "+",
                "+\t\tfor (Lifeline ll : coveredLifelines) {",
                "+\t\t\tdrawingInfo.getDrawingInfo(ll).addInterruptedArea(new Line1D(topLeft.y, topLeft.y + height));",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getOverallMinWidth(DrawHandler drawHandler, double lifelineHorizontalPadding) {",
                "+\t\treturn PentagonDrawingHelper.getPentagonMinimumWidth(drawHandler, HEADER_TEXT) * 2 + TEXT_X_PADDING * 2 + TextSplitter.getTextMinWidth(textLines, drawHandler);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Map<Integer, Double> getEveryAdditionalYHeight(DrawHandler drawHandler,",
                "+\t\t\tHorizontalDrawingInfo hInfo, double defaultTickHeight) {",
                "+\t\tMap<Integer, Double> ret = new HashMap<Integer, Double>();",
                "+\t\tdouble width = hInfo.getSymmetricWidth(getFirstLifeline(), getLastLifeline(), tick);",
                "+\t\tif (getHeight(drawHandler, width) > defaultTickHeight) {",
                "+\t\t\tret.put(tick, getHeight(drawHandler, width) - defaultTickHeight);",
                "+\t\t}",
                "+\t\treturn ret;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic ContainerPadding getPaddingInformation() {",
                "+\t\treturn null;",
                "+\t}",
                "+",
                "+\tprivate double getHeight(DrawHandler drawHandler, double width) {",
                "+\t\tdouble textWidth = width - TEXT_X_PADDING * 2 - PentagonDrawingHelper.getPentagonMinimumWidth(drawHandler, HEADER_TEXT) * 2;",
                "+\t\treturn Math.max(PentagonDrawingHelper.getHeight(drawHandler, HEADER_TEXT, width) + HEADER_BOTTOM_PADDING,",
                "+\t\t\t\tTextSplitter.getSplitStringHeight(textLines, textWidth, drawHandler) + TEXT_Y_PADDING * 2);",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Lifeline.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Lifeline.java",
                "new file mode 100644",
                "index 00000000..4327eed7",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Lifeline.java",
                "@@ -0,0 +1,542 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.ArrayList;",
                "+import java.util.HashMap;",
                "+import java.util.LinkedHashMap;",
                "+import java.util.LinkedList;",
                "+import java.util.List;",
                "+import java.util.ListIterator;",
                "+import java.util.Map;",
                "+",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "+",
                "+import com.baselet.control.basics.Line1D;",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.control.enums.AlignHorizontal;",
                "+import com.baselet.control.enums.AlignVertical;",
                "+import com.baselet.control.enums.LineType;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.diagram.draw.TextSplitter;",
                "+import com.baselet.element.draw.DrawHelper;",
                "+",
                "+public class Lifeline {",
                "+\tprivate static final double ACTOR_DIMENSION = 10;",
                "+\tprivate static final PointDouble ACTOR_SIZE = new PointDouble(DrawHelper.armLength(ACTOR_DIMENSION) * 2,",
                "+\t\t\tDrawHelper.headToLegLength(ACTOR_DIMENSION));",
                "+\tprivate static final double ACTIVE_CLASS_DOUBLE_BORDER_GAP = 10;",
                "+\tprivate static final double HEAD_VERTICAL_BORDER_PADDING = 5;",
                "+\tprivate static final double HEAD_HORIZONTAL_BORDER_PADDING = 5;",
                "+\tprivate static final double EXECUTIONSPECIFICATION_WIDTH = 20;",
                "+\tprivate static final double EXECUTIONSPECIFICATION_OVERLAPP = 8;",
                "+",
                "+\tprivate static final double DESTROY_SIZE = 20; // width and height of the destroy symbol X",
                "+",
                "+\tprivate static final Logger log = LoggerFactory.getLogger(Lifeline.class);",
                "+",
                "+\tprivate final String[] text;",
                "+\t/** position in the array = numbered from left to right starting at 0 */",
                "+\tprivate final int index;",
                "+\tprivate final LifelineHeadType headType;",
                "+\t/** If false it will be created by the first message sent to this object */",
                "+\tprivate boolean createdOnStart;",
                "+\t/** The tick time when the lifeline is created can be null even when createdOnStart is false, then nothing is drawn*/",
                "+\tprivate Integer created;",
                "+\t/** The tick time when the lifeline is destroyed (X symbol) or null if it exists till the end (no X symbol at the end) */",
                "+\tprivate Integer destroyed;",
                "+\tprivate boolean execSpecFromStart;",
                "+",
                "+\tprivate final LinkedHashMap<Integer, LifelineOccurrence> lifeline;",
                "+",
                "+\t/** order according to the start tick */",
                "+\tprivate final List<ExecutionSpecification> activeAreas;",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @param text lines need to be separated by \\n",
                "+\t * @param index",
                "+\t * @param headType",
                "+\t * @param createdOnStart",
                "+\t * @param execSpecFromStart true if an execution specification should be active from the creation",
                "+\t */",
                "+\tpublic Lifeline(String text, int index, LifelineHeadType headType, boolean createdOnStart, boolean execSpecFromStart) {",
                "+\t\tsuper();",
                "+\t\tthis.text = text.split(\"\\n\");",
                "+\t\tthis.index = index;",
                "+\t\tthis.headType = headType;",
                "+\t\tthis.createdOnStart = createdOnStart;",
                "+\t\tcreated = null;",
                "+\t\tdestroyed = null;",
                "+\t\tthis.execSpecFromStart = execSpecFromStart;",
                "+",
                "+\t\tlifeline = new LinkedHashMap<Integer, LifelineOccurrence>();",
                "+\t\tactiveAreas = new ArrayList<ExecutionSpecification>();",
                "+\t}",
                "+",
                "+\tpublic int getIndex() {",
                "+\t\treturn index;",
                "+\t}",
                "+",
                "+\t// public String[] getText() {",
                "+\t// return text;",
                "+\t// }",
                "+",
                "+\tpublic void setCreatedOnStart(boolean createdOnStart) {",
                "+\t\tthis.createdOnStart = createdOnStart;",
                "+\t}",
                "+",
                "+\tpublic boolean isCreatedOnStart() {",
                "+\t\treturn createdOnStart;",
                "+\t}",
                "+",
                "+\tpublic void setCreated(Integer created) {",
                "+\t\tthis.created = created;",
                "+\t}",
                "+",
                "+\tpublic Integer getCreated() {",
                "+\t\treturn created;",
                "+\t}",
                "+",
                "+\tpublic void setDestroyed(Integer destroyed) {",
                "+\t\tthis.destroyed = destroyed;",
                "+\t}",
                "+",
                "+\tpublic Integer getDestroyed() {",
                "+\t\treturn destroyed;",
                "+\t}",
                "+",
                "+\tpublic boolean isExecSpecFromStart() {",
                "+\t\treturn execSpecFromStart;",
                "+\t}",
                "+",
                "+\tpublic void setExecSpecFromStart(boolean execSpecFromStart) {",
                "+\t\tthis.execSpecFromStart = execSpecFromStart;",
                "+\t}",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @param occurrence",
                "+\t * @param tick",
                "+\t * @throws SequenceDiagramCheckedException if the lifeline already contains an occurrence at the specified tick or",
                "+\t * if the lifeline is not created on start and the specified tick is prior in time to the create tick",
                "+\t */",
                "+\tpublic void addLifelineOccurrenceAtTick(LifelineOccurrence occurrence, Integer tick)",
                "+\t\t\tthrows SequenceDiagramCheckedException {",
                "+\t\tif (!isCreatedOnStart()) {",
                "+\t\t\tif (created == null || created >= tick) {",
                "+\t\t\t\tthrow new SequenceDiagramCheckedException(\"The lifeline can not contain occurrences before it is created.\");",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tif (lifeline.containsKey(tick)) {",
                "+\t\t\tthrow new SequenceDiagramCheckedException(\"The lifeline already contains an occurence at the tick \" + tick);",
                "+\t\t}",
                "+\t\tlifeline.put(tick, occurrence);",
                "+\t}",
                "+",
                "+\tpublic void addExecutionSpecification(ExecutionSpecification execSpec) {",
                "+\t\tint i = 0;",
                "+\t\tfor (; i < activeAreas.size() && activeAreas.get(i).getStartTick() < execSpec.getStartTick(); i++) {}",
                "+\t\tactiveAreas.add(i, execSpec);",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * @param tick the time at which the width should be calculated",
                "+\t * @return 0 if it is only a line, otherwise return the width from",
                "+\t * the center to the left outermost border of the execution specification",
                "+\t * @see Coregion Coregion for an example how this is used for drawing",
                "+\t */",
                "+\tpublic double getLifelineLeftPartWidth(int tick) {",
                "+\t\treturn getCurrentlyActiveExecutionSpecifications(tick) > 0 ? EXECUTIONSPECIFICATION_WIDTH / 2.0 : 0;",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * @param tick the time at which the width should be calculated",
                "+\t * @return 0 if it is only a line, otherwise return the width from",
                "+\t * the center to the right outermost border of the execution specification",
                "+\t * @see Coregion Coregion for an example how this is used for drawing",
                "+\t */",
                "+\tpublic double getLifelineRightPartWidth(int tick) {",
                "+\t\tint currentlyActiveExecSpec = getCurrentlyActiveExecutionSpecifications(tick);",
                "+\t\tif (currentlyActiveExecSpec == 0) {",
                "+\t\t\treturn 0;",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\treturn (currentlyActiveExecSpec - 1) * (EXECUTIONSPECIFICATION_WIDTH - EXECUTIONSPECIFICATION_OVERLAPP) + EXECUTIONSPECIFICATION_WIDTH / 2.0;",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * @param drawHandler",
                "+\t * @return the minimum width which is needed by this lifeline",
                "+\t */",
                "+\tpublic double getMinWidth(DrawHandler drawHandler) {",
                "+\t\tdouble minWidth = DESTROY_SIZE;",
                "+\t\tfor (LifelineOccurrence llOccurrence : lifeline.values()) {",
                "+\t\t\tminWidth = Math.max(minWidth, llOccurrence.getMinWidth(drawHandler));",
                "+\t\t}",
                "+\t\tif (activeAreas.size() == 1) {",
                "+\t\t\tminWidth = Math.max(minWidth, EXECUTIONSPECIFICATION_WIDTH);",
                "+\t\t}",
                "+\t\telse if (activeAreas.size() > 1) {",
                "+\t\t\tint maxSimultaneousExecSpec = 0;",
                "+\t\t\t// for each start of an area calculate the currently active ExecutionSpecifications and set the maximum",
                "+\t\t\tfor (ExecutionSpecification activeArea : activeAreas) {",
                "+\t\t\t\tmaxSimultaneousExecSpec = Math.max(maxSimultaneousExecSpec,",
                "+\t\t\t\t\t\tgetCurrentlyActiveExecutionSpecifications(activeArea.getStartTick()));",
                "+\t\t\t}",
                "+\t\t\tminWidth = Math.max(minWidth,",
                "+\t\t\t\t\t(maxSimultaneousExecSpec - 1) * (EXECUTIONSPECIFICATION_WIDTH - EXECUTIONSPECIFICATION_OVERLAPP) * 2 + EXECUTIONSPECIFICATION_WIDTH);",
                "+\t\t}",
                "+\t\tminWidth = Math.max(minWidth, getHeadMinWidth(drawHandler));",
                "+\t\treturn minWidth;",
                "+\t}",
                "+",
                "+\tprivate int getCurrentlyActiveExecutionSpecifications(int tick) {",
                "+\t\tint currentlyActiveExecSpec = 0;",
                "+\t\tfor (int i = 0; i < activeAreas.size() && tick >= activeAreas.get(i).getStartTick(); i++) {",
                "+\t\t\tif (activeAreas.get(i).enclosesTick(tick)) {",
                "+\t\t\t\tcurrentlyActiveExecSpec++;",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\treturn currentlyActiveExecSpec;",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * Calculates the additonal height which are needed by the occurrences on this lifeline",
                "+\t * @param drawHandler",
                "+\t * @param drawingInfo",
                "+\t * @param defaultTickHeight",
                "+\t * @return a Map which stores the ticks as keys and the additional height as values",
                "+\t * (i.e. the height which exceeds the tickHeight). This values are all &gt;= 0",
                "+\t */",
                "+\tpublic Map<Integer, Double> getAdditionalYHeights(DrawHandler drawHandler,",
                "+\t\t\tLifelineHorizontalDrawingInfo drawingInfo, double defaultTickHeight) {",
                "+\t\tPointDouble size;",
                "+\t\tdouble additionalY;",
                "+\t\tMap<Integer, Double> ret = new HashMap<Integer, Double>();",
                "+\t\tfor (Map.Entry<Integer, LifelineOccurrence> e : lifeline.entrySet()) {",
                "+\t\t\tsize = new PointDouble(drawingInfo.getSymmetricWidth(e.getKey()), defaultTickHeight);",
                "+\t\t\tadditionalY = e.getValue().getAdditionalYHeight(drawHandler, size);",
                "+\t\t\tif (additionalY > 0) {",
                "+\t\t\t\tret.put(e.getKey(), additionalY);",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\t// add head size if it the obj is created with an message",
                "+\t\tif (!createdOnStart && created != null) {",
                "+\t\t\tdouble headAdditionalHeight = getHeadMinHeight(drawHandler, drawingInfo.getSymmetricWidth(created)) - defaultTickHeight;",
                "+\t\t\tif (headAdditionalHeight > 0) {",
                "+\t\t\t\tif (ret.containsKey(created)) {",
                "+\t\t\t\t\tret.put(created, Math.max(ret.get(created), headAdditionalHeight));",
                "+\t\t\t\t}",
                "+\t\t\t\telse {",
                "+\t\t\t\t\tret.put(created, headAdditionalHeight);",
                "+\t\t\t\t}",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tif (destroyed != null && DESTROY_SIZE > defaultTickHeight) {",
                "+\t\t\tif (ret.containsKey(destroyed)) {",
                "+\t\t\t\tret.put(destroyed, Math.max(ret.get(destroyed), DESTROY_SIZE - defaultTickHeight));",
                "+\t\t\t}",
                "+\t\t\telse {",
                "+\t\t\t\tret.put(destroyed, DESTROY_SIZE - defaultTickHeight);",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\treturn ret;",
                "+",
                "+\t}",
                "+",
                "+\tprivate double getHeadMinWidth(DrawHandler drawHandler) {",
                "+\t\tdouble minWidth = ACTOR_SIZE.x; // actor width is small, so use it as minimum width",
                "+\t\tminWidth = Math.max(minWidth, TextSplitter.getTextMinWidth(text, drawHandler));",
                "+\t\tif (headType == LifelineHeadType.STANDARD) {",
                "+\t\t\tminWidth = minWidth + HEAD_HORIZONTAL_BORDER_PADDING * 2;",
                "+\t\t}",
                "+\t\telse if (headType == LifelineHeadType.ACTIVE_CLASS) {",
                "+\t\t\tminWidth = minWidth + HEAD_HORIZONTAL_BORDER_PADDING * 2 + ACTIVE_CLASS_DOUBLE_BORDER_GAP * 2;",
                "+\t\t}",
                "+\t\treturn minWidth;",
                "+\t}",
                "+",
                "+\tpublic double getHeadMinHeight(DrawHandler drawHandler, double width) {",
                "+\t\tif (headType == LifelineHeadType.STANDARD || headType == LifelineHeadType.ACTIVE_CLASS) {",
                "+\t\t\twidth -= HEAD_HORIZONTAL_BORDER_PADDING * 2;",
                "+\t\t\tif (headType == LifelineHeadType.ACTIVE_CLASS) {",
                "+\t\t\t\twidth -= ACTIVE_CLASS_DOUBLE_BORDER_GAP * 2;",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tdouble minHeight = TextSplitter.getSplitStringHeight(text, width, drawHandler);",
                "+\t\tif (headType == LifelineHeadType.ACTOR) {",
                "+\t\t\tminHeight += ACTOR_SIZE.y;",
                "+\t\t}",
                "+\t\telse if (headType == LifelineHeadType.ACTIVE_CLASS || headType == LifelineHeadType.STANDARD) {",
                "+\t\t\tminHeight += HEAD_VERTICAL_BORDER_PADDING * 2;",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tlog.error(\"Encountered unhandled enumeration value '\" + headType + \"'.\");",
                "+\t\t}",
                "+\t\treturn minHeight;",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * @param drawHandler",
                "+\t * @param drawingInfo information about the drawing positions",
                "+\t * @param lifelineLastTick the last tick of the diagram",
                "+\t */",
                "+\tpublic void draw(DrawHandler drawHandler, LifelineDrawingInfo drawingInfo, int lifelineLastTick) {",
                "+\t\t// draw Head with text",
                "+\t\tif (createdOnStart) {",
                "+\t\t\tdrawHead(drawHandler, drawingInfo.getHorizontalStart(), drawingInfo.getVerticalHeadStart(),",
                "+\t\t\t\t\tdrawingInfo.getWidth(), drawingInfo.getHeadHeight());",
                "+\t\t}",
                "+\t\t// check if the creation tick was set, while writing a diagram it can be possible that the message that",
                "+\t\t// creates this head wasn't yet written",
                "+\t\telse if (created != null) {",
                "+\t\t\tdrawHead(drawHandler, drawingInfo.getSymmetricHorizontalStart(created), drawingInfo.getVerticalStart(created),",
                "+\t\t\t\t\tdrawingInfo.getSymmetricWidth(created), drawingInfo.getTickHeight(created));",
                "+\t\t}",
                "+\t\t// without an starting point we can not draw anything",
                "+\t\tif (createdOnStart || created != null) {",
                "+\t\t\t// draw lifeline occurrences",
                "+\t\t\tfor (Map.Entry<Integer, LifelineOccurrence> e : lifeline.entrySet()) {",
                "+\t\t\t\tint tick = e.getKey();",
                "+\t\t\t\tPointDouble topLeftOccurence = new PointDouble(drawingInfo.getSymmetricHorizontalStart(tick),",
                "+\t\t\t\t\t\tdrawingInfo.getVerticalStart(tick));",
                "+\t\t\t\tPointDouble sizeOccurence = new PointDouble(drawingInfo.getSymmetricWidth(tick),",
                "+\t\t\t\t\t\tdrawingInfo.getTickHeight(tick));",
                "+\t\t\t\tLine1D llInterruption = e.getValue().draw(drawHandler, topLeftOccurence, sizeOccurence);",
                "+\t\t\t\tif (llInterruption != null) {",
                "+\t\t\t\t\tdrawingInfo.addInterruptedArea(llInterruption);",
                "+\t\t\t\t}",
                "+\t\t\t}",
                "+\t\t\t// draw actual lifeline (horizontal line)",
                "+\t\t\tdrawLifeline(drawHandler, drawingInfo, lifelineLastTick);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * Draws the actual line (dashed or the rectangles of the execution specification)",
                "+\t * @param drawHandler",
                "+\t * @param drawingInfo",
                "+\t * @param lifelineLastTick",
                "+\t */",
                "+\tprivate void drawLifeline(DrawHandler drawHandler, LifelineDrawingInfo drawingInfo, int lifelineLastTick) {",
                "+\t\tint currentStartTick = 0;",
                "+\t\tint endTick;",
                "+\t\tint currentActiveCount = 0;",
                "+\t\tboolean startInc = false;",
                "+\t\tboolean endInc;",
                "+\t\t// used as stack with newest elements at start",
                "+\t\tLinkedList<ExecutionSpecification> active = new LinkedList<ExecutionSpecification>();",
                "+\t\tif (!createdOnStart) {",
                "+\t\t\tcurrentStartTick = created + 1;",
                "+\t\t}",
                "+\t\tListIterator<ExecutionSpecification> execSpecIter = activeAreas.listIterator();",
                "+\t\tListIterator<Line1D> interruptedAreasIter = drawingInfo.getInterruptedAreas().listIterator();",
                "+\t\tLineType oldLt = drawHandler.getLineType();",
                "+\t\t// add execution specification which start from the creation before the loop so that they are drawn directly beneath the head",
                "+\t\tif (execSpecFromStart && execSpecIter.hasNext()) {",
                "+\t\t\tExecutionSpecification execSpec = execSpecIter.next();",
                "+\t\t\tif (execSpec.getStartTick() == currentStartTick - 1) {",
                "+\t\t\t\tactive.addFirst(execSpec);",
                "+\t\t\t\tstartInc = true;",
                "+\t\t\t}",
                "+\t\t\telse {",
                "+\t\t\t\texecSpecIter.previous();",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tdouble llTopY = drawingInfo.getVerticalStart(currentStartTick) - drawingInfo.getTickVerticalPadding();",
                "+\t\twhile (active.size() > 0 || execSpecIter.hasNext()) {",
                "+\t\t\t// find change of drawing style; if a new executionSpecification starts or an old ends",
                "+\t\t\tcurrentActiveCount = active.size();",
                "+\t\t\tif (active.size() > 0 && execSpecIter.hasNext()) {",
                "+\t\t\t\tExecutionSpecification execSpec = execSpecIter.next();",
                "+\t\t\t\tif (active.getFirst().getEndTick() < execSpec.getStartTick()) {",
                "+\t\t\t\t\texecSpecIter.previous();",
                "+\t\t\t\t\tendInc = false;",
                "+\t\t\t\t\tendTick = active.removeFirst().getEndTick();",
                "+\t\t\t\t}",
                "+\t\t\t\telse {",
                "+\t\t\t\t\tendInc = true;",
                "+\t\t\t\t\tendTick = execSpec.getStartTick();",
                "+\t\t\t\t\tactive.addFirst(execSpec);",
                "+\t\t\t\t}",
                "+\t\t\t}",
                "+\t\t\telse if (active.size() > 0) {",
                "+\t\t\t\tendInc = false;",
                "+\t\t\t\tendTick = active.removeFirst().getEndTick();",
                "+\t\t\t}",
                "+\t\t\telse { // execSpecIter.hasNext() is true",
                "+\t\t\t\tExecutionSpecification execSpec = execSpecIter.next();",
                "+\t\t\t\tendInc = true;",
                "+\t\t\t\tendTick = execSpec.getStartTick();",
                "+\t\t\t\tactive.addFirst(execSpec);",
                "+\t\t\t}",
                "+",
                "+\t\t\tdouble llBottomY = drawingInfo.getVerticalCenter(endTick);",
                "+\t\t\t// topY + endTick * tickHeight + tickHeight / 2 + accumulativeAddiontalHeightOffsets[endTick] / 2 + accumulativeAddiontalHeightOffsets[endTick + 1] / 2;",
                "+\t\t\tdrawLifelinePart(drawHandler, drawingInfo.getHorizontalCenter(),",
                "+\t\t\t\t\tllTopY,",
                "+\t\t\t\t\tstartInc,",
                "+\t\t\t\t\tllBottomY,",
                "+\t\t\t\t\tendInc,",
                "+\t\t\t\t\tcurrentActiveCount,",
                "+\t\t\t\t\tinterruptedAreasIter);",
                "+\t\t\tcurrentStartTick = endTick;",
                "+\t\t\tllTopY = llBottomY;",
                "+\t\t\tstartInc = endInc;",
                "+\t\t}",
                "+\t\t// draw final line segment",
                "+\t\tif (destroyed == null) {",
                "+\t\t\tdrawLifelinePart(drawHandler, drawingInfo.getHorizontalCenter(),",
                "+\t\t\t\t\tllTopY,",
                "+\t\t\t\t\tfalse,",
                "+\t\t\t\t\tdrawingInfo.getVerticalEnd(lifelineLastTick),",
                "+\t\t\t\t\tfalse,",
                "+\t\t\t\t\t0,",
                "+\t\t\t\t\tinterruptedAreasIter);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tdrawHandler.setLineType(LineType.SOLID);",
                "+\t\t\tdouble halfSize = DESTROY_SIZE / 2.0;",
                "+\t\t\tdouble centerX = drawingInfo.getHorizontalCenter();",
                "+\t\t\tdouble centerY = drawingInfo.getVerticalCenter(destroyed);",
                "+\t\t\tdrawHandler.drawLine(centerX - halfSize, centerY - halfSize, centerX + halfSize, centerY + halfSize);",
                "+\t\t\tdrawHandler.drawLine(centerX + halfSize, centerY - halfSize, centerX - halfSize, centerY + halfSize);",
                "+\t\t\tif (destroyed > currentStartTick) {",
                "+",
                "+\t\t\t\tdrawLifelinePart(drawHandler, drawingInfo.getHorizontalCenter(),",
                "+\t\t\t\t\t\tllTopY,",
                "+\t\t\t\t\t\tfalse,",
                "+\t\t\t\t\t\tdrawingInfo.getVerticalCenter(destroyed),",
                "+\t\t\t\t\t\tfalse,",
                "+\t\t\t\t\t\t0,",
                "+\t\t\t\t\t\tinterruptedAreasIter);",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tdrawHandler.setLineType(oldLt);",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * draw a part of the Lifeline which has the same active count",
                "+\t * (same number of active ExecutionSpecifications), which changes at startY ending at endY.",
                "+\t * Draws head if increment at start, draws end if decrement at end.",
                "+\t *",
                "+\t * @param drawHandler",
                "+\t * @param centerX",
                "+\t * @param startY",
                "+\t * @param activeCountIncStart true if the active count was lower before the start",
                "+\t * @param endY",
                "+\t * @param activeCountIncEnd true if the active count is higher after the end",
                "+\t * @param activeCount",
                "+\t * @param interruptedAreas Iterator which point to the first span where span.End &gt; startY, after the call it points to the first span where span.End &gt; endY",
                "+\t */",
                "+\tprivate void drawLifelinePart(DrawHandler drawHandler, final double centerX,",
                "+\t\t\tfinal double startY, boolean activeCountIncStart,",
                "+\t\t\tfinal double endY, boolean activeCountIncEnd,",
                "+\t\t\tint activeCount, ListIterator<Line1D> interruptedAreas) {",
                "+\t\tdouble nextStartY = startY;",
                "+\t\tboolean drawHead = true;",
                "+\t\t// check if we must draw the head",
                "+\t\tif (interruptedAreas.hasNext()) {",
                "+\t\t\tLine1D area = interruptedAreas.next();",
                "+\t\t\tif (area.contains(nextStartY)) {",
                "+\t\t\t\tdrawHead = false;",
                "+\t\t\t\tnextStartY = area.getHigh();",
                "+\t\t\t}",
                "+\t\t\telse {",
                "+\t\t\t\tinterruptedAreas.previous(); // no intersection so push it back",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tboolean drawingFinished = false;",
                "+\t\tboolean drawEnd = false;",
                "+\t\tdouble currentEndY;",
                "+\t\tdouble currentStartY;",
                "+\t\twhile (!drawingFinished) {",
                "+\t\t\tcurrentStartY = nextStartY;",
                "+\t\t\tif (interruptedAreas.hasNext()) {",
                "+\t\t\t\tLine1D area = interruptedAreas.next();",
                "+\t\t\t\tif (area.getLow() < endY) {",
                "+\t\t\t\t\tcurrentEndY = area.getLow();",
                "+\t\t\t\t\tnextStartY = area.getHigh();",
                "+",
                "+\t\t\t\t\tif (area.getHigh() > endY) {",
                "+\t\t\t\t\t\tdrawingFinished = true;",
                "+\t\t\t\t\t\tinterruptedAreas.previous();",
                "+\t\t\t\t\t}",
                "+\t\t\t\t}",
                "+\t\t\t\t// the interruption start after the end",
                "+\t\t\t\telse {",
                "+\t\t\t\t\tinterruptedAreas.previous();",
                "+\t\t\t\t\tdrawingFinished = true;",
                "+\t\t\t\t\tdrawEnd = true;",
                "+\t\t\t\t\tcurrentEndY = endY;",
                "+\t\t\t\t}",
                "+\t\t\t}",
                "+\t\t\t// we can draw till the end",
                "+\t\t\telse {",
                "+\t\t\t\tdrawingFinished = true;",
                "+\t\t\t\tdrawEnd = true;",
                "+\t\t\t\tcurrentEndY = endY;",
                "+\t\t\t}",
                "+\t\t\t// drawing part",
                "+\t\t\tif (activeCount == 0) {",
                "+\t\t\t\tdrawHandler.setLineType(LineType.DASHED);",
                "+\t\t\t\tdrawHandler.drawLine(centerX, currentStartY, centerX, currentEndY);",
                "+\t\t\t}",
                "+\t\t\telse {",
                "+\t\t\t\tdrawHandler.setLineType(LineType.SOLID);",
                "+\t\t\t\t// the right border of an rectangle is always overlaid by the rectangle to its right -> draw left lines and the right most line",
                "+\t\t\t\tdouble lineX = centerX - EXECUTIONSPECIFICATION_WIDTH / 2.0;",
                "+\t\t\t\tdrawHandler.drawLine(lineX, currentStartY, lineX, currentEndY);",
                "+\t\t\t\tfor (int i = 0; i < activeCount - 1; i++) {",
                "+\t\t\t\t\tlineX += EXECUTIONSPECIFICATION_WIDTH - EXECUTIONSPECIFICATION_OVERLAPP;",
                "+\t\t\t\t\tdrawHandler.drawLine(lineX, currentStartY, lineX, currentEndY);",
                "+\t\t\t\t}",
                "+\t\t\t\tlineX += EXECUTIONSPECIFICATION_WIDTH;",
                "+\t\t\t\tdrawHandler.drawLine(lineX, currentStartY, lineX, currentEndY);",
                "+\t\t\t\tif (drawHead && activeCountIncStart) {",
                "+\t\t\t\t\t// draw top border",
                "+\t\t\t\t\tdrawHandler.drawLine(lineX - EXECUTIONSPECIFICATION_WIDTH, currentStartY, lineX, currentStartY);",
                "+\t\t\t\t}",
                "+\t\t\t\tif (drawEnd && !activeCountIncEnd) {",
                "+\t\t\t\t\t// draw bottom border",
                "+\t\t\t\t\tdrawHandler.drawLine(lineX - EXECUTIONSPECIFICATION_WIDTH, currentEndY, lineX, currentEndY);",
                "+\t\t\t\t}",
                "+\t\t\t}",
                "+\t\t\tdrawHead = false;",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tprivate void drawHead(DrawHandler drawHandler, double x, double y, double width, double height) {",
                "+\t\tif (headType == LifelineHeadType.STANDARD || headType == LifelineHeadType.ACTIVE_CLASS) {",
                "+\t\t\tdrawHandler.drawRectangle(x, y, width, height);",
                "+\t\t\tif (headType == LifelineHeadType.ACTIVE_CLASS) {",
                "+\t\t\t\tdrawHandler.drawLine(x + ACTIVE_CLASS_DOUBLE_BORDER_GAP, y, x + ACTIVE_CLASS_DOUBLE_BORDER_GAP, y + height);",
                "+\t\t\t\tdrawHandler.drawLine(x + width - ACTIVE_CLASS_DOUBLE_BORDER_GAP, y, x + width - ACTIVE_CLASS_DOUBLE_BORDER_GAP, y + height);",
                "+\t\t\t\tx += ACTIVE_CLASS_DOUBLE_BORDER_GAP;",
                "+\t\t\t\twidth -= ACTIVE_CLASS_DOUBLE_BORDER_GAP * 2;",
                "+\t\t\t}",
                "+\t\t\tx += HEAD_HORIZONTAL_BORDER_PADDING;",
                "+\t\t\twidth -= HEAD_HORIZONTAL_BORDER_PADDING * 2;",
                "+\t\t\ty += HEAD_VERTICAL_BORDER_PADDING;",
                "+\t\t\theight -= HEAD_VERTICAL_BORDER_PADDING * 2;",
                "+\t\t\t// draw Text in x,y with width,height",
                "+\t\t\tTextSplitter.drawText(drawHandler, text, x, y, width, height, AlignHorizontal.CENTER, AlignVertical.CENTER);",
                "+\t\t}",
                "+\t\telse if (headType == LifelineHeadType.ACTOR) {",
                "+\t\t\tDrawHelper.drawActor(drawHandler, (int) (x + width / 2.0), (int) y, ACTOR_DIMENSION);",
                "+\t\t\ty += ACTOR_SIZE.y;",
                "+\t\t\theight -= ACTOR_SIZE.y;",
                "+\t\t\t// draw Text in x,y with width,height",
                "+\t\t\tTextSplitter.drawText(drawHandler, text, x, y, width, height, AlignHorizontal.CENTER, AlignVertical.BOTTOM);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tlog.error(\"Encountered unhandled enumeration value '\" + headType + \"'.\");",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tpublic enum LifelineHeadType {",
                "+\t\tSTANDARD, ACTIVE_CLASS, ACTOR",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineDrawingInfo.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineDrawingInfo.java",
                "new file mode 100644",
                "index 00000000..386e7758",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineDrawingInfo.java",
                "@@ -0,0 +1,15 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import com.baselet.control.basics.Line1D;",
                "+import com.baselet.control.basics.SortedMergedLine1DList;",
                "+",
                "+/**",
                "+ * Interface for the drawing information which is needed by a single lifeline.",
                "+ */",
                "+public interface LifelineDrawingInfo extends LifelineHorizontalDrawingInfo, VerticalDrawingInfo {",
                "+",
                "+\t// these two methods are not in the VerticalDrawingInfo because they are different for each lifeline",
                "+\tpublic SortedMergedLine1DList getInterruptedAreas();",
                "+",
                "+\tpublic void addInterruptedArea(Line1D llInterruption);",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineHorizontalDrawingInfo.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineHorizontalDrawingInfo.java",
                "new file mode 100644",
                "index 00000000..ba306e67",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineHorizontalDrawingInfo.java",
                "@@ -0,0 +1,97 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+/**",
                "+ * Interface for the horizontal drawing information for a single lifeline.",
                "+ */",
                "+public interface LifelineHorizontalDrawingInfo {",
                "+",
                "+\t/**",
                "+\t * @return the start (left) x coordinate of the lifeline without any padding,",
                "+\t * i.e. the left x coordinate of the rectangular head (if created at start)",
                "+\t */",
                "+\tpublic double getHorizontalStart();",
                "+",
                "+\t/**",
                "+\t * @return the end (right) x coordinate of the lifeline without any padding,",
                "+\t * i.e. the right x coordinate of the rectangular head (if created at start)",
                "+\t */",
                "+\tpublic double getHorizontalEnd();",
                "+",
                "+\t/**",
                "+\t * Returns the left x coordinate with respect to the left padding.",
                "+\t * @param tick at which the start should be calculated, the tick is necessary to determine if a padding is present",
                "+\t * @return the start (left) x coordinate of the lifeline with left padding included, if no left padding is present",
                "+\t * (e.g. from a combined fragment border on the left side) it is equal to getHorizontalStart()",
                "+\t * @see #getHorizontalStart()",
                "+\t */",
                "+\tpublic double getHorizontalStart(int tick);",
                "+",
                "+\t/**",
                "+\t * Returns the right x coordinate with respect to the right padding.",
                "+\t * @param tick at which the end should be calculated, the tick is necessary to determine if a padding is present",
                "+\t * @return the end (right) x coordinate of the lifeline with right padding included, if no right padding is present",
                "+\t * (e.g. from a combined fragment border on the right side) it is equal to getHorizontalEnd()",
                "+\t * @see #getHorizontalEnd()",
                "+\t */",
                "+\tpublic double getHorizontalEnd(int tick);",
                "+",
                "+\t/**",
                "+\t * Center of the lifeline i.e. the dashed line, this must not lie at <code>getHorizontalStart + getWidth / 2</code>",
                "+\t * but always is <code>getSymmetricHorizontalStart + getSymmetricWidth / 2</code>",
                "+\t * @return the center of the lifeline",
                "+\t */",
                "+\tpublic double getHorizontalCenter();",
                "+",
                "+\t/**",
                "+\t * <code>getHorizontalEnd - getHorizontalStart</code>",
                "+\t * @return the width of the lifeline",
                "+\t * @see #getHorizontalStart()",
                "+\t * @see #getHorizontalEnd()",
                "+\t */",
                "+\tpublic double getWidth();",
                "+",
                "+\t/**",
                "+\t * <code>getHorizontalEnd - getHorizontalStart</code>",
                "+\t * @param tick",
                "+\t * @return the width of the lifeline at the given tick",
                "+\t * @see #getHorizontalStart(int)",
                "+\t * @see #getHorizontalEnd(int)",
                "+\t */",
                "+\tpublic double getWidth(int tick);",
                "+",
                "+\t/**",
                "+\t * Returns the  left x coordinate with respect to the max(left padding, right padding).",
                "+\t * getSymmetricHorizontalStart and getSymmetricHorizontalEnd have the same distance to the center.",
                "+\t * @param tick at which the start should be calculated, the tick is necessary to determine if a padding is present",
                "+\t * @return the start (left) x coordinate of the lifeline with left and right padding included, if no padding is",
                "+\t * present (e.g. from a combined fragment border) it is equal to getHorizontalStart(). If the left padding is",
                "+\t * &gt;= right padding it is equal to getHorizontalStart(int)",
                "+\t * @see #getHorizontalStart()",
                "+\t * @see #getHorizontalStart(int)",
                "+\t * @see #getSymmetricHorizontalEnd(int)",
                "+\t */",
                "+\tpublic double getSymmetricHorizontalStart(int tick);",
                "+",
                "+\t/**",
                "+\t * Returns the  right x coordinate with respect to the max(left padding, right padding).",
                "+\t * getSymmetricHorizontalStart and getSymmetricHorizontalEnd have the same distance to the center.",
                "+\t * @param tick at which the end should be calculated, the tick is necessary to determine if a padding is present",
                "+\t * @return the end (right) x coordinate of the lifeline with left and right padding included, if no padding is",
                "+\t * present (e.g. from a combined fragment border) it is equal to getHorizontalEnd(). If the left padding is",
                "+\t * &lt;= right padding it is equal to getHorizontalEnd(int)",
                "+\t * @see #getHorizontalEnd()",
                "+\t * @see #getHorizontalEnd(int)",
                "+\t * @see #getSymmetricHorizontalStart(int)",
                "+\t */",
                "+\tpublic double getSymmetricHorizontalEnd(int tick);",
                "+",
                "+\t/**",
                "+\t * <code>getSymmetricHorizontalEnd - getSymmetricHorizontalStart</code>",
                "+\t * @param tick",
                "+\t * @return the symmetric width of the lifeline at the given tick",
                "+\t * @see #getSymmetricHorizontalStart(int)",
                "+\t * @see #getSymmetricHorizontalEnd(int)",
                "+\t */",
                "+\tpublic double getSymmetricWidth(int tick);",
                "+",
                "+}",
                "\\ No newline at end of file",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineHorizontalDrawingInfoImpl.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineHorizontalDrawingInfoImpl.java",
                "new file mode 100644",
                "index 00000000..748b1824",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineHorizontalDrawingInfoImpl.java",
                "@@ -0,0 +1,70 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.Arrays;",
                "+",
                "+public class LifelineHorizontalDrawingInfoImpl implements LifelineHorizontalDrawingInfo {",
                "+",
                "+\tprivate final double[] leftPaddings;",
                "+\tprivate final double[] rightPaddings;",
                "+\tprivate final double startX;",
                "+\tprivate final double endX;",
                "+",
                "+\tpublic LifelineHorizontalDrawingInfoImpl(double[] leftPaddings, double[] rightPaddings, double startX, double endX) {",
                "+\t\tsuper();",
                "+\t\tthis.leftPaddings = Arrays.copyOf(leftPaddings, leftPaddings.length);",
                "+\t\tthis.rightPaddings = Arrays.copyOf(rightPaddings, rightPaddings.length);",
                "+\t\tthis.startX = startX;",
                "+\t\tthis.endX = endX;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getHorizontalStart() {",
                "+\t\treturn startX;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getHorizontalEnd() {",
                "+\t\treturn endX;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getHorizontalStart(int tick) {",
                "+\t\treturn getHorizontalStart() + leftPaddings[tick];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getHorizontalEnd(int tick) {",
                "+\t\treturn getHorizontalEnd() - rightPaddings[tick];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getHorizontalCenter() {",
                "+\t\treturn (startX + endX) / 2.0;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getWidth() {",
                "+\t\treturn endX - startX;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getWidth(int tick) {",
                "+\t\treturn getHorizontalEnd(tick) - getHorizontalStart(tick);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getSymmetricHorizontalStart(int tick) {",
                "+\t\treturn getHorizontalStart() + Math.max(leftPaddings[tick], rightPaddings[tick]);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getSymmetricHorizontalEnd(int tick) {",
                "+\t\treturn getHorizontalEnd() - Math.max(leftPaddings[tick], rightPaddings[tick]);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getSymmetricWidth(int tick) {",
                "+\t\treturn getWidth() - Math.max(leftPaddings[tick], rightPaddings[tick]) * 2;",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineOccurrence.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineOccurrence.java",
                "new file mode 100644",
                "index 00000000..7299a95a",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineOccurrence.java",
                "@@ -0,0 +1,32 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import com.baselet.control.basics.Line1D;",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+",
                "+public interface LifelineOccurrence {",
                "+",
                "+\t/**",
                "+\t * @param drawHandler",
                "+\t * @param topLeft the top left corner of the rectangle in which the occurrence can draw",
                "+\t * @param size of the rectangle in which the occurrence can draw.",
                "+\t * @return if the lifeline is not interrupted then null, otherwise the Point contains the y start and y end of the interrupted area",
                "+\t */",
                "+\tpublic Line1D draw(DrawHandler drawHandler, PointDouble topLeft, PointDouble size);",
                "+",
                "+\t/**",
                "+\t * @param drawHandler",
                "+\t * @return the minimum width which is needed by this element",
                "+\t */",
                "+\tpublic double getMinWidth(DrawHandler drawHandler);",
                "+",
                "+\t/**",
                "+\t * @param drawHandler",
                "+\t * @param size of the rectangle in which the occurrence can draw.",
                "+\t * @return the amount of additional y space needed to draw the LifelineOccurence",
                "+\t * (e.g. a long constraint which is wrapped into  multiple lines).",
                "+\t * If the return value is &lt;= 0 then the value is ignored.",
                "+\t */",
                "+\tpublic double getAdditionalYHeight(DrawHandler drawHandler, PointDouble size);",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineSpanningTickSpanningOccurrence.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineSpanningTickSpanningOccurrence.java",
                "new file mode 100644",
                "index 00000000..2ab32087",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineSpanningTickSpanningOccurrence.java",
                "@@ -0,0 +1,125 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.Comparator;",
                "+import java.util.Map;",
                "+",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+",
                "+/**",
                "+ * Represents an element which may span over multiple lifelines and mutliple ticks.",
                "+ */",
                "+public interface LifelineSpanningTickSpanningOccurrence {",
                "+",
                "+\t/**",
                "+\t * @return the first lifeline (lowest index) which is covered by this occurrence",
                "+\t */",
                "+\tpublic Lifeline getFirstLifeline();",
                "+",
                "+\t/**",
                "+\t * @return the last lifeline (highest index) which is covered by this occurrence",
                "+\t */",
                "+\tpublic Lifeline getLastLifeline();",
                "+",
                "+\t/**",
                "+\t * Draws the element and adds interrupted Areas to the LifelineDrawingInfo",
                "+\t * (which can be access via {@link DrawingInfo#getDrawingInfo(Lifeline)})",
                "+\t * @param drawHandler",
                "+\t * @param drawingInfo",
                "+\t */",
                "+\tpublic void draw(DrawHandler drawHandler, DrawingInfo drawingInfo);",
                "+",
                "+\t/**",
                "+\t * Returns the minimum width between the start of the first lifeline and the end of the last lifeline.",
                "+\t * @param drawHandler",
                "+\t * @param lifelineHorizontalPadding specifies how much space is between 2 adjacent lifelines",
                "+\t * (can be useful for calculating the exact minimum width)",
                "+\t * @return the minimum width of the occurrence",
                "+\t */",
                "+\tpublic double getOverallMinWidth(DrawHandler drawHandler, double lifelineHorizontalPadding);",
                "+",
                "+\t/**",
                "+\t * Returns the additional heights needed by this occurrence, the tick is the key",
                "+\t * @param drawHandler",
                "+\t * @param hInfo the horizontal drawing information, from which the usable width can be calculated",
                "+\t * @param defaultTickHeight",
                "+\t * @return a map with the additional heights, the keys are the ticks and the values is the additional height needed",
                "+\t */",
                "+\tpublic Map<Integer, Double> getEveryAdditionalYHeight(DrawHandler drawHandler, HorizontalDrawingInfo hInfo,",
                "+\t\t\tdouble defaultTickHeight);",
                "+",
                "+\tpublic ContainerPadding getPaddingInformation();",
                "+",
                "+\tpublic static class ContainerPadding {",
                "+\t\tprivate final Container container;",
                "+",
                "+\t\tprivate final double leftPadding;",
                "+\t\tprivate final double rightPadding;",
                "+\t\tprivate final double topPadding;",
                "+\t\tprivate final double bottomPadding;",
                "+",
                "+\t\tpublic ContainerPadding(Container container, double leftPadding, double rightPadding, double topPadding, double bottomPadding) {",
                "+\t\t\tsuper();",
                "+\t\t\tthis.container = container;",
                "+\t\t\tthis.leftPadding = leftPadding;",
                "+\t\t\tthis.rightPadding = rightPadding;",
                "+\t\t\tthis.topPadding = topPadding;",
                "+\t\t\tthis.bottomPadding = bottomPadding;",
                "+\t\t}",
                "+",
                "+\t\tpublic Container getContainer() {",
                "+\t\t\treturn container;",
                "+\t\t}",
                "+",
                "+\t\tpublic double getLeftPadding() {",
                "+\t\t\treturn leftPadding;",
                "+\t\t}",
                "+",
                "+\t\tpublic double getRightPadding() {",
                "+\t\t\treturn rightPadding;",
                "+\t\t}",
                "+",
                "+\t\tpublic double getTopPadding() {",
                "+\t\t\treturn topPadding;",
                "+\t\t}",
                "+",
                "+\t\tpublic double getBottomPadding() {",
                "+\t\t\treturn bottomPadding;",
                "+\t\t}",
                "+",
                "+\t\tpublic static Comparator<ContainerPadding> getContainerStartTickAscComparator()",
                "+\t\t{",
                "+\t\t\treturn new Comparator<ContainerPadding>() {",
                "+\t\t\t\t@Override",
                "+\t\t\t\tpublic int compare(ContainerPadding o1, ContainerPadding o2) {",
                "+\t\t\t\t\treturn o1.getContainer().getStartTick() - o2.getContainer().getStartTick();",
                "+\t\t\t\t}",
                "+\t\t\t};",
                "+\t\t}",
                "+",
                "+\t\tpublic static Comparator<ContainerPadding> getContainerStartTickLifelineAscComparator()",
                "+\t\t{",
                "+\t\t\treturn new Comparator<ContainerPadding>() {",
                "+\t\t\t\t@Override",
                "+\t\t\t\tpublic int compare(ContainerPadding o1, ContainerPadding o2) {",
                "+\t\t\t\t\tint ret = o1.getContainer().getStartTick() - o2.getContainer().getStartTick();",
                "+\t\t\t\t\tif (ret == 0) {",
                "+\t\t\t\t\t\treturn o1.getContainer().getFirstLifeline().getIndex() - o2.getContainer().getFirstLifeline().getIndex();",
                "+\t\t\t\t\t}",
                "+\t\t\t\t\telse {",
                "+\t\t\t\t\t\treturn ret;",
                "+\t\t\t\t\t}",
                "+\t\t\t\t}",
                "+\t\t\t};",
                "+\t\t}",
                "+",
                "+\t\tpublic static Comparator<ContainerPadding> getContainerEndTickAscComparator()",
                "+\t\t{",
                "+\t\t\treturn new Comparator<ContainerPadding>() {",
                "+\t\t\t\t@Override",
                "+\t\t\t\tpublic int compare(ContainerPadding o1, ContainerPadding o2) {",
                "+\t\t\t\t\treturn o1.getContainer().getEndTick() - o2.getContainer().getEndTick();",
                "+\t\t\t\t}",
                "+\t\t\t};",
                "+\t\t}",
                "+\t}",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LostOrFoundMessage.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LostOrFoundMessage.java",
                "new file mode 100644",
                "index 00000000..e8a3181b",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LostOrFoundMessage.java",
                "@@ -0,0 +1,183 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "+",
                "+import com.baselet.control.basics.Line1D;",
                "+import com.baselet.control.basics.geom.Line;",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.control.enums.AlignHorizontal;",
                "+import com.baselet.control.enums.AlignVertical;",
                "+import com.baselet.control.enums.LineType;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.diagram.draw.TextSplitter;",
                "+import com.baselet.diagram.draw.helper.ColorOwn;",
                "+import com.baselet.element.relation.helper.RelationDrawer;",
                "+import com.baselet.element.relation.helper.RelationDrawer.ArrowEndType;",
                "+import com.baselet.element.sequence_aio.facet.Message.ArrowType;",
                "+",
                "+/**",
                "+ * Class for representing a lost or a found message.",
                "+ * Lost Messages are always on the right side of the lifeline and found messages are always on the left side of the lifeline.",
                "+ * Therefore the message always travels from left to right.",
                "+ *",
                "+ */",
                "+public class LostOrFoundMessage implements LifelineOccurrence {",
                "+",
                "+\tprivate static final Logger log = LoggerFactory.getLogger(LostOrFoundMessage.class);",
                "+\tprivate static final double CIRCLE_RADIUS = 10;",
                "+\tprivate static final double LIFELINE_TEXT_PADDING = Math.max(RelationDrawer.ARROW_LENGTH, CIRCLE_RADIUS * 2) + 3;",
                "+",
                "+\tprivate final Lifeline lifeline;",
                "+\t// private final Lifeline to;",
                "+\tprivate final int sendTick;",
                "+\tprivate final String[] textLines;",
                "+\tprivate final ArrowType arrowType;",
                "+\tprivate final LineType lineType;",
                "+\tprivate final boolean found;",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @param lifeline",
                "+\t * @param found true if it is a found message, if false it is a lost message",
                "+\t * @param sendTick",
                "+\t * @param text can be more than one line, but if so the lines must be separated by a \\n",
                "+\t * @param arrowType",
                "+\t * @param lineType",
                "+\t */",
                "+\tpublic LostOrFoundMessage(Lifeline lifeline, boolean found, int sendTick, String text, ArrowType arrowType, LineType lineType) {",
                "+\t\tsuper();",
                "+\t\tthis.lifeline = lifeline;",
                "+\t\tthis.found = found;",
                "+\t\tthis.sendTick = sendTick;",
                "+\t\ttextLines = text.split(\"\\n\");",
                "+\t\tthis.arrowType = arrowType;",
                "+\t\tthis.lineType = lineType;",
                "+\t}",
                "+",
                "+\tpublic double getCenterXOffset() {",
                "+\t\tif (found) {",
                "+\t\t\treturn -lifeline.getLifelineLeftPartWidth(sendTick);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\treturn lifeline.getLifelineRightPartWidth(sendTick);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Line1D draw(DrawHandler drawHandler, PointDouble topLeft, PointDouble size) {",
                "+\t\tRelationDrawer.ArrowEndType arrowEndType = ArrowEndType.NORMAL;",
                "+\t\tboolean fillArrow = false;",
                "+\t\tswitch (arrowType) {",
                "+\t\t\tcase OPEN:",
                "+\t\t\t\tarrowEndType = ArrowEndType.NORMAL;",
                "+\t\t\t\tfillArrow = false;",
                "+\t\t\t\tbreak;",
                "+\t\t\tcase FILLED:",
                "+\t\t\t\tarrowEndType = ArrowEndType.CLOSED;",
                "+\t\t\t\tfillArrow = true;",
                "+\t\t\t\tbreak;",
                "+\t\t\tdefault:",
                "+\t\t\t\tlog.error(\"Encountered unhandled enumeration value '\" + arrowType + \"'.\");",
                "+\t\t\t\tbreak;",
                "+\t\t}",
                "+\t\tLineType oldLt = drawHandler.getLineType();",
                "+\t\tdrawHandler.setLineType(lineType);",
                "+\t\tdouble centerY = topLeft.y + size.y / 2;",
                "+\t\tdouble lineXStart, lineXEnd;",
                "+\t\tColorOwn oldBg = drawHandler.getBackgroundColor();",
                "+\t\tdrawHandler.setBackgroundColor(drawHandler.getForegroundColor());",
                "+\t\tif (found) {",
                "+\t\t\tdrawHandler.drawCircle(topLeft.x + CIRCLE_RADIUS, centerY, CIRCLE_RADIUS);",
                "+\t\t\tlineXStart = topLeft.x + CIRCLE_RADIUS * 2;",
                "+\t\t\tlineXEnd = topLeft.x + size.x / 2 + getCenterXOffset();",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tdrawHandler.drawCircle(topLeft.x + size.x - CIRCLE_RADIUS, topLeft.y + size.y / 2, CIRCLE_RADIUS);",
                "+\t\t\tlineXStart = topLeft.x + size.x / 2 + getCenterXOffset();",
                "+\t\t\tlineXEnd = topLeft.x + size.x - CIRCLE_RADIUS * 2;",
                "+\t\t}",
                "+\t\tdrawHandler.setBackgroundColor(oldBg);",
                "+",
                "+\t\tTextSplitter.drawText(drawHandler, textLines, lineXStart, topLeft.y,",
                "+\t\t\t\tlineXEnd - lineXStart, size.y / 2, AlignHorizontal.CENTER, AlignVertical.BOTTOM);",
                "+\t\tPointDouble arrowPoint = new PointDouble(lineXEnd, centerY);",
                "+\t\tLine line = new Line(new PointDouble(lineXStart, centerY), arrowPoint);",
                "+\t\tdrawHandler.drawLine(line);",
                "+\t\tRelationDrawer.drawArrowToLine(arrowPoint, drawHandler, line, false, arrowEndType, fillArrow, false);",
                "+\t\tdrawHandler.setLineType(oldLt);",
                "+\t\treturn null;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getMinWidth(DrawHandler drawHandler) {",
                "+\t\treturn (TextSplitter.getTextMinWidth(textLines, drawHandler)",
                "+\t\t\t\t+ LIFELINE_TEXT_PADDING * 2 + Math.abs(getCenterXOffset())) * 2;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getAdditionalYHeight(DrawHandler drawHandler, PointDouble size) {",
                "+\t\treturn TextSplitter.getSplitStringHeight(textLines,",
                "+\t\t\t\tsize.x / 2 - LIFELINE_TEXT_PADDING * 2 - Math.abs(getCenterXOffset()), drawHandler",
                "+\t\t\t\t) * 2 - size.y;",
                "+\t}",
                "+",
                "+\tpublic OccurrenceSpecification sendOccurrenceSpecification() {",
                "+\t\tif (found) {",
                "+\t\t\tthrow new IllegalStateException(\"A found message has no send occurrence specification.\");",
                "+\t\t}",
                "+\t\treturn new LostOrFoundOccurrenceSpecification();",
                "+\t}",
                "+",
                "+\tpublic OccurrenceSpecification receiveOccurrenceSpecification() {",
                "+\t\tif (!found) {",
                "+\t\t\tthrow new IllegalStateException(\"A lost message has no receive occurrence specification.\");",
                "+\t\t}",
                "+\t\treturn new LostOrFoundOccurrenceSpecification();",
                "+\t}",
                "+",
                "+\tprivate class LostOrFoundOccurrenceSpecification implements OccurrenceSpecification {",
                "+",
                "+\t\t@Override",
                "+\t\tpublic Lifeline getLifeline() {",
                "+\t\t\treturn lifeline;",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic boolean hasFixedPosition() {",
                "+\t\t\treturn true;",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic AlignHorizontal getFixedPositionAlignment() {",
                "+\t\t\tif (getCenterXOffset() >= 0) {",
                "+\t\t\t\treturn AlignHorizontal.RIGHT;",
                "+\t\t\t}",
                "+\t\t\telse {",
                "+\t\t\t\treturn AlignHorizontal.LEFT;",
                "+\t\t\t}",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getHorizonatlPosition(HorizontalDrawingInfo hDrawingInfo) {",
                "+\t\t\treturn hDrawingInfo.getHDrawingInfo(getLifeline()).getHorizontalCenter() + getCenterXOffset();",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getHorizontalPosition(HorizontalDrawingInfo llHDrawingInfo, boolean left) {",
                "+\t\t\treturn 0;",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic PointDouble getPosition(DrawingInfo drawingInfo) {",
                "+\t\t\treturn new PointDouble(getHorizonatlPosition(drawingInfo), drawingInfo.getVerticalCenter(sendTick));",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic PointDouble getPosition(DrawingInfo drawingInfo, boolean left) {",
                "+\t\t\treturn new PointDouble(0, 0);",
                "+\t\t}",
                "+",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Message.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Message.java",
                "new file mode 100644",
                "index 00000000..f866ada1",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Message.java",
                "@@ -0,0 +1,385 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.HashMap;",
                "+import java.util.Map;",
                "+",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "+",
                "+import com.baselet.control.basics.geom.Line;",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.control.enums.AlignHorizontal;",
                "+import com.baselet.control.enums.AlignVertical;",
                "+import com.baselet.control.enums.LineType;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.diagram.draw.TextSplitter;",
                "+import com.baselet.element.relation.helper.RelationDrawer;",
                "+import com.baselet.element.relation.helper.RelationDrawer.ArrowEndType;",
                "+",
                "+public class Message implements LifelineSpanningTickSpanningOccurrence {",
                "+",
                "+\tprivate static final Logger log = LoggerFactory.getLogger(Message.class);",
                "+\tprotected static final double LIFELINE_TEXT_PADDING = RelationDrawer.ARROW_LENGTH + 3;",
                "+\tprotected static final double SELF_MESSAGE_LIFELINE_GAP = RelationDrawer.ARROW_LENGTH + 7;",
                "+\tprotected static final double SELF_MESSAGE_TEXT_PADDING = 5;",
                "+",
                "+\tprotected final Lifeline from;",
                "+\tprotected final Lifeline to;",
                "+\t/** how many ticks it takes to transmit the message */",
                "+\tprotected final int duration;",
                "+\tprotected final int sendTick;",
                "+\tprotected final String[] textLines;",
                "+\tprotected final ArrowType arrowType;",
                "+\tprotected final LineType lineType;",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @param from",
                "+\t * @param to",
                "+\t * @param duration &gt;= 0; if from==to (a self message) then duration must be &gt; 0",
                "+\t * @param sendTick",
                "+\t * @param text can be more than one line, but if so the lines must be separated by a \\n",
                "+\t * @param arrowType",
                "+\t * @param lineType",
                "+\t */",
                "+\tpublic Message(Lifeline from, Lifeline to, int duration, int sendTick, String text, ArrowType arrowType, LineType lineType) {",
                "+\t\tsuper();",
                "+\t\tthis.from = from;",
                "+\t\tthis.to = to;",
                "+\t\tthis.duration = duration;",
                "+\t\tthis.sendTick = sendTick;",
                "+\t\ttextLines = text.split(\"\\n\");",
                "+\t\tthis.arrowType = arrowType;",
                "+\t\tthis.lineType = lineType;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Lifeline getFirstLifeline() {",
                "+\t\treturn from.getIndex() < to.getIndex() ? from : to;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Lifeline getLastLifeline() {",
                "+\t\treturn from.getIndex() > to.getIndex() ? from : to;",
                "+\t}",
                "+",
                "+\tprotected double getSendCenterXOffset() {",
                "+\t\tif (from == to) {",
                "+\t\t\treturn from.getLifelineRightPartWidth(sendTick);",
                "+\t\t}",
                "+\t\telse if (getFirstLifeline() == from) {",
                "+\t\t\treturn from.getLifelineRightPartWidth(sendTick);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\treturn -from.getLifelineLeftPartWidth(sendTick);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tprotected double getReceiveCenterXOffset() {",
                "+\t\tif (from == to) {",
                "+\t\t\treturn to.getLifelineRightPartWidth(sendTick + duration);",
                "+\t\t}",
                "+\t\telse if (getFirstLifeline() == from) {",
                "+\t\t\treturn -to.getLifelineLeftPartWidth(sendTick + duration);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\treturn to.getLifelineRightPartWidth(sendTick + duration);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tprotected double getSendX(HorizontalDrawingInfo hDrawingInfo) {",
                "+\t\treturn hDrawingInfo.getHDrawingInfo(from).getHorizontalCenter() + getSendCenterXOffset();",
                "+\t}",
                "+",
                "+\tprotected double getReceiveX(HorizontalDrawingInfo hDrawingInfo) {",
                "+\t\tLifelineHorizontalDrawingInfo llHDrawingInfo = hDrawingInfo.getHDrawingInfo(to);",
                "+\t\tdouble receiveX = llHDrawingInfo.getHorizontalCenter();",
                "+\t\treceiveX += getReceiveCenterXOffset();",
                "+\t\tif (!to.isCreatedOnStart() && to.getCreated() != null && sendTick + duration == to.getCreated()) {",
                "+\t\t\t// create message must end at the head",
                "+\t\t\tif (getFirstLifeline() == to) {",
                "+\t\t\t\treceiveX = llHDrawingInfo.getSymmetricHorizontalEnd(sendTick + duration);",
                "+\t\t\t}",
                "+\t\t\telse {",
                "+\t\t\t\treceiveX = llHDrawingInfo.getSymmetricHorizontalStart(sendTick + duration);",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\treturn receiveX;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic void draw(DrawHandler drawHandler, DrawingInfo drawingInfo) {",
                "+\t\tPointDouble send = new PointDouble(",
                "+\t\t\t\tgetSendX(drawingInfo),",
                "+\t\t\t\tdrawingInfo.getVerticalCenter(sendTick));",
                "+\t\tPointDouble receive = new PointDouble(getReceiveX(drawingInfo), drawingInfo.getVerticalCenter(sendTick + duration));",
                "+",
                "+\t\tRelationDrawer.ArrowEndType arrowEndType = ArrowEndType.NORMAL;",
                "+\t\tboolean fillArrow = false;",
                "+\t\tswitch (arrowType) {",
                "+\t\t\tcase OPEN:",
                "+\t\t\t\tarrowEndType = ArrowEndType.NORMAL;",
                "+\t\t\t\tfillArrow = false;",
                "+\t\t\t\tbreak;",
                "+\t\t\tcase FILLED:",
                "+\t\t\t\tarrowEndType = ArrowEndType.CLOSED;",
                "+\t\t\t\tfillArrow = true;",
                "+\t\t\t\tbreak;",
                "+\t\t\tdefault:",
                "+\t\t\t\tlog.error(\"Encountered unhandled enumeration value '\" + arrowType + \"'.\");",
                "+\t\t\t\tbreak;",
                "+\t\t}",
                "+\t\tLineType oldLt = drawHandler.getLineType();",
                "+\t\tdrawHandler.setLineType(lineType);",
                "+\t\tif (from == to) {",
                "+\t\t\tdrawSelfMessage(drawHandler, send, receive, arrowEndType, fillArrow, drawingInfo);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tdrawNormalMessage(drawHandler, send, receive, arrowEndType, fillArrow, drawingInfo);",
                "+\t\t}",
                "+\t\tdrawHandler.setLineType(oldLt);",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * draws a message which is sent between two different lifelines",
                "+\t */",
                "+\tprotected void drawNormalMessage(DrawHandler drawHandler, PointDouble send, PointDouble receive,",
                "+\t\t\tRelationDrawer.ArrowEndType arrowEndType, boolean fillArrow, DrawingInfo drawingInfo) {",
                "+\t\tLine line = new Line(send, receive);",
                "+\t\tdrawHandler.drawLine(line);",
                "+\t\tdrawHandler.setLineType(LineType.SOLID);",
                "+\t\tRelationDrawer.drawArrowToLine(receive, drawHandler, line, false, arrowEndType, fillArrow, false);",
                "+",
                "+\t\tdouble height = send.y - drawingInfo.getVerticalStart(sendTick);",
                "+\t\tdouble topLeftX;",
                "+\t\tAlignHorizontal hAlignment;",
                "+\t\tif (from == getFirstLifeline()) {",
                "+\t\t\ttopLeftX = send.x;",
                "+\t\t\thAlignment = AlignHorizontal.LEFT;",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\ttopLeftX = receive.x;",
                "+\t\t\thAlignment = AlignHorizontal.RIGHT;",
                "+\t\t}",
                "+\t\tif (duration == 0) {",
                "+\t\t\thAlignment = AlignHorizontal.CENTER;",
                "+\t\t}",
                "+\t\ttopLeftX += LIFELINE_TEXT_PADDING;",
                "+\t\tTextSplitter.drawText(drawHandler, textLines, topLeftX, send.y - height,",
                "+\t\t\t\tMath.abs(send.x - receive.x) - LIFELINE_TEXT_PADDING * 2, height, hAlignment, AlignVertical.BOTTOM);",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * draws a message which is sent to the same lifeline",
                "+\t */",
                "+\tprotected void drawSelfMessage(DrawHandler drawHandler, PointDouble send, PointDouble receive,",
                "+\t\t\tRelationDrawer.ArrowEndType arrowEndType, boolean fillArrow, DrawingInfo hInfo) {",
                "+\t\tdouble rightBorderX = Math.max(send.x, receive.x) + SELF_MESSAGE_LIFELINE_GAP;",
                "+\t\tPointDouble[] msgLine = new PointDouble[] {",
                "+\t\t\t\tsend,",
                "+\t\t\t\tnew PointDouble(rightBorderX, send.y),",
                "+\t\t\t\tnew PointDouble(rightBorderX, receive.y),",
                "+\t\t\t\treceive };",
                "+\t\tdrawHandler.drawLines(msgLine);",
                "+\t\tdrawHandler.setLineType(LineType.SOLID);",
                "+\t\tRelationDrawer.drawArrowToLine(receive, drawHandler, new Line(msgLine[2], msgLine[3]), false, arrowEndType, fillArrow, false);",
                "+",
                "+\t\trightBorderX += SELF_MESSAGE_TEXT_PADDING;",
                "+\t\tdouble lifelineXEnd = Math.min(hInfo.getHDrawingInfo(to).getSymmetricHorizontalEnd(sendTick),",
                "+\t\t\t\thInfo.getHDrawingInfo(to).getSymmetricHorizontalEnd(sendTick + duration));",
                "+\t\tTextSplitter.drawText(drawHandler, textLines, rightBorderX, send.y,",
                "+\t\t\t\tlifelineXEnd - rightBorderX, receive.y - send.y, AlignHorizontal.LEFT, AlignVertical.CENTER);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getOverallMinWidth(DrawHandler drawHandler, double lifelineHorizontalPadding) {",
                "+\t\tif (from == to) {",
                "+\t\t\treturn getOverallMinWidthSelfMessage(drawHandler, lifelineHorizontalPadding);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\treturn getOverallMinWidthNormalMessage(drawHandler, lifelineHorizontalPadding);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tprotected double getOverallMinWidthSelfMessage(DrawHandler drawHandler, double lifelineHorizontalPadding) {",
                "+\t\tdouble executionSpecWidth = Math.max(from.getLifelineRightPartWidth(sendTick),",
                "+\t\t\t\tto.getLifelineRightPartWidth(sendTick + duration));",
                "+\t\treturn (executionSpecWidth + SELF_MESSAGE_LIFELINE_GAP +",
                "+\t\t\t\tSELF_MESSAGE_TEXT_PADDING + TextSplitter.getTextMinWidth(textLines, drawHandler))",
                "+\t\t* 2.0; // multiplied by 2, because this space is needed on the right half of the lifeline",
                "+\t}",
                "+",
                "+\tprotected double getOverallMinWidthNormalMessage(DrawHandler drawHandler, double lifelineHorizontalPadding) {",
                "+\t\tdouble executionSpecWidth = Math.abs(getSendCenterXOffset()) + Math.abs(getReceiveCenterXOffset());",
                "+\t\tdouble neededWidth = executionSpecWidth + TextSplitter.getTextMinWidth(textLines, drawHandler)",
                "+\t\t\t\t\t\t\t\t+ LIFELINE_TEXT_PADDING * 2;",
                "+\t\tint affectedLifelineCount = getLastLifeline().getIndex() - getFirstLifeline().getIndex() + 1;",
                "+\t\t// increase the needed width because we only calculated the width for the arrow, but we need the overall width",
                "+\t\tif (!to.isCreatedOnStart() && to.getCreated() != null && to.getCreated() == sendTick + duration) {",
                "+\t\t\t// here we must compensate for the 1 1/2 lifelines (half one at the send and a full lifeline at the receive)",
                "+\t\t\treturn (2 * affectedLifelineCount * neededWidth - 3 * (affectedLifelineCount - 1) * lifelineHorizontalPadding)",
                "+\t\t\t\t\t/ (2 * affectedLifelineCount - 3);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\t// here we must compensate for the 2 half lifelines on each end",
                "+\t\t\treturn neededWidth / (affectedLifelineCount - 1) * affectedLifelineCount - lifelineHorizontalPadding;",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Map<Integer, Double> getEveryAdditionalYHeight(DrawHandler drawHandler, HorizontalDrawingInfo hInfo,",
                "+\t\t\tdouble defaultTickHeight) {",
                "+\t\tMap<Integer, Double> ret = new HashMap<Integer, Double>();",
                "+\t\tif (from == to) {",
                "+\t\t\tgetEveryAdditionalYHeightSelfMessage(drawHandler, hInfo, defaultTickHeight, ret);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tgetEveryAdditionalYHeightNormalMessage(drawHandler, hInfo, defaultTickHeight, ret);",
                "+\t\t}",
                "+\t\treturn ret;",
                "+\t}",
                "+",
                "+\tprotected void getEveryAdditionalYHeightNormalMessage(DrawHandler drawHandler, HorizontalDrawingInfo hInfo, double defaultTickHeight, Map<Integer, Double> ret) {",
                "+\t\tdouble maxTextWidth;",
                "+\t\tdouble additionalHeight;",
                "+\t\tmaxTextWidth = Math.abs(getSendX(hInfo) - getReceiveX(hInfo));",
                "+\t\tmaxTextWidth -= LIFELINE_TEXT_PADDING * 2;",
                "+\t\tadditionalHeight = TextSplitter.getSplitStringHeight(textLines, maxTextWidth, drawHandler);",
                "+\t\t// message text is always drawn at the send position only increase send tick height",
                "+\t\t// since the message is always drawn in the V center we only can use one half of the tick height",
                "+\t\tadditionalHeight -= defaultTickHeight / 2.0;",
                "+\t\tadditionalHeight *= 2;",
                "+\t\tif (additionalHeight > 0) {",
                "+\t\t\tret.put(sendTick, additionalHeight);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tprotected void getEveryAdditionalYHeightSelfMessage(DrawHandler drawHandler, HorizontalDrawingInfo hInfo, double defaultTickHeight, Map<Integer, Double> ret) {",
                "+\t\tdouble maxTextWidth;",
                "+\t\tdouble additionalHeight;",
                "+\t\t// if more y space is needed the all covered ticks will be increased",
                "+\t\tdouble executionSpecWidth = Math.max(from.getLifelineRightPartWidth(sendTick),",
                "+\t\t\t\tto.getLifelineRightPartWidth(sendTick + duration));",
                "+\t\tmaxTextWidth = Math.min(hInfo.getHDrawingInfo(to).getSymmetricWidth(sendTick),",
                "+\t\t\t\thInfo.getHDrawingInfo(to).getSymmetricWidth(sendTick + duration)) / 2.0;",
                "+\t\tmaxTextWidth = maxTextWidth - (executionSpecWidth + SELF_MESSAGE_LIFELINE_GAP + SELF_MESSAGE_TEXT_PADDING);",
                "+\t\tadditionalHeight = TextSplitter.getSplitStringHeight(textLines, maxTextWidth, drawHandler)",
                "+\t\t\t\t\t\t\t- duration * defaultTickHeight;",
                "+\t\tif (additionalHeight > 0) {",
                "+\t\t\tfor (int i = sendTick + 1; i < sendTick + duration; i++) {",
                "+\t\t\t\tret.put(i, additionalHeight / duration);",
                "+\t\t\t}",
                "+\t\t\tret.put(sendTick, additionalHeight / duration);",
                "+\t\t\tret.put(sendTick + duration, additionalHeight / duration);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic ContainerPadding getPaddingInformation() {",
                "+\t\treturn null;",
                "+\t}",
                "+",
                "+\tpublic enum ArrowType {",
                "+\t\tOPEN, FILLED",
                "+\t}",
                "+",
                "+\tpublic OccurrenceSpecification sendOccurrenceSpecification() {",
                "+\t\treturn new MessageSendEndpoint();",
                "+\t}",
                "+",
                "+\tpublic OccurrenceSpecification receiveOccurrenceSpecification() {",
                "+\t\treturn new MessageReceiveEndpoint();",
                "+\t}",
                "+",
                "+\tprivate class MessageSendEndpoint implements OccurrenceSpecification {",
                "+",
                "+\t\t@Override",
                "+\t\tpublic boolean hasFixedPosition() {",
                "+\t\t\treturn true;",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic PointDouble getPosition(DrawingInfo drawingInfo, boolean left) {",
                "+\t\t\treturn new PointDouble(0, 0);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic PointDouble getPosition(DrawingInfo drawingInfo) {",
                "+\t\t\treturn new PointDouble(getHorizonatlPosition(drawingInfo), drawingInfo.getVerticalCenter(sendTick));",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic Lifeline getLifeline() {",
                "+\t\t\treturn from;",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getHorizontalPosition(HorizontalDrawingInfo hDrawingInfo, boolean left) {",
                "+\t\t\treturn 0;",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getHorizonatlPosition(HorizontalDrawingInfo hDrawingInfo) {",
                "+\t\t\treturn getSendX(hDrawingInfo);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic AlignHorizontal getFixedPositionAlignment() {",
                "+\t\t\tif (from == to) {",
                "+\t\t\t\treturn AlignHorizontal.RIGHT;",
                "+\t\t\t}",
                "+\t\t\telse if (from.getIndex() < to.getIndex()) {",
                "+\t\t\t\treturn AlignHorizontal.RIGHT;",
                "+\t\t\t}",
                "+\t\t\telse {",
                "+\t\t\t\treturn AlignHorizontal.LEFT;",
                "+\t\t\t}",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tprivate class MessageReceiveEndpoint implements OccurrenceSpecification {",
                "+",
                "+\t\t@Override",
                "+\t\tpublic boolean hasFixedPosition() {",
                "+\t\t\treturn true;",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic PointDouble getPosition(DrawingInfo drawingInfo, boolean left) {",
                "+\t\t\treturn new PointDouble(0, 0);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic PointDouble getPosition(DrawingInfo drawingInfo) {",
                "+\t\t\treturn new PointDouble(getHorizonatlPosition(drawingInfo), drawingInfo.getVerticalCenter(sendTick + duration));",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic Lifeline getLifeline() {",
                "+\t\t\treturn to;",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getHorizontalPosition(HorizontalDrawingInfo hDrawingInfo, boolean left) {",
                "+\t\t\treturn 0;",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic double getHorizonatlPosition(HorizontalDrawingInfo hDrawingInfo) {",
                "+\t\t\treturn getReceiveX(hDrawingInfo);",
                "+\t\t}",
                "+",
                "+\t\t@Override",
                "+\t\tpublic AlignHorizontal getFixedPositionAlignment() {",
                "+\t\t\tif (from == to) {",
                "+\t\t\t\treturn AlignHorizontal.RIGHT;",
                "+\t\t\t}",
                "+\t\t\telse if (from.getIndex() < to.getIndex()) {",
                "+\t\t\t\treturn AlignHorizontal.RIGHT;",
                "+\t\t\t}",
                "+\t\t\telse {",
                "+\t\t\t\treturn AlignHorizontal.LEFT;",
                "+\t\t\t}",
                "+\t\t}",
                "+\t}",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/OccurrenceSpecification.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/OccurrenceSpecification.java",
                "new file mode 100644",
                "index 00000000..ef93ebcb",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/OccurrenceSpecification.java",
                "@@ -0,0 +1,63 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.control.enums.AlignHorizontal;",
                "+",
                "+/**",
                "+ * Is used to refer to a specific point on the lifeline.",
                "+ *",
                "+ * From the UML 2.5 specification: \"OccurrenceSpecifications are merely syntactic points at the ends of Messages",
                "+ * or at the beginning/end of an ExecutionSpecification.\"",
                "+ *",
                "+ * Primarily it is used to implement the GeneralOrdering, but it could also be used for the following elements of the",
                "+ * sequence diagram: DurationConstraint, DurationObservation, TimeConstraint, TimeObservation",
                "+ *",
                "+ * @see GeneralOrdering",
                "+ */",
                "+public interface OccurrenceSpecification {",
                "+",
                "+\t/**",
                "+\t * @return the lifeline on which this object lies",
                "+\t */",
                "+\tLifeline getLifeline();",
                "+",
                "+\t/**",
                "+\t * @return if the horizontal position on the lifeline is fixed (message) or is flexible (execution specification)",
                "+\t */",
                "+\tboolean hasFixedPosition();",
                "+",
                "+\t/**",
                "+\t * If hasFixedPosition() returns false this method can return any value, CENTER would be a reasonable choice.",
                "+\t * @return the relative position on the lifeline",
                "+\t */",
                "+\tAlignHorizontal getFixedPositionAlignment();",
                "+",
                "+\t/**",
                "+\t * @param hDrawingInfo",
                "+\t * @return the x value of the fixed position or the center position.",
                "+\t */",
                "+\tdouble getHorizonatlPosition(HorizontalDrawingInfo hDrawingInfo);",
                "+",
                "+\t/**",
                "+\t * <b>If hasFixedPosition() returns true this may not return valid values!</b>",
                "+\t * @param hDrawingInfo",
                "+\t * @param left if the position on the left or right side of the execution specification should be returned",
                "+\t * @return the x value of the left or right position on the lifeline",
                "+\t */",
                "+\tdouble getHorizontalPosition(HorizontalDrawingInfo hDrawingInfo, boolean left);",
                "+",
                "+\t/**",
                "+\t * @param drawingInfo",
                "+\t * @return the fixed position or the center position.",
                "+\t */",
                "+\tPointDouble getPosition(DrawingInfo drawingInfo);",
                "+",
                "+\t/**",
                "+\t * <b>If hasFixedPosition() returns true this may not return valid values!</b>",
                "+\t * @param drawingInfo",
                "+\t * @param left if the position on the left or right side of the execution specification should be returned",
                "+\t * @return the left or right position on the lifeline",
                "+\t */",
                "+\tPointDouble getPosition(DrawingInfo drawingInfo, boolean left);",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/PentagonDrawingHelper.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/PentagonDrawingHelper.java",
                "new file mode 100644",
                "index 00000000..4bfe7a42",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/PentagonDrawingHelper.java",
                "@@ -0,0 +1,146 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.Collection;",
                "+import java.util.Collections;",
                "+",
                "+import com.baselet.control.basics.Line1D;",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.control.enums.AlignHorizontal;",
                "+import com.baselet.control.enums.AlignVertical;",
                "+import com.baselet.control.enums.LineType;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.diagram.draw.TextSplitter;",
                "+",
                "+/**",
                "+ * Helper class to draw the pentagon with text for the sequence diagram header and the combined fragments.",
                "+ * Only draws the bottom and right border of the pentagon since the top and left border should be covered by",
                "+ * the surrounding rectangle.",
                "+ *",
                "+ */",
                "+public class PentagonDrawingHelper {",
                "+",
                "+\tprivate static final double HEADER_PENTAGON_SLOPE_WIDTH = 20;",
                "+\t/** how much from the overal header height is used for the slope */",
                "+\tprivate static final double HEADER_PENTAGON_SLOPE_HEIGHT_PERCENTAGE = 0.4;",
                "+\t/** minimum distance between the pentagon and the right border */",
                "+\tprivate static final double HEADER_MIN_RIGHT_BORDER_GAP = 40;",
                "+\tprivate static final double HEADER_TEXT_X_PADDING = 5;",
                "+\tprivate static final double HEADER_TEXT_Y_PADDING = 3;",
                "+",
                "+\t/**",
                "+\t * @return how much space must be added to the text width.",
                "+\t */",
                "+\tprivate static double getStaticWidthPadding() {",
                "+\t\treturn HEADER_TEXT_X_PADDING * 2",
                "+\t\t\t\t+ HEADER_PENTAGON_SLOPE_WIDTH",
                "+\t\t\t\t+ HEADER_MIN_RIGHT_BORDER_GAP;",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * @return how much space must be added to the text width.",
                "+\t */",
                "+\tprivate static double getStaticHeightPadding() {",
                "+\t\treturn HEADER_TEXT_Y_PADDING * 2;",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * Returns the minimum width of the whole element (i.e. adding the padding and other spaces to the text width)",
                "+\t * @param drawHandler",
                "+\t * @param textLines",
                "+\t * @return the minimum width of the whole element, i.e. the minimum width of the diagram or combined fragment",
                "+\t */",
                "+\tpublic static double getMinimumWidth(DrawHandler drawHandler, String[] textLines) {",
                "+\t\treturn TextSplitter.getTextMinWidth(textLines, drawHandler)",
                "+\t\t\t\t+ getStaticWidthPadding();",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * Returns the minimum width of the whole pentagon (i.e. adding the padding and other spaces to the text width but not the border gap)",
                "+\t * @param drawHandler",
                "+\t * @param textLines",
                "+\t * @return the minimum width of the whole element, i.e. the minimum width of the diagram or combined fragment",
                "+\t */",
                "+\tpublic static double getPentagonMinimumWidth(DrawHandler drawHandler, String[] textLines) {",
                "+\t\treturn TextSplitter.getTextMinWidth(textLines, drawHandler)",
                "+\t\t\t\t+ getStaticWidthPadding() - HEADER_MIN_RIGHT_BORDER_GAP;",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * Returns the height of the pentagon (text height + padding).",
                "+\t * @param drawHandler",
                "+\t * @param textLines",
                "+\t * @param width the minimum width of the whole element, i.e. the minimum width of the diagram or combined fragment",
                "+\t * @return the minimum height of the whole header/pentagon",
                "+\t */",
                "+\tpublic static double getHeight(DrawHandler drawHandler, String[] textLines, double width) {",
                "+\t\treturn TextSplitter.getSplitStringHeight(textLines, width - getStaticWidthPadding(), drawHandler) + getStaticHeightPadding();",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * Draws the text, bottom and right border of the pentagon and returning the used height.",
                "+\t * @param drawHandler",
                "+\t * @param textLines",
                "+\t * @param width the minimum width of the whole element, i.e. the minimum width of the diagram or combined fragment",
                "+\t * @param topLeft",
                "+\t * @return the size (width,height) which was needed to draw the header",
                "+\t */",
                "+\tpublic static PointDouble draw(DrawHandler drawHandler, String[] textLines, double width, PointDouble topLeft) {",
                "+\t\treturn draw(drawHandler, textLines, width, topLeft, Collections.<Line1D> emptyList());",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * Draws the text, bottom and right border of the pentagon and returning the used height.",
                "+\t * @param drawHandler",
                "+\t * @param textLines",
                "+\t * @param width the minimum width of the whole element, i.e. the minimum width of the diagram or combined fragment",
                "+\t * @param topLeft",
                "+\t * @param slopeNotPermittedAreas X-Intervals on which the slope can not be drawn in absolute values,",
                "+\t * i.e. the slope starts at the end of an interval if it would reach into one",
                "+\t * @return the size (width,height) which was needed to draw the header",
                "+\t */",
                "+\tpublic static PointDouble draw(DrawHandler drawHandler, String[] textLines, double width, PointDouble topLeft,",
                "+\t\t\tCollection<Line1D> slopeNotPermittedAreas) {",
                "+\t\tboolean splitIsNecessary = false;",
                "+\t\tdouble textWidth = width - getStaticWidthPadding();",
                "+\t\tfor (String l : textLines) {",
                "+\t\t\tif (TextSplitter.splitStringAlgorithm(l, textWidth, drawHandler).length > 1) {",
                "+\t\t\t\tsplitIsNecessary = true;",
                "+\t\t\t\tbreak;",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tdouble height = getHeight(drawHandler, textLines, width); //",
                "+\t\t// if no split is needed we can reduce the width of the title to the width of the largest line",
                "+\t\tif (!splitIsNecessary) {",
                "+\t\t\ttextWidth = 0;",
                "+\t\t\tfor (String l : textLines) {",
                "+\t\t\t\ttextWidth = Math.max(textWidth, drawHandler.textWidth(l));",
                "+\t\t\t}",
                "+\t\t\ttextWidth += drawHandler.textWidth(\"n\");",
                "+\t\t}",
                "+\t\tTextSplitter.drawText(drawHandler, textLines, topLeft.x + HEADER_TEXT_X_PADDING, topLeft.y, textWidth,",
                "+\t\t\t\theight, AlignHorizontal.LEFT, AlignVertical.CENTER);",
                "+\t\tLineType oldLt = drawHandler.getLineType();",
                "+\t\tdrawHandler.setLineType(LineType.SOLID);",
                "+\t\tdouble slopeStartX = topLeft.x + textWidth + HEADER_TEXT_X_PADDING * 2;",
                "+\t\tdouble slopeEndX = slopeStartX + HEADER_PENTAGON_SLOPE_WIDTH;",
                "+\t\t// based on the slope widht and the Lifeline gaps and the fact that the execution specification",
                "+\t\t// is very small on the left side it should be enough to jump once",
                "+\t\tfor (Line1D line : slopeNotPermittedAreas) {",
                "+\t\t\tif (line.getLow() > slopeEndX) {",
                "+\t\t\t\tbreak;",
                "+\t\t\t}",
                "+\t\t\telse if (line.isIntersecting(new Line1D(slopeStartX, slopeEndX))) {",
                "+\t\t\t\tslopeStartX = line.getHigh();",
                "+\t\t\t\tslopeEndX = slopeStartX + HEADER_PENTAGON_SLOPE_WIDTH;",
                "+\t\t\t\tbreak;",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tdrawHandler.drawLines(new PointDouble[] {",
                "+\t\t\t\tnew PointDouble(topLeft.x, topLeft.y + height),",
                "+\t\t\t\tnew PointDouble(slopeStartX, topLeft.y + height),",
                "+\t\t\t\tnew PointDouble(slopeEndX, topLeft.y + height * (1 - HEADER_PENTAGON_SLOPE_HEIGHT_PERCENTAGE)),",
                "+\t\t\t\tnew PointDouble(slopeEndX, topLeft.y) });",
                "+\t\tdrawHandler.setLineType(oldLt);",
                "+\t\treturn new PointDouble(slopeEndX - topLeft.x, height);",
                "+\t}",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceAllInOneFacet.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceAllInOneFacet.java",
                "new file mode 100644",
                "index 00000000..f42f59fc",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceAllInOneFacet.java",
                "@@ -0,0 +1,94 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.Arrays;",
                "+import java.util.List;",
                "+",
                "+import com.baselet.control.SharedUtils;",
                "+import com.baselet.control.basics.geom.DimensionDouble;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.element.facet.Facet;",
                "+import com.baselet.element.facet.PropertiesParserState;",
                "+import com.baselet.element.sequence_aio.facet.SequenceDiagram.DoubleConverter;",
                "+import com.baselet.element.sequence_aio.facet.specific.gen.ParseException;",
                "+import com.baselet.element.sequence_aio.facet.specific.gen.SequenceAllInOneParser;",
                "+import com.baselet.element.sequence_aio.facet.specific.gen.TokenMgrException;",
                "+import com.baselet.gui.AutocompletionText;",
                "+",
                "+public class SequenceAllInOneFacet extends Facet {",
                "+",
                "+\tpublic static final SequenceAllInOneFacet INSTANCE = new SequenceAllInOneFacet();",
                "+",
                "+\tprivate SequenceAllInOneFacet() {}",
                "+",
                "+\t@Override",
                "+\tpublic boolean checkStart(String line, PropertiesParserState state) {",
                "+\t\t// consume every line that wasn't handled by another facet",
                "+\t\treturn true;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic List<AutocompletionText> getAutocompletionStrings() {",
                "+\t\treturn Arrays.asList(new AutocompletionText[] {",
                "+\t\t\t\tnew AutocompletionText(\"title=\", \"Title of the sequence diagram\"),",
                "+\t\t\t\tnew AutocompletionText(\"desc=\", \"Additional text, e.g. for local variables\"),",
                "+\t\t\t\tnew AutocompletionText(\"autoTick=true\", \"(Default) Each line with an command is placed at a new time tick.\"),",
                "+\t\t\t\tnew AutocompletionText(\"autoTick=false\", \"Advancements down the time have to specified manually with the tick= command.\"),",
                "+\t\t\t\tnew AutocompletionText(\"overrideIds=true\", \"Each lifeline needs a explicit id.\"),",
                "+\t\t\t\tnew AutocompletionText(\"overrideIds=false\", \"(Default) each lifeline has a default id idX. X is a number starting at 1 and is increased from left to right.\"),",
                "+\t\t\t\tnew AutocompletionText(\"obj=New lifeline~\", \"Declares a new Lifeline\"),",
                "+",
                "+\t\t\t\tnew AutocompletionText(\"tick=\", \"Advances down the timeline\"),",
                "+\t\t\t\tnew AutocompletionText(\"on=\", \"Starts a new execution specification on the given lifelines.\"),",
                "+\t\t\t\tnew AutocompletionText(\"off=\", \"Ends a existing execution specification on the given lifelines.\"),",
                "+\t\t\t\tnew AutocompletionText(\"ref=\", \"\"),",
                "+\t\t\t\tnew AutocompletionText(\"continuation=\", \"\"),",
                "+\t\t\t\tnew AutocompletionText(\"invariant=\", \"\"),",
                "+\t\t\t\tnew AutocompletionText(\"stateInvariant=\", \"\"),",
                "+\t\t\t\tnew AutocompletionText(\"coregionStart=\", \"\"),",
                "+\t\t\t\tnew AutocompletionText(\"coregionEnd=\", \"\"),",
                "+\t\t\t\tnew AutocompletionText(\"combinedFragment=\", \"\"),",
                "+\t\t\t\tnew AutocompletionText(\"constraint=\", \"Specifies a constrain for an operand.\"),",
                "+\t\t\t\tnew AutocompletionText(\"destroy=\", \"Destroys a lifeline\"),",
                "+",
                "+\t\t\t\tnew AutocompletionText(\"lost\", \"Pseudo id for lost messages.\"),",
                "+\t\t\t\tnew AutocompletionText(\"found\", \"Pseudo id for found messages.\"),",
                "+\t\t\t\tnew AutocompletionText(\"gate\", \"Pseudo id for gate messages.\"),",
                "+",
                "+\t\t\t\tnew AutocompletionText(\"ACTIVE\", \"Creates an active class as head for the lifeline.\"),",
                "+\t\t\t\tnew AutocompletionText(\"ACTOR\", \"The Lifeline head is an actor.\"),",
                "+\t\t\t\tnew AutocompletionText(\"CREATED_LATER\", \"The lifeline is created later with the first received message.\"),",
                "+\t\t\t\tnew AutocompletionText(\"EXECUTION\", \"The Lifeline has an active execution specification at the start.\")",
                "+\t\t});",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic void handleLine(String line, PropertiesParserState state) {",
                "+\t\t// everything is done in parsingFinished",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic void parsingFinished(PropertiesParserState state, List<String> handledLines) {",
                "+\t\tfinal DrawHandler drawer = state.getDrawer();",
                "+\t\t// pass the whole text to the parser",
                "+\t\tStringBuilder strBuilder = new StringBuilder();",
                "+\t\tfor (String str : handledLines) {",
                "+\t\t\tstrBuilder.append(str);",
                "+\t\t\tstrBuilder.append('\\n');",
                "+\t\t}",
                "+\t\ttry {",
                "+\t\t\tDoubleConverter gridConverter = new DoubleConverter() {",
                "+\t\t\t\t@Override",
                "+\t\t\t\tpublic double convert(double value) {",
                "+\t\t\t\t\treturn SharedUtils.realignToGrid(false, value, true);",
                "+\t\t\t\t}",
                "+\t\t\t};",
                "+\t\t\tDimensionDouble size = new SequenceAllInOneParser(strBuilder.toString()).start().generateDiagram()",
                "+\t\t\t\t\t.draw(drawer, gridConverter, gridConverter);",
                "+\t\t\tstate.updateMinimumSize(size.getWidth(), size.getHeight());",
                "+\t\t} catch (ParseException e) {",
                "+\t\t\tthrow new SequenceDiagramException(e);",
                "+\t\t} catch (TokenMgrException e) {",
                "+\t\t\tthrow new SequenceDiagramException(e);",
                "+\t\t}",
                "+\t}",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagram.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagram.java",
                "new file mode 100644",
                "index 00000000..f9333f8c",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagram.java",
                "@@ -0,0 +1,222 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.Arrays;",
                "+import java.util.Collection;",
                "+import java.util.LinkedList;",
                "+import java.util.List;",
                "+import java.util.Map;",
                "+",
                "+import com.baselet.control.basics.geom.DimensionDouble;",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.control.enums.AlignHorizontal;",
                "+import com.baselet.control.enums.AlignVertical;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.diagram.draw.TextSplitter;",
                "+import com.baselet.element.sequence_aio.facet.LifelineSpanningTickSpanningOccurrence.ContainerPadding;",
                "+",
                "+public class SequenceDiagram {",
                "+",
                "+\tprivate static final double LIFELINE_X_PADDING = 40;",
                "+\tprivate static final double LIFELINE_Y_PADDING = 20;",
                "+\tprivate static final double LIFELINE_MIN_WIDTH = 100;",
                "+\tprivate static final double DESCRIPTION_V_PADDING = 10;",
                "+\tprivate static final double DESCRIPTION_H_PADDING = 10;",
                "+",
                "+\tprivate static final double TICK_HEIGHT = 20;",
                "+\tprivate static final double TICK_Y_PADDING = 6;// should be odd and the nothing should draw at the center!",
                "+",
                "+\tprivate String[] titleLines;",
                "+\tprivate String[] descLines;",
                "+",
                "+\t// options",
                "+\tprivate Lifeline[] lifelines;",
                "+",
                "+\tprivate final Collection<LifelineSpanningTickSpanningOccurrence> spanningLifelineOccurrences;",
                "+",
                "+\tprivate int lastTick;",
                "+",
                "+\tpublic SequenceDiagram() {",
                "+\t\ttitleLines = new String[] { \"\" };",
                "+\t\tdescLines = new String[] { \"\" };",
                "+\t\tlifelines = new Lifeline[0];",
                "+\t\tspanningLifelineOccurrences = new LinkedList<LifelineSpanningTickSpanningOccurrence>();",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * @param title lines which are separated by a \\n",
                "+\t */",
                "+\tpublic void setTitle(String title) {",
                "+\t\ttitleLines = title.split(\"\\n\");",
                "+\t}",
                "+",
                "+\t// /**",
                "+\t// * @param titleLines an array of lines which build the title (each element must not contain a \\n)",
                "+\t// */",
                "+\t// public void setTitle(String[] titleLines) {",
                "+\t// this.titleLines = titleLines;",
                "+\t// }",
                "+",
                "+\t/**",
                "+\t * @param text description lines which are separated by a \\n",
                "+\t */",
                "+\tpublic void setText(String text) {",
                "+\t\tdescLines = text.split(\"\\n\");",
                "+\t}",
                "+",
                "+\t// /**",
                "+\t// * @param textLines an array of lines which build the description (each element must not contain a \\n)",
                "+\t// */",
                "+\t// public void setText(String[] textLines) {",
                "+\t// descLines = textLines;",
                "+\t// }",
                "+",
                "+\tpublic int getLastTick() {",
                "+\t\treturn lastTick;",
                "+\t}",
                "+",
                "+\tpublic void setLastTick(int lastTick) {",
                "+\t\tthis.lastTick = lastTick;",
                "+\t}",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @param headText",
                "+\t * @param headType",
                "+\t * @param createdOnStart if false the lifeline will be created by the first message sent to this lifeline",
                "+\t * @param execSpecFromStart",
                "+\t */",
                "+\tpublic Lifeline addLiveline(String headText, Lifeline.LifelineHeadType headType, boolean createdOnStart, boolean execSpecFromStart) {",
                "+\t\tlifelines = Arrays.copyOf(lifelines, lifelines.length + 1);",
                "+\t\tlifelines[lifelines.length - 1] = new Lifeline(headText, lifelines.length - 1, headType, createdOnStart, execSpecFromStart);",
                "+\t\treturn lifelines[lifelines.length - 1];",
                "+\t}",
                "+",
                "+\tpublic void addLifelineSpanningTickSpanningOccurrence(LifelineSpanningTickSpanningOccurrence occurrence) {",
                "+\t\tspanningLifelineOccurrences.add(occurrence);",
                "+\t}",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @return how many lifelines the diagram has",
                "+\t */",
                "+\tpublic int getLifelineCount() {",
                "+\t\treturn lifelines.length;",
                "+\t}",
                "+",
                "+\tpublic List<Lifeline> getLifelines() {",
                "+\t\treturn Arrays.asList(lifelines);",
                "+\t}",
                "+",
                "+\tpublic Lifeline[] getLifelinesArray() {",
                "+\t\treturn Arrays.copyOf(lifelines, lifelines.length);",
                "+\t}",
                "+",
                "+\tpublic DimensionDouble draw(DrawHandler drawHandler) {",
                "+\t\tDoubleConverter identity = new DoubleConverter() {",
                "+\t\t\t@Override",
                "+\t\t\tpublic double convert(double value) {",
                "+\t\t\t\treturn value;",
                "+\t\t\t}",
                "+\t\t};",
                "+\t\treturn draw(drawHandler, identity, identity);",
                "+\t}",
                "+",
                "+\tpublic DimensionDouble draw(DrawHandler drawHandler, DoubleConverter widthConverter, DoubleConverter heightConverter) {",
                "+\t\tHorizontalDrawingInfo horizontalDrawingInfo;",
                "+\t\tVerticalDrawingInfo verticalInfo;",
                "+\t\tDrawingInfo drawingInfo;",
                "+\t\t// calculate the minimum width of the lifelines and the diagram; get all paddings and create the horizontal drawing info",
                "+\t\tdouble lifelineWidth = Math.max(getLifelineWidth(drawHandler), LIFELINE_MIN_WIDTH);",
                "+\t\tdouble diagramMinWidth = Math.max(LIFELINE_MIN_WIDTH,",
                "+\t\t\t\tTextSplitter.getTextMinWidth(descLines, drawHandler) + DESCRIPTION_H_PADDING * 2);",
                "+\t\tdiagramMinWidth = Math.max(diagramMinWidth, PentagonDrawingHelper.getMinimumWidth(drawHandler, titleLines));",
                "+\t\tCollection<ContainerPadding> allPaddings = new LinkedList<ContainerPadding>();",
                "+\t\tfor (LifelineSpanningTickSpanningOccurrence lstso : spanningLifelineOccurrences) {",
                "+\t\t\tif (lstso.getPaddingInformation() != null) {",
                "+\t\t\t\tallPaddings.add(lstso.getPaddingInformation());",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\thorizontalDrawingInfo = new HorizontalDrawingInfoImpl(0, diagramMinWidth, widthConverter, lifelineWidth,",
                "+\t\t\t\tLIFELINE_X_PADDING, lifelines.length, lastTick, allPaddings);",
                "+\t\tdouble diagramWidth = horizontalDrawingInfo.getDiagramWidth();",
                "+",
                "+\t\t// calculate and draw the header, then draw top border",
                "+\t\tdouble headerHeight = 0;",
                "+\t\tif (titleLines.length > 1 || titleLines.length == 1 && !titleLines[0].isEmpty()) {",
                "+\t\t\theaderHeight = PentagonDrawingHelper.draw(drawHandler, titleLines, diagramWidth, new PointDouble(0, 0)).y;",
                "+\t\t}",
                "+\t\tdrawHandler.drawLine(0, 0, diagramWidth, 0);",
                "+",
                "+\t\t// draw description",
                "+\t\tdouble descHeight = TextSplitter.getSplitStringHeight(descLines, diagramWidth - DESCRIPTION_H_PADDING * 2, drawHandler);",
                "+\t\tTextSplitter.drawText(drawHandler, descLines, DESCRIPTION_H_PADDING, headerHeight + DESCRIPTION_V_PADDING,",
                "+\t\t\t\tdiagramWidth - DESCRIPTION_H_PADDING * 2, descHeight, AlignHorizontal.LEFT, AlignVertical.CENTER);",
                "+",
                "+\t\tdouble lifelineHeadTop = headerHeight + descHeight + DESCRIPTION_H_PADDING * 2 + LIFELINE_Y_PADDING;",
                "+\t\tdouble lifelineHeadHeight = getLifelineHeadHeight(drawHandler, horizontalDrawingInfo);",
                "+\t\tverticalInfo = new VerticalDrawingInfoImpl(lifelineHeadTop, lifelineHeadHeight, TICK_HEIGHT, TICK_Y_PADDING,",
                "+\t\t\t\tcalculateAddiontalHeights(drawHandler, horizontalDrawingInfo), allPaddings);",
                "+\t\tdrawingInfo = new DrawingInfoImpl(horizontalDrawingInfo, verticalInfo, getLifelineCount());",
                "+",
                "+\t\t// first draw the occurrences which affect more than one lifeline which stores the interrupted areas in the",
                "+\t\t// corresponding LifelineDrawingInfo. This info is then passed to the lifeline so it can be drawn",
                "+\t\tif (lifelines.length > 0) {",
                "+\t\t\tfor (LifelineSpanningTickSpanningOccurrence llstso : spanningLifelineOccurrences) {",
                "+\t\t\t\tllstso.draw(drawHandler, drawingInfo);",
                "+\t\t\t}",
                "+\t\t\tfor (Lifeline ll : lifelines) {",
                "+\t\t\t\tll.draw(drawHandler, drawingInfo.getDrawingInfo(ll), lastTick);",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\t// draw left,right and bottom border",
                "+\t\tdouble bottomY = heightConverter.convert(verticalInfo.getVerticalEnd(lastTick) + LIFELINE_Y_PADDING);",
                "+\t\tdrawHandler.drawLine(0, bottomY, diagramWidth, bottomY);",
                "+\t\tdrawHandler.drawLine(0, 0, 0, bottomY);",
                "+\t\tdrawHandler.drawLine(diagramWidth, 0, diagramWidth, bottomY);",
                "+\t\treturn new DimensionDouble(diagramWidth, bottomY);",
                "+\t}",
                "+",
                "+\tprivate double getLifelineWidth(DrawHandler drawHandler) {",
                "+\t\tdouble maxMinWidth = 0;",
                "+\t\tfor (Lifeline ll : lifelines) {",
                "+\t\t\tmaxMinWidth = Math.max(maxMinWidth, ll.getMinWidth(drawHandler));",
                "+\t\t}",
                "+\t\tfor (LifelineSpanningTickSpanningOccurrence llstso : spanningLifelineOccurrences) {",
                "+\t\t\tint llCount = llstso.getLastLifeline().getIndex() - llstso.getFirstLifeline().getIndex() + 1;",
                "+\t\t\tmaxMinWidth = Math.max(maxMinWidth,",
                "+\t\t\t\t\t(llstso.getOverallMinWidth(drawHandler, LIFELINE_X_PADDING) - LIFELINE_X_PADDING * (llCount - 1)) / llCount);",
                "+\t\t}",
                "+\t\treturn maxMinWidth;",
                "+\t}",
                "+",
                "+\tprivate double[] calculateAddiontalHeights(DrawHandler drawHandler, HorizontalDrawingInfo hDrawingInfo) {",
                "+\t\tdouble[] addiontalHeight = new double[lastTick + 1];",
                "+\t\tfor (Lifeline ll : lifelines) {",
                "+\t\t\tfor (Map.Entry<Integer, Double> e : ll.getAdditionalYHeights(drawHandler, hDrawingInfo.getHDrawingInfo(ll),",
                "+\t\t\t\t\tTICK_HEIGHT).entrySet()) {",
                "+\t\t\t\taddiontalHeight[e.getKey()] = Math.max(addiontalHeight[e.getKey()], e.getValue());",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tfor (LifelineSpanningTickSpanningOccurrence llstso : spanningLifelineOccurrences) {",
                "+\t\t\tfor (Map.Entry<Integer, Double> e : llstso.getEveryAdditionalYHeight(drawHandler, hDrawingInfo,",
                "+\t\t\t\t\tTICK_HEIGHT).entrySet()) {",
                "+\t\t\t\taddiontalHeight[e.getKey()] = Math.max(addiontalHeight[e.getKey()], e.getValue());",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\treturn addiontalHeight;",
                "+\t}",
                "+",
                "+\tprivate double getLifelineHeadHeight(DrawHandler drawHandler, HorizontalDrawingInfo hDrawingInfo) {",
                "+\t\tdouble maxHeight = 0;",
                "+\t\tfor (Lifeline ll : lifelines) {",
                "+\t\t\tif (ll.isCreatedOnStart()) {",
                "+\t\t\t\tmaxHeight = Math.max(maxHeight, ll.getHeadMinHeight(drawHandler, hDrawingInfo.getHDrawingInfo(ll).getWidth()));",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\treturn maxHeight;",
                "+\t}",
                "+",
                "+\tpublic static interface DoubleConverter {",
                "+\t\tpublic double convert(double value);",
                "+\t}",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagramBuilder.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagramBuilder.java",
                "new file mode 100644",
                "index 00000000..800b2cc4",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagramBuilder.java",
                "@@ -0,0 +1,685 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.Arrays;",
                "+import java.util.HashMap;",
                "+import java.util.LinkedList;",
                "+import java.util.List;",
                "+import java.util.ListIterator;",
                "+import java.util.Map;",
                "+",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "+",
                "+import com.baselet.control.enums.LineType;",
                "+import com.baselet.element.sequence_aio.facet.StateInvariant.StateInvariantStyle;",
                "+",
                "+/**",
                "+ * Constructs a sequence diagram.",
                "+ * No modifications are allowed after the diagram was returned.",
                "+ * Events which affect a lifeline must be added after the affected lifelines.",
                "+ *",
                "+ */",
                "+public class SequenceDiagramBuilder {",
                "+",
                "+\tprivate static final Logger log = LoggerFactory.getLogger(SequenceDiagramBuilder.class);",
                "+",
                "+\tprivate final String DEFAULT_ID_PREFIX = \"id\";",
                "+\tprivate final SequenceDiagram dia;",
                "+\tprivate final Map<Lifeline, LifelineState> currentLifelineState;",
                "+",
                "+\t/** if true no default ids are generated and every lifeline needs an id */",
                "+\tprivate boolean overrideDefaultIds;",
                "+",
                "+\tprivate final Map<String, Lifeline> ids;",
                "+\tprivate final LinkedList<ActiveCombinedFragment> activeCombinedFragmentStack;",
                "+\t/** ids on a lifeline for occurrenceSpecifications (message endpoint or execution specification start/end) */",
                "+\tprivate final Map<Lifeline, Map<String, OccurrenceSpecification>> lifelineLocalIds;",
                "+\t/** stores all warnings which are found while the sequence diagram is built */",
                "+\tprivate final List<String> warnings;",
                "+",
                "+\tprivate int currentTick;",
                "+\tprivate int lastMessageReceiveTick;",
                "+\tprivate boolean diagramRetrieved;",
                "+",
                "+\tpublic SequenceDiagramBuilder() {",
                "+\t\toverrideDefaultIds = false;",
                "+\t\tids = new HashMap<String, Lifeline>();",
                "+\t\tactiveCombinedFragmentStack = new LinkedList<SequenceDiagramBuilder.ActiveCombinedFragment>();",
                "+\t\tlifelineLocalIds = new HashMap<Lifeline, Map<String, OccurrenceSpecification>>();",
                "+\t\tdia = new SequenceDiagram();",
                "+\t\tcurrentLifelineState = new HashMap<Lifeline, SequenceDiagramBuilder.LifelineState>();",
                "+\t\twarnings = new LinkedList<String>();",
                "+\t\tcurrentTick = 0;",
                "+\t\tlastMessageReceiveTick = 0;",
                "+\t\tdiagramRetrieved = false;",
                "+\t}",
                "+",
                "+\tpublic void setTitle(String title) {",
                "+\t\tcheckState();",
                "+\t\tdia.setTitle(title);",
                "+\t}",
                "+",
                "+\tpublic void setText(String text) {",
                "+\t\tcheckState();",
                "+\t\tdia.setText(text);",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * @param id of the lifeline which should be returned",
                "+\t * @return the lifeline or null if no lifeline is associated with the given id",
                "+\t */",
                "+\tpublic Lifeline getLifeline(String id) {",
                "+\t\treturn ids.get(id);",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * @param id of the lifeline which should be returned",
                "+\t * @return the lifeline",
                "+\t * @throws SequenceDiagramException if no lifeline is associated with the given id",
                "+\t */",
                "+\tLifeline getLifelineException(String id) {",
                "+\t\tif (!ids.containsKey(id)) {",
                "+\t\t\tthrow new SequenceDiagramException(\"No lifeline is associated with the id: '\" + id + \"'\");",
                "+\t\t}",
                "+\t\treturn ids.get(id);",
                "+\t}",
                "+",
                "+\tpublic Lifeline[] getLifelineInterval(String id1, String id2) {",
                "+\t\ttry {",
                "+\t\t\treturn getLifelineIntervalException(id1, id2);",
                "+\t\t} catch (SequenceDiagramException e) {",
                "+\t\t\treturn new Lifeline[0];",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tpublic Lifeline[] getLifelineIntervalException(String id1, String id2) {",
                "+\t\tLifeline ll1 = getLifelineException(id1);",
                "+\t\tLifeline ll2 = getLifelineException(id2);",
                "+\t\tif (ll1.getIndex() > ll2.getIndex()) {",
                "+\t\t\tLifeline tmp = ll1;",
                "+\t\t\tll1 = ll2;",
                "+\t\t\tll2 = tmp;",
                "+\t\t}",
                "+\t\treturn Arrays.copyOfRange(dia.getLifelinesArray(), ll1.getIndex(), ll2.getIndex() + 1);",
                "+\t}",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @param headText the text which is drawn in the head",
                "+\t * @param id can be NULL, if none of reorder and idoverride option is active",
                "+\t * @param headType the lifeline style",
                "+\t * @param createdOnStart if false the lifeline will be created by the first message sent to this lifeline",
                "+\t */",
                "+\tpublic void addLiveline(String headText, String id, Lifeline.LifelineHeadType headType, boolean createdOnStart,",
                "+\t\t\tboolean execSpecFromStart) {",
                "+\t\tcheckState();",
                "+",
                "+\t\tif (isOverrideDefaultIds() && id == null) {",
                "+\t\t\tthrow new SequenceDiagramException(\"If the override option is set to true then every lifeline needs an id!\");",
                "+\t\t}",
                "+\t\tLifeline newLifeline = dia.addLiveline(headText, headType, createdOnStart, execSpecFromStart);",
                "+\t\tif (id != null) {",
                "+\t\t\tif (ids.containsKey(id)) {",
                "+\t\t\t\tthrow new SequenceDiagramException(\"There is already a lifeline which is associated with the id '\" +id +",
                "+\t\t\t\t\t\t\t\t\t\t\t\t\t\"', please choose another identifier.\");",
                "+\t\t\t}",
                "+\t\t\tids.put(id, newLifeline);",
                "+\t\t}",
                "+\t\tif (!overrideDefaultIds) {",
                "+\t\t\tif (ids.containsKey(DEFAULT_ID_PREFIX + dia.getLifelineCount())) {",
                "+\t\t\t\tthrow new SequenceDiagramException(\"There is already a lifeline which is associated with the default id '\" +",
                "+\t\t\t\t\t\t\t\t\t\t\t\t\tDEFAULT_ID_PREFIX + dia.getLifelineCount() +",
                "+\t\t\t\t\t\t\t\t\t\t\t\t\t\"',\\nplease choose another identifier or add the option 'overrideIds=true'.\");",
                "+\t\t\t}",
                "+\t\t\tids.put(DEFAULT_ID_PREFIX + dia.getLifelineCount(), newLifeline);",
                "+\t\t}",
                "+\t\tlifelineLocalIds.put(newLifeline, new HashMap<String, OccurrenceSpecification>());",
                "+\t\tLifelineState newLifelineState = new LifelineState();",
                "+\t\tif (execSpecFromStart && createdOnStart) {",
                "+\t\t\tnewLifelineState.execSpecStartTickStack.addFirst(-1);",
                "+\t\t}",
                "+\t\tcurrentLifelineState.put(newLifeline, newLifelineState);",
                "+\t}",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @param id of the lifeline",
                "+\t * @param event e.g. message, invariant, activity",
                "+\t */",
                "+\tprivate void addLifelineOccurrence(String id, LifelineOccurrence occurrence) {",
                "+\t\tcheckState();",
                "+\t\ttry {",
                "+\t\t\tgetLifelineException(id).addLifelineOccurrenceAtTick(occurrence, currentTick);",
                "+\t\t} catch (SequenceDiagramCheckedException ex) {",
                "+\t\t\tthrow new SequenceDiagramException(\"Error on lifeline '\" + id + \"': \" + ex.getMessage(), ex);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tpublic void addTextOnLifeline(String lifelineId, String text) {",
                "+\t\taddLifelineOccurrence(lifelineId, new TextOnLifeline(text));",
                "+\t}",
                "+",
                "+\tpublic void addStateInvariant(String lifelineId, String text, boolean drawAsState) {",
                "+\t\taddLifelineOccurrence(lifelineId, new StateInvariant(text,",
                "+\t\t\t\tdrawAsState ? StateInvariantStyle.STATE : StateInvariantStyle.CURLY_BRACKETS));",
                "+\t}",
                "+",
                "+\tpublic void addCoregion(String id, boolean start) {",
                "+\t\tcheckState();",
                "+\t\t// check that every coregion should be closed and coregion should not overlap, but only add a warning and trust the user",
                "+\t\tLifeline lifeline = getLifelineException(id);",
                "+\t\tLifelineState lifelineState = currentLifelineState.get(lifeline);",
                "+\t\tif (lifelineState.coregionActive && start) {",
                "+\t\t\taddWarning(id, \"A new coregion was started while an old one was still active.\");",
                "+\t\t}",
                "+\t\telse if (!lifelineState.coregionActive && !start) {",
                "+\t\t\taddWarning(id, \"A coregion was closed, but no coregion was active.\");",
                "+\t\t}",
                "+\t\ttry {",
                "+\t\t\tlifeline.addLifelineOccurrenceAtTick(new Coregion(lifeline, currentTick, start), currentTick);",
                "+\t\t\tlifelineState.coregionActive = start;",
                "+\t\t} catch (SequenceDiagramCheckedException ex) {",
                "+\t\t\tthrow new SequenceDiagramException(\"Error on lifeline '\" + id + \"': \" + ex.getMessage(), ex);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tpublic void destroyLifeline(String id) {",
                "+\t\tcheckState();",
                "+\t\t// check that every coregion should be closed and coregion should not overlap, but only add a warning and trust the user",
                "+\t\tLifeline lifeline = getLifelineException(id);",
                "+\t\tif (lifeline.getDestroyed() != null) {",
                "+\t\t\taddWarning(id, \"The lifeline was already destroyed.\");",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tlifeline.setDestroyed(currentTick);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tpublic void changeExecutionSpecification(String lifelineId, boolean on) {",
                "+\t\tcheckState();",
                "+\t\t// check that they don't collide i.e. 2 changes at the same tick",
                "+\t\tLifeline lifeline = getLifelineException(lifelineId);",
                "+\t\tLifelineState lifelineState = currentLifelineState.get(lifeline);",
                "+\t\tif (on) {",
                "+\t\t\tif (lifelineState.execSpecStartTickStack.size() > 0 && lifelineState.execSpecStartTickStack.peek() == currentTick) {",
                "+\t\t\t\tthrow new SequenceDiagramException(\"On lifeline \" + lifelineId + \" two executionspecifications start at the same tick, this is not possible.\");",
                "+\t\t\t}",
                "+\t\t\tif (lifelineState.lastEndOfExecSpec == currentTick) {",
                "+\t\t\t\tthrow new SequenceDiagramException(\"On lifeline \" + lifelineId + \" two executionspecifications overlap, this is not possible.\");",
                "+\t\t\t}",
                "+\t\t\tif (!lifeline.isCreatedOnStart() && (lifeline.getCreated() == null || lifeline.getCreated() >= currentTick)) {",
                "+\t\t\t\tthrow new SequenceDiagramException(\"Error on lifeline '\" + lifelineId + \"': the lifeline can not contain executionspecifications before it is created.\");",
                "+\t\t\t}",
                "+\t\t\tlifelineState.execSpecStartTickStack.addFirst(currentTick);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tif (lifelineState.execSpecStartTickStack.size() == 0) {",
                "+\t\t\t\tthrow new SequenceDiagramException(\"On lifeline \" + lifelineId + \" a executionspecification was closed but no active executionspecification exists.\");",
                "+\t\t\t}",
                "+\t\t\tint startTick = lifelineState.execSpecStartTickStack.poll();",
                "+\t\t\tif (startTick == currentTick) {",
                "+\t\t\t\tthrow new SequenceDiagramException(\"On lifeline \" + lifelineId + \" a executionspecification was closed too soon, every executionspecification needs to be at least 1 tick long.\");",
                "+\t\t\t}",
                "+\t\t\tif (lifelineState.lastEndOfExecSpec == currentTick) {",
                "+\t\t\t\tthrow new SequenceDiagramException(\"On lifeline \" + lifelineId + \" two executionspecifications end at the same tick, this is not possible.\");",
                "+\t\t\t}",
                "+\t\t\tlifelineState.lastEndOfExecSpec = currentTick;",
                "+\t\t\tlifeline.addExecutionSpecification(new ExecutionSpecification(startTick, currentTick));",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * @param fromId",
                "+\t * @param toId",
                "+\t * @param duration",
                "+\t * @param text",
                "+\t * @param lineType",
                "+\t * @param arrowType",
                "+\t * @param fromLocalId can be null, if not null the send end point will be associated with the given id",
                "+\t * @param toLocalId can be null, if not null the receive end point will be associated with the given id",
                "+\t */",
                "+\tpublic void addMessage(String fromId, String toId, int duration, String text, LineType lineType,",
                "+\t\t\tMessage.ArrowType arrowType, String fromLocalId, String toLocalId) {",
                "+\t\tcheckState();",
                "+\t\t// check that a self message has a duration > 0",
                "+\t\tif (fromId.equals(toId)) {",
                "+\t\t\tif (duration < 1) {",
                "+\t\t\t\tthrow new SequenceDiagramException(\"The duration of a self message must be greater than 0, but was \" + duration + \".\");",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tlastMessageReceiveTick = Math.max(lastMessageReceiveTick, currentTick + duration);",
                "+\t\tLifeline from = getLifelineException(fromId);",
                "+\t\tcheckLifelineSendMessage(from, fromId);",
                "+\t\tLifeline to = getLifelineException(toId);",
                "+\t\t// check if the message doesn't end before the lifeline was created",
                "+\t\tif (!to.isCreatedOnStart() && to.getCreated() != null && currentTick + duration <= to.getCreated()) {",
                "+\t\t\tthrow new SequenceDiagramException(\"A message can't end on a lifeline before this lifeline was created.\\n\" +",
                "+\t\t\t\t\t\t\t\t\t\t\t\t\"Please increase the messages duration by at least \" + (to.getCreated() + 1 - (currentTick + duration)) + \".\");",
                "+\t\t}",
                "+\t\telse if (currentTick + duration < 0) {",
                "+\t\t\tthrow new SequenceDiagramException(\"A message can't end on a lifeline before this lifeline was created.\\n\" +",
                "+\t\t\t\t\t\t\t\t\t\t\t\t\"Please increase the messages duration by at least \" + -(currentTick + duration) + \".\");",
                "+\t\t}",
                "+\t\tif (!to.isCreatedOnStart() && to.getCreated() == null) {",
                "+\t\t\tto.setCreated(currentTick + duration);",
                "+\t\t\tif (to.isExecSpecFromStart()) {",
                "+\t\t\t\tcurrentLifelineState.get(to).execSpecStartTickStack.push(currentTick + duration);",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tMessage msg = new Message(from, to, duration, currentTick, text, arrowType, lineType);",
                "+\t\tif (fromLocalId != null) {",
                "+\t\t\taddOccurrenceSpecification(from, fromId, fromLocalId, msg.sendOccurrenceSpecification());",
                "+\t\t}",
                "+\t\tif (toLocalId != null) {",
                "+\t\t\taddOccurrenceSpecification(to, toId, toLocalId, msg.receiveOccurrenceSpecification());",
                "+\t\t}",
                "+\t\tdia.addLifelineSpanningTickSpanningOccurrence(msg);",
                "+\t}",
                "+",
                "+\tpublic void addLostMessage(String fromId, String text, LineType lineType, Message.ArrowType arrowType, String fromLocalId) {",
                "+\t\tcheckState();",
                "+\t\tLifeline from = getLifelineException(fromId);",
                "+\t\tcheckLifelineSendMessage(from, fromId);",
                "+\t\tLostOrFoundMessage msg = new LostOrFoundMessage(from, false, currentTick, text, arrowType, lineType);",
                "+\t\tif (fromLocalId != null) {",
                "+\t\t\taddOccurrenceSpecification(from, fromId, fromLocalId, msg.sendOccurrenceSpecification());",
                "+\t\t}",
                "+\t\taddLifelineOccurrence(fromId, msg);",
                "+\t}",
                "+",
                "+\tpublic void addFoundMessage(String toId, String text, LineType lineType, Message.ArrowType arrowType, String toLocalId) {",
                "+\t\tcheckState();",
                "+\t\tLifeline to = getLifelineException(toId);",
                "+\t\tif (!to.isCreatedOnStart()) {",
                "+\t\t\tif (to.getCreated() == null || to.getCreated() >= currentTick) {",
                "+\t\t\t\tthrow new SequenceDiagramException(\"The lifeline \" +toId +",
                "+\t\t\t\t\t\t\t\t\t\t\t\t\t\" was not yet created, therefore it is not possible to send a found message to it.\");",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tLostOrFoundMessage msg = new LostOrFoundMessage(to, true, currentTick, text, arrowType, lineType);",
                "+\t\tif (toLocalId != null) {",
                "+\t\t\taddOccurrenceSpecification(to, toId, toLocalId, msg.receiveOccurrenceSpecification());",
                "+\t\t}",
                "+",
                "+\t\taddLifelineOccurrence(toId, msg);",
                "+\t}",
                "+",
                "+\tpublic void addReceiveGateMessage(String fromId, String text, LineType lineType, Message.ArrowType arrowType, String fromLocalId) {",
                "+\t\tcheckState();",
                "+\t\tLifeline from = getLifelineException(fromId);",
                "+\t\tcheckLifelineSendMessage(from, fromId);",
                "+\t\tGateMessage msg = GateMessage.createReceiveGateMessage(from, currentTick, text, arrowType, lineType,",
                "+\t\t\t\tdia.getLifelinesArray()[0], dia.getLifelinesArray()[dia.getLifelinesArray().length - 1]);",
                "+\t\tif (fromLocalId != null) {",
                "+\t\t\taddOccurrenceSpecification(from, fromId, fromLocalId, msg.sendOccurrenceSpecification());",
                "+\t\t}",
                "+\t\tdia.addLifelineSpanningTickSpanningOccurrence(msg);",
                "+\t}",
                "+",
                "+\tpublic void addSendGateMessage(String toId, String text, LineType lineType, Message.ArrowType arrowType, String toLocalId) {",
                "+\t\tcheckState();",
                "+\t\tLifeline to = getLifelineException(toId);",
                "+\t\tGateMessage msg = GateMessage.createSendGateMessage(to, currentTick, text, arrowType, lineType,",
                "+\t\t\t\tdia.getLifelinesArray()[0], dia.getLifelinesArray()[dia.getLifelinesArray().length - 1]);",
                "+\t\tif (toLocalId != null) {",
                "+\t\t\taddOccurrenceSpecification(to, toId, toLocalId, msg.receiveOccurrenceSpecification());",
                "+\t\t}",
                "+\t\tif (!to.isCreatedOnStart() && to.getCreated() == null) {",
                "+\t\t\tto.setCreated(currentTick);",
                "+\t\t}",
                "+\t\tdia.addLifelineSpanningTickSpanningOccurrence(msg);",
                "+\t}",
                "+",
                "+\tprivate void checkLifelineSendMessage(Lifeline from, String id) {",
                "+\t\tif (!from.isCreatedOnStart()) {",
                "+\t\t\tif (from.getCreated() == null || from.getCreated() >= currentTick) {",
                "+\t\t\t\tthrow new SequenceDiagramException(\"The lifeline \" + id + \" was not yet created, therefore it is not possible to send a message from it.\");",
                "+\t\t\t}",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tpublic void addGeneralOrdering(String earlierLifelineId, String earlierLifelineLocalId,",
                "+\t\t\tString laterLifelineId, String laterLifelineLocalId) {",
                "+\t\tcheckState();",
                "+\t\tdia.addLifelineSpanningTickSpanningOccurrence(new GeneralOrdering(",
                "+\t\t\t\tgetLifelineOccurrenceSpecException(earlierLifelineId, earlierLifelineLocalId),",
                "+\t\t\t\tgetLifelineOccurrenceSpecException(laterLifelineId, laterLifelineLocalId),",
                "+\t\t\t\tgetLifelineIntervalException(earlierLifelineId, laterLifelineId)));",
                "+\t}",
                "+",
                "+\t// private void addOccurrenceSpecification(String lifelineId, String localId, OccurrenceSpecification occurrence) {",
                "+\t// addOccurrenceSpecification(getLifelineException(lifelineId), lifelineId, localId, occurrence);",
                "+\t// }",
                "+",
                "+\tprivate void addOccurrenceSpecification(Lifeline lifeline, String lifelineId, String localId, OccurrenceSpecification occurrence) {",
                "+\t\tif (lifelineLocalIds.get(lifeline).containsKey(localId)) {",
                "+\t\t\tthrow new SequenceDiagramException(\"The lifeline '\" + lifelineId + \"' has already a local id '\" + localId + \"', please choose another id.\");",
                "+\t\t}",
                "+\t\tlifelineLocalIds.get(lifeline).put(localId, occurrence);",
                "+\t}",
                "+",
                "+\tprivate OccurrenceSpecification getLifelineOccurrenceSpecException(String lifelineId, String localId) {",
                "+\t\tLifeline llifeline = getLifelineException(lifelineId);",
                "+\t\tOccurrenceSpecification occurrenceSpec = lifelineLocalIds.get(llifeline).get(localId);",
                "+\t\tif (occurrenceSpec == null) {",
                "+\t\t\tthrow new SequenceDiagramException(\"No lifeline occurrence with the id '\" + localId + \"' could be found on lifeline '\" + lifelineId + \"'.\");",
                "+\t\t}",
                "+\t\treturn occurrenceSpec;",
                "+\t}",
                "+",
                "+\tpublic void addInteractionUse(String startId, String endId, String text) {",
                "+\t\tcheckState();",
                "+\t\tLifeline[] lifelines = getLifelineIntervalException(startId, endId);",
                "+\t\tdia.addLifelineSpanningTickSpanningOccurrence(new InteractionUse(currentTick, text, lifelines));",
                "+\t}",
                "+",
                "+\tpublic void addContinuation(String startId, String endId, String text) {",
                "+\t\tcheckState();",
                "+\t\tLifeline[] lifelines = getLifelineIntervalException(startId, endId);",
                "+\t\tdia.addLifelineSpanningTickSpanningOccurrence(new Continuation(currentTick, text, lifelines));",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * @param startId starting lifeline",
                "+\t * @param endId ending lifeline",
                "+\t * @param cfId the id of the combined Fragment, can be null",
                "+\t * @param operator of the combined fragment",
                "+\t */",
                "+\tpublic void beginCombinedFragment(String startId, String endId, String cfId, String operator) {",
                "+\t\tcheckState();",
                "+\t\tLifeline[] lifelines;",
                "+\t\tif (startId == null && endId == null) {",
                "+\t\t\tlifelines = Arrays.<Lifeline> copyOf(dia.getLifelinesArray(), dia.getLifelinesArray().length);",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tlifelines = getLifelineIntervalException(startId, endId);",
                "+\t\t}",
                "+\t\tactiveCombinedFragmentStack.push(new ActiveCombinedFragment(new CombinedFragment(lifelines, currentTick, operator), cfId));",
                "+\t\tactiveCombinedFragmentStack.peek().activeOperand = new ActiveOperand(currentTick);",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * @param cfId can be null, then the latest created combined fragment which was not closed is closed.",
                "+\t * Otherwise the combined fragment associated with the given id is closed.",
                "+\t */",
                "+\tpublic void endCombinedFragment(String cfId) {",
                "+\t\tcheckState();",
                "+\t\tif (activeCombinedFragmentStack.size() == 0) {",
                "+\t\t\tthrow new SequenceDiagramException(\"Error a combined fragment was closed, but no open one exists.\");",
                "+\t\t}",
                "+\t\tActiveCombinedFragment currentCombFrag = null;",
                "+\t\tif (cfId == null) {",
                "+\t\t\tcurrentCombFrag = activeCombinedFragmentStack.pop();",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tListIterator<ActiveCombinedFragment> activeCFIter = activeCombinedFragmentStack.listIterator();",
                "+\t\t\twhile (activeCFIter.hasNext()) {",
                "+\t\t\t\tcurrentCombFrag = activeCFIter.next();",
                "+\t\t\t\tif (cfId.equals(currentCombFrag.id)) {",
                "+\t\t\t\t\tactiveCFIter.remove();",
                "+\t\t\t\t\tbreak;",
                "+\t\t\t\t}",
                "+\t\t\t\tcurrentCombFrag = null;",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tif (currentCombFrag == null) {",
                "+\t\t\tthrow new SequenceDiagramException(\"Error no combined fragment with id '\" + cfId + \"' was found.\");",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\t// TODO operand rewrite",
                "+\t\t\t// if (currentCombFrag.activeOperand != null) {",
                "+\t\t\t// throw new SequenceDiagramException(\"Error a combined fragment was closed, but there is still an open operand present.\");",
                "+\t\t\t// }",
                "+\t\t\tcurrentCombFrag.combFrag.addOperand(currentCombFrag.activeOperand.startTick, currentTick);",
                "+\t\t\tdia.addLifelineSpanningTickSpanningOccurrence(currentCombFrag.combFrag);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tpublic void endAndBeginOperand(String cfId) {",
                "+\t\tcheckState();",
                "+\t\tif (activeCombinedFragmentStack.size() == 0) {",
                "+\t\t\tthrow new SequenceDiagramException(\"Error a combined fragment was closed, but no open one exists.\");",
                "+\t\t}",
                "+\t\tActiveCombinedFragment currentCombFrag = null;",
                "+\t\tif (cfId == null) {",
                "+\t\t\tcurrentCombFrag = activeCombinedFragmentStack.peek();",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tListIterator<ActiveCombinedFragment> activeCFIter = activeCombinedFragmentStack.listIterator();",
                "+\t\t\twhile (activeCFIter.hasNext()) {",
                "+\t\t\t\tcurrentCombFrag = activeCFIter.next();",
                "+\t\t\t\tif (cfId.equals(currentCombFrag.id)) {",
                "+\t\t\t\t\tbreak;",
                "+\t\t\t\t}",
                "+\t\t\t\tcurrentCombFrag = null;",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tif (currentCombFrag == null) {",
                "+\t\t\tthrow new SequenceDiagramException(\"Error no combined fragment with id '\" + cfId + \"' was found.\");",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\t// TODO operand rewrite",
                "+\t\t\tcurrentCombFrag.combFrag.addOperand(currentCombFrag.activeOperand.startTick, currentTick);",
                "+\t\t\tcurrentCombFrag.activeOperand = new ActiveOperand(currentTick);",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t// public void beginOperand() {",
                "+\t// checkState();",
                "+\t// beginOperand(null, \"\");",
                "+\t// }",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @param text if empty or null no constraint will be generated",
                "+\t * @param lifelineId if empty or null the first occurrence in the operand will determine the lifeline on which the constraint is placed",
                "+\t */",
                "+\t// public void beginOperand(String text, String lifelineId) {",
                "+\t// checkState();",
                "+\t// if (activeCombinedFragmentStack.size() == 0) {",
                "+\t// throw new SequenceDiagramException(\"Error an operand must lie in a combined fragment, but no open one exists.\");",
                "+\t// }",
                "+\t// ActiveCombinedFragment currentCombFrag = activeCombinedFragmentStack.peek();",
                "+\t// if (currentCombFrag.activeOperand != null) {",
                "+\t// throw new SequenceDiagramException(\"Error a new operand was started, but there is still an open operand present.\");",
                "+\t// }",
                "+\t// ActiveOperand operand;",
                "+\t// if (text == null || text.isEmpty()) {",
                "+\t// operand = new ActiveOperand(currentTick);",
                "+\t// }",
                "+\t// else {",
                "+\t// operand = new ActiveOperand(text, getLifeline(lifelineId), currentTick);",
                "+\t// }",
                "+\t// currentCombFrag.activeOperand = operand;",
                "+\t// }",
                "+",
                "+\t// public void endOperand() {",
                "+\t// checkState();",
                "+\t// if (activeCombinedFragmentStack.size() == 0) {",
                "+\t// throw new SequenceDiagramException(\"Error an operand must lie in a combined fragment, but no open one exists.\");",
                "+\t// }",
                "+\t// ActiveCombinedFragment currentCombFrag = activeCombinedFragmentStack.peek();",
                "+\t// if (currentCombFrag.activeOperand == null) {",
                "+\t// throw new SequenceDiagramException(\"Error a operand was closed, but there is no open operand.\");",
                "+\t// }",
                "+\t// ActiveOperand operand = currentCombFrag.activeOperand;",
                "+\t// currentCombFrag.activeOperand = null;",
                "+\t// if (operand.constraint == null) {",
                "+\t// currentCombFrag.combFrag.addOperand(operand.startTick, currentTick);",
                "+\t// }",
                "+\t// else {",
                "+\t// Lifeline lifeline = operand.assoicatedLifeline;",
                "+\t// if (lifeline == null) { // if it wasn't set place it on the first lifeline of the combined fragment",
                "+\t// lifeline = currentCombFrag.combFrag.getFirstLifeline();",
                "+\t// }",
                "+\t// try {",
                "+\t// currentCombFrag.combFrag.addOperand(operand.startTick, currentTick, operand.constraint, lifeline);",
                "+\t// } catch (SequenceDiagramCheckedException e) {",
                "+\t// throw new SequenceDiagramException(\"Error while placing the interaction '\" + operand.constraint",
                "+\t// + \"' constraint on the \" + (lifeline.getIndex() + 1)",
                "+\t// + \" lifeline from the left.\\n\" + e.getMessage(), e);",
                "+\t// }",
                "+\t// }",
                "+\t// }",
                "+",
                "+\t/**",
                "+\t * advances a step down",
                "+\t */",
                "+\tpublic void tick() {",
                "+\t\ttick(1);",
                "+\t}",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @param tickCount needs to be &gt; 0",
                "+\t */",
                "+\tpublic void tick(int tickCount) {",
                "+\t\tcheckState();",
                "+\t\tif (tickCount < 1) {",
                "+\t\t\tthrow new IllegalArgumentException(\"The tickCount must be greater than 0.\");",
                "+\t\t}",
                "+\t\tcurrentTick += tickCount;",
                "+\t}",
                "+",
                "+\tpublic void setOverrideDefaultIds(boolean overrideDefaultIds) {",
                "+\t\tcheckState();",
                "+\t\tif (dia.getLifelineCount() > 0) {",
                "+\t\t\tthrow new SequenceDiagramException(\"The override ids option must be specified before any lifeline is specified.\");",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tthis.overrideDefaultIds = overrideDefaultIds;",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tpublic boolean isOverrideDefaultIds() {",
                "+\t\treturn overrideDefaultIds;",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * Should be called after the diagram is generated, because this last step can add further warnings.",
                "+\t * @return the empty string if no warnings exists, otherwise a headline and the warnings (with \\n as line delimiter) are returned",
                "+\t */",
                "+\tpublic String getWarnings() {",
                "+\t\tif (warnings.size() == 0) {",
                "+\t\t\treturn \"\";",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tStringBuffer strBuffer = new StringBuffer();",
                "+\t\t\tstrBuffer.append(\"Warnings:\");",
                "+\t\t\tfor (String w : warnings) {",
                "+\t\t\t\tstrBuffer.append('\\n');",
                "+\t\t\t\tstrBuffer.append(w);",
                "+\t\t\t}",
                "+\t\t\treturn strBuffer.toString();",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * Called as final step.",
                "+\t * Can be called multiple times, but every time the same diagram (same reference) is returned.",
                "+\t * If there exists a major issue with the diagram an exception is thrown, otherwise the diagram is returned",
                "+\t * and if there are minor issues these are added to the warnings.",
                "+\t *",
                "+\t * @return the generated diagram",
                "+\t * @throws SequenceDiagramException if the diagram could not be generated.",
                "+\t * @see #getWarnings()",
                "+\t */",
                "+\tpublic SequenceDiagram generateDiagram() {",
                "+\t\tif (diagramRetrieved) {",
                "+\t\t\treturn dia;",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\t// if a created later lifeline has no message it is draw at the start and a warning is added",
                "+\t\t\tboolean createdLaterWarning = false;",
                "+\t\t\tfor (Lifeline ll : dia.getLifelines()) {",
                "+\t\t\t\tif (!ll.isCreatedOnStart() && ll.getCreated() == null) {",
                "+\t\t\t\t\tcreatedLaterWarning = true;",
                "+\t\t\t\t\tll.setCreatedOnStart(true);",
                "+\t\t\t\t}",
                "+\t\t\t}",
                "+\t\t\tif (createdLaterWarning) {",
                "+\t\t\t\twarnings.add(\"At least one lifeline was specified as created later, but didn't receive a message\");",
                "+\t\t\t}",
                "+",
                "+\t\t\t// TODO for each operand condition add a LL occurence to the lifeline with the first message (or to the lowest index)",
                "+",
                "+\t\t\t// close all execution specifications and add a warning.",
                "+\t\t\tboolean openExecSpecs;",
                "+\t\t\tboolean foundOpenExecSpecs = false;",
                "+\t\t\tdo {",
                "+\t\t\t\topenExecSpecs = false;",
                "+\t\t\t\tfor (Map.Entry<Lifeline, LifelineState> e : currentLifelineState.entrySet()) {",
                "+\t\t\t\t\tif (e.getValue().execSpecStartTickStack.size() > 0) {",
                "+\t\t\t\t\t\tif (e.getValue().lastEndOfExecSpec < currentTick) {",
                "+\t\t\t\t\t\t\te.getValue().lastEndOfExecSpec = currentTick;",
                "+\t\t\t\t\t\t\te.getKey().addExecutionSpecification(",
                "+\t\t\t\t\t\t\t\t\tnew ExecutionSpecification(e.getValue().execSpecStartTickStack.pop(), currentTick));",
                "+\t\t\t\t\t\t\topenExecSpecs = openExecSpecs || e.getValue().execSpecStartTickStack.size() > 0;",
                "+\t\t\t\t\t\t\tfoundOpenExecSpecs = true;",
                "+\t\t\t\t\t\t}",
                "+\t\t\t\t\t}",
                "+\t\t\t\t}",
                "+\t\t\t\tif (openExecSpecs) {",
                "+\t\t\t\t\tcurrentTick++;",
                "+\t\t\t\t}",
                "+\t\t\t} while (openExecSpecs);",
                "+\t\t\tif (foundOpenExecSpecs) {",
                "+\t\t\t\twarnings.add(\"At least one executionspecification was not closed, any open executionspecification was closed at the end of the diagram.\");",
                "+\t\t\t}",
                "+\t\t\tdia.setLastTick(Math.max(currentTick, lastMessageReceiveTick));",
                "+\t\t\tdiagramRetrieved = true;",
                "+\t\t\treturn dia;",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t/**",
                "+\t * throws an exception if the diagram was already returned",
                "+\t */",
                "+\tprivate void checkState() {",
                "+\t\tif (diagramRetrieved) {",
                "+\t\t\tthrow new IllegalStateException(\"The final diagram was returned and therefore no more changes are allowed.\");",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tprivate void addWarning(String id, String text) {",
                "+\t\twarnings.add(\"On lifeline '\" + id + \"': \" + text);",
                "+\t}",
                "+",
                "+\tprivate static class LifelineState {",
                "+\t\t/** stores the last end of an execution specifications. */",
                "+\t\tint lastEndOfExecSpec = -1; // Starts at -1 since the first tick is 0 and therefore no overlap is possible",
                "+\t\tLinkedList<Integer> execSpecStartTickStack = new LinkedList<Integer>();",
                "+\t\tboolean coregionActive = false;",
                "+\t}",
                "+",
                "+\tprivate static class ActiveCombinedFragment {",
                "+\t\tpublic ActiveCombinedFragment(CombinedFragment combFrag, String cfId) {",
                "+\t\t\tsuper();",
                "+\t\t\tthis.combFrag = combFrag;",
                "+\t\t\tid = cfId;",
                "+\t\t}",
                "+",
                "+\t\tString id;",
                "+\t\tCombinedFragment combFrag;",
                "+\t\tActiveOperand activeOperand = null;",
                "+\t}",
                "+",
                "+\tprivate static class ActiveOperand {",
                "+\t\tpublic ActiveOperand(int startTick) {",
                "+\t\t\tsuper();",
                "+\t\t\tthis.startTick = startTick;",
                "+\t\t}",
                "+",
                "+\t\t// public ActiveOperand(String constraint, Lifeline assoicatedLifeline, int startTick) {",
                "+\t\t// super();",
                "+\t\t// this.constraint = constraint;",
                "+\t\t// this.assoicatedLifeline = assoicatedLifeline;",
                "+\t\t// this.startTick = startTick;",
                "+\t\t// }",
                "+\t\t//",
                "+\t\t// String constraint = null; // if empty no constraint needed",
                "+\t\t// Lifeline assoicatedLifeline = null; // lifeline on which the constraint should be drawn",
                "+\t\tint startTick;",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagramCheckedException.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagramCheckedException.java",
                "new file mode 100644",
                "index 00000000..eb5c816d",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagramCheckedException.java",
                "@@ -0,0 +1,23 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+public class SequenceDiagramCheckedException extends Exception {",
                "+",
                "+\tprivate static final long serialVersionUID = 3988597061858980580L;",
                "+",
                "+\tpublic SequenceDiagramCheckedException() {",
                "+\t\tsuper();",
                "+\t}",
                "+",
                "+\tpublic SequenceDiagramCheckedException(String message, Throwable cause) {",
                "+\t\tsuper(message, cause);",
                "+\t}",
                "+",
                "+\tpublic SequenceDiagramCheckedException(String message) {",
                "+\t\tsuper(message);",
                "+\t}",
                "+",
                "+\tpublic SequenceDiagramCheckedException(Throwable cause) {",
                "+\t\tsuper(cause);",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagramException.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagramException.java",
                "new file mode 100644",
                "index 00000000..4392c5a8",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagramException.java",
                "@@ -0,0 +1,23 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+public class SequenceDiagramException extends RuntimeException {",
                "+",
                "+\tprivate static final long serialVersionUID = 3988597061858980589L;",
                "+",
                "+\tpublic SequenceDiagramException() {",
                "+\t\tsuper();",
                "+\t}",
                "+",
                "+\tpublic SequenceDiagramException(String message, Throwable cause) {",
                "+\t\tsuper(message, cause);",
                "+\t}",
                "+",
                "+\tpublic SequenceDiagramException(String message) {",
                "+\t\tsuper(message);",
                "+\t}",
                "+",
                "+\tpublic SequenceDiagramException(Throwable cause) {",
                "+\t\tsuper(cause);",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/StateInvariant.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/StateInvariant.java",
                "new file mode 100644",
                "index 00000000..b6c8bfc5",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/StateInvariant.java",
                "@@ -0,0 +1,95 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import com.baselet.control.basics.Line1D;",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.control.enums.AlignHorizontal;",
                "+import com.baselet.control.enums.AlignVertical;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.diagram.draw.TextSplitter;",
                "+",
                "+public class StateInvariant implements LifelineOccurrence {",
                "+\t/** the width of the ellipse which builds the left and right border (no text is drawn in this) */",
                "+\tprivate static final double ROUND_PART_WIDTH = 20;",
                "+\t/** how much of the round part width can be used for drawing text */",
                "+\tprivate static final double ROUND_PART_TEXT_PERCENTAGE = 0.3;",
                "+\t/** the space between the text and the border line */",
                "+\tprivate static final double VERTICAL_BORDER_PADDING = 5;",
                "+\tprivate static final double CURLY_BRACKETS_Y_PADDING = 2;",
                "+\t/** the minimum width, to avoid splitting text with very short words e.g. print \"I am I\" in one line instead of 3*/",
                "+\tprivate static final double MIN_WIDTH = 50;",
                "+",
                "+\tprivate final String[] lines;",
                "+\tprivate final StateInvariantStyle style;",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @param text the text, lines need to be separated by \\n",
                "+\t * @param style how it should be drawn",
                "+\t */",
                "+\tpublic StateInvariant(String text, StateInvariantStyle style) {",
                "+\t\tsuper();",
                "+\t\tthis.style = style;",
                "+\t\tif (style == StateInvariantStyle.CURLY_BRACKETS) {",
                "+\t\t\tlines = (\"{\" + text + \"}\").split(\"\\n\");",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\tlines = text.split(\"\\n\");",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Line1D draw(DrawHandler drawHandler, PointDouble topLeft, PointDouble size) {",
                "+\t\tdouble height = getHeight(drawHandler, size.x);",
                "+\t\tdouble topY = topLeft.y + (size.y - height) / 2;",
                "+\t\tLine1D interruptedLifeline = new Line1D(topY, topY + height);",
                "+\t\tif (style == StateInvariantStyle.STATE) {",
                "+\t\t\t// draw border and adjust textY and textLeftX",
                "+\t\t\tdrawHandler.drawArc(topLeft.x, topY, ROUND_PART_WIDTH * 2, height, 90, 180, true);",
                "+\t\t\tdrawHandler.drawArc(topLeft.x + size.x - ROUND_PART_WIDTH * 2, topY, ROUND_PART_WIDTH * 2, height, 270, 180, true);",
                "+\t\t\tdrawHandler.drawLine(topLeft.x + ROUND_PART_WIDTH, topY, topLeft.x + size.x - ROUND_PART_WIDTH, topY);",
                "+\t\t\tdrawHandler.drawLine(topLeft.x + ROUND_PART_WIDTH, topY + height, topLeft.x + size.x - ROUND_PART_WIDTH, topY + height);",
                "+\t\t\tTextSplitter.drawText(drawHandler, lines, topLeft.x + ROUND_PART_WIDTH * (1 - ROUND_PART_TEXT_PERCENTAGE), topY,",
                "+\t\t\t\t\tsize.x - ROUND_PART_WIDTH * (1 - ROUND_PART_TEXT_PERCENTAGE) * 2, height, AlignHorizontal.CENTER, AlignVertical.CENTER);",
                "+\t\t}",
                "+\t\telse if (style == StateInvariantStyle.CURLY_BRACKETS) {",
                "+\t\t\tTextSplitter.drawText(drawHandler, lines, topLeft.x, topY, size.x, height,",
                "+\t\t\t\t\tAlignHorizontal.CENTER, AlignVertical.CENTER);",
                "+\t\t}",
                "+\t\treturn interruptedLifeline;",
                "+",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getMinWidth(DrawHandler drawHandler) {",
                "+\t\tdouble minWidth = Math.max(MIN_WIDTH, TextSplitter.getTextMinWidth(lines, drawHandler));",
                "+\t\tif (style == StateInvariantStyle.CURLY_BRACKETS) {",
                "+\t\t\treturn minWidth;",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\treturn minWidth + ROUND_PART_WIDTH * (1 - ROUND_PART_TEXT_PERCENTAGE) * 2;",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getAdditionalYHeight(DrawHandler drawHandler, PointDouble size) {",
                "+\t\treturn getHeight(drawHandler, size.x) - size.y;",
                "+\t}",
                "+",
                "+\tprivate double getHeight(DrawHandler drawHandler, double totalWidth) {",
                "+\t\tif (style == StateInvariantStyle.STATE) {",
                "+\t\t\ttotalWidth -= ROUND_PART_WIDTH * (1 - ROUND_PART_TEXT_PERCENTAGE) * 2;",
                "+\t\t}",
                "+\t\tif (style == StateInvariantStyle.CURLY_BRACKETS) {",
                "+\t\t\treturn TextSplitter.getSplitStringHeight(lines, totalWidth, drawHandler) + CURLY_BRACKETS_Y_PADDING * 2;",
                "+\t\t}",
                "+\t\telse {",
                "+\t\t\treturn TextSplitter.getSplitStringHeight(lines, totalWidth, drawHandler) + VERTICAL_BORDER_PADDING * 2;",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tpublic enum StateInvariantStyle {",
                "+\t\tSTATE, CURLY_BRACKETS",
                "+\t\t// UML 2.5 also allows a NOTE as a StateInvariant but this is not supported by this diagram (yet)",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/TextOnLifeline.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/TextOnLifeline.java",
                "new file mode 100644",
                "index 00000000..e1246102",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/TextOnLifeline.java",
                "@@ -0,0 +1,46 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import com.baselet.control.basics.Line1D;",
                "+import com.baselet.control.basics.geom.PointDouble;",
                "+import com.baselet.control.enums.AlignHorizontal;",
                "+import com.baselet.control.enums.AlignVertical;",
                "+import com.baselet.diagram.draw.DrawHandler;",
                "+import com.baselet.diagram.draw.TextSplitter;",
                "+",
                "+public class TextOnLifeline implements LifelineOccurrence {",
                "+\t/** the minimum width, to avoid splitting text with very short words e.g. print \"I am I\" in one line instead of 3*/",
                "+\tprivate static final double MIN_WIDTH = 50;",
                "+",
                "+\tprivate final String[] lines;",
                "+",
                "+\t/**",
                "+\t *",
                "+\t * @param text the text, lines need to be separated by \\n",
                "+\t */",
                "+\tpublic TextOnLifeline(String text) {",
                "+\t\tsuper();",
                "+\t\tlines = text.split(\"\\n\");",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic Line1D draw(DrawHandler drawHandler, PointDouble topLeft, PointDouble size) {",
                "+\t\tdouble height = TextSplitter.getSplitStringHeight(lines, size.x, drawHandler);",
                "+\t\tdouble topY = topLeft.y + (size.y - height) / 2;",
                "+\t\tLine1D interruptedLifeline = new Line1D(topY, topY + height);",
                "+\t\tTextSplitter.drawText(drawHandler, lines, topLeft.x, topY, size.x, height,",
                "+\t\t\t\tAlignHorizontal.CENTER, AlignVertical.CENTER);",
                "+\t\treturn interruptedLifeline;",
                "+",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getMinWidth(DrawHandler drawHandler) {",
                "+\t\treturn Math.max(MIN_WIDTH, TextSplitter.getTextMinWidth(lines, drawHandler));",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getAdditionalYHeight(DrawHandler drawHandler, PointDouble size) {",
                "+\t\treturn TextSplitter.getSplitStringHeight(lines, size.x, drawHandler) - size.y;",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/VerticalDrawingInfo.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/VerticalDrawingInfo.java",
                "new file mode 100644",
                "index 00000000..e716cff3",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/VerticalDrawingInfo.java",
                "@@ -0,0 +1,71 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+/**",
                "+ * Interface for the vertical drawing information of the diagram, this information is the same for each lifeline.",
                "+ */",
                "+public interface VerticalDrawingInfo {",
                "+",
                "+\t/**",
                "+\t * @return the start y coordinate of the head, if it would be created at start and not with a message.",
                "+\t */",
                "+\tpublic double getVerticalHeadStart();",
                "+",
                "+\t/**",
                "+\t * @return the end y coordinate of the head, if it would be created at start and not with a message.",
                "+\t */",
                "+\tpublic double getVerticalHeadEnd();",
                "+",
                "+\t/**",
                "+\t * @return the height of the head, if it would be created at start and not with a message.",
                "+\t */",
                "+\tpublic double getHeadHeight();",
                "+",
                "+\t/**",
                "+\t * @param tick",
                "+\t * @return the y coordinate of the start of the given tick",
                "+\t */",
                "+\tpublic double getVerticalStart(int tick);",
                "+",
                "+\t/**",
                "+\t * @param tick",
                "+\t * @return the y coordinate of the end of the given tick",
                "+\t */",
                "+\tpublic double getVerticalEnd(int tick);",
                "+",
                "+\t/**",
                "+\t * Returns the y coordinate of the vertical center of the tick,",
                "+\t * i.e. the point between getVerticalStart and getVerticalEnd",
                "+\t * @param tick",
                "+\t * @return the vertical center of the tick at the given tick time",
                "+\t * @see #getVerticalStart(int)",
                "+\t * @see #getVerticalEnd(int)",
                "+\t */",
                "+\tpublic double getVerticalCenter(int tick);",
                "+",
                "+\t/**",
                "+\t * <code>getVerticalEnd - getVerticalStart</code>",
                "+\t * @param tick",
                "+\t * @return the height of the tick at the given tick time.",
                "+\t * @see #getVerticalStart(int)",
                "+\t * @see #getVerticalEnd(int)",
                "+\t */",
                "+\tpublic double getTickHeight(int tick);",
                "+",
                "+\t/**",
                "+\t * Returns the vertical padding between two ticks.",
                "+\t * @return the vertical padding between two ticks.",
                "+\t */",
                "+\tpublic double getTickVerticalPadding();",
                "+",
                "+\t/**",
                "+\t * @param container",
                "+\t * @return the y coordinate of the start of the given container",
                "+\t */",
                "+\tpublic double getVerticalStart(Container container);",
                "+",
                "+\t/**",
                "+\t * @param container",
                "+\t * @return the y coordinate of the end of the given container",
                "+\t */",
                "+\tpublic double getVerticalEnd(Container container);",
                "+}",
                "\\ No newline at end of file",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/VerticalDrawingInfoImpl.java b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/VerticalDrawingInfoImpl.java",
                "new file mode 100644",
                "index 00000000..5c8f505c",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/VerticalDrawingInfoImpl.java",
                "@@ -0,0 +1,180 @@",
                "+package com.baselet.element.sequence_aio.facet;",
                "+",
                "+import java.util.Collection;",
                "+import java.util.Collections;",
                "+import java.util.HashMap;",
                "+import java.util.LinkedList;",
                "+import java.util.List;",
                "+import java.util.ListIterator;",
                "+import java.util.Map;",
                "+",
                "+import com.baselet.element.sequence_aio.facet.LifelineSpanningTickSpanningOccurrence.ContainerPadding;",
                "+",
                "+/**",
                "+ * Only supports ContainerPaddings which don't overlap at start, i.e. if the start tick is the same the lifeline",
                "+ * interval must not intersect.",
                "+ *",
                "+ */",
                "+public class VerticalDrawingInfoImpl implements VerticalDrawingInfo {",
                "+",
                "+\tprivate final double startingHeadTopY;",
                "+\tprivate final double startingHeadHeight;",
                "+\tprivate final double tickVerticalPadding;",
                "+\tprivate final double defaultTickHeight;",
                "+\tprivate final double[] accumulativeAddiontalHeightOffsets;",
                "+\tprivate final double[] topPadding;",
                "+\tprivate final double[] bottomPadding;",
                "+\t/** contains the bottom padding of the enclosing containers which end at the same tick */",
                "+\tprivate final Map<Container, Double> containerBottomPadding;",
                "+\tprivate final double startingTickTopY;",
                "+",
                "+\t/**",
                "+\t * @param startingHeadTopY",
                "+\t * @param startingHeadHeight",
                "+\t * @param defaultTickHeight",
                "+\t * @param tickVerticalPadding <code>tickVerticalPadding = getVerticalEnd(tick)- getVerticalStart(tick+1)</code>",
                "+\t * @param addiontalHeights for every tick how much height should be added to this tick, therefore length at least",
                "+\t * lastTick + 1 so that lastTick is a valid index",
                "+\t * @param allPaddings",
                "+\t */",
                "+\tpublic VerticalDrawingInfoImpl(double startingHeadTopY, double startingHeadHeight, double defaultTickHeight,",
                "+\t\t\tdouble tickVerticalPadding, double[] addiontalHeights, Collection<ContainerPadding> allPaddings) {",
                "+\t\tthis.startingHeadTopY = startingHeadTopY;",
                "+\t\tthis.startingHeadHeight = startingHeadHeight;",
                "+\t\tthis.tickVerticalPadding = tickVerticalPadding;",
                "+\t\tthis.defaultTickHeight = defaultTickHeight;",
                "+\t\ttopPadding = new double[addiontalHeights.length + 1];",
                "+\t\tbottomPadding = new double[addiontalHeights.length + 1];",
                "+\t\tcontainerBottomPadding = new HashMap<Container, Double>((int) (allPaddings.size() / 0.7));",
                "+\t\taccumulativeAddiontalHeightOffsets = new double[addiontalHeights.length + 1];",
                "+\t\tprocessPaddings(addiontalHeights, allPaddings);",
                "+\t\tstartingTickTopY = startingHeadTopY + startingHeadHeight + tickVerticalPadding;",
                "+\t}",
                "+",
                "+\tprivate void processPaddings(double[] addiontalHeights, Collection<ContainerPadding> allPaddings) {",
                "+\t\tMap<Integer, List<ContainerPadding>> endMap = new HashMap<Integer, List<ContainerPadding>>();",
                "+\t\tMap<Integer, List<ContainerPadding>> startMap = new HashMap<Integer, List<ContainerPadding>>();",
                "+\t\tfor (ContainerPadding cp : allPaddings) {",
                "+\t\t\tif (!startMap.containsKey(cp.getContainer().getStartTick())) {",
                "+\t\t\t\tstartMap.put(cp.getContainer().getStartTick(), new LinkedList<ContainerPadding>());",
                "+\t\t\t}",
                "+\t\t\tstartMap.get(cp.getContainer().getStartTick()).add(cp);",
                "+\t\t\tif (!endMap.containsKey(cp.getContainer().getEndTick())) {",
                "+\t\t\t\tendMap.put(cp.getContainer().getEndTick(), new LinkedList<ContainerPadding>());",
                "+\t\t\t}",
                "+\t\t\tendMap.get(cp.getContainer().getEndTick()).add(cp);",
                "+\t\t}",
                "+\t\tfor (Map.Entry<Integer, List<ContainerPadding>> e : startMap.entrySet()) {",
                "+\t\t\tfor (ContainerPadding cp : e.getValue()) {",
                "+\t\t\t\ttopPadding[e.getKey()] = Math.max(topPadding[e.getKey()], cp.getTopPadding());",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tcalculateBottomPaddings(endMap);",
                "+",
                "+\t\tdouble sum = 0;",
                "+\t\tfor (int i = 0; i < addiontalHeights.length; i++) {",
                "+\t\t\tsum += addiontalHeights[i] + topPadding[i] + bottomPadding[i];",
                "+\t\t\taccumulativeAddiontalHeightOffsets[i + 1] = sum;",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tprivate void calculateBottomPaddings(Map<Integer, List<ContainerPadding>> endMap) {",
                "+\t\tfor (Map.Entry<Integer, List<ContainerPadding>> e : endMap.entrySet()) {",
                "+\t\t\twhile (!e.getValue().isEmpty()) {",
                "+\t\t\t\tList<ContainerPadding> cpList = new LinkedList<ContainerPadding>();",
                "+\t\t\t\tcpList.add(e.getValue().remove(0));",
                "+\t\t\t\tint startLl = cpList.get(0).getContainer().getFirstLifeline().getIndex();",
                "+\t\t\t\tint endLl = cpList.get(0).getContainer().getLastLifeline().getIndex();",
                "+\t\t\t\t// add all lifelines to the list which have intersecting lifelines",
                "+\t\t\t\tListIterator<ContainerPadding> cpIter = e.getValue().listIterator();",
                "+\t\t\t\twhile (cpIter.hasNext()) {",
                "+\t\t\t\t\tContainerPadding cp = cpIter.next();",
                "+\t\t\t\t\tif (isIntersecting(startLl, endLl, cp.getContainer())) {",
                "+\t\t\t\t\t\tcpList.add(cp);",
                "+\t\t\t\t\t\tcpIter.remove();",
                "+\t\t\t\t\t\tstartLl = Math.min(startLl, cp.getContainer().getFirstLifeline().getIndex());",
                "+\t\t\t\t\t\tendLl = Math.max(endLl, cp.getContainer().getLastLifeline().getIndex());",
                "+\t\t\t\t\t}",
                "+\t\t\t\t}",
                "+\t\t\t\tCollections.sort(cpList, ContainerPadding.getContainerStartTickLifelineAscComparator());",
                "+\t\t\t\tdouble padding = 0;",
                "+\t\t\t\tfor (ContainerPadding cp : cpList) {",
                "+\t\t\t\t\tcontainerBottomPadding.put(cp.getContainer(), padding);",
                "+\t\t\t\t\tpadding += cp.getBottomPadding();",
                "+\t\t\t\t}",
                "+\t\t\t\tbottomPadding[e.getKey()] = Math.max(bottomPadding[e.getKey()], padding);",
                "+\t\t\t}",
                "+\t\t}",
                "+",
                "+\t}",
                "+",
                "+\tprivate boolean contains(int low, int high, int value) {",
                "+\t\treturn low <= value && value <= high;",
                "+\t}",
                "+",
                "+\tprivate boolean isIntersecting(int startLl, int endLl, Container container) {",
                "+\t\tboolean isIntersecting = contains(startLl, endLl, container.getFirstLifeline().getIndex());",
                "+\t\tisIntersecting = isIntersecting || contains(startLl, endLl, container.getLastLifeline().getIndex());",
                "+\t\tisIntersecting = isIntersecting || contains(container.getLastLifeline().getIndex(),",
                "+\t\t\t\tcontainer.getLastLifeline().getIndex(), startLl);",
                "+\t\treturn isIntersecting;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalStart(int tick) {",
                "+\t\treturn startingTickTopY + tick * (defaultTickHeight + tickVerticalPadding) + accumulativeAddiontalHeightOffsets[tick]",
                "+\t\t\t\t+ topPadding[tick];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalEnd(int tick) {",
                "+\t\treturn startingTickTopY + tick * (defaultTickHeight + tickVerticalPadding) + defaultTickHeight",
                "+\t\t\t\t+ accumulativeAddiontalHeightOffsets[tick + 1] - bottomPadding[tick];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getTickHeight(int tick) {",
                "+\t\treturn getVerticalEnd(tick) - getVerticalStart(tick);",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getTickVerticalPadding() {",
                "+\t\treturn tickVerticalPadding;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalHeadStart() {",
                "+\t\treturn startingHeadTopY;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalHeadEnd() {",
                "+\t\treturn getVerticalHeadStart() + startingHeadHeight;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getHeadHeight() {",
                "+\t\treturn startingHeadHeight;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalCenter(int tick) {",
                "+\t\treturn getVerticalStart(tick) / 2 + getVerticalEnd(tick) / 2;",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalStart(Container container) {",
                "+\t\t// since the starting points aren't allowed to overlapp we only need to calculate the start without the topPadding",
                "+\t\tint tick = container.getStartTick();",
                "+\t\treturn startingTickTopY + tick * (defaultTickHeight + tickVerticalPadding) + accumulativeAddiontalHeightOffsets[tick];",
                "+\t}",
                "+",
                "+\t@Override",
                "+\tpublic double getVerticalEnd(Container container) {",
                "+\t\t// this is tricky because the end ticks can overlap",
                "+\t\tint tick = container.getEndTick();",
                "+\t\treturn startingTickTopY + tick * (defaultTickHeight + tickVerticalPadding) + defaultTickHeight",
                "+\t\t\t\t+ accumulativeAddiontalHeightOffsets[tick + 1] - containerBottomPadding.get(container);",
                "+\t}",
                "+",
                "+}",
                "diff --git a/umlet-elements/src/main/javacc/SequenceAllInOneParser.jj b/umlet-elements/src/main/javacc/SequenceAllInOneParser.jj",
                "index ce35c6c2..75731861 100644",
                "--- a/umlet-elements/src/main/javacc/SequenceAllInOneParser.jj",
                "+++ b/umlet-elements/src/main/javacc/SequenceAllInOneParser.jj",
                "@@ -11,11 +11,12 @@ options {",
                " PARSER_BEGIN(SequenceAllInOneParser)",
                "-package com.baselet.element.facet.specific.sequence_aio.gen;",
                "-",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+package com.baselet.element.sequence_aio.facet.specific.gen;",
                " import com.baselet.control.enums.LineType;",
                "-import com.baselet.element.facet.specific.sequence_aio.Lifeline;",
                "-import com.baselet.element.facet.specific.sequence_aio.Message.ArrowType;",
                "-import com.baselet.element.facet.specific.sequence_aio.SequenceDiagramBuilder;",
                "-import com.baselet.element.facet.specific.sequence_aio.SequenceDiagramException;",
                "+import com.baselet.element.sequence_aio.facet.Lifeline;",
                "+import com.baselet.element.sequence_aio.facet.Message.ArrowType;",
                "+import com.baselet.element.sequence_aio.facet.SequenceDiagramBuilder;",
                "+import com.baselet.element.sequence_aio.facet.SequenceDiagramException;",
                "+",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;"
            ],
            "changed_files": [
                "umlet-elements/src/main/findbugs/findbugs-exclude.xml",
                "umlet-elements/src/main/java/com/baselet/element/elementnew/uml/SequenceAllInOne.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/CombinedFragment.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Container.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Continuation.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Coregion.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/DrawingInfo.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/DrawingInfoImpl.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/ExecutionSpecification.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/GateMessage.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/GeneralOrdering.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/HorizontalDrawingInfo.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/HorizontalDrawingInfoImpl.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/InteractionUse.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Lifeline.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineDrawingInfo.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineHorizontalDrawingInfo.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineHorizontalDrawingInfoImpl.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineOccurrence.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LifelineSpanningTickSpanningOccurrence.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/LostOrFoundMessage.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/Message.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/OccurrenceSpecification.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/PentagonDrawingHelper.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceAllInOneFacet.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagram.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagramBuilder.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagramCheckedException.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/SequenceDiagramException.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/StateInvariant.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/TextOnLifeline.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/VerticalDrawingInfo.java",
                "umlet-elements/src/main/java/com/baselet/element/sequence_aio/facet/VerticalDrawingInfoImpl.java",
                "umlet-elements/src/main/javacc/SequenceAllInOneParser.jj"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": [
                {
                    "id": "COMMIT_IN_REFERENCE",
                    "message": "This commit is mentioned 1 times in the references.",
                    "relevance": 64
                },
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: parse, contain",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "17f0791bc26fd62265298393d9f87c519320f6c8",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479550193,
            "hunks": 8,
            "message": "#289: new module which builds a p2 update site (for eclipse plugin)",
            "diff": [
                "diff --git a/pom.xml b/pom.xml",
                "index 339c7c9d..46736eed 100644",
                "--- a/pom.xml",
                "+++ b/pom.xml",
                "@@ -43,2 +43,3 @@",
                " \t\t<module>umlet-eclipse-plugin</module>",
                "+\t\t<module>umlet-eclipse-p2</module>",
                " \t\t<module>umlet-gwt</module>",
                "@@ -260,2 +261,15 @@",
                " \t\t\t\t\t\t\t\t</pluginExecution>",
                "+\t\t\t\t\t\t\t\t<pluginExecution>",
                "+\t\t\t\t\t\t\t\t\t<pluginExecutionFilter>",
                "+\t\t\t\t\t\t\t\t\t\t<groupId>org.reficio</groupId>",
                "+\t\t\t\t\t\t\t\t\t\t<artifactId>p2-maven-plugin</artifactId>",
                "+\t\t\t\t\t\t\t\t\t\t<versionRange>[1.1.1,)</versionRange>",
                "+\t\t\t\t\t\t\t\t\t\t<goals>",
                "+\t\t\t\t\t\t\t\t\t\t\t<goal>site</goal>",
                "+\t\t\t\t\t\t\t\t\t\t</goals>",
                "+\t\t\t\t\t\t\t\t\t</pluginExecutionFilter>",
                "+\t\t\t\t\t\t\t\t\t<action>",
                "+\t\t\t\t\t\t\t\t\t\t<ignore></ignore>",
                "+\t\t\t\t\t\t\t\t\t</action>",
                "+\t\t\t\t\t\t\t\t</pluginExecution>",
                " \t\t\t\t\t\t\t</pluginExecutions>",
                "diff --git a/umlet-eclipse-p2/.project b/umlet-eclipse-p2/.project",
                "new file mode 100644",
                "index 00000000..9a778cb2",
                "--- /dev/null",
                "+++ b/umlet-eclipse-p2/.project",
                "@@ -0,0 +1,17 @@",
                "+<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
                "+<projectDescription>",
                "+\t<name>umlet-eclipse-p2-builder</name>",
                "+\t<comment></comment>",
                "+\t<projects>",
                "+\t</projects>",
                "+\t<buildSpec>",
                "+\t\t<buildCommand>",
                "+\t\t\t<name>org.eclipse.m2e.core.maven2Builder</name>",
                "+\t\t\t<arguments>",
                "+\t\t\t</arguments>",
                "+\t\t</buildCommand>",
                "+\t</buildSpec>",
                "+\t<natures>",
                "+\t\t<nature>org.eclipse.m2e.core.maven2Nature</nature>",
                "+\t</natures>",
                "+</projectDescription>",
                "diff --git a/umlet-eclipse-p2/.settings/org.eclipse.core.resources.prefs b/umlet-eclipse-p2/.settings/org.eclipse.core.resources.prefs",
                "new file mode 100644",
                "index 00000000..4824b802",
                "--- /dev/null",
                "+++ b/umlet-eclipse-p2/.settings/org.eclipse.core.resources.prefs",
                "@@ -0,0 +1,2 @@",
                "+eclipse.preferences.version=1",
                "+encoding/<project>=UTF-8",
                "diff --git a/umlet-eclipse-p2/.settings/org.eclipse.m2e.core.prefs b/umlet-eclipse-p2/.settings/org.eclipse.m2e.core.prefs",
                "new file mode 100644",
                "index 00000000..14b697b7",
                "--- /dev/null",
                "+++ b/umlet-eclipse-p2/.settings/org.eclipse.m2e.core.prefs",
                "@@ -0,0 +1,4 @@",
                "+activeProfiles=",
                "+eclipse.preferences.version=1",
                "+resolveWorkspaceProjects=true",
                "+version=1",
                "diff --git a/umlet-eclipse-p2/assembly.xml b/umlet-eclipse-p2/assembly.xml",
                "new file mode 100644",
                "index 00000000..4f29c3ac",
                "--- /dev/null",
                "+++ b/umlet-eclipse-p2/assembly.xml",
                "@@ -0,0 +1,13 @@",
                "+<assembly xmlns=\"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd\">",
                "+\t<id>bin</id>",
                "+\t<formats>",
                "+\t\t<format>zip</format>",
                "+\t</formats>",
                "+\t<includeBaseDirectory>false</includeBaseDirectory>",
                "+\t<fileSets>",
                "+\t\t<fileSet>",
                "+\t\t\t<directory>${project.build.directory}/repository</directory>",
                "+\t\t\t<outputDirectory>repository</outputDirectory>",
                "+\t\t</fileSet>",
                "+\t</fileSets>",
                "+</assembly>",
                "diff --git a/umlet-eclipse-p2/pom.xml b/umlet-eclipse-p2/pom.xml",
                "new file mode 100644",
                "index 00000000..bf925e2e",
                "--- /dev/null",
                "+++ b/umlet-eclipse-p2/pom.xml",
                "@@ -0,0 +1,63 @@",
                "+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">",
                "+\t<modelVersion>4.0.0</modelVersion>",
                "+",
                "+\t<parent>",
                "+\t\t<groupId>com.umlet</groupId>",
                "+\t\t<artifactId>umlet-parent</artifactId>",
                "+\t\t<version>14.3.0-SNAPSHOT</version>",
                "+\t</parent>",
                "+",
                "+\t<artifactId>umlet-eclipse-p2</artifactId>",
                "+\t<packaging>pom</packaging>",
                "+",
                "+\t<description>",
                "+\tThis module publishes the eclipse plugin to a p2 repository (for an eclipse update site).",
                "+\tIt is a separate module to make sure it runs after the umlet eclipse plugin is installed in the local mvn repository.",
                "+\tIf umlet is published to maven central in the future, this module could be removed and the p2 generation can be done during the deploy phase (then the artifact is already pushed to maven central).",
                "+\t</description>",
                "+",
                "+\t<build>",
                "+\t\t<plugins>",
                "+\t\t\t<!-- generate p2 repo for Eclipse update site (published on GitHub) -->",
                "+\t\t\t<plugin>",
                "+\t\t\t\t<groupId>org.reficio</groupId>",
                "+\t\t\t\t<artifactId>p2-maven-plugin</artifactId>",
                "+\t\t\t\t<version>1.1.1</version>",
                "+\t\t\t\t<executions>",
                "+\t\t\t\t\t<execution>",
                "+\t\t\t\t\t\t<id>default-cli</id>",
                "+\t\t\t\t\t\t<phase>install</phase>",
                "+\t\t\t\t\t\t<goals>",
                "+\t\t\t\t\t\t\t<goal>site</goal>",
                "+\t\t\t\t\t\t</goals>",
                "+\t\t\t\t\t\t<configuration>",
                "+\t\t\t\t\t\t\t<artifacts>",
                "+\t\t\t\t\t\t\t\t<artifact>",
                "+\t\t\t\t\t\t\t\t\t<id>com.umlet:com.umlet.plugin:jar:${project.version}</id>",
                "+\t\t\t\t\t\t\t\t</artifact>",
                "+\t\t\t\t\t\t\t</artifacts>",
                "+\t\t\t\t\t\t</configuration>",
                "+\t\t\t\t\t</execution>",
                "+\t\t\t\t</executions>",
                "+\t\t\t</plugin>",
                "+\t\t\t<!-- assemble P2 Repo as zip file -->",
                "+\t\t\t<plugin>",
                "+\t\t\t\t<artifactId>maven-assembly-plugin</artifactId>",
                "+\t\t\t\t<version>2.5.3</version>",
                "+\t\t\t\t<configuration>",
                "+\t\t\t\t\t<descriptor>assembly.xml</descriptor>",
                "+\t\t\t\t\t<appendAssemblyId>false</appendAssemblyId>",
                "+\t\t\t\t</configuration>",
                "+\t\t\t\t<executions>",
                "+\t\t\t\t\t<execution>",
                "+\t\t\t\t\t\t<id>create-archive</id>",
                "+\t\t\t\t\t\t<phase>install</phase>",
                "+\t\t\t\t\t\t<goals>",
                "+\t\t\t\t\t\t\t<goal>single</goal>",
                "+\t\t\t\t\t\t</goals>",
                "+\t\t\t\t\t</execution>",
                "+\t\t\t\t</executions>",
                "+\t\t\t</plugin>",
                "+\t\t</plugins>",
                "+\t</build>",
                "+</project>",
                "\\ No newline at end of file",
                "diff --git a/umlet-eclipse-plugin/pom.xml b/umlet-eclipse-plugin/pom.xml",
                "index 7cde9764..dd043185 100644",
                "--- a/umlet-eclipse-plugin/pom.xml",
                "+++ b/umlet-eclipse-plugin/pom.xml",
                "@@ -174,20 +174,2 @@",
                " \t\t\t</plugin>",
                "-\t\t\t<!-- assemble UMLetino output as zip file -->",
                "-\t\t\t<plugin>",
                "-\t\t\t\t<artifactId>maven-assembly-plugin</artifactId>",
                "-\t\t\t\t<version>2.5.3</version>",
                "-\t\t\t\t<configuration>",
                "-\t\t\t\t\t<descriptor>src/assembly/dep.xml</descriptor>",
                "-\t\t\t\t\t<appendAssemblyId>false</appendAssemblyId>",
                "-\t\t\t\t</configuration>",
                "-\t\t\t\t<executions>",
                "-\t\t\t\t\t<execution>",
                "-\t\t\t\t\t\t<id>create-archive</id>",
                "-\t\t\t\t\t\t<phase>package</phase>",
                "-\t\t\t\t\t\t<goals>",
                "-\t\t\t\t\t\t\t<goal>single</goal>",
                "-\t\t\t\t\t\t</goals>",
                "-\t\t\t\t\t</execution>",
                "-\t\t\t\t</executions>",
                "-\t\t\t</plugin>",
                " \t\t\t<plugin>"
            ],
            "changed_files": [
                "pom.xml",
                "umlet-eclipse-p2/.project",
                "umlet-eclipse-p2/.settings/org.eclipse.core.resources.prefs",
                "umlet-eclipse-p2/.settings/org.eclipse.m2e.core.prefs",
                "umlet-eclipse-p2/assembly.xml",
                "umlet-eclipse-p2/pom.xml",
                "umlet-eclipse-plugin/pom.xml"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {
                "289": "Installation via Eclipse Marketplace #465"
            },
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": [
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: XML",
                    "relevance": 8
                },
                {
                    "id": "GITHUB_ISSUE_IN_MESSAGE",
                    "message": "The commit message references some github issue: 289",
                    "relevance": 2
                }
            ]
        },
        {
            "commit_id": "15d615b5a7d125545ab67fe6dd5649c59c406a5b",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479633537,
            "hunks": 0,
            "message": "Merge pull request #411 from afdia/master #289: new module which builds a p2 update site (for eclipse plugin)",
            "diff": [],
            "changed_files": [],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {
                "411": "",
                "289": "Installation via Eclipse Marketplace #465"
            },
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": [
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: request",
                    "relevance": 4
                },
                {
                    "id": "GITHUB_ISSUE_IN_MESSAGE",
                    "message": "The commit message references some github issue: 411, 289",
                    "relevance": 2
                }
            ]
        },
        {
            "commit_id": "0392937975c38236239db9a653f618300a3e20eb",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479547631,
            "hunks": 17,
            "message": "org imports",
            "diff": [
                "diff --git a/umlet-eclipse-plugin/src/main/java/com/baselet/plugin/refactoring/MoveClassParticipant.java b/umlet-eclipse-plugin/src/main/java/com/baselet/plugin/refactoring/MoveClassParticipant.java",
                "index b7ce20cd..c5ce3352 100644",
                "--- a/umlet-eclipse-plugin/src/main/java/com/baselet/plugin/refactoring/MoveClassParticipant.java",
                "+++ b/umlet-eclipse-plugin/src/main/java/com/baselet/plugin/refactoring/MoveClassParticipant.java",
                "@@ -19,3 +19,2 @@ import org.eclipse.text.edits.ReplaceEdit;",
                " import com.baselet.plugin.UmletPluginUtils;",
                "-import com.baselet.plugin.refactoring.JavaDocParser.HtmlTagAttr;",
                " import com.baselet.plugin.refactoring.JavaDocParser.SourceString;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/diagram/DrawPanel.java b/umlet-swing/src/main/java/com/baselet/diagram/DrawPanel.java",
                "index c02aef42..70df32fa 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/diagram/DrawPanel.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/diagram/DrawPanel.java",
                "@@ -25,3 +25,4 @@ import javax.swing.ScrollPaneConstants;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/diagram/SelectorFrame.java b/umlet-swing/src/main/java/com/baselet/diagram/SelectorFrame.java",
                "index 9003a33d..f3437438 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/diagram/SelectorFrame.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/diagram/SelectorFrame.java",
                "@@ -8,3 +8,4 @@ import javax.swing.JComponent;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/diagram/io/DiagramFileHandler.java b/umlet-swing/src/main/java/com/baselet/diagram/io/DiagramFileHandler.java",
                "index 45a8aae7..2ff3b171 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/diagram/io/DiagramFileHandler.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/diagram/io/DiagramFileHandler.java",
                "@@ -30,3 +30,4 @@ import javax.xml.transform.stream.StreamResult;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                " import org.w3c.dom.Document;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/diagram/io/InputHandler.java b/umlet-swing/src/main/java/com/baselet/diagram/io/InputHandler.java",
                "index 346d851a..c5777ea4 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/diagram/io/InputHandler.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/diagram/io/InputHandler.java",
                "@@ -5,3 +5,4 @@ import java.util.List;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                " import org.xml.sax.Attributes;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/element/old/custom/CustomElementCompiler.java b/umlet-swing/src/main/java/com/baselet/element/old/custom/CustomElementCompiler.java",
                "index 72cd6ef9..82fd6109 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/element/old/custom/CustomElementCompiler.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/element/old/custom/CustomElementCompiler.java",
                "@@ -15,3 +15,4 @@ import java.util.regex.Pattern;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/generator/java/bcel/BcelJavaClass.java b/umlet-swing/src/main/java/com/baselet/generator/java/bcel/BcelJavaClass.java",
                "index d2e62db7..16150b1e 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/generator/java/bcel/BcelJavaClass.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/generator/java/bcel/BcelJavaClass.java",
                "@@ -8,3 +8,4 @@ import org.apache.bcel.classfile.JavaClass;",
                " import org.apache.bcel.classfile.Method;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/generator/java/jp/JpJavaClass.java b/umlet-swing/src/main/java/com/baselet/generator/java/jp/JpJavaClass.java",
                "index 9877d87f..88c55f05 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/generator/java/jp/JpJavaClass.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/generator/java/jp/JpJavaClass.java",
                "@@ -7,3 +7,4 @@ import java.util.List;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/gui/BaseGUI.java b/umlet-swing/src/main/java/com/baselet/gui/BaseGUI.java",
                "index f92e98bd..2409544f 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/gui/BaseGUI.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/gui/BaseGUI.java",
                "@@ -14,3 +14,4 @@ import javax.swing.plaf.InsetsUIResource;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/gui/BrowserLauncher.java b/umlet-swing/src/main/java/com/baselet/gui/BrowserLauncher.java",
                "index d1d983ef..dfc77bbf 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/gui/BrowserLauncher.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/gui/BrowserLauncher.java",
                "@@ -9,3 +9,4 @@ import java.util.Scanner;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/gui/MailPanel.java b/umlet-swing/src/main/java/com/baselet/gui/MailPanel.java",
                "index 8ced62ab..535e1545 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/gui/MailPanel.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/gui/MailPanel.java",
                "@@ -38,3 +38,4 @@ import javax.swing.UIManager;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/gui/command/AddElement.java b/umlet-swing/src/main/java/com/baselet/gui/command/AddElement.java",
                "index fc7c1066..479b34ac 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/gui/command/AddElement.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/gui/command/AddElement.java",
                "@@ -4,3 +4,4 @@ import java.awt.Point;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/gui/command/Move.java b/umlet-swing/src/main/java/com/baselet/gui/command/Move.java",
                "index 86a33e40..90fefe54 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/gui/command/Move.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/gui/command/Move.java",
                "@@ -4,3 +4,4 @@ import java.util.Collection;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/gui/filedrop/FileDrop.java b/umlet-swing/src/main/java/com/baselet/gui/filedrop/FileDrop.java",
                "index d39824ec..ac7d3759 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/gui/filedrop/FileDrop.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/gui/filedrop/FileDrop.java",
                "@@ -10,4 +10,2 @@ import java.io.Reader;",
                "-import com.baselet.gui.filedrop.FileDrop.TransferableObject;",
                "-",
                " /**",
                "diff --git a/umlet-swing/src/main/java/com/baselet/gui/filedrop/FileDropListener.java b/umlet-swing/src/main/java/com/baselet/gui/filedrop/FileDropListener.java",
                "index face4226..afbc5a37 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/gui/filedrop/FileDropListener.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/gui/filedrop/FileDropListener.java",
                "@@ -7,3 +7,4 @@ import java.util.List;",
                "-import org.slf4j.Logger;import org.slf4j.LoggerFactory;",
                "+import org.slf4j.Logger;",
                "+import org.slf4j.LoggerFactory;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/plugin/refactoring/JavaDocParser.java b/umlet-swing/src/main/java/com/baselet/plugin/refactoring/JavaDocParser.java",
                "index e6c5d231..c4bbc182 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/plugin/refactoring/JavaDocParser.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/plugin/refactoring/JavaDocParser.java",
                "@@ -2,4 +2,4 @@ package com.baselet.plugin.refactoring;",
                "-import java.util.List;",
                " import java.util.ArrayList;",
                "+import java.util.List;"
            ],
            "changed_files": [
                "umlet-eclipse-plugin/src/main/java/com/baselet/plugin/refactoring/MoveClassParticipant.java",
                "umlet-swing/src/main/java/com/baselet/diagram/DrawPanel.java",
                "umlet-swing/src/main/java/com/baselet/diagram/SelectorFrame.java",
                "umlet-swing/src/main/java/com/baselet/diagram/io/DiagramFileHandler.java",
                "umlet-swing/src/main/java/com/baselet/diagram/io/InputHandler.java",
                "umlet-swing/src/main/java/com/baselet/element/old/custom/CustomElementCompiler.java",
                "umlet-swing/src/main/java/com/baselet/generator/java/bcel/BcelJavaClass.java",
                "umlet-swing/src/main/java/com/baselet/generator/java/jp/JpJavaClass.java",
                "umlet-swing/src/main/java/com/baselet/gui/BaseGUI.java",
                "umlet-swing/src/main/java/com/baselet/gui/BrowserLauncher.java",
                "umlet-swing/src/main/java/com/baselet/gui/MailPanel.java",
                "umlet-swing/src/main/java/com/baselet/gui/command/AddElement.java",
                "umlet-swing/src/main/java/com/baselet/gui/command/Move.java",
                "umlet-swing/src/main/java/com/baselet/gui/filedrop/FileDrop.java",
                "umlet-swing/src/main/java/com/baselet/gui/filedrop/FileDropListener.java",
                "umlet-swing/src/main/java/com/baselet/plugin/refactoring/JavaDocParser.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": [
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: file, parse",
                    "relevance": 4
                }
            ]
        },
        {
            "commit_id": "b983c4388cdb2b1a35b13499e6a249995fa64f5e",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479633901,
            "hunks": 1,
            "message": "#408 fontsize and lw max increased from 100 to 1000",
            "diff": [
                "diff --git a/umlet-elements/src/main/java/com/baselet/diagram/draw/DrawHandler.java b/umlet-elements/src/main/java/com/baselet/diagram/draw/DrawHandler.java",
                "index df6a5bd6..c8bd5750 100644",
                "--- a/umlet-elements/src/main/java/com/baselet/diagram/draw/DrawHandler.java",
                "+++ b/umlet-elements/src/main/java/com/baselet/diagram/draw/DrawHandler.java",
                "@@ -211,4 +211,4 @@ public abstract class DrawHandler {",
                " \tprivate void assertDoubleRange(double doubleValue) {",
                "-\t\tif (doubleValue < 0 || doubleValue > 100) {",
                "-\t\t\tthrow new StyleException(\"value must be >=0 and <=100\");",
                "+\t\tif (doubleValue < 0 || doubleValue > 1000) {",
                "+\t\t\tthrow new StyleException(\"value must be >=0 and <=1000\");",
                " \t\t}"
            ],
            "changed_files": [
                "umlet-elements/src/main/java/com/baselet/diagram/draw/DrawHandler.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {
                "408": ""
            },
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": [
                {
                    "id": "GITHUB_ISSUE_IN_MESSAGE",
                    "message": "The commit message references some github issue: 408",
                    "relevance": 2
                }
            ]
        },
        {
            "commit_id": "bc4285506faec9400d74e23e1049621055bd079d",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479806840,
            "hunks": 1,
            "message": "#416: \"=\" can occur in r1/r2/m1/m2 value of relations",
            "diff": [
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/relation/facet/LineDescriptionFacet.java b/umlet-elements/src/main/java/com/baselet/element/relation/facet/LineDescriptionFacet.java",
                "index 2a7a0361..bbb8f6c1 100644",
                "--- a/umlet-elements/src/main/java/com/baselet/element/relation/facet/LineDescriptionFacet.java",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/relation/facet/LineDescriptionFacet.java",
                "@@ -109,4 +109,3 @@ public class LineDescriptionFacet extends FirstRunFacet {",
                " \t\t\tLineDescriptionEnum enumVal = LineDescriptionEnum.forString(line);",
                "-\t\t\tString[] split = line.split(KeyValueFacet.SEP, -1);",
                "-\t\t\tString text = split[1];",
                "+\t\t\tString text = line.substring(line.indexOf(KeyValueFacet.SEP) + 1);",
                " \t\t\tif (!text.isEmpty()) {"
            ],
            "changed_files": [
                "umlet-elements/src/main/java/com/baselet/element/relation/facet/LineDescriptionFacet.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {
                "416": "Lines not displaying full text when using \"r1=\" and \"=\" #459"
            },
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": [
                {
                    "id": "GITHUB_ISSUE_IN_MESSAGE",
                    "message": "The commit message references some github issue: 416",
                    "relevance": 2
                }
            ]
        },
        {
            "commit_id": "9a54824f47182f1cf048fe5aa2d3a9dd1a889bf2",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479634999,
            "hunks": 1,
            "message": "#408 fontsize and lw max increased to 5000",
            "diff": [
                "diff --git a/umlet-elements/src/main/java/com/baselet/diagram/draw/DrawHandler.java b/umlet-elements/src/main/java/com/baselet/diagram/draw/DrawHandler.java",
                "index c8bd5750..b18073f9 100644",
                "--- a/umlet-elements/src/main/java/com/baselet/diagram/draw/DrawHandler.java",
                "+++ b/umlet-elements/src/main/java/com/baselet/diagram/draw/DrawHandler.java",
                "@@ -211,4 +211,4 @@ public abstract class DrawHandler {",
                " \tprivate void assertDoubleRange(double doubleValue) {",
                "-\t\tif (doubleValue < 0 || doubleValue > 1000) {",
                "-\t\t\tthrow new StyleException(\"value must be >=0 and <=1000\");",
                "+\t\tif (doubleValue < 0 || doubleValue > 5000) {",
                "+\t\t\tthrow new StyleException(\"value must be >=0 and <=5000\");",
                " \t\t}"
            ],
            "changed_files": [
                "umlet-elements/src/main/java/com/baselet/diagram/draw/DrawHandler.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {
                "408": ""
            },
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": [
                {
                    "id": "GITHUB_ISSUE_IN_MESSAGE",
                    "message": "The commit message references some github issue: 408",
                    "relevance": 2
                }
            ]
        },
        {
            "commit_id": "8ff29d147f80deeb2e85355f49c53d6f879e0c2c",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1523206302,
            "hunks": 40,
            "message": "#445 mnemonics for all menu items (matching eclipse keys if possible)",
            "diff": [
                "diff --git a/umlet-swing/src/main/java/com/baselet/gui/menu/MenuFactorySwing.java b/umlet-swing/src/main/java/com/baselet/gui/menu/MenuFactorySwing.java",
                "index 3e6969b4..ecb7d5ff 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/gui/menu/MenuFactorySwing.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/gui/menu/MenuFactorySwing.java",
                "@@ -45,2 +45,4 @@ import java.awt.event.ActionListener;",
                " import java.awt.event.KeyEvent;",
                "+import java.util.Arrays;",
                "+import java.util.Iterator;",
                " import java.util.Locale;",
                "@@ -83,3 +85,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createClose() {",
                "-\t\treturn createJMenuItem(false, CLOSE, KeyEvent.VK_W, true, null);",
                "+\t\treturn createJMenuItem(false, CLOSE, CLOSE, KeyEvent.VK_C, KeyEvent.VK_W, true, null);",
                " \t}",
                "@@ -89,2 +91,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \t\trecentFiles.setText(RECENT_FILES);",
                "+\t\trecentFiles.setMnemonic(KeyEvent.VK_R);",
                " \t\trecentFiles.addMenuListener(new MenuListener() {",
                "@@ -99,4 +102,8 @@ public class MenuFactorySwing extends MenuFactory {",
                " \t\t\t\trecentFiles.removeAll();",
                "+\t\t\t\tIterator<Integer> mnemonicsIter = Arrays.asList(KeyEvent.VK_1, KeyEvent.VK_2, KeyEvent.VK_3, KeyEvent.VK_4, KeyEvent.VK_5, KeyEvent.VK_6, KeyEvent.VK_7, KeyEvent.VK_8, KeyEvent.VK_9, KeyEvent.VK_0).iterator();",
                "+\t\t\t\tIterator<Integer> prefixIter = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0).iterator();",
                " \t\t\t\tfor (String file : RecentlyUsedFilesList.getInstance()) {",
                "-\t\t\t\t\trecentFiles.add(createJMenuItem(false, file, RECENT_FILES, file));",
                "+\t\t\t\t\tInteger mnemonic = mnemonicsIter.hasNext() ? mnemonicsIter.next() : null;",
                "+\t\t\t\t\tString prefix = prefixIter.hasNext() ? prefixIter.next().toString() : \"\";",
                "+\t\t\t\t\trecentFiles.add(createJMenuItem(false, prefix + \" \" + file, RECENT_FILES, mnemonic, null, file));",
                " \t\t\t\t}",
                "@@ -108,3 +115,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createGenerate() {",
                "-\t\treturn createJMenuItem(false, GENERATE_CLASS, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, GENERATE_CLASS, KeyEvent.VK_G);",
                " \t}",
                "@@ -112,3 +119,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createGenerateOptions() {",
                "-\t\treturn createJMenuItem(false, GENERATE_CLASS_OPTIONS, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, GENERATE_CLASS_OPTIONS, KeyEvent.VK_I);",
                " \t}",
                "@@ -120,3 +127,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createSaveAs() {",
                "-\t\treturn createJMenuItem(true, SAVE_AS, null);",
                "+\t\treturn createJMenuItemNoShortcut(true, SAVE_AS, KeyEvent.VK_A);",
                " \t}",
                "@@ -126,5 +133,6 @@ public class MenuFactorySwing extends MenuFactory {",
                " \t\texport.setText(EXPORT_AS);",
                "+\t\texport.setMnemonic(KeyEvent.VK_E);",
                " \t\tdiagramDependendComponents.add(export);",
                " \t\tfor (final String format : Constants.exportFormatList) {",
                "-\t\t\texport.add(createJMenuItem(true, format.toUpperCase(Locale.ENGLISH) + \"...\", EXPORT_AS, format));",
                "+\t\t\texport.add(createJMenuItem(true, format.toUpperCase(Locale.ENGLISH) + \"...\", EXPORT_AS, exportMnemonic(format), null, format));",
                " \t\t}",
                "@@ -133,2 +141,27 @@ public class MenuFactorySwing extends MenuFactory {",
                "+\tprivate Integer exportMnemonic(String format) {",
                "+\t\tif (\"bmp\".equals(format)) {",
                "+\t\t\treturn KeyEvent.VK_B;",
                "+\t\t}",
                "+\t\tif (\"eps\".equals(format)) {",
                "+\t\t\treturn KeyEvent.VK_E;",
                "+\t\t}",
                "+\t\tif (\"gif\".equals(format)) {",
                "+\t\t\treturn KeyEvent.VK_G;",
                "+\t\t}",
                "+\t\tif (\"jpg\".equals(format)) {",
                "+\t\t\treturn KeyEvent.VK_J;",
                "+\t\t}",
                "+\t\tif (\"pdf\".equals(format)) {",
                "+\t\t\treturn KeyEvent.VK_P;",
                "+\t\t}",
                "+\t\tif (\"png\".equals(format)) {",
                "+\t\t\treturn KeyEvent.VK_N;",
                "+\t\t}",
                "+\t\tif (\"svg\".equals(format)) {",
                "+\t\t\treturn KeyEvent.VK_S;",
                "+\t\t}",
                "+\t\treturn null;",
                "+\t}",
                "+",
                " \tpublic JMenuItem createMailTo() {",
                "@@ -138,3 +171,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createEditCurrentPalette() {",
                "-\t\treturn createJMenuItem(false, EDIT_CURRENT_PALETTE, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, EDIT_CURRENT_PALETTE, KeyEvent.VK_D);",
                " \t}",
                "@@ -142,3 +175,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createOptions() {",
                "-\t\treturn createJMenuItem(false, OPTIONS, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, OPTIONS, KeyEvent.VK_T);",
                " \t}",
                "@@ -150,3 +183,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createExit() {",
                "-\t\treturn createJMenuItem(false, EXIT, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, EXIT, KeyEvent.VK_X);",
                " \t}",
                "@@ -154,3 +187,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createUndo() {",
                "-\t\treturn createJMenuItem(false, UNDO, KeyEvent.VK_Z, true, null);",
                "+\t\treturn createJMenuItem(false, UNDO, UNDO, KeyEvent.VK_U, KeyEvent.VK_Z, true, null);",
                " \t}",
                "@@ -158,3 +191,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createRedo() {",
                "-\t\treturn createJMenuItem(false, REDO, KeyEvent.VK_Y, true, null);",
                "+\t\treturn createJMenuItem(false, REDO, REDO, KeyEvent.VK_R, KeyEvent.VK_Y, true, null);",
                " \t}",
                "@@ -164,6 +197,6 @@ public class MenuFactorySwing extends MenuFactory {",
                " \t\tif (SystemInfo.OS == Os.MAC) { // MacOS shows the backspace key mapping because it's the only one working - see http://stackoverflow.com/questions/4881262/java-keystroke-for-delete/4881606#4881606",
                "-\t\t\treturn createJMenuItem(false, DELETE, keys, KeyEvent.VK_BACK_SPACE);",
                "+\t\t\treturn createJMenuItem(false, DELETE, keys, KeyEvent.VK_D, KeyEvent.VK_BACK_SPACE);",
                " \t\t}",
                " \t\telse {",
                "-\t\t\treturn createJMenuItem(false, DELETE, keys, KeyEvent.VK_DELETE);",
                "+\t\t\treturn createJMenuItem(false, DELETE, keys, KeyEvent.VK_D, KeyEvent.VK_DELETE);",
                " \t\t}",
                "@@ -180,3 +213,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createUngroup() {",
                "-\t\treturn createJMenuItem(false, UNGROUP, KeyEvent.VK_U, true, null);",
                "+\t\treturn createJMenuItem(false, UNGROUP, UNGROUP, KeyEvent.VK_N, KeyEvent.VK_U, true, null);",
                " \t}",
                "@@ -184,3 +217,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createCut() {",
                "-\t\treturn createJMenuItem(false, CUT, KeyEvent.VK_X, true, null);",
                "+\t\treturn createJMenuItem(false, CUT, CUT, KeyEvent.VK_T, KeyEvent.VK_X, true, null);",
                " \t}",
                "@@ -192,3 +225,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createPaste() {",
                "-\t\treturn createJMenuItem(false, PASTE, KeyEvent.VK_V, true, null);",
                "+\t\treturn createJMenuItem(false, PASTE, PASTE, KeyEvent.VK_P, KeyEvent.VK_V, true, null);",
                " \t}",
                "@@ -196,3 +229,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createNewCustomElement() {",
                "-\t\treturn createJMenuItem(false, NEW_CE, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, NEW_CE, KeyEvent.VK_N);",
                " \t}",
                "@@ -201,4 +234,9 @@ public class MenuFactorySwing extends MenuFactory {",
                " \t\tJMenu menu = new JMenu(NEW_FROM_TEMPLATE);",
                "+\t\tmenu.setMnemonic(KeyEvent.VK_E);",
                "+\t\tIterator<Integer> mnemonicsIter = Arrays.asList(KeyEvent.VK_1, KeyEvent.VK_2, KeyEvent.VK_3, KeyEvent.VK_4, KeyEvent.VK_5, KeyEvent.VK_6, KeyEvent.VK_7, KeyEvent.VK_8, KeyEvent.VK_9, KeyEvent.VK_0).iterator();",
                "+\t\tIterator<Integer> prefixIter = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0).iterator();",
                " \t\tfor (String template : Main.getInstance().getTemplateNames()) {",
                "-\t\t\tmenu.add(createJMenuItem(false, template, NEW_FROM_TEMPLATE, template));",
                "+\t\t\tInteger mnemonic = mnemonicsIter.hasNext() ? mnemonicsIter.next() : null;",
                "+\t\t\tString prefix = prefixIter.hasNext() ? prefixIter.next().toString() : \"\";",
                "+\t\t\tmenu.add(createJMenuItem(false, prefix + \" \" + template, NEW_FROM_TEMPLATE, mnemonic, null, null, template));",
                " \t\t}",
                "@@ -208,3 +246,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createEditSelected() {",
                "-\t\treturn createJMenuItem(false, EDIT_SELECTED, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, EDIT_SELECTED, KeyEvent.VK_D);",
                " \t}",
                "@@ -212,3 +250,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createCustomElementTutorial() {",
                "-\t\treturn createJMenuItem(false, CUSTOM_ELEMENTS_TUTORIAL, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, CUSTOM_ELEMENTS_TUTORIAL, KeyEvent.VK_T);",
                " \t}",
                "@@ -216,3 +254,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createOnlineHelp() {",
                "-\t\treturn createJMenuItem(false, ONLINE_HELP, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, ONLINE_HELP, KeyEvent.VK_H);",
                " \t}",
                "@@ -220,3 +258,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createOnlineSampleDiagrams() {",
                "-\t\treturn createJMenuItem(false, ONLINE_SAMPLE_DIAGRAMS, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, ONLINE_SAMPLE_DIAGRAMS, KeyEvent.VK_S);",
                " \t}",
                "@@ -224,3 +262,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createVideoTutorials() {",
                "-\t\treturn createJMenuItem(false, VIDEO_TUTORIAL, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, VIDEO_TUTORIAL, KeyEvent.VK_T);",
                " \t}",
                "@@ -228,3 +266,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createProgramHomepage() {",
                "-\t\treturn createJMenuItem(false, PROGRAM_HOMEPAGE, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, PROGRAM_HOMEPAGE, KeyEvent.VK_U);",
                " \t}",
                "@@ -232,3 +270,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createRateProgram() {",
                "-\t\treturn createJMenuItem(false, RATE_PROGRAM, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, RATE_PROGRAM, KeyEvent.VK_R);",
                " \t}",
                "@@ -248,3 +286,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tpublic JMenuItem createAboutProgram() {",
                "-\t\treturn createJMenuItem(false, ABOUT_PROGRAM, null);",
                "+\t\treturn createJMenuItemNoShortcut(false, ABOUT_PROGRAM, KeyEvent.VK_A);",
                " \t}",
                "@@ -267,4 +305,4 @@ public class MenuFactorySwing extends MenuFactory {",
                "-\tprivate JMenuItem createJMenuItem(boolean grayWithoutDiagram, final String name, Object param) {",
                "-\t\treturn createJMenuItem(grayWithoutDiagram, name, name, null, null, param);",
                "+\tprivate JMenuItem createJMenuItemNoShortcut(boolean grayWithoutDiagram, final String name, Integer mnemonic) {",
                "+\t\treturn createJMenuItem(grayWithoutDiagram, name, mnemonic, null, null); // because meta is null, no shortcut is created (only the mnemonic)",
                " \t}",
                "@@ -280,2 +318,6 @@ public class MenuFactorySwing extends MenuFactory {",
                " \tprivate JMenuItem createJMenuItem(boolean grayWithoutDiagram, final String menuName, final String actionName, Integer mnemonic, Boolean meta, final Object param) {",
                "+\t\treturn createJMenuItem(grayWithoutDiagram, menuName, actionName, mnemonic, mnemonic, meta, param);",
                "+\t}",
                "+",
                "+\tprivate JMenuItem createJMenuItem(boolean grayWithoutDiagram, final String menuName, final String actionName, Integer mnemonic, Integer shortcut, Boolean meta, final Object param) {",
                " \t\tJMenuItem menuItem = new JMenuItem(menuName);",
                "@@ -283,3 +325,5 @@ public class MenuFactorySwing extends MenuFactory {",
                " \t\t\tmenuItem.setMnemonic(mnemonic);",
                "-\t\t\tmenuItem.setAccelerator(KeyStroke.getKeyStroke(mnemonic, !meta ? 0 : SystemInfo.META_KEY.getMask()));",
                "+\t\t\tif (meta != null && shortcut != null) {",
                "+\t\t\t\tmenuItem.setAccelerator(KeyStroke.getKeyStroke(shortcut, !meta ? 0 : SystemInfo.META_KEY.getMask()));",
                "+\t\t\t}",
                " \t\t}",
                "@@ -301,6 +345,5 @@ public class MenuFactorySwing extends MenuFactory {",
                " \t */",
                "-\tprivate JMenuItem createJMenuItem(boolean grayWithoutDiagram, final String name, int[] keyEvents, int preferredMnemonic) {",
                "+\tprivate JMenuItem createJMenuItem(boolean grayWithoutDiagram, final String name, int[] keyEvents, int mnemonic, int shortcut) {",
                " \t\tJMenuItem menuItem = new JMenuItem(name);",
                "-",
                "-\t\tMultipleKeyBindingsAction action = new MultipleKeyBindingsAction(name, preferredMnemonic);",
                "+\t\tMultipleKeyBindingsAction action = new MultipleKeyBindingsAction(name, shortcut);",
                " \t\tfor (int keyEvent : keyEvents) {",
                "@@ -310,2 +353,3 @@ public class MenuFactorySwing extends MenuFactory {",
                " \t\tmenuItem.setAction(action);",
                "+\t\tmenuItem.setMnemonic(mnemonic);",
                "@@ -324,5 +368,5 @@ public class MenuFactorySwing extends MenuFactory {",
                "-\t\tpublic MultipleKeyBindingsAction(String menuName, int preferredMnemonic) {",
                "+\t\tpublic MultipleKeyBindingsAction(String menuName, int shortcut) {",
                " \t\t\tsuper(menuName);",
                "-\t\t\tputValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(preferredMnemonic, 0));",
                "+\t\t\tputValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(shortcut, 0));",
                " \t\t}"
            ],
            "changed_files": [
                "umlet-swing/src/main/java/com/baselet/gui/menu/MenuFactorySwing.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {
                "445": "Quick export from the menu bar #501"
            },
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": [
                {
                    "id": "GITHUB_ISSUE_IN_MESSAGE",
                    "message": "The commit message references some github issue: 445",
                    "relevance": 2
                }
            ]
        },
        {
            "commit_id": "d23ed1c2204643c07d54b09616904a8230f4b510",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479634023,
            "hunks": 0,
            "message": "Merge branch 'master' of https://github.com/umlet/umlet",
            "diff": [],
            "changed_files": [],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": []
        },
        {
            "commit_id": "ada0b402b19d79e426c0bc61b208230450b262aa",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479900435,
            "hunks": 1,
            "message": "Bundle-Name: UMlet is now Bundle-Name: UMLet",
            "diff": [
                "diff --git a/umlet-eclipse-plugin/META-INF/MANIFEST.MF b/umlet-eclipse-plugin/META-INF/MANIFEST.MF",
                "index 1ac7fa26..9895f04b 100644",
                "--- a/umlet-eclipse-plugin/META-INF/MANIFEST.MF",
                "+++ b/umlet-eclipse-plugin/META-INF/MANIFEST.MF",
                "@@ -4,3 +4,3 @@ Created-By: 1.8.0_65-b17 (Oracle Corporation)",
                " Bundle-ManifestVersion: 2",
                "-Bundle-Name: UMlet",
                "+Bundle-Name: UMLet",
                " Bundle-SymbolicName: com.umlet.plugin;singleton:=true"
            ],
            "changed_files": [
                "umlet-eclipse-plugin/META-INF/MANIFEST.MF"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": []
        },
        {
            "commit_id": "0835592530173c0c76c39018da87798fbdd238e4",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479549825,
            "hunks": 3,
            "message": "fixed findbugs after seq aio package change",
            "diff": [
                "diff --git a/umlet-elements/src/main/findbugs/findbugs-exclude.xml b/umlet-elements/src/main/findbugs/findbugs-exclude.xml",
                "index e1cd050d..9e70c61e 100644",
                "--- a/umlet-elements/src/main/findbugs/findbugs-exclude.xml",
                "+++ b/umlet-elements/src/main/findbugs/findbugs-exclude.xml",
                "@@ -2,3 +2,3 @@",
                "   <Match>",
                "-    <Package name=\"~com.baselet.element.sequence_aio.gen.facet.specific.*\" />",
                "+    <Package name=\"~com.baselet.element.sequence_aio.gen.facet.*\" />",
                "   </Match>",
                "@@ -7,2 +7,2 @@",
                "   </Match>",
                "-</FindBugsFilter>",
                "\\ No newline at end of file",
                "+</FindBugsFilter>"
            ],
            "changed_files": [
                "umlet-elements/src/main/findbugs/findbugs-exclude.xml"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": []
        },
        {
            "commit_id": "35a1cf3344d0a88810d4c25ddb58436772ff8458",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479547736,
            "hunks": 18,
            "message": "CursorOwn moved",
            "diff": [
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/NewGridElement.java b/umlet-elements/src/main/java/com/baselet/element/NewGridElement.java",
                "index 9246dafa..6fea60a6 100644",
                "--- a/umlet-elements/src/main/java/com/baselet/element/NewGridElement.java",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/NewGridElement.java",
                "@@ -37,2 +37,3 @@ import com.baselet.element.facet.common.LayerFacet;",
                " import com.baselet.element.interfaces.Component;",
                "+import com.baselet.element.interfaces.CursorOwn;",
                " import com.baselet.element.interfaces.DrawHandlerInterface;",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/interfaces/CursorOwn.java b/umlet-elements/src/main/java/com/baselet/element/interfaces/CursorOwn.java",
                "new file mode 100644",
                "index 00000000..ab0a0621",
                "--- /dev/null",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/interfaces/CursorOwn.java",
                "@@ -0,0 +1,5 @@",
                "+package com.baselet.element.interfaces;",
                "+",
                "+public enum CursorOwn {",
                "+\tN, NE, E, SE, S, SW, W, NW, HAND, MOVE, DEFAULT, CROSS, TEXT;",
                "+}",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/interfaces/GridElement.java b/umlet-elements/src/main/java/com/baselet/element/interfaces/GridElement.java",
                "index 74ff0948..7919a284 100644",
                "--- a/umlet-elements/src/main/java/com/baselet/element/interfaces/GridElement.java",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/interfaces/GridElement.java",
                "@@ -11,3 +11,2 @@ import com.baselet.control.enums.Direction;",
                " import com.baselet.control.enums.ElementId;",
                "-import com.baselet.element.CursorOwn;",
                " import com.baselet.element.sticking.StickableMap;",
                "diff --git a/umlet-elements/src/main/java/com/baselet/element/relation/Relation.java b/umlet-elements/src/main/java/com/baselet/element/relation/Relation.java",
                "index 204e8ba4..09c6be9f 100644",
                "--- a/umlet-elements/src/main/java/com/baselet/element/relation/Relation.java",
                "+++ b/umlet-elements/src/main/java/com/baselet/element/relation/Relation.java",
                "@@ -17,3 +17,2 @@ import com.baselet.diagram.draw.helper.ColorOwn;",
                " import com.baselet.diagram.draw.helper.ColorOwn.Transparency;",
                "-import com.baselet.element.CursorOwn;",
                " import com.baselet.element.NewGridElement;",
                "@@ -23,2 +22,3 @@ import com.baselet.element.facet.Settings;",
                " import com.baselet.element.facet.common.LayerFacet;",
                "+import com.baselet.element.interfaces.CursorOwn;",
                " import com.baselet.element.relation.facet.RelationLineTypeFacet;",
                "diff --git a/umlet-gwt/src/main/java/com/baselet/gwt/client/base/Converter.java b/umlet-gwt/src/main/java/com/baselet/gwt/client/base/Converter.java",
                "index 8b03697f..9eef6314 100644",
                "--- a/umlet-gwt/src/main/java/com/baselet/gwt/client/base/Converter.java",
                "+++ b/umlet-gwt/src/main/java/com/baselet/gwt/client/base/Converter.java",
                "@@ -3,3 +3,3 @@ package com.baselet.gwt.client.base;",
                " import com.baselet.diagram.draw.helper.ColorOwn;",
                "-import com.baselet.element.CursorOwn;",
                "+import com.baselet.element.interfaces.CursorOwn;",
                " import com.google.gwt.canvas.dom.client.CssColor;",
                "diff --git a/umlet-gwt/src/main/java/com/baselet/gwt/client/base/Utils.java b/umlet-gwt/src/main/java/com/baselet/gwt/client/base/Utils.java",
                "index a3f8f698..d6d64cc7 100644",
                "--- a/umlet-gwt/src/main/java/com/baselet/gwt/client/base/Utils.java",
                "+++ b/umlet-gwt/src/main/java/com/baselet/gwt/client/base/Utils.java",
                "@@ -2,3 +2,3 @@ package com.baselet.gwt.client.base;",
                "-import com.baselet.element.CursorOwn;",
                "+import com.baselet.element.interfaces.CursorOwn;",
                " import com.google.gwt.i18n.client.DateTimeFormat;",
                "diff --git a/umlet-gwt/src/main/java/com/baselet/gwt/client/view/DrawPanel.java b/umlet-gwt/src/main/java/com/baselet/gwt/client/view/DrawPanel.java",
                "index 72247bd7..7a5dae3a 100644",
                "--- a/umlet-gwt/src/main/java/com/baselet/gwt/client/view/DrawPanel.java",
                "+++ b/umlet-gwt/src/main/java/com/baselet/gwt/client/view/DrawPanel.java",
                "@@ -18,3 +18,2 @@ import com.baselet.control.constants.SharedConstants;",
                " import com.baselet.control.enums.Direction;",
                "-import com.baselet.element.CursorOwn;",
                " import com.baselet.element.GridElementUtils;",
                "@@ -22,2 +21,3 @@ import com.baselet.element.Selector;",
                " import com.baselet.element.facet.common.GroupFacet;",
                "+import com.baselet.element.interfaces.CursorOwn;",
                " import com.baselet.element.interfaces.Diagram;",
                "diff --git a/umlet-standalone/src/main/java/com/baselet/standalone/gui/SearchListener.java b/umlet-standalone/src/main/java/com/baselet/standalone/gui/SearchListener.java",
                "index 6b3012d2..466e18fe 100644",
                "--- a/umlet-standalone/src/main/java/com/baselet/standalone/gui/SearchListener.java",
                "+++ b/umlet-standalone/src/main/java/com/baselet/standalone/gui/SearchListener.java",
                "@@ -12,3 +12,3 @@ import com.baselet.diagram.CurrentDiagram;",
                " import com.baselet.diagram.DiagramHandler;",
                "-import com.baselet.element.CursorOwn;",
                "+import com.baselet.element.interfaces.CursorOwn;",
                " import com.baselet.gui.CurrentGui;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/control/basics/Converter.java b/umlet-swing/src/main/java/com/baselet/control/basics/Converter.java",
                "index ff2ef95f..b2ab1ac0 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/control/basics/Converter.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/control/basics/Converter.java",
                "@@ -9,3 +9,3 @@ import com.baselet.control.basics.geom.Rectangle;",
                " import com.baselet.diagram.draw.helper.ColorOwn;",
                "-import com.baselet.element.CursorOwn;",
                "+import com.baselet.element.interfaces.CursorOwn;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/custom/CustomElementAddDiscardListener.java b/umlet-swing/src/main/java/com/baselet/custom/CustomElementAddDiscardListener.java",
                "index 4ebde41e..a4c62d53 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/custom/CustomElementAddDiscardListener.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/custom/CustomElementAddDiscardListener.java",
                "@@ -9,3 +9,3 @@ import javax.swing.JLabel;",
                " import com.baselet.control.basics.Converter;",
                "-import com.baselet.element.CursorOwn;",
                "+import com.baselet.element.interfaces.CursorOwn;",
                " import com.baselet.gui.CurrentGui;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/element/old/OldGridElement.java b/umlet-swing/src/main/java/com/baselet/element/old/OldGridElement.java",
                "index a2a2d847..14122fb2 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/element/old/OldGridElement.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/element/old/OldGridElement.java",
                "@@ -41,3 +41,2 @@ import com.baselet.diagram.draw.helper.ColorOwn;",
                " import com.baselet.diagram.draw.helper.ColorOwn.Transparency;",
                "-import com.baselet.element.CursorOwn;",
                " import com.baselet.element.ElementUtils;",
                "@@ -49,2 +48,3 @@ import com.baselet.element.facet.common.GroupFacet;",
                " import com.baselet.element.facet.common.LayerFacet;",
                "+import com.baselet.element.interfaces.CursorOwn;",
                " import com.baselet.element.interfaces.GridElement;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/gui/listener/DiagramListener.java b/umlet-swing/src/main/java/com/baselet/gui/listener/DiagramListener.java",
                "index ff6e420e..28668997 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/gui/listener/DiagramListener.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/gui/listener/DiagramListener.java",
                "@@ -18,3 +18,3 @@ import com.baselet.diagram.DiagramHandler;",
                " import com.baselet.diagram.SelectorFrame;",
                "-import com.baselet.element.CursorOwn;",
                "+import com.baselet.element.interfaces.CursorOwn;",
                " import com.baselet.gui.CurrentGui;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/gui/listener/GridElementListener.java b/umlet-swing/src/main/java/com/baselet/gui/listener/GridElementListener.java",
                "index 529caba0..c26aba94 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/gui/listener/GridElementListener.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/gui/listener/GridElementListener.java",
                "@@ -27,5 +27,5 @@ import com.baselet.diagram.PaletteHandler;",
                " import com.baselet.diagram.SelectorFrame;",
                "-import com.baselet.element.CursorOwn;",
                " import com.baselet.element.ElementFactorySwing;",
                " import com.baselet.element.facet.common.GroupFacet;",
                "+import com.baselet.element.interfaces.CursorOwn;",
                " import com.baselet.element.interfaces.GridElement;",
                "diff --git a/umlet-swing/src/main/java/com/baselet/gui/listener/OldRelationListener.java b/umlet-swing/src/main/java/com/baselet/gui/listener/OldRelationListener.java",
                "index 51650939..5bd1f97c 100644",
                "--- a/umlet-swing/src/main/java/com/baselet/gui/listener/OldRelationListener.java",
                "+++ b/umlet-swing/src/main/java/com/baselet/gui/listener/OldRelationListener.java",
                "@@ -12,3 +12,3 @@ import com.baselet.diagram.CurrentDiagram;",
                " import com.baselet.diagram.DiagramHandler;",
                "-import com.baselet.element.CursorOwn;",
                "+import com.baselet.element.interfaces.CursorOwn;",
                " import com.baselet.element.old.element.Relation;"
            ],
            "changed_files": [
                "umlet-elements/src/main/java/com/baselet/element/NewGridElement.java",
                "umlet-elements/src/main/java/com/baselet/element/interfaces/CursorOwn.java",
                "umlet-elements/src/main/java/com/baselet/element/interfaces/GridElement.java",
                "umlet-elements/src/main/java/com/baselet/element/relation/Relation.java",
                "umlet-gwt/src/main/java/com/baselet/gwt/client/base/Converter.java",
                "umlet-gwt/src/main/java/com/baselet/gwt/client/base/Utils.java",
                "umlet-gwt/src/main/java/com/baselet/gwt/client/view/DrawPanel.java",
                "umlet-standalone/src/main/java/com/baselet/standalone/gui/SearchListener.java",
                "umlet-swing/src/main/java/com/baselet/control/basics/Converter.java",
                "umlet-swing/src/main/java/com/baselet/custom/CustomElementAddDiscardListener.java",
                "umlet-swing/src/main/java/com/baselet/element/old/OldGridElement.java",
                "umlet-swing/src/main/java/com/baselet/gui/listener/DiagramListener.java",
                "umlet-swing/src/main/java/com/baselet/gui/listener/GridElementListener.java",
                "umlet-swing/src/main/java/com/baselet/gui/listener/OldRelationListener.java"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": []
        },
        {
            "commit_id": "629fd0c560aaa4dc54af99cba121d39508a1f188",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479634319,
            "hunks": 4,
            "message": "eclipse settings changes",
            "diff": [
                "diff --git a/umlet-eclipse-plugin/.settings/org.eclipse.jdt.core.prefs b/umlet-eclipse-plugin/.settings/org.eclipse.jdt.core.prefs",
                "index c387f1bd..068871b7 100644",
                "--- a/umlet-eclipse-plugin/.settings/org.eclipse.jdt.core.prefs",
                "+++ b/umlet-eclipse-plugin/.settings/org.eclipse.jdt.core.prefs",
                "@@ -396 +396,2 @@ org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested=true",
                " org.eclipse.jdt.core.javaFormatter=org.eclipse.jdt.core.defaultJavaFormatter",
                "+org.eclipse.objectteams.otdt.compiler.option.pure_java=enabled",
                "diff --git a/umlet-gwt/.project b/umlet-gwt/.project",
                "index 4debcc18..8d52c96c 100644",
                "--- a/umlet-gwt/.project",
                "+++ b/umlet-gwt/.project",
                "@@ -13,3 +13,3 @@",
                " \t\t<buildCommand>",
                "-\t\t\t<name>org.eclipse.m2e.core.maven2Builder</name>",
                "+\t\t\t<name>com.google.gdt.eclipse.core.webAppProjectValidator</name>",
                " \t\t\t<arguments>",
                "@@ -18,3 +18,3 @@",
                " \t\t<buildCommand>",
                "-\t\t\t<name>com.google.gdt.eclipse.core.webAppProjectValidator</name>",
                "+\t\t\t<name>com.google.gwt.eclipse.core.gwtProjectValidator</name>",
                " \t\t\t<arguments>",
                "@@ -23,3 +23,3 @@",
                " \t\t<buildCommand>",
                "-\t\t\t<name>com.google.gwt.eclipse.core.gwtProjectValidator</name>",
                "+\t\t\t<name>org.eclipse.m2e.core.maven2Builder</name>",
                " \t\t\t<arguments>"
            ],
            "changed_files": [
                "umlet-eclipse-plugin/.settings/org.eclipse.jdt.core.prefs",
                "umlet-gwt/.project"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": []
        },
        {
            "commit_id": "7c28629e6ebcb922896643304183eef2062748d0",
            "repository": "https://github.com/umlet/umlet",
            "timestamp": 1479634302,
            "hunks": 1,
            "message": "findbugs fix for seq aio package change",
            "diff": [
                "diff --git a/umlet-elements/src/main/findbugs/findbugs-exclude.xml b/umlet-elements/src/main/findbugs/findbugs-exclude.xml",
                "index 9e70c61e..b697e1ef 100644",
                "--- a/umlet-elements/src/main/findbugs/findbugs-exclude.xml",
                "+++ b/umlet-elements/src/main/findbugs/findbugs-exclude.xml",
                "@@ -2,3 +2,3 @@",
                "   <Match>",
                "-    <Package name=\"~com.baselet.element.sequence_aio.gen.facet.*\" />",
                "+    <Package name=\"~com.baselet.element.sequence_aio.facet.*\" />",
                "   </Match>"
            ],
            "changed_files": [
                "umlet-elements/src/main/findbugs/findbugs-exclude.xml"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [],
            "twins": [],
            "tags": [
                "2018-08-05_UMLet_v14.3",
                "2022-04-26_UMLet_v15",
                "2023-03-20_UMLet_v15.1",
                "v15.1"
            ],
            "matched_rules": []
        }
    ]
}
