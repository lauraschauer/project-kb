{
    "advisory_record": {
        "cve_id": "CVE-2018-12976",
        "description": "In Go Doc Dot Org (gddo) through 2018-06-27, an attacker could use specially crafted <go-import> tags in packages being fetched by gddo to cause a directory traversal and remote code execution.",
        "reserved_timestamp": 1530144000,
        "published_timestamp": 1530813600,
        "updated_timestamp": 1530813421,
        "repository_url": null,
        "references": {
            "https://groups.google.com/forum/#%21msg/golang-announce/4rpTbfzYB1k/no6MEwlQAwAJ": 2,
            "commit::daffe1f90ec57f8ed69464f9094753fc6452e983": 2
        },
        "affected_products": [
            "Doc",
            "Org",
            "n/a",
            "gddo",
            "Dot"
        ],
        "versions": {
            "status": "affected",
            "version": "n/a"
        },
        "files": [
            "go-import"
        ],
        "keywords": [
            "package",
            "cause",
            "traversal",
            "import",
            "code",
            "attacker",
            "execution",
            "gddo",
            "fetch",
            "craft",
            "directory"
        ],
        "files_extension": [],
        "has_fixing_commit": true
    },
    "commits": [
        {
            "commit_id": "daffe1f90ec57f8ed69464f9094753fc6452e983",
            "repository": "https://github.com/golang/gddo",
            "timestamp": 1530160035,
            "hunks": 5,
            "message": "gosrc: validate repo from meta Fixes CVE-2018-12976. Change-Id: I6b87ab692915d46ba4f668ab848473de9b054c8a Reviewed-on: https://go-review.googlesource.com/121358 Reviewed-by: Filippo Valsorda <filippo@golang.org>",
            "diff": [
                "diff --git a/gosrc/gosrc.go b/gosrc/gosrc.go",
                "index 9a9e44b..b5173d3 100644",
                "--- a/gosrc/gosrc.go",
                "+++ b/gosrc/gosrc.go",
                "@@ -380,2 +380,5 @@ func getDynamic(ctx context.Context, client *http.Client, importPath, etag strin",
                " \trepo := strings.TrimSuffix(clonePath, \".\"+im.vcs)",
                "+\tif !IsValidRemotePath(repo) {",
                "+\t\treturn nil, fmt.Errorf(\"bad path from meta: %s\", repo)",
                "+\t}",
                " \tdirName := importPath[len(im.projectRoot):]",
                "diff --git a/gosrc/gosrc_test.go b/gosrc/gosrc_test.go",
                "index be4acde..d90e798 100644",
                "--- a/gosrc/gosrc_test.go",
                "+++ b/gosrc/gosrc_test.go",
                "@@ -96,2 +96,5 @@ var testWeb = map[string]string{",
                " \t\t`</head>`,",
                "+",
                "+\t// The repo element of go-import includes \"../\"",
                "+\t\"http://my.host/pkg\": `<head> <meta name=\"go-import\" content=\"my.host/pkg git http://vcs.net/myhost/../../tmp/pkg.git\"></head>`,",
                " }",
                "@@ -223,2 +226,3 @@ var getDynamicTests = []struct {",
                " \t}},",
                "+\t{\"my.host/pkg\", nil},",
                " }",
                "@@ -295,3 +299,3 @@ func TestGetDynamic(t *testing.T) {",
                " \t\t\tif err == nil {",
                "-\t\t\t\tt.Errorf(\"getDynamic(client, %q, etag) did not return expected error\", tt.importPath)",
                "+\t\t\t\tt.Errorf(\"getDynamic(ctx, client, %q, etag) did not return expected error\", tt.importPath)",
                " \t\t\t}",
                "@@ -301,3 +305,3 @@ func TestGetDynamic(t *testing.T) {",
                " \t\tif err != nil {",
                "-\t\t\tt.Errorf(\"getDynamic(client, %q, etag) return unexpected error: %v\", tt.importPath, err)",
                "+\t\t\tt.Errorf(\"getDynamic(ctx, client, %q, etag) return unexpected error: %v\", tt.importPath, err)",
                " \t\t\tcontinue"
            ],
            "changed_files": [
                "gosrc/gosrc.go",
                "gosrc/gosrc_test.go"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {},
            "cve_refs": [
                "CVE-2018-12976"
            ],
            "twins": [],
            "tags": [],
            "matched_rules": [
                {
                    "id": "COMMIT_IN_REFERENCE",
                    "message": "This commit is mentioned 2 times in the references.",
                    "relevance": 64
                },
                {
                    "id": "VULN_ID_IN_MESSAGE",
                    "message": "The commit message mentions the vulnerability ID",
                    "relevance": 64
                },
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: go-import",
                    "relevance": 8
                }
            ]
        },
        {
            "commit_id": "9ab275bde8fe1bb887642e9250b8d58aba11af61",
            "repository": "https://github.com/golang/gddo",
            "timestamp": 1529999155,
            "hunks": 3,
            "message": "gosrc: add minimal support for vgo-aware modules Currently, gddo assumes that there will be just one go-import HTML meta tag when resolving a custom import's VCS repository. vgo introduces a special new go-import meta tag to identify the location of published Go modules; it has the VCS identifier 'mod'. https://golang.org/issue/25140 and https://golang.org/issue/25139 added minimal awareness to the Go 1.9 and 1.10 branches for the vgo transition that will start in Go 1.11. Part of this backported support is to ignore the module special go-import meta tag which has a 'mod' vcvs type: https://go-review.googlesource.com/c/go/+/115298/4/src/cmd/go/internal/get/discovery.go Per https://golang.org/issue/25069, the 'mod' vcs type is used by 'new' Go code to identify where published modules can be fetched. As a first minimal step we can make gddo \"aware\" in the same way that Go 1.9 and 1.10 are \"aware\" of these published modules by simply ignoring that go-import meta tag. Later gddo CLs will likely need to enhance support for vgo, but this is a sufficient first step. Fixes #558 Change-Id: Ibddfcc8e0a663792da206a244e5cffb8c68fe894 Reviewed-on: https://go-review.googlesource.com/120817 Reviewed-by: Tuo Shan <shantuo@google.com>",
            "diff": [
                "diff --git a/gosrc/gosrc.go b/gosrc/gosrc.go",
                "index 38005ec..9a9e44b 100644",
                "--- a/gosrc/gosrc.go",
                "+++ b/gosrc/gosrc.go",
                "@@ -304,2 +304,6 @@ metaScan:",
                " \t\t\t\t}",
                "+\t\t\t\tif fields[1] == \"mod\" {",
                "+\t\t\t\t\t// vgo adds a special mod vcs type; we can skip this",
                "+\t\t\t\t\tcontinue",
                "+\t\t\t\t}",
                " \t\t\t\tif im != nil {",
                "diff --git a/gosrc/gosrc_test.go b/gosrc/gosrc_test.go",
                "index 9213e62..be4acde 100644",
                "--- a/gosrc/gosrc_test.go",
                "+++ b/gosrc/gosrc_test.go",
                "@@ -88,2 +88,10 @@ var testWeb = map[string]string{",
                " \t\t`</head>`,",
                "+",
                "+\t// Multiple go-import meta tags; one of which is a vgo-special mod vcs type",
                "+\t\"http://myitcv.io/blah2\": `<!DOCTYPE html><html><head>` +",
                "+\t\t`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>` +",
                "+\t\t`<meta name=\"go-import\" content=\"myitcv.io/blah2 git https://github.com/myitcv/x\">` +",
                "+\t\t`<meta name=\"go-import\" content=\"myitcv.io/blah2 mod https://raw.githubusercontent.com/myitcv/pubx/master\">` +",
                "+\t\t`<meta name=\"go-source\" content=\"myitcv.io https://github.com/myitcv/x/wiki https://github.com/myitcv/x/tree/master{/dir} https://github.com/myitcv/x/blob/master{/dir}/{file}#L{line}\">` +",
                "+\t\t`</head>`,",
                " }",
                "@@ -204,2 +212,13 @@ var getDynamicTests = []struct {",
                " \t}},",
                "+\t{\"myitcv.io/blah2\", &Directory{",
                "+\t\tBrowseURL:    \"https://github.com/myitcv/x\",",
                "+\t\tImportPath:   \"myitcv.io/blah2\",",
                "+\t\tLineFmt:      \"%s#L%d\",",
                "+\t\tProjectName:  \"blah2\",",
                "+\t\tProjectRoot:  \"myitcv.io/blah2\",",
                "+\t\tProjectURL:   \"http://myitcv.io/blah2\",",
                "+\t\tResolvedPath: \"github.com/myitcv/x\",",
                "+\t\tVCS:          \"git\",",
                "+\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://github.com/myitcv/x/blob/master/main.go\"}},",
                "+\t}},",
                " }"
            ],
            "changed_files": [
                "gosrc/gosrc.go",
                "gosrc/gosrc_test.go"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {
                "558": ""
            },
            "cve_refs": [],
            "twins": [],
            "tags": [],
            "matched_rules": [
                {
                    "id": "RELEVANT_WORDS_IN_MESSAGE",
                    "message": "The commit message contains some relevant words: go-import",
                    "relevance": 8
                },
                {
                    "id": "CHANGES_RELEVANT_CODE",
                    "message": "The commit modifies code containing relevant filename or methods: go-import",
                    "relevance": 8
                },
                {
                    "id": "ADV_KEYWORDS_IN_MSG",
                    "message": "The commit message and the advisory description contain the following keywords: code, import, fetch",
                    "relevance": 4
                },
                {
                    "id": "GITHUB_ISSUE_IN_MESSAGE",
                    "message": "The commit message references some github issue: 558",
                    "relevance": 2
                }
            ]
        },
        {
            "commit_id": "574849d519ec3acb591fc5620ee0aa3ea48081e0",
            "repository": "https://github.com/golang/gddo",
            "timestamp": 1528292596,
            "hunks": 44,
            "message": "cloud.google.com/go/pubsub added to vendor Fixes #553 I've added `cloud.google.com/go/pubsub` to vendor to avoid problem with double http handlers registrations. Change-Id: I0ea6cebdc8547b53ae4dd8801a4bd89547e4f2b7 GitHub-Last-Rev: 0cb2eab2e3a401a9fa3b128d0480c5b5964a9b67 GitHub-Pull-Request: golang/gddo#557 Reviewed-on: https://go-review.googlesource.com/116417 Reviewed-by: Tuo Shan <shantuo@google.com>",
            "diff": [
                "diff --git a/Godeps/Godeps.json b/Godeps/Godeps.json",
                "index e532843..8af16a1 100644",
                "--- a/Godeps/Godeps.json",
                "+++ b/Godeps/Godeps.json",
                "@@ -2,4 +2,4 @@",
                " \t\"ImportPath\": \"github.com/golang/gddo\",",
                "-\t\"GoVersion\": \"go1.9\",",
                "-\t\"GodepVersion\": \"v79\",",
                "+\t\"GoVersion\": \"go1.10\",",
                "+\t\"GodepVersion\": \"v80\",",
                " \t\"Packages\": [",
                "@@ -13,2 +13,7 @@",
                " \t\t},",
                "+\t\t{",
                "+\t\t\t\"ImportPath\": \"cloud.google.com/go/iam\",",
                "+\t\t\t\"Comment\": \"v0.16.0\",",
                "+\t\t\t\"Rev\": \"2d3a6656c17a60b0815b7e06ab0be04eacb6e613\"",
                "+\t\t},",
                " \t\t{",
                "@@ -38,2 +43,12 @@",
                " \t\t},",
                "+\t\t{",
                "+\t\t\t\"ImportPath\": \"cloud.google.com/go/pubsub\",",
                "+\t\t\t\"Comment\": \"v0.16.0\",",
                "+\t\t\t\"Rev\": \"2d3a6656c17a60b0815b7e06ab0be04eacb6e613\"",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\t\"ImportPath\": \"cloud.google.com/go/pubsub/apiv1\",",
                "+\t\t\t\"Comment\": \"v0.16.0\",",
                "+\t\t\t\"Rev\": \"2d3a6656c17a60b0815b7e06ab0be04eacb6e613\"",
                "+\t\t},",
                " \t\t{",
                "@@ -290,2 +305,6 @@",
                " \t\t},",
                "+\t\t{",
                "+\t\t\t\"ImportPath\": \"golang.org/x/sync/errgroup\",",
                "+\t\t\t\"Rev\": \"f52d1811a62927559de87708c8913c1650ce4f26\"",
                "+\t\t},",
                " \t\t{",
                "@@ -300,2 +319,3 @@",
                " \t\t\t\"ImportPath\": \"golang.org/x/text/secure/bidirule\",",
                "+\t\t\t\"Comment\": \"v0.1.0-6-g1cbadb4\",",
                " \t\t\t\"Rev\": \"1cbadb444a806fd9430d14ad08967ed91da4fa0a\"",
                "@@ -304,2 +324,3 @@",
                " \t\t\t\"ImportPath\": \"golang.org/x/text/transform\",",
                "+\t\t\t\"Comment\": \"v0.1.0-6-g1cbadb4\",",
                " \t\t\t\"Rev\": \"1cbadb444a806fd9430d14ad08967ed91da4fa0a\"",
                "@@ -308,2 +329,3 @@",
                " \t\t\t\"ImportPath\": \"golang.org/x/text/unicode/bidi\",",
                "+\t\t\t\"Comment\": \"v0.1.0-6-g1cbadb4\",",
                " \t\t\t\"Rev\": \"1cbadb444a806fd9430d14ad08967ed91da4fa0a\"",
                "@@ -312,2 +334,3 @@",
                " \t\t\t\"ImportPath\": \"golang.org/x/text/unicode/norm\",",
                "+\t\t\t\"Comment\": \"v0.1.0-6-g1cbadb4\",",
                " \t\t\t\"Rev\": \"1cbadb444a806fd9430d14ad08967ed91da4fa0a\"",
                "@@ -320,7 +343,7 @@",
                " \t\t\t\"ImportPath\": \"golang.org/x/tools/go/gcexportdata\",",
                "-\t\t\t\"Rev\": \"e531a2a1c15f94033f6fa87666caeb19a688175f\"",
                "+\t\t\t\"Rev\": \"a5b4c53f6e8bdcafa95a94671bf2d1203365858b\"",
                " \t\t},",
                " \t\t{",
                "-\t\t\t\"ImportPath\": \"golang.org/x/tools/go/gcimporter15\",",
                "-\t\t\t\"Rev\": \"e531a2a1c15f94033f6fa87666caeb19a688175f\"",
                "+\t\t\t\"ImportPath\": \"golang.org/x/tools/go/internal/gcimporter\",",
                "+\t\t\t\"Rev\": \"a5b4c53f6e8bdcafa95a94671bf2d1203365858b\"",
                " \t\t},",
                "@@ -328,3 +351,3 @@",
                " \t\t\t\"ImportPath\": \"golang.org/x/tools/present\",",
                "-\t\t\t\"Rev\": \"e531a2a1c15f94033f6fa87666caeb19a688175f\"",
                "+\t\t\t\"Rev\": \"a5b4c53f6e8bdcafa95a94671bf2d1203365858b\"",
                " \t\t},",
                "@@ -499,3 +522,3 @@",
                " \t\t{",
                "-\t\t\t\"ImportPath\": \"google.golang.org/genproto/googleapis/cloud/runtimeconfig/v1beta1\",",
                "+\t\t\t\"ImportPath\": \"google.golang.org/genproto/googleapis/iam/v1\",",
                " \t\t\t\"Rev\": \"1e559d0a00eef8a9a43151db4665280bd8dd5886\"",
                "@@ -511,3 +534,3 @@",
                " \t\t{",
                "-\t\t\t\"ImportPath\": \"google.golang.org/genproto/googleapis/longrunning\",",
                "+\t\t\t\"ImportPath\": \"google.golang.org/genproto/googleapis/pubsub/v1\",",
                " \t\t\t\"Rev\": \"1e559d0a00eef8a9a43151db4665280bd8dd5886\"",
                "diff --git a/vendor/cloud.google.com/go/iam/iam.go b/vendor/cloud.google.com/go/iam/iam.go",
                "new file mode 100644",
                "index 0000000..8722ee8",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/iam/iam.go",
                "@@ -0,0 +1,256 @@",
                "+// Copyright 2016 Google Inc. All Rights Reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//      http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+// Package iam supports the resource-specific operations of Google Cloud",
                "+// IAM (Identity and Access Management) for the Google Cloud Libraries.",
                "+// See https://cloud.google.com/iam for more about IAM.",
                "+//",
                "+// Users of the Google Cloud Libraries will typically not use this package",
                "+// directly. Instead they will begin with some resource that supports IAM, like",
                "+// a pubsub topic, and call its IAM method to get a Handle for that resource.",
                "+package iam",
                "+",
                "+import (",
                "+\t\"golang.org/x/net/context\"",
                "+\tpb \"google.golang.org/genproto/googleapis/iam/v1\"",
                "+\t\"google.golang.org/grpc\"",
                "+)",
                "+",
                "+// client abstracts the IAMPolicy API to allow multiple implementations.",
                "+type client interface {",
                "+\tGet(ctx context.Context, resource string) (*pb.Policy, error)",
                "+\tSet(ctx context.Context, resource string, p *pb.Policy) error",
                "+\tTest(ctx context.Context, resource string, perms []string) ([]string, error)",
                "+}",
                "+",
                "+// grpcClient implements client for the standard gRPC-based IAMPolicy service.",
                "+type grpcClient struct {",
                "+\tc pb.IAMPolicyClient",
                "+}",
                "+",
                "+func (g *grpcClient) Get(ctx context.Context, resource string) (*pb.Policy, error) {",
                "+\tproto, err := g.c.GetIamPolicy(ctx, &pb.GetIamPolicyRequest{Resource: resource})",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn proto, nil",
                "+}",
                "+func (g *grpcClient) Set(ctx context.Context, resource string, p *pb.Policy) error {",
                "+\t_, err := g.c.SetIamPolicy(ctx, &pb.SetIamPolicyRequest{",
                "+\t\tResource: resource,",
                "+\t\tPolicy:   p,",
                "+\t})",
                "+\treturn err",
                "+}",
                "+",
                "+func (g *grpcClient) Test(ctx context.Context, resource string, perms []string) ([]string, error) {",
                "+\tres, err := g.c.TestIamPermissions(ctx, &pb.TestIamPermissionsRequest{",
                "+\t\tResource:    resource,",
                "+\t\tPermissions: perms,",
                "+\t})",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn res.Permissions, nil",
                "+}",
                "+",
                "+// A Handle provides IAM operations for a resource.",
                "+type Handle struct {",
                "+\tc        client",
                "+\tresource string",
                "+}",
                "+",
                "+// InternalNewHandle is for use by the Google Cloud Libraries only.",
                "+//",
                "+// InternalNewHandle returns a Handle for resource.",
                "+// The conn parameter refers to a server that must support the IAMPolicy service.",
                "+func InternalNewHandle(conn *grpc.ClientConn, resource string) *Handle {",
                "+\treturn InternalNewHandleClient(&grpcClient{c: pb.NewIAMPolicyClient(conn)}, resource)",
                "+}",
                "+",
                "+// InternalNewHandleClient is for use by the Google Cloud Libraries only.",
                "+//",
                "+// InternalNewHandleClient returns a Handle for resource using the given",
                "+// client implementation.",
                "+func InternalNewHandleClient(c client, resource string) *Handle {",
                "+\treturn &Handle{",
                "+\t\tc:        c,",
                "+\t\tresource: resource,",
                "+\t}",
                "+}",
                "+",
                "+// Policy retrieves the IAM policy for the resource.",
                "+func (h *Handle) Policy(ctx context.Context) (*Policy, error) {",
                "+\tproto, err := h.c.Get(ctx, h.resource)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn &Policy{InternalProto: proto}, nil",
                "+}",
                "+",
                "+// SetPolicy replaces the resource's current policy with the supplied Policy.",
                "+//",
                "+// If policy was created from a prior call to Get, then the modification will",
                "+// only succeed if the policy has not changed since the Get.",
                "+func (h *Handle) SetPolicy(ctx context.Context, policy *Policy) error {",
                "+\treturn h.c.Set(ctx, h.resource, policy.InternalProto)",
                "+}",
                "+",
                "+// TestPermissions returns the subset of permissions that the caller has on the resource.",
                "+func (h *Handle) TestPermissions(ctx context.Context, permissions []string) ([]string, error) {",
                "+\treturn h.c.Test(ctx, h.resource, permissions)",
                "+}",
                "+",
                "+// A RoleName is a name representing a collection of permissions.",
                "+type RoleName string",
                "+",
                "+// Common role names.",
                "+const (",
                "+\tOwner  RoleName = \"roles/owner\"",
                "+\tEditor RoleName = \"roles/editor\"",
                "+\tViewer RoleName = \"roles/viewer\"",
                "+)",
                "+",
                "+const (",
                "+\t// AllUsers is a special member that denotes all users, even unauthenticated ones.",
                "+\tAllUsers = \"allUsers\"",
                "+",
                "+\t// AllAuthenticatedUsers is a special member that denotes all authenticated users.",
                "+\tAllAuthenticatedUsers = \"allAuthenticatedUsers\"",
                "+)",
                "+",
                "+// A Policy is a list of Bindings representing roles",
                "+// granted to members.",
                "+//",
                "+// The zero Policy is a valid policy with no bindings.",
                "+type Policy struct {",
                "+\t// TODO(jba): when type aliases are available, put Policy into an internal package",
                "+\t// and provide an exported alias here.",
                "+",
                "+\t// This field is exported for use by the Google Cloud Libraries only.",
                "+\t// It may become unexported in a future release.",
                "+\tInternalProto *pb.Policy",
                "+}",
                "+",
                "+// Members returns the list of members with the supplied role.",
                "+// The return value should not be modified. Use Add and Remove",
                "+// to modify the members of a role.",
                "+func (p *Policy) Members(r RoleName) []string {",
                "+\tb := p.binding(r)",
                "+\tif b == nil {",
                "+\t\treturn nil",
                "+\t}",
                "+\treturn b.Members",
                "+}",
                "+",
                "+// HasRole reports whether member has role r.",
                "+func (p *Policy) HasRole(member string, r RoleName) bool {",
                "+\treturn memberIndex(member, p.binding(r)) >= 0",
                "+}",
                "+",
                "+// Add adds member member to role r if it is not already present.",
                "+// A new binding is created if there is no binding for the role.",
                "+func (p *Policy) Add(member string, r RoleName) {",
                "+\tb := p.binding(r)",
                "+\tif b == nil {",
                "+\t\tif p.InternalProto == nil {",
                "+\t\t\tp.InternalProto = &pb.Policy{}",
                "+\t\t}",
                "+\t\tp.InternalProto.Bindings = append(p.InternalProto.Bindings, &pb.Binding{",
                "+\t\t\tRole:    string(r),",
                "+\t\t\tMembers: []string{member},",
                "+\t\t})",
                "+\t\treturn",
                "+\t}",
                "+\tif memberIndex(member, b) < 0 {",
                "+\t\tb.Members = append(b.Members, member)",
                "+\t\treturn",
                "+\t}",
                "+}",
                "+",
                "+// Remove removes member from role r if it is present.",
                "+func (p *Policy) Remove(member string, r RoleName) {",
                "+\tbi := p.bindingIndex(r)",
                "+\tif bi < 0 {",
                "+\t\treturn",
                "+\t}",
                "+\tbindings := p.InternalProto.Bindings",
                "+\tb := bindings[bi]",
                "+\tmi := memberIndex(member, b)",
                "+\tif mi < 0 {",
                "+\t\treturn",
                "+\t}",
                "+\t// Order doesn't matter for bindings or members, so to remove, move the last item",
                "+\t// into the removed spot and shrink the slice.",
                "+\tif len(b.Members) == 1 {",
                "+\t\t// Remove binding.",
                "+\t\tlast := len(bindings) - 1",
                "+\t\tbindings[bi] = bindings[last]",
                "+\t\tbindings[last] = nil",
                "+\t\tp.InternalProto.Bindings = bindings[:last]",
                "+\t\treturn",
                "+\t}",
                "+\t// Remove member.",
                "+\t// TODO(jba): worry about multiple copies of m?",
                "+\tlast := len(b.Members) - 1",
                "+\tb.Members[mi] = b.Members[last]",
                "+\tb.Members[last] = \"\"",
                "+\tb.Members = b.Members[:last]",
                "+}",
                "+",
                "+// Roles returns the names of all the roles that appear in the Policy.",
                "+func (p *Policy) Roles() []RoleName {",
                "+\tif p.InternalProto == nil {",
                "+\t\treturn nil",
                "+\t}",
                "+\tvar rns []RoleName",
                "+\tfor _, b := range p.InternalProto.Bindings {",
                "+\t\trns = append(rns, RoleName(b.Role))",
                "+\t}",
                "+\treturn rns",
                "+}",
                "+",
                "+// binding returns the Binding for the suppied role, or nil if there isn't one.",
                "+func (p *Policy) binding(r RoleName) *pb.Binding {",
                "+\ti := p.bindingIndex(r)",
                "+\tif i < 0 {",
                "+\t\treturn nil",
                "+\t}",
                "+\treturn p.InternalProto.Bindings[i]",
                "+}",
                "+",
                "+func (p *Policy) bindingIndex(r RoleName) int {",
                "+\tif p.InternalProto == nil {",
                "+\t\treturn -1",
                "+\t}",
                "+\tfor i, b := range p.InternalProto.Bindings {",
                "+\t\tif b.Role == string(r) {",
                "+\t\t\treturn i",
                "+\t\t}",
                "+\t}",
                "+\treturn -1",
                "+}",
                "+",
                "+// memberIndex returns the index of m in b's Members, or -1 if not found.",
                "+func memberIndex(m string, b *pb.Binding) int {",
                "+\tif b == nil {",
                "+\t\treturn -1",
                "+\t}",
                "+\tfor i, mm := range b.Members {",
                "+\t\tif mm == m {",
                "+\t\t\treturn i",
                "+\t\t}",
                "+\t}",
                "+\treturn -1",
                "+}",
                "diff --git a/vendor/cloud.google.com/go/pubsub/apiv1/doc.go b/vendor/cloud.google.com/go/pubsub/apiv1/doc.go",
                "new file mode 100644",
                "index 0000000..8945cfa",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/pubsub/apiv1/doc.go",
                "@@ -0,0 +1,50 @@",
                "+// Copyright 2017, Google Inc. All rights reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//     http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+// AUTO-GENERATED CODE. DO NOT EDIT.",
                "+",
                "+// Package pubsub is an auto-generated package for the",
                "+// Google Cloud Pub/Sub API.",
                "+//",
                "+//   NOTE: This package is in alpha. It is not stable, and is likely to be subject to changes.",
                "+//",
                "+// Provides reliable, many-to-many, asynchronous messaging between",
                "+// applications.",
                "+//",
                "+// Use the client at cloud.google.com/go/pubsub in preference to this.",
                "+package pubsub",
                "+",
                "+import (",
                "+\t\"golang.org/x/net/context\"",
                "+\t\"google.golang.org/grpc/metadata\"",
                "+)",
                "+",
                "+func insertMetadata(ctx context.Context, mds ...metadata.MD) context.Context {",
                "+\tout, _ := metadata.FromOutgoingContext(ctx)",
                "+\tout = out.Copy()",
                "+\tfor _, md := range mds {",
                "+\t\tfor k, v := range md {",
                "+\t\t\tout[k] = append(out[k], v...)",
                "+\t\t}",
                "+\t}",
                "+\treturn metadata.NewOutgoingContext(ctx, out)",
                "+}",
                "+",
                "+// DefaultAuthScopes reports the default set of authentication scopes to use with this package.",
                "+func DefaultAuthScopes() []string {",
                "+\treturn []string{",
                "+\t\t\"https://www.googleapis.com/auth/cloud-platform\",",
                "+\t\t\"https://www.googleapis.com/auth/pubsub\",",
                "+\t}",
                "+}",
                "diff --git a/vendor/cloud.google.com/go/pubsub/apiv1/publisher_client.go b/vendor/cloud.google.com/go/pubsub/apiv1/publisher_client.go",
                "new file mode 100644",
                "index 0000000..6088dac",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/pubsub/apiv1/publisher_client.go",
                "@@ -0,0 +1,416 @@",
                "+// Copyright 2017, Google Inc. All rights reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//     http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+// AUTO-GENERATED CODE. DO NOT EDIT.",
                "+",
                "+package pubsub",
                "+",
                "+import (",
                "+\t\"math\"",
                "+\t\"time\"",
                "+",
                "+\t\"cloud.google.com/go/iam\"",
                "+\t\"cloud.google.com/go/internal/version\"",
                "+\tgax \"github.com/googleapis/gax-go\"",
                "+\t\"golang.org/x/net/context\"",
                "+\t\"google.golang.org/api/iterator\"",
                "+\t\"google.golang.org/api/option\"",
                "+\t\"google.golang.org/api/transport\"",
                "+\tpubsubpb \"google.golang.org/genproto/googleapis/pubsub/v1\"",
                "+\t\"google.golang.org/grpc\"",
                "+\t\"google.golang.org/grpc/codes\"",
                "+\t\"google.golang.org/grpc/metadata\"",
                "+)",
                "+",
                "+// PublisherCallOptions contains the retry settings for each method of PublisherClient.",
                "+type PublisherCallOptions struct {",
                "+\tCreateTopic            []gax.CallOption",
                "+\tUpdateTopic            []gax.CallOption",
                "+\tPublish                []gax.CallOption",
                "+\tGetTopic               []gax.CallOption",
                "+\tListTopics             []gax.CallOption",
                "+\tListTopicSubscriptions []gax.CallOption",
                "+\tDeleteTopic            []gax.CallOption",
                "+}",
                "+",
                "+func defaultPublisherClientOptions() []option.ClientOption {",
                "+\treturn []option.ClientOption{",
                "+\t\toption.WithEndpoint(\"pubsub.googleapis.com:443\"),",
                "+\t\toption.WithScopes(DefaultAuthScopes()...),",
                "+\t}",
                "+}",
                "+",
                "+func defaultPublisherCallOptions() *PublisherCallOptions {",
                "+\tretry := map[[2]string][]gax.CallOption{",
                "+\t\t{\"default\", \"idempotent\"}: {",
                "+\t\t\tgax.WithRetry(func() gax.Retryer {",
                "+\t\t\t\treturn gax.OnCodes([]codes.Code{",
                "+\t\t\t\t\tcodes.DeadlineExceeded,",
                "+\t\t\t\t\tcodes.Unavailable,",
                "+\t\t\t\t}, gax.Backoff{",
                "+\t\t\t\t\tInitial:    100 * time.Millisecond,",
                "+\t\t\t\t\tMax:        60000 * time.Millisecond,",
                "+\t\t\t\t\tMultiplier: 1.3,",
                "+\t\t\t\t})",
                "+\t\t\t}),",
                "+\t\t},",
                "+\t\t{\"messaging\", \"one_plus_delivery\"}: {",
                "+\t\t\tgax.WithRetry(func() gax.Retryer {",
                "+\t\t\t\treturn gax.OnCodes([]codes.Code{",
                "+\t\t\t\t\tcodes.Aborted,",
                "+\t\t\t\t\tcodes.Canceled,",
                "+\t\t\t\t\tcodes.DeadlineExceeded,",
                "+\t\t\t\t\tcodes.Internal,",
                "+\t\t\t\t\tcodes.ResourceExhausted,",
                "+\t\t\t\t\tcodes.Unavailable,",
                "+\t\t\t\t\tcodes.Unknown,",
                "+\t\t\t\t}, gax.Backoff{",
                "+\t\t\t\t\tInitial:    100 * time.Millisecond,",
                "+\t\t\t\t\tMax:        60000 * time.Millisecond,",
                "+\t\t\t\t\tMultiplier: 1.3,",
                "+\t\t\t\t})",
                "+\t\t\t}),",
                "+\t\t},",
                "+\t}",
                "+\treturn &PublisherCallOptions{",
                "+\t\tCreateTopic:            retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tUpdateTopic:            retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tPublish:                retry[[2]string{\"messaging\", \"one_plus_delivery\"}],",
                "+\t\tGetTopic:               retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tListTopics:             retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tListTopicSubscriptions: retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tDeleteTopic:            retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t}",
                "+}",
                "+",
                "+// PublisherClient is a client for interacting with Google Cloud Pub/Sub API.",
                "+type PublisherClient struct {",
                "+\t// The connection to the service.",
                "+\tconn *grpc.ClientConn",
                "+",
                "+\t// The gRPC API client.",
                "+\tpublisherClient pubsubpb.PublisherClient",
                "+",
                "+\t// The call options for this service.",
                "+\tCallOptions *PublisherCallOptions",
                "+",
                "+\t// The metadata to be sent with each request.",
                "+\tMetadata metadata.MD",
                "+}",
                "+",
                "+// NewPublisherClient creates a new publisher client.",
                "+//",
                "+// The service that an application uses to manipulate topics, and to send",
                "+// messages to a topic.",
                "+func NewPublisherClient(ctx context.Context, opts ...option.ClientOption) (*PublisherClient, error) {",
                "+\tconn, err := transport.DialGRPC(ctx, append(defaultPublisherClientOptions(), opts...)...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tc := &PublisherClient{",
                "+\t\tconn:        conn,",
                "+\t\tCallOptions: defaultPublisherCallOptions(),",
                "+",
                "+\t\tpublisherClient: pubsubpb.NewPublisherClient(conn),",
                "+\t}",
                "+\tc.SetGoogleClientInfo()",
                "+\treturn c, nil",
                "+}",
                "+",
                "+// Connection returns the client's connection to the API service.",
                "+func (c *PublisherClient) Connection() *grpc.ClientConn {",
                "+\treturn c.conn",
                "+}",
                "+",
                "+// Close closes the connection to the API service. The user should invoke this when",
                "+// the client is no longer required.",
                "+func (c *PublisherClient) Close() error {",
                "+\treturn c.conn.Close()",
                "+}",
                "+",
                "+// SetGoogleClientInfo sets the name and version of the application in",
                "+// the `x-goog-api-client` header passed on each request. Intended for",
                "+// use by Google-written clients.",
                "+func (c *PublisherClient) SetGoogleClientInfo(keyval ...string) {",
                "+\tkv := append([]string{\"gl-go\", version.Go()}, keyval...)",
                "+\tkv = append(kv, \"gapic\", version.Repo, \"gax\", gax.Version, \"grpc\", grpc.Version)",
                "+\tc.Metadata = metadata.Pairs(\"x-goog-api-client\", gax.XGoogHeader(kv...))",
                "+}",
                "+",
                "+// PublisherProjectPath returns the path for the project resource.",
                "+func PublisherProjectPath(project string) string {",
                "+\treturn \"\" +",
                "+\t\t\"projects/\" +",
                "+\t\tproject +",
                "+\t\t\"\"",
                "+}",
                "+",
                "+// PublisherTopicPath returns the path for the topic resource.",
                "+func PublisherTopicPath(project, topic string) string {",
                "+\treturn \"\" +",
                "+\t\t\"projects/\" +",
                "+\t\tproject +",
                "+\t\t\"/topics/\" +",
                "+\t\ttopic +",
                "+\t\t\"\"",
                "+}",
                "+",
                "+func (c *PublisherClient) SubscriptionIAM(subscription *pubsubpb.Subscription) *iam.Handle {",
                "+\treturn iam.InternalNewHandle(c.Connection(), subscription.Name)",
                "+}",
                "+",
                "+func (c *PublisherClient) TopicIAM(topic *pubsubpb.Topic) *iam.Handle {",
                "+\treturn iam.InternalNewHandle(c.Connection(), topic.Name)",
                "+}",
                "+",
                "+// CreateTopic creates the given topic with the given name.",
                "+func (c *PublisherClient) CreateTopic(ctx context.Context, req *pubsubpb.Topic, opts ...gax.CallOption) (*pubsubpb.Topic, error) {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.CreateTopic[0:len(c.CallOptions.CreateTopic):len(c.CallOptions.CreateTopic)], opts...)",
                "+\tvar resp *pubsubpb.Topic",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\tresp, err = c.publisherClient.CreateTopic(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp, nil",
                "+}",
                "+",
                "+// UpdateTopic updates an existing topic. Note that certain properties of a topic are not",
                "+// modifiable.  Options settings follow the style guide:",
                "+// NOTE:  The style guide requires body: \"topic\" instead of body: \"*\".",
                "+// Keeping the latter for internal consistency in V1, however it should be",
                "+// corrected in V2.  See",
                "+// https://cloud.google.com/apis/design/standard_methods#update for details.",
                "+func (c *PublisherClient) UpdateTopic(ctx context.Context, req *pubsubpb.UpdateTopicRequest, opts ...gax.CallOption) (*pubsubpb.Topic, error) {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.UpdateTopic[0:len(c.CallOptions.UpdateTopic):len(c.CallOptions.UpdateTopic)], opts...)",
                "+\tvar resp *pubsubpb.Topic",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\tresp, err = c.publisherClient.UpdateTopic(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp, nil",
                "+}",
                "+",
                "+// Publish adds one or more messages to the topic. Returns NOT_FOUND if the topic",
                "+// does not exist. The message payload must not be empty; it must contain",
                "+// either a non-empty data field, or at least one attribute.",
                "+func (c *PublisherClient) Publish(ctx context.Context, req *pubsubpb.PublishRequest, opts ...gax.CallOption) (*pubsubpb.PublishResponse, error) {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.Publish[0:len(c.CallOptions.Publish):len(c.CallOptions.Publish)], opts...)",
                "+\tvar resp *pubsubpb.PublishResponse",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\tresp, err = c.publisherClient.Publish(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp, nil",
                "+}",
                "+",
                "+// GetTopic gets the configuration of a topic.",
                "+func (c *PublisherClient) GetTopic(ctx context.Context, req *pubsubpb.GetTopicRequest, opts ...gax.CallOption) (*pubsubpb.Topic, error) {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.GetTopic[0:len(c.CallOptions.GetTopic):len(c.CallOptions.GetTopic)], opts...)",
                "+\tvar resp *pubsubpb.Topic",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\tresp, err = c.publisherClient.GetTopic(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp, nil",
                "+}",
                "+",
                "+// ListTopics lists matching topics.",
                "+func (c *PublisherClient) ListTopics(ctx context.Context, req *pubsubpb.ListTopicsRequest, opts ...gax.CallOption) *TopicIterator {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.ListTopics[0:len(c.CallOptions.ListTopics):len(c.CallOptions.ListTopics)], opts...)",
                "+\tit := &TopicIterator{}",
                "+\tit.InternalFetch = func(pageSize int, pageToken string) ([]*pubsubpb.Topic, string, error) {",
                "+\t\tvar resp *pubsubpb.ListTopicsResponse",
                "+\t\treq.PageToken = pageToken",
                "+\t\tif pageSize > math.MaxInt32 {",
                "+\t\t\treq.PageSize = math.MaxInt32",
                "+\t\t} else {",
                "+\t\t\treq.PageSize = int32(pageSize)",
                "+\t\t}",
                "+\t\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\t\tvar err error",
                "+\t\t\tresp, err = c.publisherClient.ListTopics(ctx, req, settings.GRPC...)",
                "+\t\t\treturn err",
                "+\t\t}, opts...)",
                "+\t\tif err != nil {",
                "+\t\t\treturn nil, \"\", err",
                "+\t\t}",
                "+\t\treturn resp.Topics, resp.NextPageToken, nil",
                "+\t}",
                "+\tfetch := func(pageSize int, pageToken string) (string, error) {",
                "+\t\titems, nextPageToken, err := it.InternalFetch(pageSize, pageToken)",
                "+\t\tif err != nil {",
                "+\t\t\treturn \"\", err",
                "+\t\t}",
                "+\t\tit.items = append(it.items, items...)",
                "+\t\treturn nextPageToken, nil",
                "+\t}",
                "+\tit.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)",
                "+\treturn it",
                "+}",
                "+",
                "+// ListTopicSubscriptions lists the name of the subscriptions for this topic.",
                "+func (c *PublisherClient) ListTopicSubscriptions(ctx context.Context, req *pubsubpb.ListTopicSubscriptionsRequest, opts ...gax.CallOption) *StringIterator {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.ListTopicSubscriptions[0:len(c.CallOptions.ListTopicSubscriptions):len(c.CallOptions.ListTopicSubscriptions)], opts...)",
                "+\tit := &StringIterator{}",
                "+\tit.InternalFetch = func(pageSize int, pageToken string) ([]string, string, error) {",
                "+\t\tvar resp *pubsubpb.ListTopicSubscriptionsResponse",
                "+\t\treq.PageToken = pageToken",
                "+\t\tif pageSize > math.MaxInt32 {",
                "+\t\t\treq.PageSize = math.MaxInt32",
                "+\t\t} else {",
                "+\t\t\treq.PageSize = int32(pageSize)",
                "+\t\t}",
                "+\t\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\t\tvar err error",
                "+\t\t\tresp, err = c.publisherClient.ListTopicSubscriptions(ctx, req, settings.GRPC...)",
                "+\t\t\treturn err",
                "+\t\t}, opts...)",
                "+\t\tif err != nil {",
                "+\t\t\treturn nil, \"\", err",
                "+\t\t}",
                "+\t\treturn resp.Subscriptions, resp.NextPageToken, nil",
                "+\t}",
                "+\tfetch := func(pageSize int, pageToken string) (string, error) {",
                "+\t\titems, nextPageToken, err := it.InternalFetch(pageSize, pageToken)",
                "+\t\tif err != nil {",
                "+\t\t\treturn \"\", err",
                "+\t\t}",
                "+\t\tit.items = append(it.items, items...)",
                "+\t\treturn nextPageToken, nil",
                "+\t}",
                "+\tit.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)",
                "+\treturn it",
                "+}",
                "+",
                "+// DeleteTopic deletes the topic with the given name. Returns NOT_FOUND if the topic",
                "+// does not exist. After a topic is deleted, a new topic may be created with",
                "+// the same name; this is an entirely new topic with none of the old",
                "+// configuration or subscriptions. Existing subscriptions to this topic are",
                "+// not deleted, but their topic field is set to _deleted-topic_.",
                "+func (c *PublisherClient) DeleteTopic(ctx context.Context, req *pubsubpb.DeleteTopicRequest, opts ...gax.CallOption) error {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.DeleteTopic[0:len(c.CallOptions.DeleteTopic):len(c.CallOptions.DeleteTopic)], opts...)",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\t_, err = c.publisherClient.DeleteTopic(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\treturn err",
                "+}",
                "+",
                "+// StringIterator manages a stream of string.",
                "+type StringIterator struct {",
                "+\titems    []string",
                "+\tpageInfo *iterator.PageInfo",
                "+\tnextFunc func() error",
                "+",
                "+\t// InternalFetch is for use by the Google Cloud Libraries only.",
                "+\t// It is not part of the stable interface of this package.",
                "+\t//",
                "+\t// InternalFetch returns results from a single call to the underlying RPC.",
                "+\t// The number of results is no greater than pageSize.",
                "+\t// If there are no more results, nextPageToken is empty and err is nil.",
                "+\tInternalFetch func(pageSize int, pageToken string) (results []string, nextPageToken string, err error)",
                "+}",
                "+",
                "+// PageInfo supports pagination. See the google.golang.org/api/iterator package for details.",
                "+func (it *StringIterator) PageInfo() *iterator.PageInfo {",
                "+\treturn it.pageInfo",
                "+}",
                "+",
                "+// Next returns the next result. Its second return value is iterator.Done if there are no more",
                "+// results. Once Next returns Done, all subsequent calls will return Done.",
                "+func (it *StringIterator) Next() (string, error) {",
                "+\tvar item string",
                "+\tif err := it.nextFunc(); err != nil {",
                "+\t\treturn item, err",
                "+\t}",
                "+\titem = it.items[0]",
                "+\tit.items = it.items[1:]",
                "+\treturn item, nil",
                "+}",
                "+",
                "+func (it *StringIterator) bufLen() int {",
                "+\treturn len(it.items)",
                "+}",
                "+",
                "+func (it *StringIterator) takeBuf() interface{} {",
                "+\tb := it.items",
                "+\tit.items = nil",
                "+\treturn b",
                "+}",
                "+",
                "+// TopicIterator manages a stream of *pubsubpb.Topic.",
                "+type TopicIterator struct {",
                "+\titems    []*pubsubpb.Topic",
                "+\tpageInfo *iterator.PageInfo",
                "+\tnextFunc func() error",
                "+",
                "+\t// InternalFetch is for use by the Google Cloud Libraries only.",
                "+\t// It is not part of the stable interface of this package.",
                "+\t//",
                "+\t// InternalFetch returns results from a single call to the underlying RPC.",
                "+\t// The number of results is no greater than pageSize.",
                "+\t// If there are no more results, nextPageToken is empty and err is nil.",
                "+\tInternalFetch func(pageSize int, pageToken string) (results []*pubsubpb.Topic, nextPageToken string, err error)",
                "+}",
                "+",
                "+// PageInfo supports pagination. See the google.golang.org/api/iterator package for details.",
                "+func (it *TopicIterator) PageInfo() *iterator.PageInfo {",
                "+\treturn it.pageInfo",
                "+}",
                "+",
                "+// Next returns the next result. Its second return value is iterator.Done if there are no more",
                "+// results. Once Next returns Done, all subsequent calls will return Done.",
                "+func (it *TopicIterator) Next() (*pubsubpb.Topic, error) {",
                "+\tvar item *pubsubpb.Topic",
                "+\tif err := it.nextFunc(); err != nil {",
                "+\t\treturn item, err",
                "+\t}",
                "+\titem = it.items[0]",
                "+\tit.items = it.items[1:]",
                "+\treturn item, nil",
                "+}",
                "+",
                "+func (it *TopicIterator) bufLen() int {",
                "+\treturn len(it.items)",
                "+}",
                "+",
                "+func (it *TopicIterator) takeBuf() interface{} {",
                "+\tb := it.items",
                "+\tit.items = nil",
                "+\treturn b",
                "+}",
                "diff --git a/vendor/cloud.google.com/go/pubsub/apiv1/subscriber_client.go b/vendor/cloud.google.com/go/pubsub/apiv1/subscriber_client.go",
                "new file mode 100644",
                "index 0000000..574c07d",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/pubsub/apiv1/subscriber_client.go",
                "@@ -0,0 +1,631 @@",
                "+// Copyright 2017, Google Inc. All rights reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//     http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+// AUTO-GENERATED CODE. DO NOT EDIT.",
                "+",
                "+package pubsub",
                "+",
                "+import (",
                "+\t\"math\"",
                "+\t\"time\"",
                "+",
                "+\t\"cloud.google.com/go/iam\"",
                "+\t\"cloud.google.com/go/internal/version\"",
                "+\tgax \"github.com/googleapis/gax-go\"",
                "+\t\"golang.org/x/net/context\"",
                "+\t\"google.golang.org/api/iterator\"",
                "+\t\"google.golang.org/api/option\"",
                "+\t\"google.golang.org/api/transport\"",
                "+\tpubsubpb \"google.golang.org/genproto/googleapis/pubsub/v1\"",
                "+\t\"google.golang.org/grpc\"",
                "+\t\"google.golang.org/grpc/codes\"",
                "+\t\"google.golang.org/grpc/metadata\"",
                "+)",
                "+",
                "+// SubscriberCallOptions contains the retry settings for each method of SubscriberClient.",
                "+type SubscriberCallOptions struct {",
                "+\tCreateSubscription []gax.CallOption",
                "+\tGetSubscription    []gax.CallOption",
                "+\tUpdateSubscription []gax.CallOption",
                "+\tListSubscriptions  []gax.CallOption",
                "+\tDeleteSubscription []gax.CallOption",
                "+\tModifyAckDeadline  []gax.CallOption",
                "+\tAcknowledge        []gax.CallOption",
                "+\tPull               []gax.CallOption",
                "+\tStreamingPull      []gax.CallOption",
                "+\tModifyPushConfig   []gax.CallOption",
                "+\tListSnapshots      []gax.CallOption",
                "+\tCreateSnapshot     []gax.CallOption",
                "+\tUpdateSnapshot     []gax.CallOption",
                "+\tDeleteSnapshot     []gax.CallOption",
                "+\tSeek               []gax.CallOption",
                "+}",
                "+",
                "+func defaultSubscriberClientOptions() []option.ClientOption {",
                "+\treturn []option.ClientOption{",
                "+\t\toption.WithEndpoint(\"pubsub.googleapis.com:443\"),",
                "+\t\toption.WithScopes(DefaultAuthScopes()...),",
                "+\t}",
                "+}",
                "+",
                "+func defaultSubscriberCallOptions() *SubscriberCallOptions {",
                "+\tretry := map[[2]string][]gax.CallOption{",
                "+\t\t{\"default\", \"idempotent\"}: {",
                "+\t\t\tgax.WithRetry(func() gax.Retryer {",
                "+\t\t\t\treturn gax.OnCodes([]codes.Code{",
                "+\t\t\t\t\tcodes.DeadlineExceeded,",
                "+\t\t\t\t\tcodes.Unavailable,",
                "+\t\t\t\t}, gax.Backoff{",
                "+\t\t\t\t\tInitial:    100 * time.Millisecond,",
                "+\t\t\t\t\tMax:        60000 * time.Millisecond,",
                "+\t\t\t\t\tMultiplier: 1.3,",
                "+\t\t\t\t})",
                "+\t\t\t}),",
                "+\t\t},",
                "+\t\t{\"messaging\", \"pull\"}: {",
                "+\t\t\tgax.WithRetry(func() gax.Retryer {",
                "+\t\t\t\treturn gax.OnCodes([]codes.Code{",
                "+\t\t\t\t\tcodes.Canceled,",
                "+\t\t\t\t\tcodes.DeadlineExceeded,",
                "+\t\t\t\t\tcodes.Internal,",
                "+\t\t\t\t\tcodes.ResourceExhausted,",
                "+\t\t\t\t\tcodes.Unavailable,",
                "+\t\t\t\t}, gax.Backoff{",
                "+\t\t\t\t\tInitial:    100 * time.Millisecond,",
                "+\t\t\t\t\tMax:        60000 * time.Millisecond,",
                "+\t\t\t\t\tMultiplier: 1.3,",
                "+\t\t\t\t})",
                "+\t\t\t}),",
                "+\t\t},",
                "+\t\t{\"streaming_messaging\", \"pull\"}: {",
                "+\t\t\tgax.WithRetry(func() gax.Retryer {",
                "+\t\t\t\treturn gax.OnCodes([]codes.Code{",
                "+\t\t\t\t\tcodes.Canceled,",
                "+\t\t\t\t\tcodes.DeadlineExceeded,",
                "+\t\t\t\t\tcodes.Internal,",
                "+\t\t\t\t\tcodes.ResourceExhausted,",
                "+\t\t\t\t\tcodes.Unavailable,",
                "+\t\t\t\t}, gax.Backoff{",
                "+\t\t\t\t\tInitial:    100 * time.Millisecond,",
                "+\t\t\t\t\tMax:        60000 * time.Millisecond,",
                "+\t\t\t\t\tMultiplier: 1.3,",
                "+\t\t\t\t})",
                "+\t\t\t}),",
                "+\t\t},",
                "+\t}",
                "+\treturn &SubscriberCallOptions{",
                "+\t\tCreateSubscription: retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tGetSubscription:    retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tUpdateSubscription: retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tListSubscriptions:  retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tDeleteSubscription: retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tModifyAckDeadline:  retry[[2]string{\"default\", \"non_idempotent\"}],",
                "+\t\tAcknowledge:        retry[[2]string{\"messaging\", \"non_idempotent\"}],",
                "+\t\tPull:               retry[[2]string{\"messaging\", \"pull\"}],",
                "+\t\tStreamingPull:      retry[[2]string{\"streaming_messaging\", \"pull\"}],",
                "+\t\tModifyPushConfig:   retry[[2]string{\"default\", \"non_idempotent\"}],",
                "+\t\tListSnapshots:      retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tCreateSnapshot:     retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tUpdateSnapshot:     retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tDeleteSnapshot:     retry[[2]string{\"default\", \"idempotent\"}],",
                "+\t\tSeek:               retry[[2]string{\"default\", \"non_idempotent\"}],",
                "+\t}",
                "+}",
                "+",
                "+// SubscriberClient is a client for interacting with Google Cloud Pub/Sub API.",
                "+type SubscriberClient struct {",
                "+\t// The connection to the service.",
                "+\tconn *grpc.ClientConn",
                "+",
                "+\t// The gRPC API client.",
                "+\tsubscriberClient pubsubpb.SubscriberClient",
                "+",
                "+\t// The call options for this service.",
                "+\tCallOptions *SubscriberCallOptions",
                "+",
                "+\t// The metadata to be sent with each request.",
                "+\tMetadata metadata.MD",
                "+}",
                "+",
                "+// NewSubscriberClient creates a new subscriber client.",
                "+//",
                "+// The service that an application uses to manipulate subscriptions and to",
                "+// consume messages from a subscription via the Pull method.",
                "+func NewSubscriberClient(ctx context.Context, opts ...option.ClientOption) (*SubscriberClient, error) {",
                "+\tconn, err := transport.DialGRPC(ctx, append(defaultSubscriberClientOptions(), opts...)...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tc := &SubscriberClient{",
                "+\t\tconn:        conn,",
                "+\t\tCallOptions: defaultSubscriberCallOptions(),",
                "+",
                "+\t\tsubscriberClient: pubsubpb.NewSubscriberClient(conn),",
                "+\t}",
                "+\tc.SetGoogleClientInfo()",
                "+\treturn c, nil",
                "+}",
                "+",
                "+// Connection returns the client's connection to the API service.",
                "+func (c *SubscriberClient) Connection() *grpc.ClientConn {",
                "+\treturn c.conn",
                "+}",
                "+",
                "+// Close closes the connection to the API service. The user should invoke this when",
                "+// the client is no longer required.",
                "+func (c *SubscriberClient) Close() error {",
                "+\treturn c.conn.Close()",
                "+}",
                "+",
                "+// SetGoogleClientInfo sets the name and version of the application in",
                "+// the `x-goog-api-client` header passed on each request. Intended for",
                "+// use by Google-written clients.",
                "+func (c *SubscriberClient) SetGoogleClientInfo(keyval ...string) {",
                "+\tkv := append([]string{\"gl-go\", version.Go()}, keyval...)",
                "+\tkv = append(kv, \"gapic\", version.Repo, \"gax\", gax.Version, \"grpc\", grpc.Version)",
                "+\tc.Metadata = metadata.Pairs(\"x-goog-api-client\", gax.XGoogHeader(kv...))",
                "+}",
                "+",
                "+// SubscriberProjectPath returns the path for the project resource.",
                "+func SubscriberProjectPath(project string) string {",
                "+\treturn \"\" +",
                "+\t\t\"projects/\" +",
                "+\t\tproject +",
                "+\t\t\"\"",
                "+}",
                "+",
                "+// SubscriberSnapshotPath returns the path for the snapshot resource.",
                "+func SubscriberSnapshotPath(project, snapshot string) string {",
                "+\treturn \"\" +",
                "+\t\t\"projects/\" +",
                "+\t\tproject +",
                "+\t\t\"/snapshots/\" +",
                "+\t\tsnapshot +",
                "+\t\t\"\"",
                "+}",
                "+",
                "+// SubscriberSubscriptionPath returns the path for the subscription resource.",
                "+func SubscriberSubscriptionPath(project, subscription string) string {",
                "+\treturn \"\" +",
                "+\t\t\"projects/\" +",
                "+\t\tproject +",
                "+\t\t\"/subscriptions/\" +",
                "+\t\tsubscription +",
                "+\t\t\"\"",
                "+}",
                "+",
                "+// SubscriberTopicPath returns the path for the topic resource.",
                "+func SubscriberTopicPath(project, topic string) string {",
                "+\treturn \"\" +",
                "+\t\t\"projects/\" +",
                "+\t\tproject +",
                "+\t\t\"/topics/\" +",
                "+\t\ttopic +",
                "+\t\t\"\"",
                "+}",
                "+",
                "+func (c *SubscriberClient) SubscriptionIAM(subscription *pubsubpb.Subscription) *iam.Handle {",
                "+\treturn iam.InternalNewHandle(c.Connection(), subscription.Name)",
                "+}",
                "+",
                "+func (c *SubscriberClient) TopicIAM(topic *pubsubpb.Topic) *iam.Handle {",
                "+\treturn iam.InternalNewHandle(c.Connection(), topic.Name)",
                "+}",
                "+",
                "+// CreateSubscription creates a subscription to a given topic.",
                "+// If the subscription already exists, returns ALREADY_EXISTS.",
                "+// If the corresponding topic doesn't exist, returns NOT_FOUND.",
                "+//",
                "+// If the name is not provided in the request, the server will assign a random",
                "+// name for this subscription on the same project as the topic, conforming",
                "+// to the",
                "+// resource name format (at https://cloud.google.com/pubsub/docs/overview#names).",
                "+// The generated name is populated in the returned Subscription object.",
                "+// Note that for REST API requests, you must specify a name in the request.",
                "+func (c *SubscriberClient) CreateSubscription(ctx context.Context, req *pubsubpb.Subscription, opts ...gax.CallOption) (*pubsubpb.Subscription, error) {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.CreateSubscription[0:len(c.CallOptions.CreateSubscription):len(c.CallOptions.CreateSubscription)], opts...)",
                "+\tvar resp *pubsubpb.Subscription",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\tresp, err = c.subscriberClient.CreateSubscription(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp, nil",
                "+}",
                "+",
                "+// GetSubscription gets the configuration details of a subscription.",
                "+func (c *SubscriberClient) GetSubscription(ctx context.Context, req *pubsubpb.GetSubscriptionRequest, opts ...gax.CallOption) (*pubsubpb.Subscription, error) {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.GetSubscription[0:len(c.CallOptions.GetSubscription):len(c.CallOptions.GetSubscription)], opts...)",
                "+\tvar resp *pubsubpb.Subscription",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\tresp, err = c.subscriberClient.GetSubscription(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp, nil",
                "+}",
                "+",
                "+// UpdateSubscription updates an existing subscription. Note that certain properties of a",
                "+// subscription, such as its topic, are not modifiable.",
                "+// NOTE:  The style guide requires body: \"subscription\" instead of body: \"*\".",
                "+// Keeping the latter for internal consistency in V1, however it should be",
                "+// corrected in V2.  See",
                "+// https://cloud.google.com/apis/design/standard_methods#update for details.",
                "+func (c *SubscriberClient) UpdateSubscription(ctx context.Context, req *pubsubpb.UpdateSubscriptionRequest, opts ...gax.CallOption) (*pubsubpb.Subscription, error) {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.UpdateSubscription[0:len(c.CallOptions.UpdateSubscription):len(c.CallOptions.UpdateSubscription)], opts...)",
                "+\tvar resp *pubsubpb.Subscription",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\tresp, err = c.subscriberClient.UpdateSubscription(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp, nil",
                "+}",
                "+",
                "+// ListSubscriptions lists matching subscriptions.",
                "+func (c *SubscriberClient) ListSubscriptions(ctx context.Context, req *pubsubpb.ListSubscriptionsRequest, opts ...gax.CallOption) *SubscriptionIterator {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.ListSubscriptions[0:len(c.CallOptions.ListSubscriptions):len(c.CallOptions.ListSubscriptions)], opts...)",
                "+\tit := &SubscriptionIterator{}",
                "+\tit.InternalFetch = func(pageSize int, pageToken string) ([]*pubsubpb.Subscription, string, error) {",
                "+\t\tvar resp *pubsubpb.ListSubscriptionsResponse",
                "+\t\treq.PageToken = pageToken",
                "+\t\tif pageSize > math.MaxInt32 {",
                "+\t\t\treq.PageSize = math.MaxInt32",
                "+\t\t} else {",
                "+\t\t\treq.PageSize = int32(pageSize)",
                "+\t\t}",
                "+\t\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\t\tvar err error",
                "+\t\t\tresp, err = c.subscriberClient.ListSubscriptions(ctx, req, settings.GRPC...)",
                "+\t\t\treturn err",
                "+\t\t}, opts...)",
                "+\t\tif err != nil {",
                "+\t\t\treturn nil, \"\", err",
                "+\t\t}",
                "+\t\treturn resp.Subscriptions, resp.NextPageToken, nil",
                "+\t}",
                "+\tfetch := func(pageSize int, pageToken string) (string, error) {",
                "+\t\titems, nextPageToken, err := it.InternalFetch(pageSize, pageToken)",
                "+\t\tif err != nil {",
                "+\t\t\treturn \"\", err",
                "+\t\t}",
                "+\t\tit.items = append(it.items, items...)",
                "+\t\treturn nextPageToken, nil",
                "+\t}",
                "+\tit.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)",
                "+\treturn it",
                "+}",
                "+",
                "+// DeleteSubscription deletes an existing subscription. All messages retained in the subscription",
                "+// are immediately dropped. Calls to Pull after deletion will return",
                "+// NOT_FOUND. After a subscription is deleted, a new one may be created with",
                "+// the same name, but the new one has no association with the old",
                "+// subscription or its topic unless the same topic is specified.",
                "+func (c *SubscriberClient) DeleteSubscription(ctx context.Context, req *pubsubpb.DeleteSubscriptionRequest, opts ...gax.CallOption) error {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.DeleteSubscription[0:len(c.CallOptions.DeleteSubscription):len(c.CallOptions.DeleteSubscription)], opts...)",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\t_, err = c.subscriberClient.DeleteSubscription(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\treturn err",
                "+}",
                "+",
                "+// ModifyAckDeadline modifies the ack deadline for a specific message. This method is useful",
                "+// to indicate that more time is needed to process a message by the",
                "+// subscriber, or to make the message available for redelivery if the",
                "+// processing was interrupted. Note that this does not modify the",
                "+// subscription-level ackDeadlineSeconds used for subsequent messages.",
                "+func (c *SubscriberClient) ModifyAckDeadline(ctx context.Context, req *pubsubpb.ModifyAckDeadlineRequest, opts ...gax.CallOption) error {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.ModifyAckDeadline[0:len(c.CallOptions.ModifyAckDeadline):len(c.CallOptions.ModifyAckDeadline)], opts...)",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\t_, err = c.subscriberClient.ModifyAckDeadline(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\treturn err",
                "+}",
                "+",
                "+// Acknowledge acknowledges the messages associated with the ack_ids in the",
                "+// AcknowledgeRequest. The Pub/Sub system can remove the relevant messages",
                "+// from the subscription.",
                "+//",
                "+// Acknowledging a message whose ack deadline has expired may succeed,",
                "+// but such a message may be redelivered later. Acknowledging a message more",
                "+// than once will not result in an error.",
                "+func (c *SubscriberClient) Acknowledge(ctx context.Context, req *pubsubpb.AcknowledgeRequest, opts ...gax.CallOption) error {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.Acknowledge[0:len(c.CallOptions.Acknowledge):len(c.CallOptions.Acknowledge)], opts...)",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\t_, err = c.subscriberClient.Acknowledge(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\treturn err",
                "+}",
                "+",
                "+// Pull pulls messages from the server. Returns an empty list if there are no",
                "+// messages available in the backlog. The server may return UNAVAILABLE if",
                "+// there are too many concurrent pull requests pending for the given",
                "+// subscription.",
                "+func (c *SubscriberClient) Pull(ctx context.Context, req *pubsubpb.PullRequest, opts ...gax.CallOption) (*pubsubpb.PullResponse, error) {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.Pull[0:len(c.CallOptions.Pull):len(c.CallOptions.Pull)], opts...)",
                "+\tvar resp *pubsubpb.PullResponse",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\tresp, err = c.subscriberClient.Pull(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp, nil",
                "+}",
                "+",
                "+// StreamingPull (EXPERIMENTAL) StreamingPull is an experimental feature. This RPC will",
                "+// respond with UNIMPLEMENTED errors unless you have been invited to test",
                "+// this feature. Contact cloud-pubsub@google.com with any questions.",
                "+//",
                "+// Establishes a stream with the server, which sends messages down to the",
                "+// client. The client streams acknowledgements and ack deadline modifications",
                "+// back to the server. The server will close the stream and return the status",
                "+// on any error. The server may close the stream with status OK to reassign",
                "+// server-side resources, in which case, the client should re-establish the",
                "+// stream. UNAVAILABLE may also be returned in the case of a transient error",
                "+// (e.g., a server restart). These should also be retried by the client. Flow",
                "+// control can be achieved by configuring the underlying RPC channel.",
                "+func (c *SubscriberClient) StreamingPull(ctx context.Context, opts ...gax.CallOption) (pubsubpb.Subscriber_StreamingPullClient, error) {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.StreamingPull[0:len(c.CallOptions.StreamingPull):len(c.CallOptions.StreamingPull)], opts...)",
                "+\tvar resp pubsubpb.Subscriber_StreamingPullClient",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\tresp, err = c.subscriberClient.StreamingPull(ctx, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp, nil",
                "+}",
                "+",
                "+// ModifyPushConfig modifies the PushConfig for a specified subscription.",
                "+//",
                "+// This may be used to change a push subscription to a pull one (signified by",
                "+// an empty PushConfig) or vice versa, or change the endpoint URL and other",
                "+// attributes of a push subscription. Messages will accumulate for delivery",
                "+// continuously through the call regardless of changes to the PushConfig.",
                "+func (c *SubscriberClient) ModifyPushConfig(ctx context.Context, req *pubsubpb.ModifyPushConfigRequest, opts ...gax.CallOption) error {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.ModifyPushConfig[0:len(c.CallOptions.ModifyPushConfig):len(c.CallOptions.ModifyPushConfig)], opts...)",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\t_, err = c.subscriberClient.ModifyPushConfig(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\treturn err",
                "+}",
                "+",
                "+// ListSnapshots lists the existing snapshots.",
                "+func (c *SubscriberClient) ListSnapshots(ctx context.Context, req *pubsubpb.ListSnapshotsRequest, opts ...gax.CallOption) *SnapshotIterator {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.ListSnapshots[0:len(c.CallOptions.ListSnapshots):len(c.CallOptions.ListSnapshots)], opts...)",
                "+\tit := &SnapshotIterator{}",
                "+\tit.InternalFetch = func(pageSize int, pageToken string) ([]*pubsubpb.Snapshot, string, error) {",
                "+\t\tvar resp *pubsubpb.ListSnapshotsResponse",
                "+\t\treq.PageToken = pageToken",
                "+\t\tif pageSize > math.MaxInt32 {",
                "+\t\t\treq.PageSize = math.MaxInt32",
                "+\t\t} else {",
                "+\t\t\treq.PageSize = int32(pageSize)",
                "+\t\t}",
                "+\t\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\t\tvar err error",
                "+\t\t\tresp, err = c.subscriberClient.ListSnapshots(ctx, req, settings.GRPC...)",
                "+\t\t\treturn err",
                "+\t\t}, opts...)",
                "+\t\tif err != nil {",
                "+\t\t\treturn nil, \"\", err",
                "+\t\t}",
                "+\t\treturn resp.Snapshots, resp.NextPageToken, nil",
                "+\t}",
                "+\tfetch := func(pageSize int, pageToken string) (string, error) {",
                "+\t\titems, nextPageToken, err := it.InternalFetch(pageSize, pageToken)",
                "+\t\tif err != nil {",
                "+\t\t\treturn \"\", err",
                "+\t\t}",
                "+\t\tit.items = append(it.items, items...)",
                "+\t\treturn nextPageToken, nil",
                "+\t}",
                "+\tit.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)",
                "+\treturn it",
                "+}",
                "+",
                "+// CreateSnapshot creates a snapshot from the requested subscription.",
                "+// If the snapshot already exists, returns ALREADY_EXISTS.",
                "+// If the requested subscription doesn't exist, returns NOT_FOUND.",
                "+//",
                "+// If the name is not provided in the request, the server will assign a random",
                "+// name for this snapshot on the same project as the subscription, conforming",
                "+// to the",
                "+// resource name format (at https://cloud.google.com/pubsub/docs/overview#names).",
                "+// The generated name is populated in the returned Snapshot object.",
                "+// Note that for REST API requests, you must specify a name in the request.",
                "+func (c *SubscriberClient) CreateSnapshot(ctx context.Context, req *pubsubpb.CreateSnapshotRequest, opts ...gax.CallOption) (*pubsubpb.Snapshot, error) {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.CreateSnapshot[0:len(c.CallOptions.CreateSnapshot):len(c.CallOptions.CreateSnapshot)], opts...)",
                "+\tvar resp *pubsubpb.Snapshot",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\tresp, err = c.subscriberClient.CreateSnapshot(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp, nil",
                "+}",
                "+",
                "+// UpdateSnapshot updates an existing snapshot. Note that certain properties of a snapshot",
                "+// are not modifiable.",
                "+// NOTE:  The style guide requires body: \"snapshot\" instead of body: \"*\".",
                "+// Keeping the latter for internal consistency in V1, however it should be",
                "+// corrected in V2.  See",
                "+// https://cloud.google.com/apis/design/standard_methods#update for details.",
                "+func (c *SubscriberClient) UpdateSnapshot(ctx context.Context, req *pubsubpb.UpdateSnapshotRequest, opts ...gax.CallOption) (*pubsubpb.Snapshot, error) {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.UpdateSnapshot[0:len(c.CallOptions.UpdateSnapshot):len(c.CallOptions.UpdateSnapshot)], opts...)",
                "+\tvar resp *pubsubpb.Snapshot",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\tresp, err = c.subscriberClient.UpdateSnapshot(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp, nil",
                "+}",
                "+",
                "+// DeleteSnapshot removes an existing snapshot. All messages retained in the snapshot",
                "+// are immediately dropped. After a snapshot is deleted, a new one may be",
                "+// created with the same name, but the new one has no association with the old",
                "+// snapshot or its subscription, unless the same subscription is specified.",
                "+func (c *SubscriberClient) DeleteSnapshot(ctx context.Context, req *pubsubpb.DeleteSnapshotRequest, opts ...gax.CallOption) error {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.DeleteSnapshot[0:len(c.CallOptions.DeleteSnapshot):len(c.CallOptions.DeleteSnapshot)], opts...)",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\t_, err = c.subscriberClient.DeleteSnapshot(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\treturn err",
                "+}",
                "+",
                "+// Seek seeks an existing subscription to a point in time or to a given snapshot,",
                "+// whichever is provided in the request.",
                "+func (c *SubscriberClient) Seek(ctx context.Context, req *pubsubpb.SeekRequest, opts ...gax.CallOption) (*pubsubpb.SeekResponse, error) {",
                "+\tctx = insertMetadata(ctx, c.Metadata)",
                "+\topts = append(c.CallOptions.Seek[0:len(c.CallOptions.Seek):len(c.CallOptions.Seek)], opts...)",
                "+\tvar resp *pubsubpb.SeekResponse",
                "+\terr := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {",
                "+\t\tvar err error",
                "+\t\tresp, err = c.subscriberClient.Seek(ctx, req, settings.GRPC...)",
                "+\t\treturn err",
                "+\t}, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp, nil",
                "+}",
                "+",
                "+// SnapshotIterator manages a stream of *pubsubpb.Snapshot.",
                "+type SnapshotIterator struct {",
                "+\titems    []*pubsubpb.Snapshot",
                "+\tpageInfo *iterator.PageInfo",
                "+\tnextFunc func() error",
                "+",
                "+\t// InternalFetch is for use by the Google Cloud Libraries only.",
                "+\t// It is not part of the stable interface of this package.",
                "+\t//",
                "+\t// InternalFetch returns results from a single call to the underlying RPC.",
                "+\t// The number of results is no greater than pageSize.",
                "+\t// If there are no more results, nextPageToken is empty and err is nil.",
                "+\tInternalFetch func(pageSize int, pageToken string) (results []*pubsubpb.Snapshot, nextPageToken string, err error)",
                "+}",
                "+",
                "+// PageInfo supports pagination. See the google.golang.org/api/iterator package for details.",
                "+func (it *SnapshotIterator) PageInfo() *iterator.PageInfo {",
                "+\treturn it.pageInfo",
                "+}",
                "+",
                "+// Next returns the next result. Its second return value is iterator.Done if there are no more",
                "+// results. Once Next returns Done, all subsequent calls will return Done.",
                "+func (it *SnapshotIterator) Next() (*pubsubpb.Snapshot, error) {",
                "+\tvar item *pubsubpb.Snapshot",
                "+\tif err := it.nextFunc(); err != nil {",
                "+\t\treturn item, err",
                "+\t}",
                "+\titem = it.items[0]",
                "+\tit.items = it.items[1:]",
                "+\treturn item, nil",
                "+}",
                "+",
                "+func (it *SnapshotIterator) bufLen() int {",
                "+\treturn len(it.items)",
                "+}",
                "+",
                "+func (it *SnapshotIterator) takeBuf() interface{} {",
                "+\tb := it.items",
                "+\tit.items = nil",
                "+\treturn b",
                "+}",
                "+",
                "+// SubscriptionIterator manages a stream of *pubsubpb.Subscription.",
                "+type SubscriptionIterator struct {",
                "+\titems    []*pubsubpb.Subscription",
                "+\tpageInfo *iterator.PageInfo",
                "+\tnextFunc func() error",
                "+",
                "+\t// InternalFetch is for use by the Google Cloud Libraries only.",
                "+\t// It is not part of the stable interface of this package.",
                "+\t//",
                "+\t// InternalFetch returns results from a single call to the underlying RPC.",
                "+\t// The number of results is no greater than pageSize.",
                "+\t// If there are no more results, nextPageToken is empty and err is nil.",
                "+\tInternalFetch func(pageSize int, pageToken string) (results []*pubsubpb.Subscription, nextPageToken string, err error)",
                "+}",
                "+",
                "+// PageInfo supports pagination. See the google.golang.org/api/iterator package for details.",
                "+func (it *SubscriptionIterator) PageInfo() *iterator.PageInfo {",
                "+\treturn it.pageInfo",
                "+}",
                "+",
                "+// Next returns the next result. Its second return value is iterator.Done if there are no more",
                "+// results. Once Next returns Done, all subsequent calls will return Done.",
                "+func (it *SubscriptionIterator) Next() (*pubsubpb.Subscription, error) {",
                "+\tvar item *pubsubpb.Subscription",
                "+\tif err := it.nextFunc(); err != nil {",
                "+\t\treturn item, err",
                "+\t}",
                "+\titem = it.items[0]",
                "+\tit.items = it.items[1:]",
                "+\treturn item, nil",
                "+}",
                "+",
                "+func (it *SubscriptionIterator) bufLen() int {",
                "+\treturn len(it.items)",
                "+}",
                "+",
                "+func (it *SubscriptionIterator) takeBuf() interface{} {",
                "+\tb := it.items",
                "+\tit.items = nil",
                "+\treturn b",
                "+}",
                "diff --git a/vendor/cloud.google.com/go/pubsub/doc.go b/vendor/cloud.google.com/go/pubsub/doc.go",
                "new file mode 100644",
                "index 0000000..3349f07",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/pubsub/doc.go",
                "@@ -0,0 +1,120 @@",
                "+// Copyright 2016 Google Inc. All Rights Reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//      http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+/*",
                "+Package pubsub provides an easy way to publish and receive Google Cloud Pub/Sub",
                "+messages, hiding the the details of the underlying server RPCs.  Google Cloud",
                "+Pub/Sub is a many-to-many, asynchronous messaging system that decouples senders",
                "+and receivers.",
                "+",
                "+Note: This package is in beta. Some backwards-incompatible changes may occur.",
                "+",
                "+More information about Google Cloud Pub/Sub is available at",
                "+https://cloud.google.com/pubsub/docs",
                "+",
                "+Publishing",
                "+",
                "+Google Cloud Pub/Sub messages are published to topics. Topics may be created",
                "+using the pubsub package like so:",
                "+",
                "+ topic, err := pubsubClient.CreateTopic(context.Background(), \"topic-name\")",
                "+",
                "+Messages may then be published to a topic:",
                "+",
                "+ res := topic.Publish(ctx, &pubsub.Message{Data: []byte(\"payload\")})",
                "+",
                "+Publish queues the message for publishing and returns immediately. When enough",
                "+messages have accumulated, or enough time has elapsed, the batch of messages is",
                "+sent to the Pub/Sub service.",
                "+",
                "+Publish returns a PublishResult, which behaves like a future: its Get method",
                "+blocks until the message has been sent to the service.",
                "+",
                "+The first time you call Publish on a topic, goroutines are started in the",
                "+background. To clean up these goroutines, call Stop:",
                "+",
                "+  topic.Stop()",
                "+",
                "+Receiving",
                "+",
                "+To receive messages published to a topic, clients create subscriptions",
                "+to the topic. There may be more than one subscription per topic; each message",
                "+that is published to the topic will be delivered to all of its subscriptions.",
                "+",
                "+Subsciptions may be created like so:",
                "+",
                "+ sub, err := pubsubClient.CreateSubscription(context.Background(), \"sub-name\",",
                "+\tpubsub.SubscriptionConfig{Topic: topic})",
                "+",
                "+Messages are then consumed from a subscription via callback.",
                "+",
                "+ err := sub.Receive(context.Background(), func(ctx context.Context, m *Message) {",
                "+ \tlog.Printf(\"Got message: %s\", m.Data)",
                "+ \tm.Ack()",
                "+ })",
                "+ if err != nil {",
                "+\t// Handle error.",
                "+ }",
                "+",
                "+The callback is invoked concurrently by multiple goroutines, maximizing",
                "+throughput. To terminate a call to Receive, cancel its context.",
                "+",
                "+Once client code has processed the message, it must call Message.Ack, otherwise",
                "+the message will eventually be redelivered. As an optimization, if the client",
                "+cannot or doesn't want to process the message, it can call Message.Nack to",
                "+speed redelivery. For more information and configuration options, see",
                "+\"Deadlines\" below.",
                "+",
                "+Note: It is possible for Messages to be redelivered, even if Message.Ack has",
                "+been called. Client code must be robust to multiple deliveries of messages.",
                "+",
                "+Deadlines",
                "+",
                "+The default pubsub deadlines are suitable for most use cases, but may be",
                "+overridden.  This section describes the tradeoffs that should be considered",
                "+when overriding the defaults.",
                "+",
                "+Behind the scenes, each message returned by the Pub/Sub server has an",
                "+associated lease, known as an \"ACK deadline\".",
                "+Unless a message is acknowledged within the ACK deadline, or the client requests that",
                "+the ACK deadline be extended, the message will become elegible for redelivery.",
                "+As a convenience, the pubsub package will automatically extend deadlines until",
                "+either:",
                "+ * Message.Ack or Message.Nack is called, or",
                "+ * the \"MaxExtension\" period elapses from the time the message is fetched from the server.",
                "+",
                "+The initial ACK deadline given to each messages defaults to 10 seconds, but may",
                "+be overridden during subscription creation.  Selecting an ACK deadline is a",
                "+tradeoff between message redelivery latency and RPC volume. If the pubsub",
                "+package fails to acknowledge or extend a message (e.g. due to unexpected",
                "+termination of the process), a shorter ACK deadline will generally result in",
                "+faster message redelivery by the Pub/Sub system. However, a short ACK deadline",
                "+may also increase the number of deadline extension RPCs that the pubsub package",
                "+sends to the server.",
                "+",
                "+The default max extension period is DefaultReceiveSettings.MaxExtension, and can",
                "+be overridden by setting Subscription.ReceiveSettings.MaxExtension. Selecting a",
                "+max extension period is a tradeoff between the speed at which client code must",
                "+process messages, and the redelivery delay if messages fail to be acknowledged",
                "+(e.g. because client code neglects to do so). Using a large MaxExtension",
                "+increases the available time for client code to process messages. However, if",
                "+the client code neglects to call Message.Ack/Nack, a large MaxExtension will",
                "+increase the delay before the message is redelivered.",
                "+",
                "+Authentication",
                "+",
                "+See examples of authorization and authentication at",
                "+https://godoc.org/cloud.google.com/go#pkg-examples.",
                "+*/",
                "+package pubsub",
                "diff --git a/vendor/cloud.google.com/go/pubsub/flow_controller.go b/vendor/cloud.google.com/go/pubsub/flow_controller.go",
                "new file mode 100644",
                "index 0000000..0fd7bd6",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/pubsub/flow_controller.go",
                "@@ -0,0 +1,106 @@",
                "+// Copyright 2017 Google Inc. All Rights Reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//      http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+package pubsub",
                "+",
                "+import (",
                "+\t\"golang.org/x/net/context\"",
                "+\t\"golang.org/x/sync/semaphore\"",
                "+)",
                "+",
                "+// flowController implements flow control for Subscription.Receive.",
                "+type flowController struct {",
                "+\tmaxSize           int                 // max total size of messages",
                "+\tsemCount, semSize *semaphore.Weighted // enforces max number and size of messages",
                "+}",
                "+",
                "+// newFlowController creates a new flowController that ensures no more than",
                "+// maxCount messages or maxSize bytes are outstanding at once. If maxCount or",
                "+// maxSize is < 1, then an unlimited number of messages or bytes is permitted,",
                "+// respectively.",
                "+func newFlowController(maxCount, maxSize int) *flowController {",
                "+\tfc := &flowController{",
                "+\t\tmaxSize:  maxSize,",
                "+\t\tsemCount: nil,",
                "+\t\tsemSize:  nil,",
                "+\t}",
                "+\tif maxCount > 0 {",
                "+\t\tfc.semCount = semaphore.NewWeighted(int64(maxCount))",
                "+\t}",
                "+\tif maxSize > 0 {",
                "+\t\tfc.semSize = semaphore.NewWeighted(int64(maxSize))",
                "+\t}",
                "+\treturn fc",
                "+}",
                "+",
                "+// acquire blocks until one message of size bytes can proceed or ctx is done.",
                "+// It returns nil in the first case, or ctx.Err() in the second.",
                "+//",
                "+// acquire allows large messages to proceed by treating a size greater than maxSize",
                "+// as if it were equal to maxSize.",
                "+func (f *flowController) acquire(ctx context.Context, size int) error {",
                "+\tif f.semCount != nil {",
                "+\t\tif err := f.semCount.Acquire(ctx, 1); err != nil {",
                "+\t\t\treturn err",
                "+\t\t}",
                "+\t}",
                "+\tif f.semSize != nil {",
                "+\t\tif err := f.semSize.Acquire(ctx, f.bound(size)); err != nil {",
                "+\t\t\tif f.semCount != nil {",
                "+\t\t\t\tf.semCount.Release(1)",
                "+\t\t\t}",
                "+\t\t\treturn err",
                "+\t\t}",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// tryAcquire returns false if acquire would block. Otherwise, it behaves like",
                "+// acquire and returns true.",
                "+//",
                "+// tryAcquire allows large messages to proceed by treating a size greater than",
                "+// maxSize as if it were equal to maxSize.",
                "+func (f *flowController) tryAcquire(size int) bool {",
                "+\tif f.semCount != nil {",
                "+\t\tif !f.semCount.TryAcquire(1) {",
                "+\t\t\treturn false",
                "+\t\t}",
                "+\t}",
                "+\tif f.semSize != nil {",
                "+\t\tif !f.semSize.TryAcquire(f.bound(size)) {",
                "+\t\t\tif f.semCount != nil {",
                "+\t\t\t\tf.semCount.Release(1)",
                "+\t\t\t}",
                "+\t\t\treturn false",
                "+\t\t}",
                "+\t}",
                "+\treturn true",
                "+}",
                "+",
                "+// release notes that one message of size bytes is no longer outstanding.",
                "+func (f *flowController) release(size int) {",
                "+\tif f.semCount != nil {",
                "+\t\tf.semCount.Release(1)",
                "+\t}",
                "+\tif f.semSize != nil {",
                "+\t\tf.semSize.Release(f.bound(size))",
                "+\t}",
                "+}",
                "+",
                "+func (f *flowController) bound(size int) int64 {",
                "+\tif size > f.maxSize {",
                "+\t\treturn int64(f.maxSize)",
                "+\t}",
                "+\treturn int64(size)",
                "+}",
                "diff --git a/vendor/cloud.google.com/go/pubsub/iterator.go b/vendor/cloud.google.com/go/pubsub/iterator.go",
                "new file mode 100644",
                "index 0000000..12d1f07",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/pubsub/iterator.go",
                "@@ -0,0 +1,271 @@",
                "+// Copyright 2016 Google Inc. All Rights Reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//      http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+package pubsub",
                "+",
                "+import (",
                "+\t\"sync\"",
                "+\t\"time\"",
                "+",
                "+\t\"golang.org/x/net/context\"",
                "+\tpb \"google.golang.org/genproto/googleapis/pubsub/v1\"",
                "+)",
                "+",
                "+// newMessageIterator starts a new streamingMessageIterator.  Stop must be called on the messageIterator",
                "+// when it is no longer needed.",
                "+// subName is the full name of the subscription to pull messages from.",
                "+// ctx is the context to use for acking messages and extending message deadlines.",
                "+func newMessageIterator(ctx context.Context, s service, subName string, po *pullOptions) *streamingMessageIterator {",
                "+\tsp := s.newStreamingPuller(ctx, subName, int32(po.ackDeadline.Seconds()))",
                "+\t_ = sp.open() // error stored in sp",
                "+\treturn newStreamingMessageIterator(ctx, sp, po)",
                "+}",
                "+",
                "+type streamingMessageIterator struct {",
                "+\tctx        context.Context",
                "+\tpo         *pullOptions",
                "+\tsp         *streamingPuller",
                "+\tkaTicker   *time.Ticker  // keep-alive (deadline extensions)",
                "+\tackTicker  *time.Ticker  // message acks",
                "+\tnackTicker *time.Ticker  // message nacks (more frequent than acks)",
                "+\tfailed     chan struct{} // closed on stream error",
                "+\tstopped    chan struct{} // closed when Stop is called",
                "+\tdrained    chan struct{} // closed when stopped && no more pending messages",
                "+\twg         sync.WaitGroup",
                "+",
                "+\tmu                 sync.Mutex",
                "+\tkeepAliveDeadlines map[string]time.Time",
                "+\tpendingReq         *pb.StreamingPullRequest",
                "+\terr                error // error from stream failure",
                "+}",
                "+",
                "+func newStreamingMessageIterator(ctx context.Context, sp *streamingPuller, po *pullOptions) *streamingMessageIterator {",
                "+\t// TODO: make kaTicker frequency more configurable. (ackDeadline - 5s) is a",
                "+\t// reasonable default for now, because the minimum ack period is 10s. This",
                "+\t// gives us 5s grace.",
                "+\tkeepAlivePeriod := po.ackDeadline - 5*time.Second",
                "+\tkaTicker := time.NewTicker(keepAlivePeriod)",
                "+",
                "+\t// Ack promptly so users don't lose work if client crashes.",
                "+\tackTicker := time.NewTicker(100 * time.Millisecond)",
                "+\tnackTicker := time.NewTicker(100 * time.Millisecond)",
                "+\tit := &streamingMessageIterator{",
                "+\t\tctx:                ctx,",
                "+\t\tsp:                 sp,",
                "+\t\tpo:                 po,",
                "+\t\tkaTicker:           kaTicker,",
                "+\t\tackTicker:          ackTicker,",
                "+\t\tnackTicker:         nackTicker,",
                "+\t\tfailed:             make(chan struct{}),",
                "+\t\tstopped:            make(chan struct{}),",
                "+\t\tdrained:            make(chan struct{}),",
                "+\t\tkeepAliveDeadlines: map[string]time.Time{},",
                "+\t\tpendingReq:         &pb.StreamingPullRequest{},",
                "+\t}",
                "+\tit.wg.Add(1)",
                "+\tgo it.sender()",
                "+\treturn it",
                "+}",
                "+",
                "+// Subscription.receive will call stop on its messageIterator when finished with it.",
                "+// Stop will block until Done has been called on all Messages that have been",
                "+// returned by Next, or until the context with which the messageIterator was created",
                "+// is cancelled or exceeds its deadline.",
                "+func (it *streamingMessageIterator) stop() {",
                "+\tit.mu.Lock()",
                "+\tselect {",
                "+\tcase <-it.stopped:",
                "+\tdefault:",
                "+\t\tclose(it.stopped)",
                "+\t}",
                "+\tit.checkDrained()",
                "+\tit.mu.Unlock()",
                "+\tit.wg.Wait()",
                "+}",
                "+",
                "+// checkDrained closes the drained channel if the iterator has been stopped and all",
                "+// pending messages have either been n/acked or expired.",
                "+//",
                "+// Called with the lock held.",
                "+func (it *streamingMessageIterator) checkDrained() {",
                "+\tselect {",
                "+\tcase <-it.drained:",
                "+\t\treturn",
                "+\tdefault:",
                "+\t}",
                "+\tselect {",
                "+\tcase <-it.stopped:",
                "+\t\tif len(it.keepAliveDeadlines) == 0 {",
                "+\t\t\tclose(it.drained)",
                "+\t\t}",
                "+\tdefault:",
                "+\t}",
                "+}",
                "+",
                "+// Called when a message is acked/nacked.",
                "+func (it *streamingMessageIterator) done(ackID string, ack bool) {",
                "+\tit.mu.Lock()",
                "+\tdefer it.mu.Unlock()",
                "+\tdelete(it.keepAliveDeadlines, ackID)",
                "+\tif ack {",
                "+\t\tit.pendingReq.AckIds = append(it.pendingReq.AckIds, ackID)",
                "+\t} else {",
                "+\t\tit.addDeadlineMod(ackID, 0) // Nack indicated by modifying the deadline to zero.",
                "+\t}",
                "+\tit.checkDrained()",
                "+}",
                "+",
                "+// addDeadlineMod adds the ack ID to the pending request with the given deadline.",
                "+//",
                "+// Called with the lock held.",
                "+func (it *streamingMessageIterator) addDeadlineMod(ackID string, deadlineSecs int32) {",
                "+\tpr := it.pendingReq",
                "+\tpr.ModifyDeadlineAckIds = append(pr.ModifyDeadlineAckIds, ackID)",
                "+\tpr.ModifyDeadlineSeconds = append(pr.ModifyDeadlineSeconds, deadlineSecs)",
                "+}",
                "+",
                "+// fail is called when a stream method returns a permanent error.",
                "+func (it *streamingMessageIterator) fail(err error) {",
                "+\tit.mu.Lock()",
                "+\tif it.err == nil {",
                "+\t\tit.err = err",
                "+\t\tclose(it.failed)",
                "+\t}",
                "+\tit.mu.Unlock()",
                "+}",
                "+",
                "+// receive makes a call to the stream's Recv method and returns",
                "+// its messages.",
                "+func (it *streamingMessageIterator) receive() ([]*Message, error) {",
                "+\t// Stop retrieving messages if the context is done, the stream",
                "+\t// failed, or the iterator's Stop method was called.",
                "+\tselect {",
                "+\tcase <-it.ctx.Done():",
                "+\t\treturn nil, it.ctx.Err()",
                "+\tdefault:",
                "+\t}",
                "+\tit.mu.Lock()",
                "+\terr := it.err",
                "+\tit.mu.Unlock()",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\t// Receive messages from stream. This may block indefinitely.",
                "+\tmsgs, err := it.sp.fetchMessages()",
                "+\t// The streamingPuller handles retries, so any error here",
                "+\t// is fatal.",
                "+\tif err != nil {",
                "+\t\tit.fail(err)",
                "+\t\treturn nil, err",
                "+\t}",
                "+\t// We received some messages. Remember them so we can",
                "+\t// keep them alive.",
                "+\tdeadline := time.Now().Add(it.po.maxExtension)",
                "+\tit.mu.Lock()",
                "+\tfor _, m := range msgs {",
                "+\t\tm.doneFunc = it.done",
                "+\t\tit.keepAliveDeadlines[m.ackID] = deadline",
                "+\t}",
                "+\tit.mu.Unlock()",
                "+\treturn msgs, nil",
                "+}",
                "+",
                "+// sender runs in a goroutine and handles all sends to the stream.",
                "+func (it *streamingMessageIterator) sender() {",
                "+\tdefer it.wg.Done()",
                "+\tdefer it.kaTicker.Stop()",
                "+\tdefer it.ackTicker.Stop()",
                "+\tdefer it.nackTicker.Stop()",
                "+\tdefer it.sp.closeSend()",
                "+",
                "+\tdone := false",
                "+\tfor !done {",
                "+\t\tsend := false",
                "+\t\tselect {",
                "+\t\tcase <-it.ctx.Done():",
                "+\t\t\t// Context canceled or timed out: stop immediately, without",
                "+\t\t\t// another RPC.",
                "+\t\t\treturn",
                "+",
                "+\t\tcase <-it.failed:",
                "+\t\t\t// Stream failed: nothing to do, so stop immediately.",
                "+\t\t\treturn",
                "+",
                "+\t\tcase <-it.drained:",
                "+\t\t\t// All outstanding messages have been marked done:",
                "+\t\t\t// nothing left to do except send the final request.",
                "+\t\t\tit.mu.Lock()",
                "+\t\t\tsend = (len(it.pendingReq.AckIds) > 0 || len(it.pendingReq.ModifyDeadlineAckIds) > 0)",
                "+\t\t\tdone = true",
                "+",
                "+\t\tcase <-it.kaTicker.C:",
                "+\t\t\tit.mu.Lock()",
                "+\t\t\tsend = it.handleKeepAlives()",
                "+",
                "+\t\tcase <-it.nackTicker.C:",
                "+\t\t\tit.mu.Lock()",
                "+\t\t\tsend = (len(it.pendingReq.ModifyDeadlineAckIds) > 0)",
                "+",
                "+\t\tcase <-it.ackTicker.C:",
                "+\t\t\tit.mu.Lock()",
                "+\t\t\tsend = (len(it.pendingReq.AckIds) > 0)",
                "+",
                "+\t\t}",
                "+\t\t// Lock is held here.",
                "+\t\tif send {",
                "+\t\t\treq := it.pendingReq",
                "+\t\t\tit.pendingReq = &pb.StreamingPullRequest{}",
                "+\t\t\tit.mu.Unlock()",
                "+\t\t\terr := it.sp.send(req)",
                "+\t\t\tif err != nil {",
                "+\t\t\t\t// The streamingPuller handles retries, so any error here",
                "+\t\t\t\t// is fatal to the iterator.",
                "+\t\t\t\tit.fail(err)",
                "+\t\t\t\treturn",
                "+\t\t\t}",
                "+\t\t} else {",
                "+\t\t\tit.mu.Unlock()",
                "+\t\t}",
                "+\t}",
                "+}",
                "+",
                "+// handleKeepAlives modifies the pending request to include deadline extensions",
                "+// for live messages. It also purges expired messages. It reports whether",
                "+// there were any live messages.",
                "+//",
                "+// Called with the lock held.",
                "+func (it *streamingMessageIterator) handleKeepAlives() bool {",
                "+\tlive, expired := getKeepAliveAckIDs(it.keepAliveDeadlines)",
                "+\tfor _, e := range expired {",
                "+\t\tdelete(it.keepAliveDeadlines, e)",
                "+\t}",
                "+\tdl := trunc32(int64(it.po.ackDeadline.Seconds()))",
                "+\tfor _, m := range live {",
                "+\t\tit.addDeadlineMod(m, dl)",
                "+\t}",
                "+\tit.checkDrained()",
                "+\treturn len(live) > 0",
                "+}",
                "+",
                "+func getKeepAliveAckIDs(items map[string]time.Time) (live, expired []string) {",
                "+\tnow := time.Now()",
                "+\tfor id, expiry := range items {",
                "+\t\tif expiry.Before(now) {",
                "+\t\t\texpired = append(expired, id)",
                "+\t\t} else {",
                "+\t\t\tlive = append(live, id)",
                "+\t\t}",
                "+\t}",
                "+\treturn live, expired",
                "+}",
                "diff --git a/vendor/cloud.google.com/go/pubsub/message.go b/vendor/cloud.google.com/go/pubsub/message.go",
                "new file mode 100644",
                "index 0000000..f6bb5e0",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/pubsub/message.go",
                "@@ -0,0 +1,97 @@",
                "+// Copyright 2016 Google Inc. All Rights Reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//      http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+package pubsub",
                "+",
                "+import (",
                "+\t\"time\"",
                "+",
                "+\t\"github.com/golang/protobuf/ptypes\"",
                "+\tpb \"google.golang.org/genproto/googleapis/pubsub/v1\"",
                "+)",
                "+",
                "+// Message represents a Pub/Sub message.",
                "+type Message struct {",
                "+\t// ID identifies this message.",
                "+\t// This ID is assigned by the server and is populated for Messages obtained from a subscription.",
                "+\t// This field is read-only.",
                "+\tID string",
                "+",
                "+\t// Data is the actual data in the message.",
                "+\tData []byte",
                "+",
                "+\t// Attributes represents the key-value pairs the current message",
                "+\t// is labelled with.",
                "+\tAttributes map[string]string",
                "+",
                "+\t// ackID is the identifier to acknowledge this message.",
                "+\tackID string",
                "+",
                "+\t// The time at which the message was published.",
                "+\t// This is populated by the server for Messages obtained from a subscription.",
                "+\t// This field is read-only.",
                "+\tPublishTime time.Time",
                "+",
                "+\t// size is the approximate size of the message's data and attributes.",
                "+\tsize int",
                "+",
                "+\tcalledDone bool",
                "+",
                "+\t// The done method of the iterator that created this Message.",
                "+\tdoneFunc func(string, bool)",
                "+}",
                "+",
                "+func toMessage(resp *pb.ReceivedMessage) (*Message, error) {",
                "+\tif resp.Message == nil {",
                "+\t\treturn &Message{ackID: resp.AckId}, nil",
                "+\t}",
                "+",
                "+\tpubTime, err := ptypes.Timestamp(resp.Message.PublishTime)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn &Message{",
                "+\t\tackID:       resp.AckId,",
                "+\t\tData:        resp.Message.Data,",
                "+\t\tAttributes:  resp.Message.Attributes,",
                "+\t\tID:          resp.Message.MessageId,",
                "+\t\tPublishTime: pubTime,",
                "+\t}, nil",
                "+}",
                "+",
                "+// Ack indicates successful processing of a Message passed to the Subscriber.Receive callback.",
                "+// It should not be called on any other Message value.",
                "+// If message acknowledgement fails, the Message will be redelivered.",
                "+// Client code must call Ack or Nack when finished for each received Message.",
                "+// Calls to Ack or Nack have no effect after the first call.",
                "+func (m *Message) Ack() {",
                "+\tm.done(true)",
                "+}",
                "+",
                "+// Nack indicates that the client will not or cannot process a Message passed to the Subscriber.Receive callback.",
                "+// It should not be called on any other Message value.",
                "+// Nack will result in the Message being redelivered more quickly than if it were allowed to expire.",
                "+// Client code must call Ack or Nack when finished for each received Message.",
                "+// Calls to Ack or Nack have no effect after the first call.",
                "+func (m *Message) Nack() {",
                "+\tm.done(false)",
                "+}",
                "+",
                "+func (m *Message) done(ack bool) {",
                "+\tif m.calledDone {",
                "+\t\treturn",
                "+\t}",
                "+\tm.calledDone = true",
                "+\tm.doneFunc(m.ackID, ack)",
                "+}",
                "diff --git a/vendor/cloud.google.com/go/pubsub/pubsub.go b/vendor/cloud.google.com/go/pubsub/pubsub.go",
                "new file mode 100644",
                "index 0000000..6f88b25",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/pubsub/pubsub.go",
                "@@ -0,0 +1,149 @@",
                "+// Copyright 2014 Google Inc. All Rights Reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//      http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+package pubsub",
                "+",
                "+import (",
                "+\t\"fmt\"",
                "+\t\"os\"",
                "+\t\"runtime\"",
                "+\t\"time\"",
                "+",
                "+\t\"google.golang.org/api/iterator\"",
                "+\t\"google.golang.org/api/option\"",
                "+\t\"google.golang.org/grpc\"",
                "+\t\"google.golang.org/grpc/keepalive\"",
                "+",
                "+\t\"golang.org/x/net/context\"",
                "+)",
                "+",
                "+const (",
                "+\t// ScopePubSub grants permissions to view and manage Pub/Sub",
                "+\t// topics and subscriptions.",
                "+\tScopePubSub = \"https://www.googleapis.com/auth/pubsub\"",
                "+",
                "+\t// ScopeCloudPlatform grants permissions to view and manage your data",
                "+\t// across Google Cloud Platform services.",
                "+\tScopeCloudPlatform = \"https://www.googleapis.com/auth/cloud-platform\"",
                "+)",
                "+",
                "+const prodAddr = \"https://pubsub.googleapis.com/\"",
                "+",
                "+// Client is a Google Pub/Sub client scoped to a single project.",
                "+//",
                "+// Clients should be reused rather than being created as needed.",
                "+// A Client may be shared by multiple goroutines.",
                "+type Client struct {",
                "+\tprojectID string",
                "+\ts         service",
                "+}",
                "+",
                "+// NewClient creates a new PubSub client.",
                "+func NewClient(ctx context.Context, projectID string, opts ...option.ClientOption) (*Client, error) {",
                "+\tvar o []option.ClientOption",
                "+\t// Environment variables for gcloud emulator:",
                "+\t// https://cloud.google.com/sdk/gcloud/reference/beta/emulators/pubsub/",
                "+\tif addr := os.Getenv(\"PUBSUB_EMULATOR_HOST\"); addr != \"\" {",
                "+\t\tconn, err := grpc.Dial(addr, grpc.WithInsecure())",
                "+\t\tif err != nil {",
                "+\t\t\treturn nil, fmt.Errorf(\"grpc.Dial: %v\", err)",
                "+\t\t}",
                "+\t\to = []option.ClientOption{option.WithGRPCConn(conn)}",
                "+\t} else {",
                "+\t\to = []option.ClientOption{",
                "+\t\t\t// Create multiple connections to increase throughput.",
                "+\t\t\toption.WithGRPCConnectionPool(runtime.GOMAXPROCS(0)),",
                "+",
                "+\t\t\t// TODO(grpc/grpc-go#1388) using connection pool without WithBlock",
                "+\t\t\t// can cause RPCs to fail randomly. We can delete this after the issue is fixed.",
                "+\t\t\toption.WithGRPCDialOption(grpc.WithBlock()),",
                "+",
                "+\t\t\toption.WithGRPCDialOption(grpc.WithKeepaliveParams(keepalive.ClientParameters{",
                "+\t\t\t\tTime: 5 * time.Minute,",
                "+\t\t\t})),",
                "+\t\t}",
                "+\t}",
                "+\to = append(o, opts...)",
                "+\ts, err := newPubSubService(ctx, o)",
                "+\tif err != nil {",
                "+\t\treturn nil, fmt.Errorf(\"constructing pubsub client: %v\", err)",
                "+\t}",
                "+",
                "+\tc := &Client{",
                "+\t\tprojectID: projectID,",
                "+\t\ts:         s,",
                "+\t}",
                "+",
                "+\treturn c, nil",
                "+}",
                "+",
                "+// Close closes any resources held by the client.",
                "+//",
                "+// Close need not be called at program exit.",
                "+func (c *Client) Close() error {",
                "+\treturn c.s.close()",
                "+}",
                "+",
                "+func (c *Client) fullyQualifiedProjectName() string {",
                "+\treturn fmt.Sprintf(\"projects/%s\", c.projectID)",
                "+}",
                "+",
                "+// pageToken stores the next page token for a server response which is split over multiple pages.",
                "+type pageToken struct {",
                "+\ttok      string",
                "+\texplicit bool",
                "+}",
                "+",
                "+func (pt *pageToken) set(tok string) {",
                "+\tpt.tok = tok",
                "+\tpt.explicit = true",
                "+}",
                "+",
                "+func (pt *pageToken) get() string {",
                "+\treturn pt.tok",
                "+}",
                "+",
                "+// more returns whether further pages should be fetched from the server.",
                "+func (pt *pageToken) more() bool {",
                "+\treturn pt.tok != \"\" || !pt.explicit",
                "+}",
                "+",
                "+// stringsIterator provides an iterator API for a sequence of API page fetches that return lists of strings.",
                "+type stringsIterator struct {",
                "+\tctx     context.Context",
                "+\tstrings []string",
                "+\ttoken   pageToken",
                "+\tfetch   func(ctx context.Context, tok string) (*stringsPage, error)",
                "+}",
                "+",
                "+// Next returns the next string. If there are no more strings, iterator.Done will be returned.",
                "+func (si *stringsIterator) Next() (string, error) {",
                "+\tfor len(si.strings) == 0 && si.token.more() {",
                "+\t\tpage, err := si.fetch(si.ctx, si.token.get())",
                "+\t\tif err != nil {",
                "+\t\t\treturn \"\", err",
                "+\t\t}",
                "+\t\tsi.token.set(page.tok)",
                "+\t\tsi.strings = page.strings",
                "+\t}",
                "+",
                "+\tif len(si.strings) == 0 {",
                "+\t\treturn \"\", iterator.Done",
                "+\t}",
                "+",
                "+\ts := si.strings[0]",
                "+\tsi.strings = si.strings[1:]",
                "+",
                "+\treturn s, nil",
                "+}",
                "diff --git a/vendor/cloud.google.com/go/pubsub/service.go b/vendor/cloud.google.com/go/pubsub/service.go",
                "new file mode 100644",
                "index 0000000..4d57d1b",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/pubsub/service.go",
                "@@ -0,0 +1,598 @@",
                "+// Copyright 2016 Google Inc. All Rights Reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//      http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+package pubsub",
                "+",
                "+import (",
                "+\t\"fmt\"",
                "+\t\"math\"",
                "+\t\"strings\"",
                "+\t\"sync\"",
                "+\t\"time\"",
                "+",
                "+\t\"github.com/golang/protobuf/ptypes\"",
                "+",
                "+\t\"cloud.google.com/go/iam\"",
                "+\t\"cloud.google.com/go/internal/version\"",
                "+\tvkit \"cloud.google.com/go/pubsub/apiv1\"",
                "+\tdurpb \"github.com/golang/protobuf/ptypes/duration\"",
                "+\tgax \"github.com/googleapis/gax-go\"",
                "+\t\"golang.org/x/net/context\"",
                "+\t\"google.golang.org/api/option\"",
                "+\tpb \"google.golang.org/genproto/googleapis/pubsub/v1\"",
                "+\t\"google.golang.org/grpc\"",
                "+\t\"google.golang.org/grpc/codes\"",
                "+\t\"google.golang.org/grpc/status\"",
                "+)",
                "+",
                "+type nextStringFunc func() (string, error)",
                "+type nextSnapshotFunc func() (*snapshotConfig, error)",
                "+",
                "+// service provides an internal abstraction to isolate the generated",
                "+// PubSub API; most of this package uses this interface instead.",
                "+// The single implementation, *apiService, contains all the knowledge",
                "+// of the generated PubSub API (except for that present in legacy code).",
                "+type service interface {",
                "+\tcreateSubscription(ctx context.Context, subName string, cfg SubscriptionConfig) error",
                "+\tgetSubscriptionConfig(ctx context.Context, subName string) (SubscriptionConfig, string, error)",
                "+\tlistProjectSubscriptions(ctx context.Context, projName string) nextStringFunc",
                "+\tdeleteSubscription(ctx context.Context, name string) error",
                "+\tsubscriptionExists(ctx context.Context, name string) (bool, error)",
                "+\tmodifyPushConfig(ctx context.Context, subName string, conf PushConfig) error",
                "+",
                "+\tcreateTopic(ctx context.Context, name string) error",
                "+\tdeleteTopic(ctx context.Context, name string) error",
                "+\ttopicExists(ctx context.Context, name string) (bool, error)",
                "+\tlistProjectTopics(ctx context.Context, projName string) nextStringFunc",
                "+\tlistTopicSubscriptions(ctx context.Context, topicName string) nextStringFunc",
                "+",
                "+\tmodifyAckDeadline(ctx context.Context, subName string, deadline time.Duration, ackIDs []string) error",
                "+\tfetchMessages(ctx context.Context, subName string, maxMessages int32) ([]*Message, error)",
                "+\tpublishMessages(ctx context.Context, topicName string, msgs []*Message) ([]string, error)",
                "+",
                "+\t// splitAckIDs divides ackIDs into",
                "+\t//  * a batch of a size which is suitable for passing to acknowledge or",
                "+\t//    modifyAckDeadline, and",
                "+\t//  * the rest.",
                "+\tsplitAckIDs(ackIDs []string) ([]string, []string)",
                "+",
                "+\t// acknowledge ACKs the IDs in ackIDs.",
                "+\tacknowledge(ctx context.Context, subName string, ackIDs []string) error",
                "+",
                "+\tiamHandle(resourceName string) *iam.Handle",
                "+",
                "+\tnewStreamingPuller(ctx context.Context, subName string, ackDeadline int32) *streamingPuller",
                "+",
                "+\tcreateSnapshot(ctx context.Context, snapName, subName string) (*snapshotConfig, error)",
                "+\tdeleteSnapshot(ctx context.Context, snapName string) error",
                "+\tlistProjectSnapshots(ctx context.Context, projName string) nextSnapshotFunc",
                "+",
                "+\t// TODO(pongad): Raw proto returns an empty SeekResponse; figure out if we want to return it before GA.",
                "+\tseekToTime(ctx context.Context, subName string, t time.Time) error",
                "+\tseekToSnapshot(ctx context.Context, subName, snapName string) error",
                "+",
                "+\tclose() error",
                "+}",
                "+",
                "+type apiService struct {",
                "+\tpubc *vkit.PublisherClient",
                "+\tsubc *vkit.SubscriberClient",
                "+}",
                "+",
                "+func newPubSubService(ctx context.Context, opts []option.ClientOption) (*apiService, error) {",
                "+\tpubc, err := vkit.NewPublisherClient(ctx, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tsubc, err := vkit.NewSubscriberClient(ctx, option.WithGRPCConn(pubc.Connection()))",
                "+\tif err != nil {",
                "+\t\t_ = pubc.Close() // ignore error",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tpubc.SetGoogleClientInfo(\"gccl\", version.Repo)",
                "+\tsubc.SetGoogleClientInfo(\"gccl\", version.Repo)",
                "+\treturn &apiService{pubc: pubc, subc: subc}, nil",
                "+}",
                "+",
                "+func (s *apiService) close() error {",
                "+\t// Return the first error, because the first call closes the connection.",
                "+\terr := s.pubc.Close()",
                "+\t_ = s.subc.Close()",
                "+\treturn err",
                "+}",
                "+",
                "+func (s *apiService) createSubscription(ctx context.Context, subName string, cfg SubscriptionConfig) error {",
                "+\tvar rawPushConfig *pb.PushConfig",
                "+\tif cfg.PushConfig.Endpoint != \"\" || len(cfg.PushConfig.Attributes) != 0 {",
                "+\t\trawPushConfig = &pb.PushConfig{",
                "+\t\t\tAttributes:   cfg.PushConfig.Attributes,",
                "+\t\t\tPushEndpoint: cfg.PushConfig.Endpoint,",
                "+\t\t}",
                "+\t}",
                "+\tvar retentionDuration *durpb.Duration",
                "+\tif cfg.retentionDuration != 0 {",
                "+\t\tretentionDuration = ptypes.DurationProto(cfg.retentionDuration)",
                "+\t}",
                "+",
                "+\t_, err := s.subc.CreateSubscription(ctx, &pb.Subscription{",
                "+\t\tName:                     subName,",
                "+\t\tTopic:                    cfg.Topic.name,",
                "+\t\tPushConfig:               rawPushConfig,",
                "+\t\tAckDeadlineSeconds:       trunc32(int64(cfg.AckDeadline.Seconds())),",
                "+\t\tRetainAckedMessages:      cfg.retainAckedMessages,",
                "+\t\tMessageRetentionDuration: retentionDuration,",
                "+\t})",
                "+\treturn err",
                "+}",
                "+",
                "+func (s *apiService) getSubscriptionConfig(ctx context.Context, subName string) (SubscriptionConfig, string, error) {",
                "+\trawSub, err := s.subc.GetSubscription(ctx, &pb.GetSubscriptionRequest{Subscription: subName})",
                "+\tif err != nil {",
                "+\t\treturn SubscriptionConfig{}, \"\", err",
                "+\t}",
                "+\tvar rd time.Duration",
                "+\t// TODO(pongad): Remove nil-check after white list is removed.",
                "+\tif rawSub.MessageRetentionDuration != nil {",
                "+\t\tif rd, err = ptypes.Duration(rawSub.MessageRetentionDuration); err != nil {",
                "+\t\t\treturn SubscriptionConfig{}, \"\", err",
                "+\t\t}",
                "+\t}",
                "+\tsub := SubscriptionConfig{",
                "+\t\tAckDeadline: time.Second * time.Duration(rawSub.AckDeadlineSeconds),",
                "+\t\tPushConfig: PushConfig{",
                "+\t\t\tEndpoint:   rawSub.PushConfig.PushEndpoint,",
                "+\t\t\tAttributes: rawSub.PushConfig.Attributes,",
                "+\t\t},",
                "+\t\tretainAckedMessages: rawSub.RetainAckedMessages,",
                "+\t\tretentionDuration:   rd,",
                "+\t}",
                "+\treturn sub, rawSub.Topic, nil",
                "+}",
                "+",
                "+// stringsPage contains a list of strings and a token for fetching the next page.",
                "+type stringsPage struct {",
                "+\tstrings []string",
                "+\ttok     string",
                "+}",
                "+",
                "+func (s *apiService) listProjectSubscriptions(ctx context.Context, projName string) nextStringFunc {",
                "+\tit := s.subc.ListSubscriptions(ctx, &pb.ListSubscriptionsRequest{",
                "+\t\tProject: projName,",
                "+\t})",
                "+\treturn func() (string, error) {",
                "+\t\tsub, err := it.Next()",
                "+\t\tif err != nil {",
                "+\t\t\treturn \"\", err",
                "+\t\t}",
                "+\t\treturn sub.Name, nil",
                "+\t}",
                "+}",
                "+",
                "+func (s *apiService) deleteSubscription(ctx context.Context, name string) error {",
                "+\treturn s.subc.DeleteSubscription(ctx, &pb.DeleteSubscriptionRequest{Subscription: name})",
                "+}",
                "+",
                "+func (s *apiService) subscriptionExists(ctx context.Context, name string) (bool, error) {",
                "+\t_, err := s.subc.GetSubscription(ctx, &pb.GetSubscriptionRequest{Subscription: name})",
                "+\tif err == nil {",
                "+\t\treturn true, nil",
                "+\t}",
                "+\tif grpc.Code(err) == codes.NotFound {",
                "+\t\treturn false, nil",
                "+\t}",
                "+\treturn false, err",
                "+}",
                "+",
                "+func (s *apiService) createTopic(ctx context.Context, name string) error {",
                "+\t_, err := s.pubc.CreateTopic(ctx, &pb.Topic{Name: name})",
                "+\treturn err",
                "+}",
                "+",
                "+func (s *apiService) listProjectTopics(ctx context.Context, projName string) nextStringFunc {",
                "+\tit := s.pubc.ListTopics(ctx, &pb.ListTopicsRequest{",
                "+\t\tProject: projName,",
                "+\t})",
                "+\treturn func() (string, error) {",
                "+\t\ttopic, err := it.Next()",
                "+\t\tif err != nil {",
                "+\t\t\treturn \"\", err",
                "+\t\t}",
                "+\t\treturn topic.Name, nil",
                "+\t}",
                "+}",
                "+",
                "+func (s *apiService) deleteTopic(ctx context.Context, name string) error {",
                "+\treturn s.pubc.DeleteTopic(ctx, &pb.DeleteTopicRequest{Topic: name})",
                "+}",
                "+",
                "+func (s *apiService) topicExists(ctx context.Context, name string) (bool, error) {",
                "+\t_, err := s.pubc.GetTopic(ctx, &pb.GetTopicRequest{Topic: name})",
                "+\tif err == nil {",
                "+\t\treturn true, nil",
                "+\t}",
                "+\tif grpc.Code(err) == codes.NotFound {",
                "+\t\treturn false, nil",
                "+\t}",
                "+\treturn false, err",
                "+}",
                "+",
                "+func (s *apiService) listTopicSubscriptions(ctx context.Context, topicName string) nextStringFunc {",
                "+\tit := s.pubc.ListTopicSubscriptions(ctx, &pb.ListTopicSubscriptionsRequest{",
                "+\t\tTopic: topicName,",
                "+\t})",
                "+\treturn it.Next",
                "+}",
                "+",
                "+func (s *apiService) modifyAckDeadline(ctx context.Context, subName string, deadline time.Duration, ackIDs []string) error {",
                "+\treturn s.subc.ModifyAckDeadline(ctx, &pb.ModifyAckDeadlineRequest{",
                "+\t\tSubscription:       subName,",
                "+\t\tAckIds:             ackIDs,",
                "+\t\tAckDeadlineSeconds: trunc32(int64(deadline.Seconds())),",
                "+\t})",
                "+}",
                "+",
                "+// maxPayload is the maximum number of bytes to devote to actual ids in",
                "+// acknowledgement or modifyAckDeadline requests. A serialized",
                "+// AcknowledgeRequest proto has a small constant overhead, plus the size of the",
                "+// subscription name, plus 3 bytes per ID (a tag byte and two size bytes). A",
                "+// ModifyAckDeadlineRequest has an additional few bytes for the deadline. We",
                "+// don't know the subscription name here, so we just assume the size exclusive",
                "+// of ids is 100 bytes.",
                "+//",
                "+// With gRPC there is no way for the client to know the server's max message size (it is",
                "+// configurable on the server). We know from experience that it",
                "+// it 512K.",
                "+const (",
                "+\tmaxPayload       = 512 * 1024",
                "+\treqFixedOverhead = 100",
                "+\toverheadPerID    = 3",
                "+\tmaxSendRecvBytes = 20 * 1024 * 1024 // 20M",
                "+)",
                "+",
                "+// splitAckIDs splits ids into two slices, the first of which contains at most maxPayload bytes of ackID data.",
                "+func (s *apiService) splitAckIDs(ids []string) ([]string, []string) {",
                "+\ttotal := reqFixedOverhead",
                "+\tfor i, id := range ids {",
                "+\t\ttotal += len(id) + overheadPerID",
                "+\t\tif total > maxPayload {",
                "+\t\t\treturn ids[:i], ids[i:]",
                "+\t\t}",
                "+\t}",
                "+\treturn ids, nil",
                "+}",
                "+",
                "+func (s *apiService) acknowledge(ctx context.Context, subName string, ackIDs []string) error {",
                "+\treturn s.subc.Acknowledge(ctx, &pb.AcknowledgeRequest{",
                "+\t\tSubscription: subName,",
                "+\t\tAckIds:       ackIDs,",
                "+\t})",
                "+}",
                "+",
                "+func (s *apiService) fetchMessages(ctx context.Context, subName string, maxMessages int32) ([]*Message, error) {",
                "+\tresp, err := s.subc.Pull(ctx, &pb.PullRequest{",
                "+\t\tSubscription: subName,",
                "+\t\tMaxMessages:  maxMessages,",
                "+\t}, gax.WithGRPCOptions(grpc.MaxCallRecvMsgSize(maxSendRecvBytes)))",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn convertMessages(resp.ReceivedMessages)",
                "+}",
                "+",
                "+func convertMessages(rms []*pb.ReceivedMessage) ([]*Message, error) {",
                "+\tmsgs := make([]*Message, 0, len(rms))",
                "+\tfor i, m := range rms {",
                "+\t\tmsg, err := toMessage(m)",
                "+\t\tif err != nil {",
                "+\t\t\treturn nil, fmt.Errorf(\"pubsub: cannot decode the retrieved message at index: %d, message: %+v\", i, m)",
                "+\t\t}",
                "+\t\tmsgs = append(msgs, msg)",
                "+\t}",
                "+\treturn msgs, nil",
                "+}",
                "+",
                "+func (s *apiService) publishMessages(ctx context.Context, topicName string, msgs []*Message) ([]string, error) {",
                "+\trawMsgs := make([]*pb.PubsubMessage, len(msgs))",
                "+\tfor i, msg := range msgs {",
                "+\t\trawMsgs[i] = &pb.PubsubMessage{",
                "+\t\t\tData:       msg.Data,",
                "+\t\t\tAttributes: msg.Attributes,",
                "+\t\t}",
                "+\t}",
                "+\tresp, err := s.pubc.Publish(ctx, &pb.PublishRequest{",
                "+\t\tTopic:    topicName,",
                "+\t\tMessages: rawMsgs,",
                "+\t}, gax.WithGRPCOptions(grpc.MaxCallSendMsgSize(maxSendRecvBytes)))",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn resp.MessageIds, nil",
                "+}",
                "+",
                "+func (s *apiService) modifyPushConfig(ctx context.Context, subName string, conf PushConfig) error {",
                "+\treturn s.subc.ModifyPushConfig(ctx, &pb.ModifyPushConfigRequest{",
                "+\t\tSubscription: subName,",
                "+\t\tPushConfig: &pb.PushConfig{",
                "+\t\t\tAttributes:   conf.Attributes,",
                "+\t\t\tPushEndpoint: conf.Endpoint,",
                "+\t\t},",
                "+\t})",
                "+}",
                "+",
                "+func (s *apiService) iamHandle(resourceName string) *iam.Handle {",
                "+\treturn iam.InternalNewHandle(s.pubc.Connection(), resourceName)",
                "+}",
                "+",
                "+func trunc32(i int64) int32 {",
                "+\tif i > math.MaxInt32 {",
                "+\t\ti = math.MaxInt32",
                "+\t}",
                "+\treturn int32(i)",
                "+}",
                "+",
                "+func (s *apiService) newStreamingPuller(ctx context.Context, subName string, ackDeadlineSecs int32) *streamingPuller {",
                "+\tp := &streamingPuller{",
                "+\t\tctx:             ctx,",
                "+\t\tsubName:         subName,",
                "+\t\tackDeadlineSecs: ackDeadlineSecs,",
                "+\t\tsubc:            s.subc,",
                "+\t}",
                "+\tp.c = sync.NewCond(&p.mu)",
                "+\treturn p",
                "+}",
                "+",
                "+type streamingPuller struct {",
                "+\tctx             context.Context",
                "+\tsubName         string",
                "+\tackDeadlineSecs int32",
                "+\tsubc            *vkit.SubscriberClient",
                "+",
                "+\tmu       sync.Mutex",
                "+\tc        *sync.Cond",
                "+\tinFlight bool",
                "+\tclosed   bool // set after CloseSend called",
                "+\tspc      pb.Subscriber_StreamingPullClient",
                "+\terr      error",
                "+}",
                "+",
                "+// open establishes (or re-establishes) a stream for pulling messages.",
                "+// It takes care that only one RPC is in flight at a time.",
                "+func (p *streamingPuller) open() error {",
                "+\tp.c.L.Lock()",
                "+\tdefer p.c.L.Unlock()",
                "+\tp.openLocked()",
                "+\treturn p.err",
                "+}",
                "+",
                "+func (p *streamingPuller) openLocked() {",
                "+\tif p.inFlight {",
                "+\t\t// Another goroutine is opening; wait for it.",
                "+\t\tfor p.inFlight {",
                "+\t\t\tp.c.Wait()",
                "+\t\t}",
                "+\t\treturn",
                "+\t}",
                "+\t// No opens in flight; start one.",
                "+\t// Keep the lock held, to avoid a race where we",
                "+\t// close the old stream while opening a new one.",
                "+\tp.inFlight = true",
                "+\tspc, err := p.subc.StreamingPull(p.ctx, gax.WithGRPCOptions(grpc.MaxCallRecvMsgSize(maxSendRecvBytes)))",
                "+\tif err == nil {",
                "+\t\terr = spc.Send(&pb.StreamingPullRequest{",
                "+\t\t\tSubscription:             p.subName,",
                "+\t\t\tStreamAckDeadlineSeconds: p.ackDeadlineSecs,",
                "+\t\t})",
                "+\t}",
                "+\tp.spc = spc",
                "+\tp.err = err",
                "+\tp.inFlight = false",
                "+\tp.c.Broadcast()",
                "+}",
                "+",
                "+func (p *streamingPuller) call(f func(pb.Subscriber_StreamingPullClient) error) error {",
                "+\tp.c.L.Lock()",
                "+\tdefer p.c.L.Unlock()",
                "+\t// Wait for an open in flight.",
                "+\tfor p.inFlight {",
                "+\t\tp.c.Wait()",
                "+\t}",
                "+\tvar err error",
                "+\tvar bo gax.Backoff",
                "+\tfor {",
                "+\t\tselect {",
                "+\t\tcase <-p.ctx.Done():",
                "+\t\t\tp.err = p.ctx.Err()",
                "+\t\tdefault:",
                "+\t\t}",
                "+\t\tif p.err != nil {",
                "+\t\t\treturn p.err",
                "+\t\t}",
                "+\t\tspc := p.spc",
                "+\t\t// Do not call f with the lock held. Only one goroutine calls Send",
                "+\t\t// (streamingMessageIterator.sender) and only one calls Recv",
                "+\t\t// (streamingMessageIterator.receiver). If we locked, then a",
                "+\t\t// blocked Recv would prevent a Send from happening.",
                "+\t\tp.c.L.Unlock()",
                "+\t\terr = f(spc)",
                "+\t\tp.c.L.Lock()",
                "+\t\tif !p.closed && err != nil && isRetryable(err) {",
                "+\t\t\t// Sleep with exponential backoff. Normally we wouldn't hold the lock while sleeping,",
                "+\t\t\t// but here it can't do any harm, since the stream is broken anyway.",
                "+\t\t\tgax.Sleep(p.ctx, bo.Pause())",
                "+\t\t\tp.openLocked()",
                "+\t\t\tcontinue",
                "+\t\t}",
                "+\t\t// Not an error, or not a retryable error; stop retrying.",
                "+\t\tp.err = err",
                "+\t\treturn err",
                "+\t}",
                "+}",
                "+",
                "+// Logic from https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-pubsub/src/main/java/com/google/cloud/pubsub/v1/StatusUtil.java.",
                "+func isRetryable(err error) bool {",
                "+\ts, ok := status.FromError(err)",
                "+\tif !ok { // includes io.EOF, normal stream close, which causes us to reopen",
                "+\t\treturn true",
                "+\t}",
                "+\tswitch s.Code() {",
                "+\tcase codes.DeadlineExceeded, codes.Internal, codes.Canceled, codes.ResourceExhausted:",
                "+\t\treturn true",
                "+\tcase codes.Unavailable:",
                "+\t\treturn !strings.Contains(s.Message(), \"Server shutdownNow invoked\")",
                "+\tdefault:",
                "+\t\treturn false",
                "+\t}",
                "+}",
                "+",
                "+func (p *streamingPuller) fetchMessages() ([]*Message, error) {",
                "+\tvar res *pb.StreamingPullResponse",
                "+\terr := p.call(func(spc pb.Subscriber_StreamingPullClient) error {",
                "+\t\tvar err error",
                "+\t\tres, err = spc.Recv()",
                "+\t\treturn err",
                "+\t})",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn convertMessages(res.ReceivedMessages)",
                "+}",
                "+",
                "+func (p *streamingPuller) send(req *pb.StreamingPullRequest) error {",
                "+\t// Note: len(modAckIDs) == len(modSecs)",
                "+\tvar rest *pb.StreamingPullRequest",
                "+\tfor len(req.AckIds) > 0 || len(req.ModifyDeadlineAckIds) > 0 {",
                "+\t\treq, rest = splitRequest(req, maxPayload)",
                "+\t\terr := p.call(func(spc pb.Subscriber_StreamingPullClient) error {",
                "+\t\t\tx := spc.Send(req)",
                "+\t\t\treturn x",
                "+\t\t})",
                "+\t\tif err != nil {",
                "+\t\t\treturn err",
                "+\t\t}",
                "+\t\treq = rest",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (p *streamingPuller) closeSend() {",
                "+\tp.mu.Lock()",
                "+\tp.closed = true",
                "+\tp.spc.CloseSend()",
                "+\tp.mu.Unlock()",
                "+}",
                "+",
                "+// Split req into a prefix that is smaller than maxSize, and a remainder.",
                "+func splitRequest(req *pb.StreamingPullRequest, maxSize int) (prefix, remainder *pb.StreamingPullRequest) {",
                "+\tconst int32Bytes = 4",
                "+",
                "+\t// Copy all fields before splitting the variable-sized ones.",
                "+\tremainder = &pb.StreamingPullRequest{}",
                "+\t*remainder = *req",
                "+\t// Split message so it isn't too big.",
                "+\tsize := reqFixedOverhead",
                "+\ti := 0",
                "+\tfor size < maxSize && (i < len(req.AckIds) || i < len(req.ModifyDeadlineAckIds)) {",
                "+\t\tif i < len(req.AckIds) {",
                "+\t\t\tsize += overheadPerID + len(req.AckIds[i])",
                "+\t\t}",
                "+\t\tif i < len(req.ModifyDeadlineAckIds) {",
                "+\t\t\tsize += overheadPerID + len(req.ModifyDeadlineAckIds[i]) + int32Bytes",
                "+\t\t}",
                "+\t\ti++",
                "+\t}",
                "+",
                "+\tmin := func(a, b int) int {",
                "+\t\tif a < b {",
                "+\t\t\treturn a",
                "+\t\t}",
                "+\t\treturn b",
                "+\t}",
                "+",
                "+\tj := i",
                "+\tif size > maxSize {",
                "+\t\tj--",
                "+\t}",
                "+\tk := min(j, len(req.AckIds))",
                "+\tremainder.AckIds = req.AckIds[k:]",
                "+\treq.AckIds = req.AckIds[:k]",
                "+\tk = min(j, len(req.ModifyDeadlineAckIds))",
                "+\tremainder.ModifyDeadlineAckIds = req.ModifyDeadlineAckIds[k:]",
                "+\tremainder.ModifyDeadlineSeconds = req.ModifyDeadlineSeconds[k:]",
                "+\treq.ModifyDeadlineAckIds = req.ModifyDeadlineAckIds[:k]",
                "+\treq.ModifyDeadlineSeconds = req.ModifyDeadlineSeconds[:k]",
                "+\treturn req, remainder",
                "+}",
                "+",
                "+func (s *apiService) createSnapshot(ctx context.Context, snapName, subName string) (*snapshotConfig, error) {",
                "+\tsnap, err := s.subc.CreateSnapshot(ctx, &pb.CreateSnapshotRequest{",
                "+\t\tName:         snapName,",
                "+\t\tSubscription: subName,",
                "+\t})",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn s.toSnapshotConfig(snap)",
                "+}",
                "+",
                "+func (s *apiService) deleteSnapshot(ctx context.Context, snapName string) error {",
                "+\treturn s.subc.DeleteSnapshot(ctx, &pb.DeleteSnapshotRequest{Snapshot: snapName})",
                "+}",
                "+",
                "+func (s *apiService) listProjectSnapshots(ctx context.Context, projName string) nextSnapshotFunc {",
                "+\tit := s.subc.ListSnapshots(ctx, &pb.ListSnapshotsRequest{",
                "+\t\tProject: projName,",
                "+\t})",
                "+\treturn func() (*snapshotConfig, error) {",
                "+\t\tsnap, err := it.Next()",
                "+\t\tif err != nil {",
                "+\t\t\treturn nil, err",
                "+\t\t}",
                "+\t\treturn s.toSnapshotConfig(snap)",
                "+\t}",
                "+}",
                "+",
                "+func (s *apiService) toSnapshotConfig(snap *pb.Snapshot) (*snapshotConfig, error) {",
                "+\texp, err := ptypes.Timestamp(snap.ExpireTime)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn &snapshotConfig{",
                "+\t\tsnapshot: &snapshot{",
                "+\t\t\ts:    s,",
                "+\t\t\tname: snap.Name,",
                "+\t\t},",
                "+\t\tTopic:      newTopic(s, snap.Topic),",
                "+\t\tExpiration: exp,",
                "+\t}, nil",
                "+}",
                "+",
                "+func (s *apiService) seekToTime(ctx context.Context, subName string, t time.Time) error {",
                "+\tts, err := ptypes.TimestampProto(t)",
                "+\tif err != nil {",
                "+\t\treturn err",
                "+\t}",
                "+\t_, err = s.subc.Seek(ctx, &pb.SeekRequest{",
                "+\t\tSubscription: subName,",
                "+\t\tTarget:       &pb.SeekRequest_Time{ts},",
                "+\t})",
                "+\treturn err",
                "+}",
                "+",
                "+func (s *apiService) seekToSnapshot(ctx context.Context, subName, snapName string) error {",
                "+\t_, err := s.subc.Seek(ctx, &pb.SeekRequest{",
                "+\t\tSubscription: subName,",
                "+\t\tTarget:       &pb.SeekRequest_Snapshot{snapName},",
                "+\t})",
                "+\treturn err",
                "+}",
                "diff --git a/vendor/cloud.google.com/go/pubsub/snapshot.go b/vendor/cloud.google.com/go/pubsub/snapshot.go",
                "new file mode 100644",
                "index 0000000..77115b5",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/pubsub/snapshot.go",
                "@@ -0,0 +1,119 @@",
                "+// Copyright 2017 Google Inc. All Rights Reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//      http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+package pubsub",
                "+",
                "+import (",
                "+\t\"strings\"",
                "+\t\"time\"",
                "+",
                "+\tvkit \"cloud.google.com/go/pubsub/apiv1\"",
                "+\t\"golang.org/x/net/context\"",
                "+)",
                "+",
                "+// Snapshot is a reference to a PubSub snapshot.",
                "+type snapshot struct {",
                "+\ts service",
                "+",
                "+\t// The fully qualified identifier for the snapshot, in the format \"projects/<projid>/snapshots/<snap>\"",
                "+\tname string",
                "+}",
                "+",
                "+// ID returns the unique identifier of the snapshot within its project.",
                "+func (s *snapshot) ID() string {",
                "+\tslash := strings.LastIndex(s.name, \"/\")",
                "+\tif slash == -1 {",
                "+\t\t// name is not a fully-qualified name.",
                "+\t\tpanic(\"bad snapshot name\")",
                "+\t}",
                "+\treturn s.name[slash+1:]",
                "+}",
                "+",
                "+// SnapshotConfig contains the details of a Snapshot.",
                "+type snapshotConfig struct {",
                "+\t*snapshot",
                "+\tTopic      *Topic",
                "+\tExpiration time.Time",
                "+}",
                "+",
                "+// Snapshot creates a reference to a snapshot.",
                "+func (c *Client) snapshot(id string) *snapshot {",
                "+\treturn &snapshot{",
                "+\t\ts:    c.s,",
                "+\t\tname: vkit.SubscriberSnapshotPath(c.projectID, id),",
                "+\t}",
                "+}",
                "+",
                "+// Snapshots returns an iterator which returns snapshots for this project.",
                "+func (c *Client) snapshots(ctx context.Context) *snapshotConfigIterator {",
                "+\treturn &snapshotConfigIterator{",
                "+\t\tnext: c.s.listProjectSnapshots(ctx, c.fullyQualifiedProjectName()),",
                "+\t}",
                "+}",
                "+",
                "+// SnapshotConfigIterator is an iterator that returns a series of snapshots.",
                "+type snapshotConfigIterator struct {",
                "+\tnext nextSnapshotFunc",
                "+}",
                "+",
                "+// Next returns the next SnapshotConfig. Its second return value is iterator.Done if there are no more results.",
                "+// Once Next returns iterator.Done, all subsequent calls will return iterator.Done.",
                "+func (snaps *snapshotConfigIterator) Next() (*snapshotConfig, error) {",
                "+\treturn snaps.next()",
                "+}",
                "+",
                "+// Delete deletes a snapshot.",
                "+func (snap *snapshot) delete(ctx context.Context) error {",
                "+\treturn snap.s.deleteSnapshot(ctx, snap.name)",
                "+}",
                "+",
                "+// SeekTime seeks the subscription to a point in time.",
                "+//",
                "+// Messages retained in the subscription that were published before this",
                "+// time are marked as acknowledged, and messages retained in the",
                "+// subscription that were published after this time are marked as",
                "+// unacknowledged. Note that this operation affects only those messages",
                "+// retained in the subscription (configured by SnapshotConfig). For example,",
                "+// if `time` corresponds to a point before the message retention",
                "+// window (or to a point before the system's notion of the subscription",
                "+// creation time), only retained messages will be marked as unacknowledged,",
                "+// and already-expunged messages will not be restored.",
                "+func (s *Subscription) seekToTime(ctx context.Context, t time.Time) error {",
                "+\treturn s.s.seekToTime(ctx, s.name, t)",
                "+}",
                "+",
                "+// Snapshot creates a new snapshot from this subscription.",
                "+// The snapshot will be for the topic this subscription is subscribed to.",
                "+// If the name is empty string, a unique name is assigned.",
                "+//",
                "+// The created snapshot is guaranteed to retain:",
                "+//  (a) The existing backlog on the subscription. More precisely, this is",
                "+//      defined as the messages in the subscription's backlog that are",
                "+//      unacknowledged when Snapshot returns without error.",
                "+//  (b) Any messages published to the subscription's topic following",
                "+//      Snapshot returning without error.",
                "+func (s *Subscription) createSnapshot(ctx context.Context, name string) (*snapshotConfig, error) {",
                "+\tif name != \"\" {",
                "+\t\tname = vkit.SubscriberSnapshotPath(strings.Split(s.name, \"/\")[1], name)",
                "+\t}",
                "+\treturn s.s.createSnapshot(ctx, name, s.name)",
                "+}",
                "+",
                "+// SeekSnapshot seeks the subscription to a snapshot.",
                "+//",
                "+// The snapshot needs not be created from this subscription,",
                "+// but the snapshot must be for the topic this subscription is subscribed to.",
                "+func (s *Subscription) seekToSnapshot(ctx context.Context, snap *snapshot) error {",
                "+\treturn s.s.seekToSnapshot(ctx, s.name, snap.name)",
                "+}",
                "diff --git a/vendor/cloud.google.com/go/pubsub/subscription.go b/vendor/cloud.google.com/go/pubsub/subscription.go",
                "new file mode 100644",
                "index 0000000..2144125",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/pubsub/subscription.go",
                "@@ -0,0 +1,405 @@",
                "+// Copyright 2016 Google Inc. All Rights Reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//      http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+package pubsub",
                "+",
                "+import (",
                "+\t\"errors\"",
                "+\t\"fmt\"",
                "+\t\"io\"",
                "+\t\"strings\"",
                "+\t\"sync\"",
                "+\t\"time\"",
                "+",
                "+\t\"cloud.google.com/go/iam\"",
                "+\t\"golang.org/x/net/context\"",
                "+\t\"golang.org/x/sync/errgroup\"",
                "+\t\"google.golang.org/grpc\"",
                "+\t\"google.golang.org/grpc/codes\"",
                "+)",
                "+",
                "+// Subscription is a reference to a PubSub subscription.",
                "+type Subscription struct {",
                "+\ts service",
                "+",
                "+\t// The fully qualified identifier for the subscription, in the format \"projects/<projid>/subscriptions/<name>\"",
                "+\tname string",
                "+",
                "+\t// Settings for pulling messages. Configure these before calling Receive.",
                "+\tReceiveSettings ReceiveSettings",
                "+",
                "+\tmu            sync.Mutex",
                "+\treceiveActive bool",
                "+}",
                "+",
                "+// Subscription creates a reference to a subscription.",
                "+func (c *Client) Subscription(id string) *Subscription {",
                "+\treturn newSubscription(c.s, fmt.Sprintf(\"projects/%s/subscriptions/%s\", c.projectID, id))",
                "+}",
                "+",
                "+func newSubscription(s service, name string) *Subscription {",
                "+\treturn &Subscription{",
                "+\t\ts:    s,",
                "+\t\tname: name,",
                "+\t}",
                "+}",
                "+",
                "+// String returns the globally unique printable name of the subscription.",
                "+func (s *Subscription) String() string {",
                "+\treturn s.name",
                "+}",
                "+",
                "+// ID returns the unique identifier of the subscription within its project.",
                "+func (s *Subscription) ID() string {",
                "+\tslash := strings.LastIndex(s.name, \"/\")",
                "+\tif slash == -1 {",
                "+\t\t// name is not a fully-qualified name.",
                "+\t\tpanic(\"bad subscription name\")",
                "+\t}",
                "+\treturn s.name[slash+1:]",
                "+}",
                "+",
                "+// Subscriptions returns an iterator which returns all of the subscriptions for the client's project.",
                "+func (c *Client) Subscriptions(ctx context.Context) *SubscriptionIterator {",
                "+\treturn &SubscriptionIterator{",
                "+\t\ts:    c.s,",
                "+\t\tnext: c.s.listProjectSubscriptions(ctx, c.fullyQualifiedProjectName()),",
                "+\t}",
                "+}",
                "+",
                "+// SubscriptionIterator is an iterator that returns a series of subscriptions.",
                "+type SubscriptionIterator struct {",
                "+\ts    service",
                "+\tnext nextStringFunc",
                "+}",
                "+",
                "+// Next returns the next subscription. If there are no more subscriptions, iterator.Done will be returned.",
                "+func (subs *SubscriptionIterator) Next() (*Subscription, error) {",
                "+\tsubName, err := subs.next()",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn newSubscription(subs.s, subName), nil",
                "+}",
                "+",
                "+// PushConfig contains configuration for subscriptions that operate in push mode.",
                "+type PushConfig struct {",
                "+\t// A URL locating the endpoint to which messages should be pushed.",
                "+\tEndpoint string",
                "+",
                "+\t// Endpoint configuration attributes. See https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.subscriptions#pushconfig for more details.",
                "+\tAttributes map[string]string",
                "+}",
                "+",
                "+// Subscription config contains the configuration of a subscription.",
                "+type SubscriptionConfig struct {",
                "+\tTopic      *Topic",
                "+\tPushConfig PushConfig",
                "+",
                "+\t// The default maximum time after a subscriber receives a message before",
                "+\t// the subscriber should acknowledge the message. Note: messages which are",
                "+\t// obtained via Subscription.Receive need not be acknowledged within this",
                "+\t// deadline, as the deadline will be automatically extended.",
                "+\tAckDeadline time.Duration",
                "+",
                "+\t// Whether to retain acknowledged messages. If true, acknowledged messages",
                "+\t// will not be expunged until they fall out of the RetentionDuration window.",
                "+\tretainAckedMessages bool",
                "+",
                "+\t// How long to retain messages in backlog, from the time of publish. If RetainAckedMessages is true,",
                "+\t// this duration affects the retention of acknowledged messages,",
                "+\t// otherwise only unacknowledged messages are retained.",
                "+\t// Defaults to 7 days. Cannot be longer than 7 days or shorter than 10 minutes.",
                "+\tretentionDuration time.Duration",
                "+}",
                "+",
                "+// ReceiveSettings configure the Receive method.",
                "+// A zero ReceiveSettings will result in values equivalent to DefaultReceiveSettings.",
                "+type ReceiveSettings struct {",
                "+\t// MaxExtension is the maximum period for which the Subscription should",
                "+\t// automatically extend the ack deadline for each message.",
                "+\t//",
                "+\t// The Subscription will automatically extend the ack deadline of all",
                "+\t// fetched Messages for the duration specified. Automatic deadline",
                "+\t// extension may be disabled by specifying a duration less than 1.",
                "+\tMaxExtension time.Duration",
                "+",
                "+\t// MaxOutstandingMessages is the maximum number of unprocessed messages",
                "+\t// (unacknowledged but not yet expired). If MaxOutstandingMessages is 0, it",
                "+\t// will be treated as if it were DefaultReceiveSettings.MaxOutstandingMessages.",
                "+\t// If the value is negative, then there will be no limit on the number of",
                "+\t// unprocessed messages.",
                "+\tMaxOutstandingMessages int",
                "+",
                "+\t// MaxOutstandingBytes is the maximum size of unprocessed messages",
                "+\t// (unacknowledged but not yet expired). If MaxOutstandingBytes is 0, it will",
                "+\t// be treated as if it were DefaultReceiveSettings.MaxOutstandingBytes. If",
                "+\t// the value is negative, then there will be no limit on the number of bytes",
                "+\t// for unprocessed messages.",
                "+\tMaxOutstandingBytes int",
                "+",
                "+\t// NumGoroutines is the number of goroutines Receive will spawn to pull",
                "+\t// messages concurrently. If NumGoroutines is less than 1, it will be treated",
                "+\t// as if it were DefaultReceiveSettings.NumGoroutines.",
                "+\t//",
                "+\t// NumGoroutines does not limit the number of messages that can be processed",
                "+\t// concurrently. Even with one goroutine, many messages might be processed at",
                "+\t// once, because that goroutine may continually receive messages and invoke the",
                "+\t// function passed to Receive on them. To limit the number of messages being",
                "+\t// processed concurrently, set MaxOutstandingMessages.",
                "+\tNumGoroutines int",
                "+}",
                "+",
                "+// DefaultReceiveSettings holds the default values for ReceiveSettings.",
                "+var DefaultReceiveSettings = ReceiveSettings{",
                "+\tMaxExtension:           10 * time.Minute,",
                "+\tMaxOutstandingMessages: 1000,",
                "+\tMaxOutstandingBytes:    1e9, // 1G",
                "+\tNumGoroutines:          1,",
                "+}",
                "+",
                "+// Delete deletes the subscription.",
                "+func (s *Subscription) Delete(ctx context.Context) error {",
                "+\treturn s.s.deleteSubscription(ctx, s.name)",
                "+}",
                "+",
                "+// Exists reports whether the subscription exists on the server.",
                "+func (s *Subscription) Exists(ctx context.Context) (bool, error) {",
                "+\treturn s.s.subscriptionExists(ctx, s.name)",
                "+}",
                "+",
                "+// Config fetches the current configuration for the subscription.",
                "+func (s *Subscription) Config(ctx context.Context) (SubscriptionConfig, error) {",
                "+\tconf, topicName, err := s.s.getSubscriptionConfig(ctx, s.name)",
                "+\tif err != nil {",
                "+\t\treturn SubscriptionConfig{}, err",
                "+\t}",
                "+\tconf.Topic = &Topic{",
                "+\t\ts:    s.s,",
                "+\t\tname: topicName,",
                "+\t}",
                "+\treturn conf, nil",
                "+}",
                "+",
                "+// SubscriptionConfigToUpdate describes how to update a subscription.",
                "+type SubscriptionConfigToUpdate struct {",
                "+\t// If non-nil, the push config is changed.",
                "+\tPushConfig *PushConfig",
                "+}",
                "+",
                "+// Update changes an existing subscription according to the fields set in cfg.",
                "+// It returns the new SubscriptionConfig.",
                "+//",
                "+// Update returns an error if no fields were modified.",
                "+func (s *Subscription) Update(ctx context.Context, cfg SubscriptionConfigToUpdate) (SubscriptionConfig, error) {",
                "+\tif cfg.PushConfig == nil {",
                "+\t\treturn SubscriptionConfig{}, errors.New(\"pubsub: UpdateSubscription call with nothing to update\")",
                "+\t}",
                "+\tif err := s.s.modifyPushConfig(ctx, s.name, *cfg.PushConfig); err != nil {",
                "+\t\treturn SubscriptionConfig{}, err",
                "+\t}",
                "+\treturn s.Config(ctx)",
                "+}",
                "+",
                "+func (s *Subscription) IAM() *iam.Handle {",
                "+\treturn s.s.iamHandle(s.name)",
                "+}",
                "+",
                "+// CreateSubscription creates a new subscription on a topic.",
                "+//",
                "+// id is the name of the subscription to create. It must start with a letter,",
                "+// and contain only letters ([A-Za-z]), numbers ([0-9]), dashes (-),",
                "+// underscores (_), periods (.), tildes (~), plus (+) or percent signs (%). It",
                "+// must be between 3 and 255 characters in length, and must not start with",
                "+// \"goog\".",
                "+//",
                "+// cfg.Topic is the topic from which the subscription should receive messages. It",
                "+// need not belong to the same project as the subscription. This field is required.",
                "+//",
                "+// cfg.AckDeadline is the maximum time after a subscriber receives a message before",
                "+// the subscriber should acknowledge the message. It must be between 10 and 600",
                "+// seconds (inclusive), and is rounded down to the nearest second. If the",
                "+// provided ackDeadline is 0, then the default value of 10 seconds is used.",
                "+// Note: messages which are obtained via Subscription.Receive need not be",
                "+// acknowledged within this deadline, as the deadline will be automatically",
                "+// extended.",
                "+//",
                "+// cfg.PushConfig may be set to configure this subscription for push delivery.",
                "+//",
                "+// If the subscription already exists an error will be returned.",
                "+func (c *Client) CreateSubscription(ctx context.Context, id string, cfg SubscriptionConfig) (*Subscription, error) {",
                "+\tif cfg.Topic == nil {",
                "+\t\treturn nil, errors.New(\"pubsub: require non-nil Topic\")",
                "+\t}",
                "+\tif cfg.AckDeadline == 0 {",
                "+\t\tcfg.AckDeadline = 10 * time.Second",
                "+\t}",
                "+\tif d := cfg.AckDeadline; d < 10*time.Second || d > 600*time.Second {",
                "+\t\treturn nil, fmt.Errorf(\"ack deadline must be between 10 and 600 seconds; got: %v\", d)",
                "+\t}",
                "+",
                "+\tsub := c.Subscription(id)",
                "+\terr := c.s.createSubscription(ctx, sub.name, cfg)",
                "+\treturn sub, err",
                "+}",
                "+",
                "+var errReceiveInProgress = errors.New(\"pubsub: Receive already in progress for this subscription\")",
                "+",
                "+// Receive calls f with the outstanding messages from the subscription.",
                "+// It blocks until ctx is done, or the service returns a non-retryable error.",
                "+//",
                "+// The standard way to terminate a Receive is to cancel its context:",
                "+//",
                "+//   cctx, cancel := context.WithCancel(ctx)",
                "+//   err := sub.Receive(cctx, callback)",
                "+//   // Call cancel from callback, or another goroutine.",
                "+//",
                "+// If the service returns a non-retryable error, Receive returns that error after",
                "+// all of the outstanding calls to f have returned. If ctx is done, Receive",
                "+// returns nil after all of the outstanding calls to f have returned and",
                "+// all messages have been acknowledged or have expired.",
                "+//",
                "+// Receive calls f concurrently from multiple goroutines. It is encouraged to",
                "+// process messages synchronously in f, even if that processing is relatively",
                "+// time-consuming; Receive will spawn new goroutines for incoming messages,",
                "+// limited by MaxOutstandingMessages and MaxOutstandingBytes in ReceiveSettings.",
                "+//",
                "+// The context passed to f will be canceled when ctx is Done or there is a",
                "+// fatal service error.",
                "+//",
                "+// Receive will automatically extend the ack deadline of all fetched Messages for the",
                "+// period specified by s.ReceiveSettings.MaxExtension.",
                "+//",
                "+// Each Subscription may have only one invocation of Receive active at a time.",
                "+func (s *Subscription) Receive(ctx context.Context, f func(context.Context, *Message)) error {",
                "+\ts.mu.Lock()",
                "+\tif s.receiveActive {",
                "+\t\ts.mu.Unlock()",
                "+\t\treturn errReceiveInProgress",
                "+\t}",
                "+\ts.receiveActive = true",
                "+\ts.mu.Unlock()",
                "+\tdefer func() { s.mu.Lock(); s.receiveActive = false; s.mu.Unlock() }()",
                "+",
                "+\tconfig, err := s.Config(ctx)",
                "+\tif err != nil {",
                "+\t\tif grpc.Code(err) == codes.Canceled {",
                "+\t\t\treturn nil",
                "+\t\t}",
                "+\t\treturn err",
                "+\t}",
                "+\tmaxCount := s.ReceiveSettings.MaxOutstandingMessages",
                "+\tif maxCount == 0 {",
                "+\t\tmaxCount = DefaultReceiveSettings.MaxOutstandingMessages",
                "+\t}",
                "+\tmaxBytes := s.ReceiveSettings.MaxOutstandingBytes",
                "+\tif maxBytes == 0 {",
                "+\t\tmaxBytes = DefaultReceiveSettings.MaxOutstandingBytes",
                "+\t}",
                "+\tmaxExt := s.ReceiveSettings.MaxExtension",
                "+\tif maxExt == 0 {",
                "+\t\tmaxExt = DefaultReceiveSettings.MaxExtension",
                "+\t} else if maxExt < 0 {",
                "+\t\t// If MaxExtension is negative, disable automatic extension.",
                "+\t\tmaxExt = 0",
                "+\t}",
                "+\tnumGoroutines := s.ReceiveSettings.NumGoroutines",
                "+\tif numGoroutines < 1 {",
                "+\t\tnumGoroutines = DefaultReceiveSettings.NumGoroutines",
                "+\t}",
                "+\t// TODO(jba): add tests that verify that ReceiveSettings are correctly processed.",
                "+\tpo := &pullOptions{",
                "+\t\tmaxExtension: maxExt,",
                "+\t\tmaxPrefetch:  trunc32(int64(maxCount)),",
                "+\t\tackDeadline:  config.AckDeadline,",
                "+\t}",
                "+\tfc := newFlowController(maxCount, maxBytes)",
                "+",
                "+\t// Wait for all goroutines started by Receive to return, so instead of an",
                "+\t// obscure goroutine leak we have an obvious blocked call to Receive.",
                "+\tgroup, gctx := errgroup.WithContext(ctx)",
                "+\tfor i := 0; i < numGoroutines; i++ {",
                "+\t\tgroup.Go(func() error {",
                "+\t\t\treturn s.receive(gctx, po, fc, f)",
                "+\t\t})",
                "+\t}",
                "+\treturn group.Wait()",
                "+}",
                "+",
                "+func (s *Subscription) receive(ctx context.Context, po *pullOptions, fc *flowController, f func(context.Context, *Message)) error {",
                "+\t// Cancel a sub-context when we return, to kick the context-aware callbacks",
                "+\t// and the goroutine below.",
                "+\tctx2, cancel := context.WithCancel(ctx)",
                "+\t// Call stop when Receive's context is done.",
                "+\t// Stop will block until all outstanding messages have been acknowledged",
                "+\t// or there was a fatal service error.",
                "+\t// The iterator does not use the context passed to Receive. If it did, canceling",
                "+\t// that context would immediately stop the iterator without waiting for unacked",
                "+\t// messages.",
                "+\titer := newMessageIterator(context.Background(), s.s, s.name, po)",
                "+",
                "+\t// We cannot use errgroup from Receive here. Receive might already be calling group.Wait,",
                "+\t// and group.Wait cannot be called concurrently with group.Go. We give each receive() its",
                "+\t// own WaitGroup instead.",
                "+\t// Since wg.Add is only called from the main goroutine, wg.Wait is guaranteed",
                "+\t// to be called after all Adds.",
                "+\tvar wg sync.WaitGroup",
                "+\twg.Add(1)",
                "+\tgo func() {",
                "+\t\t<-ctx2.Done()",
                "+\t\titer.stop()",
                "+\t\twg.Done()",
                "+\t}()",
                "+\tdefer wg.Wait()",
                "+",
                "+\tdefer cancel()",
                "+\tfor {",
                "+\t\tmsgs, err := iter.receive()",
                "+\t\tif err == io.EOF {",
                "+\t\t\treturn nil",
                "+\t\t}",
                "+\t\tif err != nil {",
                "+\t\t\treturn err",
                "+\t\t}",
                "+\t\tfor i, msg := range msgs {",
                "+\t\t\tmsg := msg",
                "+\t\t\t// TODO(jba): call acquire closer to when the message is allocated.",
                "+\t\t\tif err := fc.acquire(ctx, len(msg.Data)); err != nil {",
                "+\t\t\t\t// TODO(jba): test that these \"orphaned\" messages are nacked immediately when ctx is done.",
                "+\t\t\t\tfor _, m := range msgs[i:] {",
                "+\t\t\t\t\tm.Nack()",
                "+\t\t\t\t}",
                "+\t\t\t\treturn nil",
                "+\t\t\t}",
                "+\t\t\twg.Add(1)",
                "+\t\t\tgo func() {",
                "+\t\t\t\t// TODO(jba): call release when the message is available for GC.",
                "+\t\t\t\t// This considers the message to be released when",
                "+\t\t\t\t// f is finished, but f may ack early or not at all.",
                "+\t\t\t\tdefer wg.Done()",
                "+\t\t\t\tdefer fc.release(len(msg.Data))",
                "+\t\t\t\tf(ctx2, msg)",
                "+\t\t\t}()",
                "+\t\t}",
                "+\t}",
                "+}",
                "+",
                "+// TODO(jba): remove when we delete messageIterator.",
                "+type pullOptions struct {",
                "+\tmaxExtension time.Duration",
                "+\tmaxPrefetch  int32",
                "+\t// ackDeadline is the default ack deadline for the subscription. Not",
                "+\t// configurable.",
                "+\tackDeadline time.Duration",
                "+}",
                "diff --git a/vendor/cloud.google.com/go/pubsub/topic.go b/vendor/cloud.google.com/go/pubsub/topic.go",
                "new file mode 100644",
                "index 0000000..274f54d",
                "--- /dev/null",
                "+++ b/vendor/cloud.google.com/go/pubsub/topic.go",
                "@@ -0,0 +1,368 @@",
                "+// Copyright 2016 Google Inc. All Rights Reserved.",
                "+//",
                "+// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "+// you may not use this file except in compliance with the License.",
                "+// You may obtain a copy of the License at",
                "+//",
                "+//      http://www.apache.org/licenses/LICENSE-2.0",
                "+//",
                "+// Unless required by applicable law or agreed to in writing, software",
                "+// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "+// See the License for the specific language governing permissions and",
                "+// limitations under the License.",
                "+",
                "+package pubsub",
                "+",
                "+import (",
                "+\t\"errors\"",
                "+\t\"fmt\"",
                "+\t\"runtime\"",
                "+\t\"strings\"",
                "+\t\"sync\"",
                "+\t\"time\"",
                "+",
                "+\t\"cloud.google.com/go/iam\"",
                "+\t\"github.com/golang/protobuf/proto\"",
                "+\t\"golang.org/x/net/context\"",
                "+\t\"google.golang.org/api/support/bundler\"",
                "+\tpb \"google.golang.org/genproto/googleapis/pubsub/v1\"",
                "+)",
                "+",
                "+const (",
                "+\t// The maximum number of messages that can be in a single publish request, as",
                "+\t// determined by the PubSub service.",
                "+\tMaxPublishRequestCount = 1000",
                "+",
                "+\t// The maximum size of a single publish request in bytes, as determined by the PubSub service.",
                "+\tMaxPublishRequestBytes = 1e7",
                "+",
                "+\tmaxInt = int(^uint(0) >> 1)",
                "+)",
                "+",
                "+// ErrOversizedMessage indicates that a message's size exceeds MaxPublishRequestBytes.",
                "+var ErrOversizedMessage = bundler.ErrOversizedItem",
                "+",
                "+// Topic is a reference to a PubSub topic.",
                "+//",
                "+// The methods of Topic are safe for use by multiple goroutines.",
                "+type Topic struct {",
                "+\ts service",
                "+\t// The fully qualified identifier for the topic, in the format \"projects/<projid>/topics/<name>\"",
                "+\tname string",
                "+",
                "+\t// Settings for publishing messages. All changes must be made before the",
                "+\t// first call to Publish. The default is DefaultPublishSettings.",
                "+\tPublishSettings PublishSettings",
                "+",
                "+\tmu      sync.RWMutex",
                "+\tstopped bool",
                "+\tbundler *bundler.Bundler",
                "+",
                "+\twg sync.WaitGroup",
                "+",
                "+\t// Channel for message bundles to be published. Close to indicate that Stop was called.",
                "+\tbundlec chan []*bundledMessage",
                "+}",
                "+",
                "+// PublishSettings control the bundling of published messages.",
                "+type PublishSettings struct {",
                "+",
                "+\t// Publish a non-empty batch after this delay has passed.",
                "+\tDelayThreshold time.Duration",
                "+",
                "+\t// Publish a batch when it has this many messages. The maximum is",
                "+\t// MaxPublishRequestCount.",
                "+\tCountThreshold int",
                "+",
                "+\t// Publish a batch when its size in bytes reaches this value.",
                "+\tByteThreshold int",
                "+",
                "+\t// The number of goroutines that invoke the Publish RPC concurrently.",
                "+\t// Defaults to a multiple of GOMAXPROCS.",
                "+\tNumGoroutines int",
                "+",
                "+\t// The maximum time that the client will attempt to publish a bundle of messages.",
                "+\tTimeout time.Duration",
                "+}",
                "+",
                "+// DefaultPublishSettings holds the default values for topics' PublishSettings.",
                "+var DefaultPublishSettings = PublishSettings{",
                "+\tDelayThreshold: 1 * time.Millisecond,",
                "+\tCountThreshold: 100,",
                "+\tByteThreshold:  1e6,",
                "+\tTimeout:        60 * time.Second,",
                "+}",
                "+",
                "+// CreateTopic creates a new topic.",
                "+// The specified topic ID must start with a letter, and contain only letters",
                "+// ([A-Za-z]), numbers ([0-9]), dashes (-), underscores (_), periods (.),",
                "+// tildes (~), plus (+) or percent signs (%). It must be between 3 and 255",
                "+// characters in length, and must not start with \"goog\".",
                "+// If the topic already exists an error will be returned.",
                "+func (c *Client) CreateTopic(ctx context.Context, id string) (*Topic, error) {",
                "+\tt := c.Topic(id)",
                "+\terr := c.s.createTopic(ctx, t.name)",
                "+\treturn t, err",
                "+}",
                "+",
                "+// Topic creates a reference to a topic in the client's project.",
                "+//",
                "+// If a Topic's Publish method is called, it has background goroutines",
                "+// associated with it. Clean them up by calling Topic.Stop.",
                "+//",
                "+// Avoid creating many Topic instances if you use them to publish.",
                "+func (c *Client) Topic(id string) *Topic {",
                "+\treturn c.TopicInProject(id, c.projectID)",
                "+}",
                "+",
                "+// TopicInProject creates a reference to a topic in the given project.",
                "+//",
                "+// If a Topic's Publish method is called, it has background goroutines",
                "+// associated with it. Clean them up by calling Topic.Stop.",
                "+//",
                "+// Avoid creating many Topic instances if you use them to publish.",
                "+func (c *Client) TopicInProject(id, projectID string) *Topic {",
                "+\treturn newTopic(c.s, fmt.Sprintf(\"projects/%s/topics/%s\", projectID, id))",
                "+}",
                "+",
                "+func newTopic(s service, name string) *Topic {",
                "+\t// bundlec is unbuffered. A buffer would occupy memory not",
                "+\t// accounted for by the bundler, so BufferedByteLimit would be a lie:",
                "+\t// the actual memory consumed would be higher.",
                "+\treturn &Topic{",
                "+\t\ts:               s,",
                "+\t\tname:            name,",
                "+\t\tPublishSettings: DefaultPublishSettings,",
                "+\t\tbundlec:         make(chan []*bundledMessage),",
                "+\t}",
                "+}",
                "+",
                "+// Topics returns an iterator which returns all of the topics for the client's project.",
                "+func (c *Client) Topics(ctx context.Context) *TopicIterator {",
                "+\treturn &TopicIterator{",
                "+\t\ts:    c.s,",
                "+\t\tnext: c.s.listProjectTopics(ctx, c.fullyQualifiedProjectName()),",
                "+\t}",
                "+}",
                "+",
                "+// TopicIterator is an iterator that returns a series of topics.",
                "+type TopicIterator struct {",
                "+\ts    service",
                "+\tnext nextStringFunc",
                "+}",
                "+",
                "+// Next returns the next topic. If there are no more topics, iterator.Done will be returned.",
                "+func (tps *TopicIterator) Next() (*Topic, error) {",
                "+\ttopicName, err := tps.next()",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn newTopic(tps.s, topicName), nil",
                "+}",
                "+",
                "+// ID returns the unique idenfier of the topic within its project.",
                "+func (t *Topic) ID() string {",
                "+\tslash := strings.LastIndex(t.name, \"/\")",
                "+\tif slash == -1 {",
                "+\t\t// name is not a fully-qualified name.",
                "+\t\tpanic(\"bad topic name\")",
                "+\t}",
                "+\treturn t.name[slash+1:]",
                "+}",
                "+",
                "+// String returns the printable globally unique name for the topic.",
                "+func (t *Topic) String() string {",
                "+\treturn t.name",
                "+}",
                "+",
                "+// Delete deletes the topic.",
                "+func (t *Topic) Delete(ctx context.Context) error {",
                "+\treturn t.s.deleteTopic(ctx, t.name)",
                "+}",
                "+",
                "+// Exists reports whether the topic exists on the server.",
                "+func (t *Topic) Exists(ctx context.Context) (bool, error) {",
                "+\tif t.name == \"_deleted-topic_\" {",
                "+\t\treturn false, nil",
                "+\t}",
                "+",
                "+\treturn t.s.topicExists(ctx, t.name)",
                "+}",
                "+",
                "+func (t *Topic) IAM() *iam.Handle {",
                "+\treturn t.s.iamHandle(t.name)",
                "+}",
                "+",
                "+// Subscriptions returns an iterator which returns the subscriptions for this topic.",
                "+func (t *Topic) Subscriptions(ctx context.Context) *SubscriptionIterator {",
                "+\t// NOTE: zero or more Subscriptions that are ultimately returned by this",
                "+\t// Subscriptions iterator may belong to a different project to t.",
                "+\treturn &SubscriptionIterator{",
                "+\t\ts:    t.s,",
                "+\t\tnext: t.s.listTopicSubscriptions(ctx, t.name),",
                "+\t}",
                "+}",
                "+",
                "+var errTopicStopped = errors.New(\"pubsub: Stop has been called for this topic\")",
                "+",
                "+// Publish publishes msg to the topic asynchronously. Messages are batched and",
                "+// sent according to the topic's PublishSettings. Publish never blocks.",
                "+//",
                "+// Publish returns a non-nil PublishResult which will be ready when the",
                "+// message has been sent (or has failed to be sent) to the server.",
                "+//",
                "+// Publish creates goroutines for batching and sending messages. These goroutines",
                "+// need to be stopped by calling t.Stop(). Once stopped, future calls to Publish",
                "+// will immediately return a PublishResult with an error.",
                "+func (t *Topic) Publish(ctx context.Context, msg *Message) *PublishResult {",
                "+\t// TODO(jba): if this turns out to take significant time, try to approximate it.",
                "+\t// Or, convert the messages to protos in Publish, instead of in the service.",
                "+\tmsg.size = proto.Size(&pb.PubsubMessage{",
                "+\t\tData:       msg.Data,",
                "+\t\tAttributes: msg.Attributes,",
                "+\t})",
                "+\tr := &PublishResult{ready: make(chan struct{})}",
                "+\tt.initBundler()",
                "+\tt.mu.RLock()",
                "+\tdefer t.mu.RUnlock()",
                "+\t// TODO(aboulhosn) [from bcmills] consider changing the semantics of bundler to perform this logic so we don't have to do it here",
                "+\tif t.stopped {",
                "+\t\tr.set(\"\", errTopicStopped)",
                "+\t\treturn r",
                "+\t}",
                "+",
                "+\t// TODO(jba) [from bcmills] consider using a shared channel per bundle",
                "+\t// (requires Bundler API changes; would reduce allocations)",
                "+\t// The call to Add should never return an error because the bundler's",
                "+\t// BufferedByteLimit is set to maxInt; we do not perform any flow",
                "+\t// control in the client.",
                "+\terr := t.bundler.Add(&bundledMessage{msg, r}, msg.size)",
                "+\tif err != nil {",
                "+\t\tr.set(\"\", err)",
                "+\t}",
                "+\treturn r",
                "+}",
                "+",
                "+// Send all remaining published messages and stop goroutines created for handling",
                "+// publishing. Returns once all outstanding messages have been sent or have",
                "+// failed to be sent.",
                "+func (t *Topic) Stop() {",
                "+\tt.mu.Lock()",
                "+\tnoop := t.stopped || t.bundler == nil",
                "+\tt.stopped = true",
                "+\tt.mu.Unlock()",
                "+\tif noop {",
                "+\t\treturn",
                "+\t}",
                "+\tt.bundler.Flush()",
                "+\t// At this point, all pending bundles have been published and the bundler's",
                "+\t// goroutines have exited, so it is OK for this goroutine to close bundlec.",
                "+\tclose(t.bundlec)",
                "+\tt.wg.Wait()",
                "+}",
                "+",
                "+// A PublishResult holds the result from a call to Publish.",
                "+type PublishResult struct {",
                "+\tready    chan struct{}",
                "+\tserverID string",
                "+\terr      error",
                "+}",
                "+",
                "+// Ready returns a channel that is closed when the result is ready.",
                "+// When the Ready channel is closed, Get is guaranteed not to block.",
                "+func (r *PublishResult) Ready() <-chan struct{} { return r.ready }",
                "+",
                "+// Get returns the server-generated message ID and/or error result of a Publish call.",
                "+// Get blocks until the Publish call completes or the context is done.",
                "+func (r *PublishResult) Get(ctx context.Context) (serverID string, err error) {",
                "+\t// If the result is already ready, return it even if the context is done.",
                "+\tselect {",
                "+\tcase <-r.Ready():",
                "+\t\treturn r.serverID, r.err",
                "+\tdefault:",
                "+\t}",
                "+\tselect {",
                "+\tcase <-ctx.Done():",
                "+\t\treturn \"\", ctx.Err()",
                "+\tcase <-r.Ready():",
                "+\t\treturn r.serverID, r.err",
                "+\t}",
                "+}",
                "+",
                "+func (r *PublishResult) set(sid string, err error) {",
                "+\tr.serverID = sid",
                "+\tr.err = err",
                "+\tclose(r.ready)",
                "+}",
                "+",
                "+type bundledMessage struct {",
                "+\tmsg *Message",
                "+\tres *PublishResult",
                "+}",
                "+",
                "+func (t *Topic) initBundler() {",
                "+\tt.mu.RLock()",
                "+\tnoop := t.stopped || t.bundler != nil",
                "+\tt.mu.RUnlock()",
                "+\tif noop {",
                "+\t\treturn",
                "+\t}",
                "+\tt.mu.Lock()",
                "+\tdefer t.mu.Unlock()",
                "+\t// Must re-check, since we released the lock.",
                "+\tif t.stopped || t.bundler != nil {",
                "+\t\treturn",
                "+\t}",
                "+",
                "+\t// TODO(jba): use a context detached from the one passed to NewClient.",
                "+\tctx := context.TODO()",
                "+\t// Unless overridden, run several goroutines per CPU to call the Publish RPC.",
                "+\tn := t.PublishSettings.NumGoroutines",
                "+\tif n <= 0 {",
                "+\t\tn = 25 * runtime.GOMAXPROCS(0)",
                "+\t}",
                "+\ttimeout := t.PublishSettings.Timeout",
                "+\tt.wg.Add(n)",
                "+\tfor i := 0; i < n; i++ {",
                "+\t\tgo func() {",
                "+\t\t\tdefer t.wg.Done()",
                "+\t\t\tfor b := range t.bundlec {",
                "+\t\t\t\tbctx := ctx",
                "+\t\t\t\tcancel := func() {}",
                "+\t\t\t\tif timeout != 0 {",
                "+\t\t\t\t\tbctx, cancel = context.WithTimeout(ctx, timeout)",
                "+\t\t\t\t}",
                "+\t\t\t\tt.publishMessageBundle(bctx, b)",
                "+\t\t\t\tcancel()",
                "+\t\t\t}",
                "+\t\t}()",
                "+\t}",
                "+\tt.bundler = bundler.NewBundler(&bundledMessage{}, func(items interface{}) {",
                "+\t\tt.bundlec <- items.([]*bundledMessage)",
                "+",
                "+\t})",
                "+\tt.bundler.DelayThreshold = t.PublishSettings.DelayThreshold",
                "+\tt.bundler.BundleCountThreshold = t.PublishSettings.CountThreshold",
                "+\tif t.bundler.BundleCountThreshold > MaxPublishRequestCount {",
                "+\t\tt.bundler.BundleCountThreshold = MaxPublishRequestCount",
                "+\t}",
                "+\tt.bundler.BundleByteThreshold = t.PublishSettings.ByteThreshold",
                "+\tt.bundler.BufferedByteLimit = maxInt",
                "+\tt.bundler.BundleByteLimit = MaxPublishRequestBytes",
                "+}",
                "+",
                "+func (t *Topic) publishMessageBundle(ctx context.Context, bms []*bundledMessage) {",
                "+\tmsgs := make([]*Message, len(bms))",
                "+\tfor i, bm := range bms {",
                "+\t\tmsgs[i], bm.msg = bm.msg, nil // release bm.msg for GC",
                "+\t}",
                "+\tids, err := t.s.publishMessages(ctx, t.name, msgs)",
                "+\tfor i, bm := range bms {",
                "+\t\tif err != nil {",
                "+\t\t\tbm.res.set(\"\", err)",
                "+\t\t} else {",
                "+\t\t\tbm.res.set(ids[i], nil)",
                "+\t\t}",
                "+\t}",
                "+}",
                "diff --git a/vendor/golang.org/x/sync/errgroup/errgroup.go b/vendor/golang.org/x/sync/errgroup/errgroup.go",
                "new file mode 100644",
                "index 0000000..533438d",
                "--- /dev/null",
                "+++ b/vendor/golang.org/x/sync/errgroup/errgroup.go",
                "@@ -0,0 +1,67 @@",
                "+// Copyright 2016 The Go Authors. All rights reserved.",
                "+// Use of this source code is governed by a BSD-style",
                "+// license that can be found in the LICENSE file.",
                "+",
                "+// Package errgroup provides synchronization, error propagation, and Context",
                "+// cancelation for groups of goroutines working on subtasks of a common task.",
                "+package errgroup",
                "+",
                "+import (",
                "+\t\"sync\"",
                "+",
                "+\t\"golang.org/x/net/context\"",
                "+)",
                "+",
                "+// A Group is a collection of goroutines working on subtasks that are part of",
                "+// the same overall task.",
                "+//",
                "+// A zero Group is valid and does not cancel on error.",
                "+type Group struct {",
                "+\tcancel func()",
                "+",
                "+\twg sync.WaitGroup",
                "+",
                "+\terrOnce sync.Once",
                "+\terr     error",
                "+}",
                "+",
                "+// WithContext returns a new Group and an associated Context derived from ctx.",
                "+//",
                "+// The derived Context is canceled the first time a function passed to Go",
                "+// returns a non-nil error or the first time Wait returns, whichever occurs",
                "+// first.",
                "+func WithContext(ctx context.Context) (*Group, context.Context) {",
                "+\tctx, cancel := context.WithCancel(ctx)",
                "+\treturn &Group{cancel: cancel}, ctx",
                "+}",
                "+",
                "+// Wait blocks until all function calls from the Go method have returned, then",
                "+// returns the first non-nil error (if any) from them.",
                "+func (g *Group) Wait() error {",
                "+\tg.wg.Wait()",
                "+\tif g.cancel != nil {",
                "+\t\tg.cancel()",
                "+\t}",
                "+\treturn g.err",
                "+}",
                "+",
                "+// Go calls the given function in a new goroutine.",
                "+//",
                "+// The first call to return a non-nil error cancels the group; its error will be",
                "+// returned by Wait.",
                "+func (g *Group) Go(f func() error) {",
                "+\tg.wg.Add(1)",
                "+",
                "+\tgo func() {",
                "+\t\tdefer g.wg.Done()",
                "+",
                "+\t\tif err := f(); err != nil {",
                "+\t\t\tg.errOnce.Do(func() {",
                "+\t\t\t\tg.err = err",
                "+\t\t\t\tif g.cancel != nil {",
                "+\t\t\t\t\tg.cancel()",
                "+\t\t\t\t}",
                "+\t\t\t})",
                "+\t\t}",
                "+\t}()",
                "+}",
                "diff --git a/vendor/golang.org/x/tools/go/gcexportdata/gcexportdata.go b/vendor/golang.org/x/tools/go/gcexportdata/gcexportdata.go",
                "index fc3c4d7..b1c0727 100644",
                "--- a/vendor/golang.org/x/tools/go/gcexportdata/gcexportdata.go",
                "+++ b/vendor/golang.org/x/tools/go/gcexportdata/gcexportdata.go",
                "@@ -9,5 +9,2 @@",
                " //",
                "-// This package replaces the deprecated golang.org/x/tools/go/gcimporter15",
                "-// package, which will be deleted in October 2017.",
                "-//",
                " // Although it might seem convenient for this package to live alongside",
                "@@ -34,3 +31,3 @@ import (",
                "-\tgcimporter \"golang.org/x/tools/go/gcimporter15\"",
                "+\t\"golang.org/x/tools/go/internal/gcimporter\"",
                " )",
                "@@ -97,3 +94,7 @@ func Read(in io.Reader, fset *token.FileSet, imports map[string]*types.Package,",
                " func Write(out io.Writer, fset *token.FileSet, pkg *types.Package) error {",
                "-\t_, err := out.Write(gcimporter.BExportData(fset, pkg))",
                "+\tb, err := gcimporter.BExportData(fset, pkg)",
                "+\tif err != nil {",
                "+\t\treturn err",
                "+\t}",
                "+\t_, err = out.Write(b)",
                " \treturn err",
                "diff --git a/vendor/golang.org/x/tools/go/internal/gcimporter/bexport.go b/vendor/golang.org/x/tools/go/internal/gcimporter/bexport.go",
                "new file mode 100644",
                "index 0000000..b106172",
                "--- /dev/null",
                "+++ b/vendor/golang.org/x/tools/go/internal/gcimporter/bexport.go",
                "@@ -0,0 +1,847 @@",
                "+// Copyright 2016 The Go Authors. All rights reserved.",
                "+// Use of this source code is governed by a BSD-style",
                "+// license that can be found in the LICENSE file.",
                "+",
                "+// Binary package export.",
                "+// This file was derived from $GOROOT/src/cmd/compile/internal/gc/bexport.go;",
                "+// see that file for specification of the format.",
                "+",
                "+package gcimporter",
                "+",
                "+import (",
                "+\t\"bytes\"",
                "+\t\"encoding/binary\"",
                "+\t\"fmt\"",
                "+\t\"go/ast\"",
                "+\t\"go/constant\"",
                "+\t\"go/token\"",
                "+\t\"go/types\"",
                "+\t\"math\"",
                "+\t\"math/big\"",
                "+\t\"sort\"",
                "+\t\"strings\"",
                "+)",
                "+",
                "+// If debugFormat is set, each integer and string value is preceded by a marker",
                "+// and position information in the encoding. This mechanism permits an importer",
                "+// to recognize immediately when it is out of sync. The importer recognizes this",
                "+// mode automatically (i.e., it can import export data produced with debugging",
                "+// support even if debugFormat is not set at the time of import). This mode will",
                "+// lead to massively larger export data (by a factor of 2 to 3) and should only",
                "+// be enabled during development and debugging.",
                "+//",
                "+// NOTE: This flag is the first flag to enable if importing dies because of",
                "+// (suspected) format errors, and whenever a change is made to the format.",
                "+const debugFormat = false // default: false",
                "+",
                "+// If trace is set, debugging output is printed to std out.",
                "+const trace = false // default: false",
                "+",
                "+// Current export format version. Increase with each format change.",
                "+// 4: type name objects support type aliases, uses aliasTag",
                "+// 3: Go1.8 encoding (same as version 2, aliasTag defined but never used)",
                "+// 2: removed unused bool in ODCL export (compiler only)",
                "+// 1: header format change (more regular), export package for _ struct fields",
                "+// 0: Go1.7 encoding",
                "+const exportVersion = 4",
                "+",
                "+// trackAllTypes enables cycle tracking for all types, not just named",
                "+// types. The existing compiler invariants assume that unnamed types",
                "+// that are not completely set up are not used, or else there are spurious",
                "+// errors.",
                "+// If disabled, only named types are tracked, possibly leading to slightly",
                "+// less efficient encoding in rare cases. It also prevents the export of",
                "+// some corner-case type declarations (but those are not handled correctly",
                "+// with with the textual export format either).",
                "+// TODO(gri) enable and remove once issues caused by it are fixed",
                "+const trackAllTypes = false",
                "+",
                "+type exporter struct {",
                "+\tfset *token.FileSet",
                "+\tout  bytes.Buffer",
                "+",
                "+\t// object -> index maps, indexed in order of serialization",
                "+\tstrIndex map[string]int",
                "+\tpkgIndex map[*types.Package]int",
                "+\ttypIndex map[types.Type]int",
                "+",
                "+\t// position encoding",
                "+\tposInfoFormat bool",
                "+\tprevFile      string",
                "+\tprevLine      int",
                "+",
                "+\t// debugging support",
                "+\twritten int // bytes written",
                "+\tindent  int // for trace",
                "+}",
                "+",
                "+// internalError represents an error generated inside this package.",
                "+type internalError string",
                "+",
                "+func (e internalError) Error() string { return \"gcimporter: \" + string(e) }",
                "+",
                "+func internalErrorf(format string, args ...interface{}) error {",
                "+\treturn internalError(fmt.Sprintf(format, args...))",
                "+}",
                "+",
                "+// BExportData returns binary export data for pkg.",
                "+// If no file set is provided, position info will be missing.",
                "+func BExportData(fset *token.FileSet, pkg *types.Package) (b []byte, err error) {",
                "+\tdefer func() {",
                "+\t\tif e := recover(); e != nil {",
                "+\t\t\tif ierr, ok := e.(internalError); ok {",
                "+\t\t\t\terr = ierr",
                "+\t\t\t\treturn",
                "+\t\t\t}",
                "+\t\t\t// Not an internal error; panic again.",
                "+\t\t\tpanic(e)",
                "+\t\t}",
                "+\t}()",
                "+",
                "+\tp := exporter{",
                "+\t\tfset:          fset,",
                "+\t\tstrIndex:      map[string]int{\"\": 0}, // empty string is mapped to 0",
                "+\t\tpkgIndex:      make(map[*types.Package]int),",
                "+\t\ttypIndex:      make(map[types.Type]int),",
                "+\t\tposInfoFormat: true, // TODO(gri) might become a flag, eventually",
                "+\t}",
                "+",
                "+\t// write version info",
                "+\t// The version string must start with \"version %d\" where %d is the version",
                "+\t// number. Additional debugging information may follow after a blank; that",
                "+\t// text is ignored by the importer.",
                "+\tp.rawStringln(fmt.Sprintf(\"version %d\", exportVersion))",
                "+\tvar debug string",
                "+\tif debugFormat {",
                "+\t\tdebug = \"debug\"",
                "+\t}",
                "+\tp.rawStringln(debug) // cannot use p.bool since it's affected by debugFormat; also want to see this clearly",
                "+\tp.bool(trackAllTypes)",
                "+\tp.bool(p.posInfoFormat)",
                "+",
                "+\t// --- generic export data ---",
                "+",
                "+\t// populate type map with predeclared \"known\" types",
                "+\tfor index, typ := range predeclared {",
                "+\t\tp.typIndex[typ] = index",
                "+\t}",
                "+\tif len(p.typIndex) != len(predeclared) {",
                "+\t\treturn nil, internalError(\"duplicate entries in type map?\")",
                "+\t}",
                "+",
                "+\t// write package data",
                "+\tp.pkg(pkg, true)",
                "+\tif trace {",
                "+\t\tp.tracef(\"\\n\")",
                "+\t}",
                "+",
                "+\t// write objects",
                "+\tobjcount := 0",
                "+\tscope := pkg.Scope()",
                "+\tfor _, name := range scope.Names() {",
                "+\t\tif !ast.IsExported(name) {",
                "+\t\t\tcontinue",
                "+\t\t}",
                "+\t\tif trace {",
                "+\t\t\tp.tracef(\"\\n\")",
                "+\t\t}",
                "+\t\tp.obj(scope.Lookup(name))",
                "+\t\tobjcount++",
                "+\t}",
                "+",
                "+\t// indicate end of list",
                "+\tif trace {",
                "+\t\tp.tracef(\"\\n\")",
                "+\t}",
                "+\tp.tag(endTag)",
                "+",
                "+\t// for self-verification only (redundant)",
                "+\tp.int(objcount)",
                "+",
                "+\tif trace {",
                "+\t\tp.tracef(\"\\n\")",
                "+\t}",
                "+",
                "+\t// --- end of export data ---",
                "+",
                "+\treturn p.out.Bytes(), nil",
                "+}",
                "+",
                "+func (p *exporter) pkg(pkg *types.Package, emptypath bool) {",
                "+\tif pkg == nil {",
                "+\t\tpanic(internalError(\"unexpected nil pkg\"))",
                "+\t}",
                "+",
                "+\t// if we saw the package before, write its index (>= 0)",
                "+\tif i, ok := p.pkgIndex[pkg]; ok {",
                "+\t\tp.index('P', i)",
                "+\t\treturn",
                "+\t}",
                "+",
                "+\t// otherwise, remember the package, write the package tag (< 0) and package data",
                "+\tif trace {",
                "+\t\tp.tracef(\"P%d = { \", len(p.pkgIndex))",
                "+\t\tdefer p.tracef(\"} \")",
                "+\t}",
                "+\tp.pkgIndex[pkg] = len(p.pkgIndex)",
                "+",
                "+\tp.tag(packageTag)",
                "+\tp.string(pkg.Name())",
                "+\tif emptypath {",
                "+\t\tp.string(\"\")",
                "+\t} else {",
                "+\t\tp.string(pkg.Path())",
                "+\t}",
                "+}",
                "+",
                "+func (p *exporter) obj(obj types.Object) {",
                "+\tswitch obj := obj.(type) {",
                "+\tcase *types.Const:",
                "+\t\tp.tag(constTag)",
                "+\t\tp.pos(obj)",
                "+\t\tp.qualifiedName(obj)",
                "+\t\tp.typ(obj.Type())",
                "+\t\tp.value(obj.Val())",
                "+",
                "+\tcase *types.TypeName:",
                "+\t\tif isAlias(obj) {",
                "+\t\t\tp.tag(aliasTag)",
                "+\t\t\tp.pos(obj)",
                "+\t\t\tp.qualifiedName(obj)",
                "+\t\t} else {",
                "+\t\t\tp.tag(typeTag)",
                "+\t\t}",
                "+\t\tp.typ(obj.Type())",
                "+",
                "+\tcase *types.Var:",
                "+\t\tp.tag(varTag)",
                "+\t\tp.pos(obj)",
                "+\t\tp.qualifiedName(obj)",
                "+\t\tp.typ(obj.Type())",
                "+",
                "+\tcase *types.Func:",
                "+\t\tp.tag(funcTag)",
                "+\t\tp.pos(obj)",
                "+\t\tp.qualifiedName(obj)",
                "+\t\tsig := obj.Type().(*types.Signature)",
                "+\t\tp.paramList(sig.Params(), sig.Variadic())",
                "+\t\tp.paramList(sig.Results(), false)",
                "+",
                "+\tdefault:",
                "+\t\tpanic(internalErrorf(\"unexpected object %v (%T)\", obj, obj))",
                "+\t}",
                "+}",
                "+",
                "+func (p *exporter) pos(obj types.Object) {",
                "+\tif !p.posInfoFormat {",
                "+\t\treturn",
                "+\t}",
                "+",
                "+\tfile, line := p.fileLine(obj)",
                "+\tif file == p.prevFile {",
                "+\t\t// common case: write line delta",
                "+\t\t// delta == 0 means different file or no line change",
                "+\t\tdelta := line - p.prevLine",
                "+\t\tp.int(delta)",
                "+\t\tif delta == 0 {",
                "+\t\t\tp.int(-1) // -1 means no file change",
                "+\t\t}",
                "+\t} else {",
                "+\t\t// different file",
                "+\t\tp.int(0)",
                "+\t\t// Encode filename as length of common prefix with previous",
                "+\t\t// filename, followed by (possibly empty) suffix. Filenames",
                "+\t\t// frequently share path prefixes, so this can save a lot",
                "+\t\t// of space and make export data size less dependent on file",
                "+\t\t// path length. The suffix is unlikely to be empty because",
                "+\t\t// file names tend to end in \".go\".",
                "+\t\tn := commonPrefixLen(p.prevFile, file)",
                "+\t\tp.int(n)           // n >= 0",
                "+\t\tp.string(file[n:]) // write suffix only",
                "+\t\tp.prevFile = file",
                "+\t\tp.int(line)",
                "+\t}",
                "+\tp.prevLine = line",
                "+}",
                "+",
                "+func (p *exporter) fileLine(obj types.Object) (file string, line int) {",
                "+\tif p.fset != nil {",
                "+\t\tpos := p.fset.Position(obj.Pos())",
                "+\t\tfile = pos.Filename",
                "+\t\tline = pos.Line",
                "+\t}",
                "+\treturn",
                "+}",
                "+",
                "+func commonPrefixLen(a, b string) int {",
                "+\tif len(a) > len(b) {",
                "+\t\ta, b = b, a",
                "+\t}",
                "+\t// len(a) <= len(b)",
                "+\ti := 0",
                "+\tfor i < len(a) && a[i] == b[i] {",
                "+\t\ti++",
                "+\t}",
                "+\treturn i",
                "+}",
                "+",
                "+func (p *exporter) qualifiedName(obj types.Object) {",
                "+\tp.string(obj.Name())",
                "+\tp.pkg(obj.Pkg(), false)",
                "+}",
                "+",
                "+func (p *exporter) typ(t types.Type) {",
                "+\tif t == nil {",
                "+\t\tpanic(internalError(\"nil type\"))",
                "+\t}",
                "+",
                "+\t// Possible optimization: Anonymous pointer types *T where",
                "+\t// T is a named type are common. We could canonicalize all",
                "+\t// such types *T to a single type PT = *T. This would lead",
                "+\t// to at most one *T entry in typIndex, and all future *T's",
                "+\t// would be encoded as the respective index directly. Would",
                "+\t// save 1 byte (pointerTag) per *T and reduce the typIndex",
                "+\t// size (at the cost of a canonicalization map). We can do",
                "+\t// this later, without encoding format change.",
                "+",
                "+\t// if we saw the type before, write its index (>= 0)",
                "+\tif i, ok := p.typIndex[t]; ok {",
                "+\t\tp.index('T', i)",
                "+\t\treturn",
                "+\t}",
                "+",
                "+\t// otherwise, remember the type, write the type tag (< 0) and type data",
                "+\tif trackAllTypes {",
                "+\t\tif trace {",
                "+\t\t\tp.tracef(\"T%d = {>\\n\", len(p.typIndex))",
                "+\t\t\tdefer p.tracef(\"<\\n} \")",
                "+\t\t}",
                "+\t\tp.typIndex[t] = len(p.typIndex)",
                "+\t}",
                "+",
                "+\tswitch t := t.(type) {",
                "+\tcase *types.Named:",
                "+\t\tif !trackAllTypes {",
                "+\t\t\t// if we don't track all types, track named types now",
                "+\t\t\tp.typIndex[t] = len(p.typIndex)",
                "+\t\t}",
                "+",
                "+\t\tp.tag(namedTag)",
                "+\t\tp.pos(t.Obj())",
                "+\t\tp.qualifiedName(t.Obj())",
                "+\t\tp.typ(t.Underlying())",
                "+\t\tif !types.IsInterface(t) {",
                "+\t\t\tp.assocMethods(t)",
                "+\t\t}",
                "+",
                "+\tcase *types.Array:",
                "+\t\tp.tag(arrayTag)",
                "+\t\tp.int64(t.Len())",
                "+\t\tp.typ(t.Elem())",
                "+",
                "+\tcase *types.Slice:",
                "+\t\tp.tag(sliceTag)",
                "+\t\tp.typ(t.Elem())",
                "+",
                "+\tcase *dddSlice:",
                "+\t\tp.tag(dddTag)",
                "+\t\tp.typ(t.elem)",
                "+",
                "+\tcase *types.Struct:",
                "+\t\tp.tag(structTag)",
                "+\t\tp.fieldList(t)",
                "+",
                "+\tcase *types.Pointer:",
                "+\t\tp.tag(pointerTag)",
                "+\t\tp.typ(t.Elem())",
                "+",
                "+\tcase *types.Signature:",
                "+\t\tp.tag(signatureTag)",
                "+\t\tp.paramList(t.Params(), t.Variadic())",
                "+\t\tp.paramList(t.Results(), false)",
                "+",
                "+\tcase *types.Interface:",
                "+\t\tp.tag(interfaceTag)",
                "+\t\tp.iface(t)",
                "+",
                "+\tcase *types.Map:",
                "+\t\tp.tag(mapTag)",
                "+\t\tp.typ(t.Key())",
                "+\t\tp.typ(t.Elem())",
                "+",
                "+\tcase *types.Chan:",
                "+\t\tp.tag(chanTag)",
                "+\t\tp.int(int(3 - t.Dir())) // hack",
                "+\t\tp.typ(t.Elem())",
                "+",
                "+\tdefault:",
                "+\t\tpanic(internalErrorf(\"unexpected type %T: %s\", t, t))",
                "+\t}",
                "+}",
                "+",
                "+func (p *exporter) assocMethods(named *types.Named) {",
                "+\t// Sort methods (for determinism).",
                "+\tvar methods []*types.Func",
                "+\tfor i := 0; i < named.NumMethods(); i++ {",
                "+\t\tmethods = append(methods, named.Method(i))",
                "+\t}",
                "+\tsort.Sort(methodsByName(methods))",
                "+",
                "+\tp.int(len(methods))",
                "+",
                "+\tif trace && methods != nil {",
                "+\t\tp.tracef(\"associated methods {>\\n\")",
                "+\t}",
                "+",
                "+\tfor i, m := range methods {",
                "+\t\tif trace && i > 0 {",
                "+\t\t\tp.tracef(\"\\n\")",
                "+\t\t}",
                "+",
                "+\t\tp.pos(m)",
                "+\t\tname := m.Name()",
                "+\t\tp.string(name)",
                "+\t\tif !exported(name) {",
                "+\t\t\tp.pkg(m.Pkg(), false)",
                "+\t\t}",
                "+",
                "+\t\tsig := m.Type().(*types.Signature)",
                "+\t\tp.paramList(types.NewTuple(sig.Recv()), false)",
                "+\t\tp.paramList(sig.Params(), sig.Variadic())",
                "+\t\tp.paramList(sig.Results(), false)",
                "+\t\tp.int(0) // dummy value for go:nointerface pragma - ignored by importer",
                "+\t}",
                "+",
                "+\tif trace && methods != nil {",
                "+\t\tp.tracef(\"<\\n} \")",
                "+\t}",
                "+}",
                "+",
                "+type methodsByName []*types.Func",
                "+",
                "+func (x methodsByName) Len() int           { return len(x) }",
                "+func (x methodsByName) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }",
                "+func (x methodsByName) Less(i, j int) bool { return x[i].Name() < x[j].Name() }",
                "+",
                "+func (p *exporter) fieldList(t *types.Struct) {",
                "+\tif trace && t.NumFields() > 0 {",
                "+\t\tp.tracef(\"fields {>\\n\")",
                "+\t\tdefer p.tracef(\"<\\n} \")",
                "+\t}",
                "+",
                "+\tp.int(t.NumFields())",
                "+\tfor i := 0; i < t.NumFields(); i++ {",
                "+\t\tif trace && i > 0 {",
                "+\t\t\tp.tracef(\"\\n\")",
                "+\t\t}",
                "+\t\tp.field(t.Field(i))",
                "+\t\tp.string(t.Tag(i))",
                "+\t}",
                "+}",
                "+",
                "+func (p *exporter) field(f *types.Var) {",
                "+\tif !f.IsField() {",
                "+\t\tpanic(internalError(\"field expected\"))",
                "+\t}",
                "+",
                "+\tp.pos(f)",
                "+\tp.fieldName(f)",
                "+\tp.typ(f.Type())",
                "+}",
                "+",
                "+func (p *exporter) iface(t *types.Interface) {",
                "+\t// TODO(gri): enable importer to load embedded interfaces,",
                "+\t// then emit Embeddeds and ExplicitMethods separately here.",
                "+\tp.int(0)",
                "+",
                "+\tn := t.NumMethods()",
                "+\tif trace && n > 0 {",
                "+\t\tp.tracef(\"methods {>\\n\")",
                "+\t\tdefer p.tracef(\"<\\n} \")",
                "+\t}",
                "+\tp.int(n)",
                "+\tfor i := 0; i < n; i++ {",
                "+\t\tif trace && i > 0 {",
                "+\t\t\tp.tracef(\"\\n\")",
                "+\t\t}",
                "+\t\tp.method(t.Method(i))",
                "+\t}",
                "+}",
                "+",
                "+func (p *exporter) method(m *types.Func) {",
                "+\tsig := m.Type().(*types.Signature)",
                "+\tif sig.Recv() == nil {",
                "+\t\tpanic(internalError(\"method expected\"))",
                "+\t}",
                "+",
                "+\tp.pos(m)",
                "+\tp.string(m.Name())",
                "+\tif m.Name() != \"_\" && !ast.IsExported(m.Name()) {",
                "+\t\tp.pkg(m.Pkg(), false)",
                "+\t}",
                "+",
                "+\t// interface method; no need to encode receiver.",
                "+\tp.paramList(sig.Params(), sig.Variadic())",
                "+\tp.paramList(sig.Results(), false)",
                "+}",
                "+",
                "+func (p *exporter) fieldName(f *types.Var) {",
                "+\tname := f.Name()",
                "+",
                "+\tif f.Anonymous() {",
                "+\t\t// anonymous field - we distinguish between 3 cases:",
                "+\t\t// 1) field name matches base type name and is exported",
                "+\t\t// 2) field name matches base type name and is not exported",
                "+\t\t// 3) field name doesn't match base type name (alias name)",
                "+\t\tbname := basetypeName(f.Type())",
                "+\t\tif name == bname {",
                "+\t\t\tif ast.IsExported(name) {",
                "+\t\t\t\tname = \"\" // 1) we don't need to know the field name or package",
                "+\t\t\t} else {",
                "+\t\t\t\tname = \"?\" // 2) use unexported name \"?\" to force package export",
                "+\t\t\t}",
                "+\t\t} else {",
                "+\t\t\t// 3) indicate alias and export name as is",
                "+\t\t\t// (this requires an extra \"@\" but this is a rare case)",
                "+\t\t\tp.string(\"@\")",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tp.string(name)",
                "+\tif name != \"\" && !ast.IsExported(name) {",
                "+\t\tp.pkg(f.Pkg(), false)",
                "+\t}",
                "+}",
                "+",
                "+func basetypeName(typ types.Type) string {",
                "+\tswitch typ := deref(typ).(type) {",
                "+\tcase *types.Basic:",
                "+\t\treturn typ.Name()",
                "+\tcase *types.Named:",
                "+\t\treturn typ.Obj().Name()",
                "+\tdefault:",
                "+\t\treturn \"\" // unnamed type",
                "+\t}",
                "+}",
                "+",
                "+func (p *exporter) paramList(params *types.Tuple, variadic bool) {",
                "+\t// use negative length to indicate unnamed parameters",
                "+\t// (look at the first parameter only since either all",
                "+\t// names are present or all are absent)",
                "+\tn := params.Len()",
                "+\tif n > 0 && params.At(0).Name() == \"\" {",
                "+\t\tn = -n",
                "+\t}",
                "+\tp.int(n)",
                "+\tfor i := 0; i < params.Len(); i++ {",
                "+\t\tq := params.At(i)",
                "+\t\tt := q.Type()",
                "+\t\tif variadic && i == params.Len()-1 {",
                "+\t\t\tt = &dddSlice{t.(*types.Slice).Elem()}",
                "+\t\t}",
                "+\t\tp.typ(t)",
                "+\t\tif n > 0 {",
                "+\t\t\tname := q.Name()",
                "+\t\t\tp.string(name)",
                "+\t\t\tif name != \"_\" {",
                "+\t\t\t\tp.pkg(q.Pkg(), false)",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tp.string(\"\") // no compiler-specific info",
                "+\t}",
                "+}",
                "+",
                "+func (p *exporter) value(x constant.Value) {",
                "+\tif trace {",
                "+\t\tp.tracef(\"= \")",
                "+\t}",
                "+",
                "+\tswitch x.Kind() {",
                "+\tcase constant.Bool:",
                "+\t\ttag := falseTag",
                "+\t\tif constant.BoolVal(x) {",
                "+\t\t\ttag = trueTag",
                "+\t\t}",
                "+\t\tp.tag(tag)",
                "+",
                "+\tcase constant.Int:",
                "+\t\tif v, exact := constant.Int64Val(x); exact {",
                "+\t\t\t// common case: x fits into an int64 - use compact encoding",
                "+\t\t\tp.tag(int64Tag)",
                "+\t\t\tp.int64(v)",
                "+\t\t\treturn",
                "+\t\t}",
                "+\t\t// uncommon case: large x - use float encoding",
                "+\t\t// (powers of 2 will be encoded efficiently with exponent)",
                "+\t\tp.tag(floatTag)",
                "+\t\tp.float(constant.ToFloat(x))",
                "+",
                "+\tcase constant.Float:",
                "+\t\tp.tag(floatTag)",
                "+\t\tp.float(x)",
                "+",
                "+\tcase constant.Complex:",
                "+\t\tp.tag(complexTag)",
                "+\t\tp.float(constant.Real(x))",
                "+\t\tp.float(constant.Imag(x))",
                "+",
                "+\tcase constant.String:",
                "+\t\tp.tag(stringTag)",
                "+\t\tp.string(constant.StringVal(x))",
                "+",
                "+\tcase constant.Unknown:",
                "+\t\t// package contains type errors",
                "+\t\tp.tag(unknownTag)",
                "+",
                "+\tdefault:",
                "+\t\tpanic(internalErrorf(\"unexpected value %v (%T)\", x, x))",
                "+\t}",
                "+}",
                "+",
                "+func (p *exporter) float(x constant.Value) {",
                "+\tif x.Kind() != constant.Float {",
                "+\t\tpanic(internalErrorf(\"unexpected constant %v, want float\", x))",
                "+\t}",
                "+\t// extract sign (there is no -0)",
                "+\tsign := constant.Sign(x)",
                "+\tif sign == 0 {",
                "+\t\t// x == 0",
                "+\t\tp.int(0)",
                "+\t\treturn",
                "+\t}",
                "+\t// x != 0",
                "+",
                "+\tvar f big.Float",
                "+\tif v, exact := constant.Float64Val(x); exact {",
                "+\t\t// float64",
                "+\t\tf.SetFloat64(v)",
                "+\t} else if num, denom := constant.Num(x), constant.Denom(x); num.Kind() == constant.Int {",
                "+\t\t// TODO(gri): add big.Rat accessor to constant.Value.",
                "+\t\tr := valueToRat(num)",
                "+\t\tf.SetRat(r.Quo(r, valueToRat(denom)))",
                "+\t} else {",
                "+\t\t// Value too large to represent as a fraction => inaccessible.",
                "+\t\t// TODO(gri): add big.Float accessor to constant.Value.",
                "+\t\tf.SetFloat64(math.MaxFloat64) // FIXME",
                "+\t}",
                "+",
                "+\t// extract exponent such that 0.5 <= m < 1.0",
                "+\tvar m big.Float",
                "+\texp := f.MantExp(&m)",
                "+",
                "+\t// extract mantissa as *big.Int",
                "+\t// - set exponent large enough so mant satisfies mant.IsInt()",
                "+\t// - get *big.Int from mant",
                "+\tm.SetMantExp(&m, int(m.MinPrec()))",
                "+\tmant, acc := m.Int(nil)",
                "+\tif acc != big.Exact {",
                "+\t\tpanic(internalError(\"internal error\"))",
                "+\t}",
                "+",
                "+\tp.int(sign)",
                "+\tp.int(exp)",
                "+\tp.string(string(mant.Bytes()))",
                "+}",
                "+",
                "+func valueToRat(x constant.Value) *big.Rat {",
                "+\t// Convert little-endian to big-endian.",
                "+\t// I can't believe this is necessary.",
                "+\tbytes := constant.Bytes(x)",
                "+\tfor i := 0; i < len(bytes)/2; i++ {",
                "+\t\tbytes[i], bytes[len(bytes)-1-i] = bytes[len(bytes)-1-i], bytes[i]",
                "+\t}",
                "+\treturn new(big.Rat).SetInt(new(big.Int).SetBytes(bytes))",
                "+}",
                "+",
                "+func (p *exporter) bool(b bool) bool {",
                "+\tif trace {",
                "+\t\tp.tracef(\"[\")",
                "+\t\tdefer p.tracef(\"= %v] \", b)",
                "+\t}",
                "+",
                "+\tx := 0",
                "+\tif b {",
                "+\t\tx = 1",
                "+\t}",
                "+\tp.int(x)",
                "+\treturn b",
                "+}",
                "+",
                "+// ----------------------------------------------------------------------------",
                "+// Low-level encoders",
                "+",
                "+func (p *exporter) index(marker byte, index int) {",
                "+\tif index < 0 {",
                "+\t\tpanic(internalError(\"invalid index < 0\"))",
                "+\t}",
                "+\tif debugFormat {",
                "+\t\tp.marker('t')",
                "+\t}",
                "+\tif trace {",
                "+\t\tp.tracef(\"%c%d \", marker, index)",
                "+\t}",
                "+\tp.rawInt64(int64(index))",
                "+}",
                "+",
                "+func (p *exporter) tag(tag int) {",
                "+\tif tag >= 0 {",
                "+\t\tpanic(internalError(\"invalid tag >= 0\"))",
                "+\t}",
                "+\tif debugFormat {",
                "+\t\tp.marker('t')",
                "+\t}",
                "+\tif trace {",
                "+\t\tp.tracef(\"%s \", tagString[-tag])",
                "+\t}",
                "+\tp.rawInt64(int64(tag))",
                "+}",
                "+",
                "+func (p *exporter) int(x int) {",
                "+\tp.int64(int64(x))",
                "+}",
                "+",
                "+func (p *exporter) int64(x int64) {",
                "+\tif debugFormat {",
                "+\t\tp.marker('i')",
                "+\t}",
                "+\tif trace {",
                "+\t\tp.tracef(\"%d \", x)",
                "+\t}",
                "+\tp.rawInt64(x)",
                "+}",
                "+",
                "+func (p *exporter) string(s string) {",
                "+\tif debugFormat {",
                "+\t\tp.marker('s')",
                "+\t}",
                "+\tif trace {",
                "+\t\tp.tracef(\"%q \", s)",
                "+\t}",
                "+\t// if we saw the string before, write its index (>= 0)",
                "+\t// (the empty string is mapped to 0)",
                "+\tif i, ok := p.strIndex[s]; ok {",
                "+\t\tp.rawInt64(int64(i))",
                "+\t\treturn",
                "+\t}",
                "+\t// otherwise, remember string and write its negative length and bytes",
                "+\tp.strIndex[s] = len(p.strIndex)",
                "+\tp.rawInt64(-int64(len(s)))",
                "+\tfor i := 0; i < len(s); i++ {",
                "+\t\tp.rawByte(s[i])",
                "+\t}",
                "+}",
                "+",
                "+// marker emits a marker byte and position information which makes",
                "+// it easy for a reader to detect if it is \"out of sync\". Used for",
                "+// debugFormat format only.",
                "+func (p *exporter) marker(m byte) {",
                "+\tp.rawByte(m)",
                "+\t// Enable this for help tracking down the location",
                "+\t// of an incorrect marker when running in debugFormat.",
                "+\tif false && trace {",
                "+\t\tp.tracef(\"#%d \", p.written)",
                "+\t}",
                "+\tp.rawInt64(int64(p.written))",
                "+}",
                "+",
                "+// rawInt64 should only be used by low-level encoders.",
                "+func (p *exporter) rawInt64(x int64) {",
                "+\tvar tmp [binary.MaxVarintLen64]byte",
                "+\tn := binary.PutVarint(tmp[:], x)",
                "+\tfor i := 0; i < n; i++ {",
                "+\t\tp.rawByte(tmp[i])",
                "+\t}",
                "+}",
                "+",
                "+// rawStringln should only be used to emit the initial version string.",
                "+func (p *exporter) rawStringln(s string) {",
                "+\tfor i := 0; i < len(s); i++ {",
                "+\t\tp.rawByte(s[i])",
                "+\t}",
                "+\tp.rawByte('\\n')",
                "+}",
                "+",
                "+// rawByte is the bottleneck interface to write to p.out.",
                "+// rawByte escapes b as follows (any encoding does that",
                "+// hides '$'):",
                "+//",
                "+//\t'$'  => '|' 'S'",
                "+//\t'|'  => '|' '|'",
                "+//",
                "+// Necessary so other tools can find the end of the",
                "+// export data by searching for \"$$\".",
                "+// rawByte should only be used by low-level encoders.",
                "+func (p *exporter) rawByte(b byte) {",
                "+\tswitch b {",
                "+\tcase '$':",
                "+\t\t// write '$' as '|' 'S'",
                "+\t\tb = 'S'",
                "+\t\tfallthrough",
                "+\tcase '|':",
                "+\t\t// write '|' as '|' '|'",
                "+\t\tp.out.WriteByte('|')",
                "+\t\tp.written++",
                "+\t}",
                "+\tp.out.WriteByte(b)",
                "+\tp.written++",
                "+}",
                "+",
                "+// tracef is like fmt.Printf but it rewrites the format string",
                "+// to take care of indentation.",
                "+func (p *exporter) tracef(format string, args ...interface{}) {",
                "+\tif strings.ContainsAny(format, \"<>\\n\") {",
                "+\t\tvar buf bytes.Buffer",
                "+\t\tfor i := 0; i < len(format); i++ {",
                "+\t\t\t// no need to deal with runes",
                "+\t\t\tch := format[i]",
                "+\t\t\tswitch ch {",
                "+\t\t\tcase '>':",
                "+\t\t\t\tp.indent++",
                "+\t\t\t\tcontinue",
                "+\t\t\tcase '<':",
                "+\t\t\t\tp.indent--",
                "+\t\t\t\tcontinue",
                "+\t\t\t}",
                "+\t\t\tbuf.WriteByte(ch)",
                "+\t\t\tif ch == '\\n' {",
                "+\t\t\t\tfor j := p.indent; j > 0; j-- {",
                "+\t\t\t\t\tbuf.WriteString(\".  \")",
                "+\t\t\t\t}",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\tformat = buf.String()",
                "+\t}",
                "+\tfmt.Printf(format, args...)",
                "+}",
                "+",
                "+// Debugging support.",
                "+// (tagString is only used when tracing is enabled)",
                "+var tagString = [...]string{",
                "+\t// Packages",
                "+\t-packageTag: \"package\",",
                "+",
                "+\t// Types",
                "+\t-namedTag:     \"named type\",",
                "+\t-arrayTag:     \"array\",",
                "+\t-sliceTag:     \"slice\",",
                "+\t-dddTag:       \"ddd\",",
                "+\t-structTag:    \"struct\",",
                "+\t-pointerTag:   \"pointer\",",
                "+\t-signatureTag: \"signature\",",
                "+\t-interfaceTag: \"interface\",",
                "+\t-mapTag:       \"map\",",
                "+\t-chanTag:      \"chan\",",
                "+",
                "+\t// Values",
                "+\t-falseTag:    \"false\",",
                "+\t-trueTag:     \"true\",",
                "+\t-int64Tag:    \"int64\",",
                "+\t-floatTag:    \"float\",",
                "+\t-fractionTag: \"fraction\",",
                "+\t-complexTag:  \"complex\",",
                "+\t-stringTag:   \"string\",",
                "+\t-unknownTag:  \"unknown\",",
                "+",
                "+\t// Type aliases",
                "+\t-aliasTag: \"alias\",",
                "+}",
                "diff --git a/vendor/golang.org/x/tools/go/internal/gcimporter/bimport.go b/vendor/golang.org/x/tools/go/internal/gcimporter/bimport.go",
                "new file mode 100644",
                "index 0000000..3e845ea",
                "--- /dev/null",
                "+++ b/vendor/golang.org/x/tools/go/internal/gcimporter/bimport.go",
                "@@ -0,0 +1,1027 @@",
                "+// Copyright 2015 The Go Authors. All rights reserved.",
                "+// Use of this source code is governed by a BSD-style",
                "+// license that can be found in the LICENSE file.",
                "+",
                "+// This file is a copy of $GOROOT/src/go/internal/gcimporter/bimport.go.",
                "+",
                "+package gcimporter",
                "+",
                "+import (",
                "+\t\"encoding/binary\"",
                "+\t\"fmt\"",
                "+\t\"go/constant\"",
                "+\t\"go/token\"",
                "+\t\"go/types\"",
                "+\t\"sort\"",
                "+\t\"strconv\"",
                "+\t\"strings\"",
                "+\t\"sync\"",
                "+\t\"unicode\"",
                "+\t\"unicode/utf8\"",
                "+)",
                "+",
                "+type importer struct {",
                "+\timports    map[string]*types.Package",
                "+\tdata       []byte",
                "+\timportpath string",
                "+\tbuf        []byte // for reading strings",
                "+\tversion    int    // export format version",
                "+",
                "+\t// object lists",
                "+\tstrList       []string           // in order of appearance",
                "+\tpathList      []string           // in order of appearance",
                "+\tpkgList       []*types.Package   // in order of appearance",
                "+\ttypList       []types.Type       // in order of appearance",
                "+\tinterfaceList []*types.Interface // for delayed completion only",
                "+\ttrackAllTypes bool",
                "+",
                "+\t// position encoding",
                "+\tposInfoFormat bool",
                "+\tprevFile      string",
                "+\tprevLine      int",
                "+\tfake          fakeFileSet",
                "+",
                "+\t// debugging support",
                "+\tdebugFormat bool",
                "+\tread        int // bytes read",
                "+}",
                "+",
                "+// BImportData imports a package from the serialized package data",
                "+// and returns the number of bytes consumed and a reference to the package.",
                "+// If the export data version is not recognized or the format is otherwise",
                "+// compromised, an error is returned.",
                "+func BImportData(fset *token.FileSet, imports map[string]*types.Package, data []byte, path string) (_ int, pkg *types.Package, err error) {",
                "+\t// catch panics and return them as errors",
                "+\tdefer func() {",
                "+\t\tif e := recover(); e != nil {",
                "+\t\t\t// The package (filename) causing the problem is added to this",
                "+\t\t\t// error by a wrapper in the caller (Import in gcimporter.go).",
                "+\t\t\t// Return a (possibly nil or incomplete) package unchanged (see #16088).",
                "+\t\t\terr = fmt.Errorf(\"cannot import, possibly version skew (%v) - reinstall package\", e)",
                "+\t\t}",
                "+\t}()",
                "+",
                "+\tif len(data) > 0 && data[0] == 'i' {",
                "+\t\treturn iImportData(fset, imports, data[1:], path)",
                "+\t}",
                "+",
                "+\tp := importer{",
                "+\t\timports:    imports,",
                "+\t\tdata:       data,",
                "+\t\timportpath: path,",
                "+\t\tversion:    -1,           // unknown version",
                "+\t\tstrList:    []string{\"\"}, // empty string is mapped to 0",
                "+\t\tpathList:   []string{\"\"}, // empty string is mapped to 0",
                "+\t\tfake: fakeFileSet{",
                "+\t\t\tfset:  fset,",
                "+\t\t\tfiles: make(map[string]*token.File),",
                "+\t\t},",
                "+\t}",
                "+",
                "+\t// read version info",
                "+\tvar versionstr string",
                "+\tif b := p.rawByte(); b == 'c' || b == 'd' {",
                "+\t\t// Go1.7 encoding; first byte encodes low-level",
                "+\t\t// encoding format (compact vs debug).",
                "+\t\t// For backward-compatibility only (avoid problems with",
                "+\t\t// old installed packages). Newly compiled packages use",
                "+\t\t// the extensible format string.",
                "+\t\t// TODO(gri) Remove this support eventually; after Go1.8.",
                "+\t\tif b == 'd' {",
                "+\t\t\tp.debugFormat = true",
                "+\t\t}",
                "+\t\tp.trackAllTypes = p.rawByte() == 'a'",
                "+\t\tp.posInfoFormat = p.int() != 0",
                "+\t\tversionstr = p.string()",
                "+\t\tif versionstr == \"v1\" {",
                "+\t\t\tp.version = 0",
                "+\t\t}",
                "+\t} else {",
                "+\t\t// Go1.8 extensible encoding",
                "+\t\t// read version string and extract version number (ignore anything after the version number)",
                "+\t\tversionstr = p.rawStringln(b)",
                "+\t\tif s := strings.SplitN(versionstr, \" \", 3); len(s) >= 2 && s[0] == \"version\" {",
                "+\t\t\tif v, err := strconv.Atoi(s[1]); err == nil && v > 0 {",
                "+\t\t\t\tp.version = v",
                "+\t\t\t}",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t// read version specific flags - extend as necessary",
                "+\tswitch p.version {",
                "+\t// case 7:",
                "+\t// \t...",
                "+\t//\tfallthrough",
                "+\tcase 6, 5, 4, 3, 2, 1:",
                "+\t\tp.debugFormat = p.rawStringln(p.rawByte()) == \"debug\"",
                "+\t\tp.trackAllTypes = p.int() != 0",
                "+\t\tp.posInfoFormat = p.int() != 0",
                "+\tcase 0:",
                "+\t\t// Go1.7 encoding format - nothing to do here",
                "+\tdefault:",
                "+\t\terrorf(\"unknown export format version %d (%q)\", p.version, versionstr)",
                "+\t}",
                "+",
                "+\t// --- generic export data ---",
                "+",
                "+\t// populate typList with predeclared \"known\" types",
                "+\tp.typList = append(p.typList, predeclared...)",
                "+",
                "+\t// read package data",
                "+\tpkg = p.pkg()",
                "+",
                "+\t// read objects of phase 1 only (see cmd/compile/internal/gc/bexport.go)",
                "+\tobjcount := 0",
                "+\tfor {",
                "+\t\ttag := p.tagOrIndex()",
                "+\t\tif tag == endTag {",
                "+\t\t\tbreak",
                "+\t\t}",
                "+\t\tp.obj(tag)",
                "+\t\tobjcount++",
                "+\t}",
                "+",
                "+\t// self-verification",
                "+\tif count := p.int(); count != objcount {",
                "+\t\terrorf(\"got %d objects; want %d\", objcount, count)",
                "+\t}",
                "+",
                "+\t// ignore compiler-specific import data",
                "+",
                "+\t// complete interfaces",
                "+\t// TODO(gri) re-investigate if we still need to do this in a delayed fashion",
                "+\tfor _, typ := range p.interfaceList {",
                "+\t\ttyp.Complete()",
                "+\t}",
                "+",
                "+\t// record all referenced packages as imports",
                "+\tlist := append(([]*types.Package)(nil), p.pkgList[1:]...)",
                "+\tsort.Sort(byPath(list))",
                "+\tpkg.SetImports(list)",
                "+",
                "+\t// package was imported completely and without errors",
                "+\tpkg.MarkComplete()",
                "+",
                "+\treturn p.read, pkg, nil",
                "+}",
                "+",
                "+func errorf(format string, args ...interface{}) {",
                "+\tpanic(fmt.Sprintf(format, args...))",
                "+}",
                "+",
                "+func (p *importer) pkg() *types.Package {",
                "+\t// if the package was seen before, i is its index (>= 0)",
                "+\ti := p.tagOrIndex()",
                "+\tif i >= 0 {",
                "+\t\treturn p.pkgList[i]",
                "+\t}",
                "+",
                "+\t// otherwise, i is the package tag (< 0)",
                "+\tif i != packageTag {",
                "+\t\terrorf(\"unexpected package tag %d version %d\", i, p.version)",
                "+\t}",
                "+",
                "+\t// read package data",
                "+\tname := p.string()",
                "+\tvar path string",
                "+\tif p.version >= 5 {",
                "+\t\tpath = p.path()",
                "+\t} else {",
                "+\t\tpath = p.string()",
                "+\t}",
                "+\tif p.version >= 6 {",
                "+\t\tp.int() // package height; unused by go/types",
                "+\t}",
                "+",
                "+\t// we should never see an empty package name",
                "+\tif name == \"\" {",
                "+\t\terrorf(\"empty package name in import\")",
                "+\t}",
                "+",
                "+\t// an empty path denotes the package we are currently importing;",
                "+\t// it must be the first package we see",
                "+\tif (path == \"\") != (len(p.pkgList) == 0) {",
                "+\t\terrorf(\"package path %q for pkg index %d\", path, len(p.pkgList))",
                "+\t}",
                "+",
                "+\t// if the package was imported before, use that one; otherwise create a new one",
                "+\tif path == \"\" {",
                "+\t\tpath = p.importpath",
                "+\t}",
                "+\tpkg := p.imports[path]",
                "+\tif pkg == nil {",
                "+\t\tpkg = types.NewPackage(path, name)",
                "+\t\tp.imports[path] = pkg",
                "+\t} else if pkg.Name() != name {",
                "+\t\terrorf(\"conflicting names %s and %s for package %q\", pkg.Name(), name, path)",
                "+\t}",
                "+\tp.pkgList = append(p.pkgList, pkg)",
                "+",
                "+\treturn pkg",
                "+}",
                "+",
                "+// objTag returns the tag value for each object kind.",
                "+func objTag(obj types.Object) int {",
                "+\tswitch obj.(type) {",
                "+\tcase *types.Const:",
                "+\t\treturn constTag",
                "+\tcase *types.TypeName:",
                "+\t\treturn typeTag",
                "+\tcase *types.Var:",
                "+\t\treturn varTag",
                "+\tcase *types.Func:",
                "+\t\treturn funcTag",
                "+\tdefault:",
                "+\t\terrorf(\"unexpected object: %v (%T)\", obj, obj) // panics",
                "+\t\tpanic(\"unreachable\")",
                "+\t}",
                "+}",
                "+",
                "+func sameObj(a, b types.Object) bool {",
                "+\t// Because unnamed types are not canonicalized, we cannot simply compare types for",
                "+\t// (pointer) identity.",
                "+\t// Ideally we'd check equality of constant values as well, but this is good enough.",
                "+\treturn objTag(a) == objTag(b) && types.Identical(a.Type(), b.Type())",
                "+}",
                "+",
                "+func (p *importer) declare(obj types.Object) {",
                "+\tpkg := obj.Pkg()",
                "+\tif alt := pkg.Scope().Insert(obj); alt != nil {",
                "+\t\t// This can only trigger if we import a (non-type) object a second time.",
                "+\t\t// Excluding type aliases, this cannot happen because 1) we only import a package",
                "+\t\t// once; and b) we ignore compiler-specific export data which may contain",
                "+\t\t// functions whose inlined function bodies refer to other functions that",
                "+\t\t// were already imported.",
                "+\t\t// However, type aliases require reexporting the original type, so we need",
                "+\t\t// to allow it (see also the comment in cmd/compile/internal/gc/bimport.go,",
                "+\t\t// method importer.obj, switch case importing functions).",
                "+\t\t// TODO(gri) review/update this comment once the gc compiler handles type aliases.",
                "+\t\tif !sameObj(obj, alt) {",
                "+\t\t\terrorf(\"inconsistent import:\\n\\t%v\\npreviously imported as:\\n\\t%v\\n\", obj, alt)",
                "+\t\t}",
                "+\t}",
                "+}",
                "+",
                "+func (p *importer) obj(tag int) {",
                "+\tswitch tag {",
                "+\tcase constTag:",
                "+\t\tpos := p.pos()",
                "+\t\tpkg, name := p.qualifiedName()",
                "+\t\ttyp := p.typ(nil, nil)",
                "+\t\tval := p.value()",
                "+\t\tp.declare(types.NewConst(pos, pkg, name, typ, val))",
                "+",
                "+\tcase aliasTag:",
                "+\t\t// TODO(gri) verify type alias hookup is correct",
                "+\t\tpos := p.pos()",
                "+\t\tpkg, name := p.qualifiedName()",
                "+\t\ttyp := p.typ(nil, nil)",
                "+\t\tp.declare(types.NewTypeName(pos, pkg, name, typ))",
                "+",
                "+\tcase typeTag:",
                "+\t\tp.typ(nil, nil)",
                "+",
                "+\tcase varTag:",
                "+\t\tpos := p.pos()",
                "+\t\tpkg, name := p.qualifiedName()",
                "+\t\ttyp := p.typ(nil, nil)",
                "+\t\tp.declare(types.NewVar(pos, pkg, name, typ))",
                "+",
                "+\tcase funcTag:",
                "+\t\tpos := p.pos()",
                "+\t\tpkg, name := p.qualifiedName()",
                "+\t\tparams, isddd := p.paramList()",
                "+\t\tresult, _ := p.paramList()",
                "+\t\tsig := types.NewSignature(nil, params, result, isddd)",
                "+\t\tp.declare(types.NewFunc(pos, pkg, name, sig))",
                "+",
                "+\tdefault:",
                "+\t\terrorf(\"unexpected object tag %d\", tag)",
                "+\t}",
                "+}",
                "+",
                "+const deltaNewFile = -64 // see cmd/compile/internal/gc/bexport.go",
                "+",
                "+func (p *importer) pos() token.Pos {",
                "+\tif !p.posInfoFormat {",
                "+\t\treturn token.NoPos",
                "+\t}",
                "+",
                "+\tfile := p.prevFile",
                "+\tline := p.prevLine",
                "+\tdelta := p.int()",
                "+\tline += delta",
                "+\tif p.version >= 5 {",
                "+\t\tif delta == deltaNewFile {",
                "+\t\t\tif n := p.int(); n >= 0 {",
                "+\t\t\t\t// file changed",
                "+\t\t\t\tfile = p.path()",
                "+\t\t\t\tline = n",
                "+\t\t\t}",
                "+\t\t}",
                "+\t} else {",
                "+\t\tif delta == 0 {",
                "+\t\t\tif n := p.int(); n >= 0 {",
                "+\t\t\t\t// file changed",
                "+\t\t\t\tfile = p.prevFile[:n] + p.string()",
                "+\t\t\t\tline = p.int()",
                "+\t\t\t}",
                "+\t\t}",
                "+\t}",
                "+\tp.prevFile = file",
                "+\tp.prevLine = line",
                "+",
                "+\treturn p.fake.pos(file, line)",
                "+}",
                "+",
                "+// Synthesize a token.Pos",
                "+type fakeFileSet struct {",
                "+\tfset  *token.FileSet",
                "+\tfiles map[string]*token.File",
                "+}",
                "+",
                "+func (s *fakeFileSet) pos(file string, line int) token.Pos {",
                "+\t// Since we don't know the set of needed file positions, we",
                "+\t// reserve maxlines positions per file.",
                "+\tconst maxlines = 64 * 1024",
                "+\tf := s.files[file]",
                "+\tif f == nil {",
                "+\t\tf = s.fset.AddFile(file, -1, maxlines)",
                "+\t\ts.files[file] = f",
                "+\t\t// Allocate the fake linebreak indices on first use.",
                "+\t\t// TODO(adonovan): opt: save ~512KB using a more complex scheme?",
                "+\t\tfakeLinesOnce.Do(func() {",
                "+\t\t\tfakeLines = make([]int, maxlines)",
                "+\t\t\tfor i := range fakeLines {",
                "+\t\t\t\tfakeLines[i] = i",
                "+\t\t\t}",
                "+\t\t})",
                "+\t\tf.SetLines(fakeLines)",
                "+\t}",
                "+",
                "+\tif line > maxlines {",
                "+\t\tline = 1",
                "+\t}",
                "+",
                "+\t// Treat the file as if it contained only newlines",
                "+\t// and column=1: use the line number as the offset.",
                "+\treturn f.Pos(line - 1)",
                "+}",
                "+",
                "+var (",
                "+\tfakeLines     []int",
                "+\tfakeLinesOnce sync.Once",
                "+)",
                "+",
                "+func (p *importer) qualifiedName() (pkg *types.Package, name string) {",
                "+\tname = p.string()",
                "+\tpkg = p.pkg()",
                "+\treturn",
                "+}",
                "+",
                "+func (p *importer) record(t types.Type) {",
                "+\tp.typList = append(p.typList, t)",
                "+}",
                "+",
                "+// A dddSlice is a types.Type representing ...T parameters.",
                "+// It only appears for parameter types and does not escape",
                "+// the importer.",
                "+type dddSlice struct {",
                "+\telem types.Type",
                "+}",
                "+",
                "+func (t *dddSlice) Underlying() types.Type { return t }",
                "+func (t *dddSlice) String() string         { return \"...\" + t.elem.String() }",
                "+",
                "+// parent is the package which declared the type; parent == nil means",
                "+// the package currently imported. The parent package is needed for",
                "+// exported struct fields and interface methods which don't contain",
                "+// explicit package information in the export data.",
                "+//",
                "+// A non-nil tname is used as the \"owner\" of the result type; i.e.,",
                "+// the result type is the underlying type of tname. tname is used",
                "+// to give interface methods a named receiver type where possible.",
                "+func (p *importer) typ(parent *types.Package, tname *types.Named) types.Type {",
                "+\t// if the type was seen before, i is its index (>= 0)",
                "+\ti := p.tagOrIndex()",
                "+\tif i >= 0 {",
                "+\t\treturn p.typList[i]",
                "+\t}",
                "+",
                "+\t// otherwise, i is the type tag (< 0)",
                "+\tswitch i {",
                "+\tcase namedTag:",
                "+\t\t// read type object",
                "+\t\tpos := p.pos()",
                "+\t\tparent, name := p.qualifiedName()",
                "+\t\tscope := parent.Scope()",
                "+\t\tobj := scope.Lookup(name)",
                "+",
                "+\t\t// if the object doesn't exist yet, create and insert it",
                "+\t\tif obj == nil {",
                "+\t\t\tobj = types.NewTypeName(pos, parent, name, nil)",
                "+\t\t\tscope.Insert(obj)",
                "+\t\t}",
                "+",
                "+\t\tif _, ok := obj.(*types.TypeName); !ok {",
                "+\t\t\terrorf(\"pkg = %s, name = %s => %s\", parent, name, obj)",
                "+\t\t}",
                "+",
                "+\t\t// associate new named type with obj if it doesn't exist yet",
                "+\t\tt0 := types.NewNamed(obj.(*types.TypeName), nil, nil)",
                "+",
                "+\t\t// but record the existing type, if any",
                "+\t\ttname := obj.Type().(*types.Named) // tname is either t0 or the existing type",
                "+\t\tp.record(tname)",
                "+",
                "+\t\t// read underlying type",
                "+\t\tt0.SetUnderlying(p.typ(parent, t0))",
                "+",
                "+\t\t// interfaces don't have associated methods",
                "+\t\tif types.IsInterface(t0) {",
                "+\t\t\treturn tname",
                "+\t\t}",
                "+",
                "+\t\t// read associated methods",
                "+\t\tfor i := p.int(); i > 0; i-- {",
                "+\t\t\t// TODO(gri) replace this with something closer to fieldName",
                "+\t\t\tpos := p.pos()",
                "+\t\t\tname := p.string()",
                "+\t\t\tif !exported(name) {",
                "+\t\t\t\tp.pkg()",
                "+\t\t\t}",
                "+",
                "+\t\t\trecv, _ := p.paramList() // TODO(gri) do we need a full param list for the receiver?",
                "+\t\t\tparams, isddd := p.paramList()",
                "+\t\t\tresult, _ := p.paramList()",
                "+\t\t\tp.int() // go:nointerface pragma - discarded",
                "+",
                "+\t\t\tsig := types.NewSignature(recv.At(0), params, result, isddd)",
                "+\t\t\tt0.AddMethod(types.NewFunc(pos, parent, name, sig))",
                "+\t\t}",
                "+",
                "+\t\treturn tname",
                "+",
                "+\tcase arrayTag:",
                "+\t\tt := new(types.Array)",
                "+\t\tif p.trackAllTypes {",
                "+\t\t\tp.record(t)",
                "+\t\t}",
                "+",
                "+\t\tn := p.int64()",
                "+\t\t*t = *types.NewArray(p.typ(parent, nil), n)",
                "+\t\treturn t",
                "+",
                "+\tcase sliceTag:",
                "+\t\tt := new(types.Slice)",
                "+\t\tif p.trackAllTypes {",
                "+\t\t\tp.record(t)",
                "+\t\t}",
                "+",
                "+\t\t*t = *types.NewSlice(p.typ(parent, nil))",
                "+\t\treturn t",
                "+",
                "+\tcase dddTag:",
                "+\t\tt := new(dddSlice)",
                "+\t\tif p.trackAllTypes {",
                "+\t\t\tp.record(t)",
                "+\t\t}",
                "+",
                "+\t\tt.elem = p.typ(parent, nil)",
                "+\t\treturn t",
                "+",
                "+\tcase structTag:",
                "+\t\tt := new(types.Struct)",
                "+\t\tif p.trackAllTypes {",
                "+\t\t\tp.record(t)",
                "+\t\t}",
                "+",
                "+\t\t*t = *types.NewStruct(p.fieldList(parent))",
                "+\t\treturn t",
                "+",
                "+\tcase pointerTag:",
                "+\t\tt := new(types.Pointer)",
                "+\t\tif p.trackAllTypes {",
                "+\t\t\tp.record(t)",
                "+\t\t}",
                "+",
                "+\t\t*t = *types.NewPointer(p.typ(parent, nil))",
                "+\t\treturn t",
                "+",
                "+\tcase signatureTag:",
                "+\t\tt := new(types.Signature)",
                "+\t\tif p.trackAllTypes {",
                "+\t\t\tp.record(t)",
                "+\t\t}",
                "+",
                "+\t\tparams, isddd := p.paramList()",
                "+\t\tresult, _ := p.paramList()",
                "+\t\t*t = *types.NewSignature(nil, params, result, isddd)",
                "+\t\treturn t",
                "+",
                "+\tcase interfaceTag:",
                "+\t\t// Create a dummy entry in the type list. This is safe because we",
                "+\t\t// cannot expect the interface type to appear in a cycle, as any",
                "+\t\t// such cycle must contain a named type which would have been",
                "+\t\t// first defined earlier.",
                "+\t\t// TODO(gri) Is this still true now that we have type aliases?",
                "+\t\t// See issue #23225.",
                "+\t\tn := len(p.typList)",
                "+\t\tif p.trackAllTypes {",
                "+\t\t\tp.record(nil)",
                "+\t\t}",
                "+",
                "+\t\tvar embeddeds []*types.Named",
                "+\t\tfor n := p.int(); n > 0; n-- {",
                "+\t\t\tp.pos()",
                "+\t\t\tembeddeds = append(embeddeds, p.typ(parent, nil).(*types.Named))",
                "+\t\t}",
                "+",
                "+\t\tt := types.NewInterface(p.methodList(parent, tname), embeddeds)",
                "+\t\tp.interfaceList = append(p.interfaceList, t)",
                "+\t\tif p.trackAllTypes {",
                "+\t\t\tp.typList[n] = t",
                "+\t\t}",
                "+\t\treturn t",
                "+",
                "+\tcase mapTag:",
                "+\t\tt := new(types.Map)",
                "+\t\tif p.trackAllTypes {",
                "+\t\t\tp.record(t)",
                "+\t\t}",
                "+",
                "+\t\tkey := p.typ(parent, nil)",
                "+\t\tval := p.typ(parent, nil)",
                "+\t\t*t = *types.NewMap(key, val)",
                "+\t\treturn t",
                "+",
                "+\tcase chanTag:",
                "+\t\tt := new(types.Chan)",
                "+\t\tif p.trackAllTypes {",
                "+\t\t\tp.record(t)",
                "+\t\t}",
                "+",
                "+\t\tdir := chanDir(p.int())",
                "+\t\tval := p.typ(parent, nil)",
                "+\t\t*t = *types.NewChan(dir, val)",
                "+\t\treturn t",
                "+",
                "+\tdefault:",
                "+\t\terrorf(\"unexpected type tag %d\", i) // panics",
                "+\t\tpanic(\"unreachable\")",
                "+\t}",
                "+}",
                "+",
                "+func chanDir(d int) types.ChanDir {",
                "+\t// tag values must match the constants in cmd/compile/internal/gc/go.go",
                "+\tswitch d {",
                "+\tcase 1 /* Crecv */ :",
                "+\t\treturn types.RecvOnly",
                "+\tcase 2 /* Csend */ :",
                "+\t\treturn types.SendOnly",
                "+\tcase 3 /* Cboth */ :",
                "+\t\treturn types.SendRecv",
                "+\tdefault:",
                "+\t\terrorf(\"unexpected channel dir %d\", d)",
                "+\t\treturn 0",
                "+\t}",
                "+}",
                "+",
                "+func (p *importer) fieldList(parent *types.Package) (fields []*types.Var, tags []string) {",
                "+\tif n := p.int(); n > 0 {",
                "+\t\tfields = make([]*types.Var, n)",
                "+\t\ttags = make([]string, n)",
                "+\t\tfor i := range fields {",
                "+\t\t\tfields[i], tags[i] = p.field(parent)",
                "+\t\t}",
                "+\t}",
                "+\treturn",
                "+}",
                "+",
                "+func (p *importer) field(parent *types.Package) (*types.Var, string) {",
                "+\tpos := p.pos()",
                "+\tpkg, name, alias := p.fieldName(parent)",
                "+\ttyp := p.typ(parent, nil)",
                "+\ttag := p.string()",
                "+",
                "+\tanonymous := false",
                "+\tif name == \"\" {",
                "+\t\t// anonymous field - typ must be T or *T and T must be a type name",
                "+\t\tswitch typ := deref(typ).(type) {",
                "+\t\tcase *types.Basic: // basic types are named types",
                "+\t\t\tpkg = nil // // objects defined in Universe scope have no package",
                "+\t\t\tname = typ.Name()",
                "+\t\tcase *types.Named:",
                "+\t\t\tname = typ.Obj().Name()",
                "+\t\tdefault:",
                "+\t\t\terrorf(\"named base type expected\")",
                "+\t\t}",
                "+\t\tanonymous = true",
                "+\t} else if alias {",
                "+\t\t// anonymous field: we have an explicit name because it's an alias",
                "+\t\tanonymous = true",
                "+\t}",
                "+",
                "+\treturn types.NewField(pos, pkg, name, typ, anonymous), tag",
                "+}",
                "+",
                "+func (p *importer) methodList(parent *types.Package, baseType *types.Named) (methods []*types.Func) {",
                "+\tif n := p.int(); n > 0 {",
                "+\t\tmethods = make([]*types.Func, n)",
                "+\t\tfor i := range methods {",
                "+\t\t\tmethods[i] = p.method(parent, baseType)",
                "+\t\t}",
                "+\t}",
                "+\treturn",
                "+}",
                "+",
                "+func (p *importer) method(parent *types.Package, baseType *types.Named) *types.Func {",
                "+\tpos := p.pos()",
                "+\tpkg, name, _ := p.fieldName(parent)",
                "+\t// If we don't have a baseType, use a nil receiver.",
                "+\t// A receiver using the actual interface type (which",
                "+\t// we don't know yet) will be filled in when we call",
                "+\t// types.Interface.Complete.",
                "+\tvar recv *types.Var",
                "+\tif baseType != nil {",
                "+\t\trecv = types.NewVar(token.NoPos, parent, \"\", baseType)",
                "+\t}",
                "+\tparams, isddd := p.paramList()",
                "+\tresult, _ := p.paramList()",
                "+\tsig := types.NewSignature(recv, params, result, isddd)",
                "+\treturn types.NewFunc(pos, pkg, name, sig)",
                "+}",
                "+",
                "+func (p *importer) fieldName(parent *types.Package) (pkg *types.Package, name string, alias bool) {",
                "+\tname = p.string()",
                "+\tpkg = parent",
                "+\tif pkg == nil {",
                "+\t\t// use the imported package instead",
                "+\t\tpkg = p.pkgList[0]",
                "+\t}",
                "+\tif p.version == 0 && name == \"_\" {",
                "+\t\t// version 0 didn't export a package for _ fields",
                "+\t\treturn",
                "+\t}",
                "+\tswitch name {",
                "+\tcase \"\":",
                "+\t\t// 1) field name matches base type name and is exported: nothing to do",
                "+\tcase \"?\":",
                "+\t\t// 2) field name matches base type name and is not exported: need package",
                "+\t\tname = \"\"",
                "+\t\tpkg = p.pkg()",
                "+\tcase \"@\":",
                "+\t\t// 3) field name doesn't match type name (alias)",
                "+\t\tname = p.string()",
                "+\t\talias = true",
                "+\t\tfallthrough",
                "+\tdefault:",
                "+\t\tif !exported(name) {",
                "+\t\t\tpkg = p.pkg()",
                "+\t\t}",
                "+\t}",
                "+\treturn",
                "+}",
                "+",
                "+func (p *importer) paramList() (*types.Tuple, bool) {",
                "+\tn := p.int()",
                "+\tif n == 0 {",
                "+\t\treturn nil, false",
                "+\t}",
                "+\t// negative length indicates unnamed parameters",
                "+\tnamed := true",
                "+\tif n < 0 {",
                "+\t\tn = -n",
                "+\t\tnamed = false",
                "+\t}",
                "+\t// n > 0",
                "+\tparams := make([]*types.Var, n)",
                "+\tisddd := false",
                "+\tfor i := range params {",
                "+\t\tparams[i], isddd = p.param(named)",
                "+\t}",
                "+\treturn types.NewTuple(params...), isddd",
                "+}",
                "+",
                "+func (p *importer) param(named bool) (*types.Var, bool) {",
                "+\tt := p.typ(nil, nil)",
                "+\ttd, isddd := t.(*dddSlice)",
                "+\tif isddd {",
                "+\t\tt = types.NewSlice(td.elem)",
                "+\t}",
                "+",
                "+\tvar pkg *types.Package",
                "+\tvar name string",
                "+\tif named {",
                "+\t\tname = p.string()",
                "+\t\tif name == \"\" {",
                "+\t\t\terrorf(\"expected named parameter\")",
                "+\t\t}",
                "+\t\tif name != \"_\" {",
                "+\t\t\tpkg = p.pkg()",
                "+\t\t}",
                "+\t\tif i := strings.Index(name, \"\u00c2\u00b7\"); i > 0 {",
                "+\t\t\tname = name[:i] // cut off gc-specific parameter numbering",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t// read and discard compiler-specific info",
                "+\tp.string()",
                "+",
                "+\treturn types.NewVar(token.NoPos, pkg, name, t), isddd",
                "+}",
                "+",
                "+func exported(name string) bool {",
                "+\tch, _ := utf8.DecodeRuneInString(name)",
                "+\treturn unicode.IsUpper(ch)",
                "+}",
                "+",
                "+func (p *importer) value() constant.Value {",
                "+\tswitch tag := p.tagOrIndex(); tag {",
                "+\tcase falseTag:",
                "+\t\treturn constant.MakeBool(false)",
                "+\tcase trueTag:",
                "+\t\treturn constant.MakeBool(true)",
                "+\tcase int64Tag:",
                "+\t\treturn constant.MakeInt64(p.int64())",
                "+\tcase floatTag:",
                "+\t\treturn p.float()",
                "+\tcase complexTag:",
                "+\t\tre := p.float()",
                "+\t\tim := p.float()",
                "+\t\treturn constant.BinaryOp(re, token.ADD, constant.MakeImag(im))",
                "+\tcase stringTag:",
                "+\t\treturn constant.MakeString(p.string())",
                "+\tcase unknownTag:",
                "+\t\treturn constant.MakeUnknown()",
                "+\tdefault:",
                "+\t\terrorf(\"unexpected value tag %d\", tag) // panics",
                "+\t\tpanic(\"unreachable\")",
                "+\t}",
                "+}",
                "+",
                "+func (p *importer) float() constant.Value {",
                "+\tsign := p.int()",
                "+\tif sign == 0 {",
                "+\t\treturn constant.MakeInt64(0)",
                "+\t}",
                "+",
                "+\texp := p.int()",
                "+\tmant := []byte(p.string()) // big endian",
                "+",
                "+\t// remove leading 0's if any",
                "+\tfor len(mant) > 0 && mant[0] == 0 {",
                "+\t\tmant = mant[1:]",
                "+\t}",
                "+",
                "+\t// convert to little endian",
                "+\t// TODO(gri) go/constant should have a more direct conversion function",
                "+\t//           (e.g., once it supports a big.Float based implementation)",
                "+\tfor i, j := 0, len(mant)-1; i < j; i, j = i+1, j-1 {",
                "+\t\tmant[i], mant[j] = mant[j], mant[i]",
                "+\t}",
                "+",
                "+\t// adjust exponent (constant.MakeFromBytes creates an integer value,",
                "+\t// but mant represents the mantissa bits such that 0.5 <= mant < 1.0)",
                "+\texp -= len(mant) << 3",
                "+\tif len(mant) > 0 {",
                "+\t\tfor msd := mant[len(mant)-1]; msd&0x80 == 0; msd <<= 1 {",
                "+\t\t\texp++",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tx := constant.MakeFromBytes(mant)",
                "+\tswitch {",
                "+\tcase exp < 0:",
                "+\t\td := constant.Shift(constant.MakeInt64(1), token.SHL, uint(-exp))",
                "+\t\tx = constant.BinaryOp(x, token.QUO, d)",
                "+\tcase exp > 0:",
                "+\t\tx = constant.Shift(x, token.SHL, uint(exp))",
                "+\t}",
                "+",
                "+\tif sign < 0 {",
                "+\t\tx = constant.UnaryOp(token.SUB, x, 0)",
                "+\t}",
                "+\treturn x",
                "+}",
                "+",
                "+// ----------------------------------------------------------------------------",
                "+// Low-level decoders",
                "+",
                "+func (p *importer) tagOrIndex() int {",
                "+\tif p.debugFormat {",
                "+\t\tp.marker('t')",
                "+\t}",
                "+",
                "+\treturn int(p.rawInt64())",
                "+}",
                "+",
                "+func (p *importer) int() int {",
                "+\tx := p.int64()",
                "+\tif int64(int(x)) != x {",
                "+\t\terrorf(\"exported integer too large\")",
                "+\t}",
                "+\treturn int(x)",
                "+}",
                "+",
                "+func (p *importer) int64() int64 {",
                "+\tif p.debugFormat {",
                "+\t\tp.marker('i')",
                "+\t}",
                "+",
                "+\treturn p.rawInt64()",
                "+}",
                "+",
                "+func (p *importer) path() string {",
                "+\tif p.debugFormat {",
                "+\t\tp.marker('p')",
                "+\t}",
                "+\t// if the path was seen before, i is its index (>= 0)",
                "+\t// (the empty string is at index 0)",
                "+\ti := p.rawInt64()",
                "+\tif i >= 0 {",
                "+\t\treturn p.pathList[i]",
                "+\t}",
                "+\t// otherwise, i is the negative path length (< 0)",
                "+\ta := make([]string, -i)",
                "+\tfor n := range a {",
                "+\t\ta[n] = p.string()",
                "+\t}",
                "+\ts := strings.Join(a, \"/\")",
                "+\tp.pathList = append(p.pathList, s)",
                "+\treturn s",
                "+}",
                "+",
                "+func (p *importer) string() string {",
                "+\tif p.debugFormat {",
                "+\t\tp.marker('s')",
                "+\t}",
                "+\t// if the string was seen before, i is its index (>= 0)",
                "+\t// (the empty string is at index 0)",
                "+\ti := p.rawInt64()",
                "+\tif i >= 0 {",
                "+\t\treturn p.strList[i]",
                "+\t}",
                "+\t// otherwise, i is the negative string length (< 0)",
                "+\tif n := int(-i); n <= cap(p.buf) {",
                "+\t\tp.buf = p.buf[:n]",
                "+\t} else {",
                "+\t\tp.buf = make([]byte, n)",
                "+\t}",
                "+\tfor i := range p.buf {",
                "+\t\tp.buf[i] = p.rawByte()",
                "+\t}",
                "+\ts := string(p.buf)",
                "+\tp.strList = append(p.strList, s)",
                "+\treturn s",
                "+}",
                "+",
                "+func (p *importer) marker(want byte) {",
                "+\tif got := p.rawByte(); got != want {",
                "+\t\terrorf(\"incorrect marker: got %c; want %c (pos = %d)\", got, want, p.read)",
                "+\t}",
                "+",
                "+\tpos := p.read",
                "+\tif n := int(p.rawInt64()); n != pos {",
                "+\t\terrorf(\"incorrect position: got %d; want %d\", n, pos)",
                "+\t}",
                "+}",
                "+",
                "+// rawInt64 should only be used by low-level decoders.",
                "+func (p *importer) rawInt64() int64 {",
                "+\ti, err := binary.ReadVarint(p)",
                "+\tif err != nil {",
                "+\t\terrorf(\"read error: %v\", err)",
                "+\t}",
                "+\treturn i",
                "+}",
                "+",
                "+// rawStringln should only be used to read the initial version string.",
                "+func (p *importer) rawStringln(b byte) string {",
                "+\tp.buf = p.buf[:0]",
                "+\tfor b != '\\n' {",
                "+\t\tp.buf = append(p.buf, b)",
                "+\t\tb = p.rawByte()",
                "+\t}",
                "+\treturn string(p.buf)",
                "+}",
                "+",
                "+// needed for binary.ReadVarint in rawInt64",
                "+func (p *importer) ReadByte() (byte, error) {",
                "+\treturn p.rawByte(), nil",
                "+}",
                "+",
                "+// byte is the bottleneck interface for reading p.data.",
                "+// It unescapes '|' 'S' to '$' and '|' '|' to '|'.",
                "+// rawByte should only be used by low-level decoders.",
                "+func (p *importer) rawByte() byte {",
                "+\tb := p.data[0]",
                "+\tr := 1",
                "+\tif b == '|' {",
                "+\t\tb = p.data[1]",
                "+\t\tr = 2",
                "+\t\tswitch b {",
                "+\t\tcase 'S':",
                "+\t\t\tb = '$'",
                "+\t\tcase '|':",
                "+\t\t\t// nothing to do",
                "+\t\tdefault:",
                "+\t\t\terrorf(\"unexpected escape sequence in export data\")",
                "+\t\t}",
                "+\t}",
                "+\tp.data = p.data[r:]",
                "+\tp.read += r",
                "+\treturn b",
                "+",
                "+}",
                "+",
                "+// ----------------------------------------------------------------------------",
                "+// Export format",
                "+",
                "+// Tags. Must be < 0.",
                "+const (",
                "+\t// Objects",
                "+\tpackageTag = -(iota + 1)",
                "+\tconstTag",
                "+\ttypeTag",
                "+\tvarTag",
                "+\tfuncTag",
                "+\tendTag",
                "+",
                "+\t// Types",
                "+\tnamedTag",
                "+\tarrayTag",
                "+\tsliceTag",
                "+\tdddTag",
                "+\tstructTag",
                "+\tpointerTag",
                "+\tsignatureTag",
                "+\tinterfaceTag",
                "+\tmapTag",
                "+\tchanTag",
                "+",
                "+\t// Values",
                "+\tfalseTag",
                "+\ttrueTag",
                "+\tint64Tag",
                "+\tfloatTag",
                "+\tfractionTag // not used by gc",
                "+\tcomplexTag",
                "+\tstringTag",
                "+\tnilTag     // only used by gc (appears in exported inlined function bodies)",
                "+\tunknownTag // not used by gc (only appears in packages with errors)",
                "+",
                "+\t// Type aliases",
                "+\taliasTag",
                "+)",
                "+",
                "+var predeclared = []types.Type{",
                "+\t// basic types",
                "+\ttypes.Typ[types.Bool],",
                "+\ttypes.Typ[types.Int],",
                "+\ttypes.Typ[types.Int8],",
                "+\ttypes.Typ[types.Int16],",
                "+\ttypes.Typ[types.Int32],",
                "+\ttypes.Typ[types.Int64],",
                "+\ttypes.Typ[types.Uint],",
                "+\ttypes.Typ[types.Uint8],",
                "+\ttypes.Typ[types.Uint16],",
                "+\ttypes.Typ[types.Uint32],",
                "+\ttypes.Typ[types.Uint64],",
                "+\ttypes.Typ[types.Uintptr],",
                "+\ttypes.Typ[types.Float32],",
                "+\ttypes.Typ[types.Float64],",
                "+\ttypes.Typ[types.Complex64],",
                "+\ttypes.Typ[types.Complex128],",
                "+\ttypes.Typ[types.String],",
                "+",
                "+\t// basic type aliases",
                "+\ttypes.Universe.Lookup(\"byte\").Type(),",
                "+\ttypes.Universe.Lookup(\"rune\").Type(),",
                "+",
                "+\t// error",
                "+\ttypes.Universe.Lookup(\"error\").Type(),",
                "+",
                "+\t// untyped types",
                "+\ttypes.Typ[types.UntypedBool],",
                "+\ttypes.Typ[types.UntypedInt],",
                "+\ttypes.Typ[types.UntypedRune],",
                "+\ttypes.Typ[types.UntypedFloat],",
                "+\ttypes.Typ[types.UntypedComplex],",
                "+\ttypes.Typ[types.UntypedString],",
                "+\ttypes.Typ[types.UntypedNil],",
                "+",
                "+\t// package unsafe",
                "+\ttypes.Typ[types.UnsafePointer],",
                "+",
                "+\t// invalid type",
                "+\ttypes.Typ[types.Invalid], // only appears in packages with errors",
                "+",
                "+\t// used internally by gc; never used by this package or in .a files",
                "+\tanyType{},",
                "+}",
                "+",
                "+type anyType struct{}",
                "+",
                "+func (t anyType) Underlying() types.Type { return t }",
                "+func (t anyType) String() string         { return \"any\" }",
                "diff --git a/vendor/golang.org/x/tools/go/internal/gcimporter/exportdata.go b/vendor/golang.org/x/tools/go/internal/gcimporter/exportdata.go",
                "new file mode 100644",
                "index 0000000..f33dc56",
                "--- /dev/null",
                "+++ b/vendor/golang.org/x/tools/go/internal/gcimporter/exportdata.go",
                "@@ -0,0 +1,93 @@",
                "+// Copyright 2011 The Go Authors. All rights reserved.",
                "+// Use of this source code is governed by a BSD-style",
                "+// license that can be found in the LICENSE file.",
                "+",
                "+// This file is a copy of $GOROOT/src/go/internal/gcimporter/exportdata.go.",
                "+",
                "+// This file implements FindExportData.",
                "+",
                "+package gcimporter",
                "+",
                "+import (",
                "+\t\"bufio\"",
                "+\t\"fmt\"",
                "+\t\"io\"",
                "+\t\"strconv\"",
                "+\t\"strings\"",
                "+)",
                "+",
                "+func readGopackHeader(r *bufio.Reader) (name string, size int, err error) {",
                "+\t// See $GOROOT/include/ar.h.",
                "+\thdr := make([]byte, 16+12+6+6+8+10+2)",
                "+\t_, err = io.ReadFull(r, hdr)",
                "+\tif err != nil {",
                "+\t\treturn",
                "+\t}",
                "+\t// leave for debugging",
                "+\tif false {",
                "+\t\tfmt.Printf(\"header: %s\", hdr)",
                "+\t}",
                "+\ts := strings.TrimSpace(string(hdr[16+12+6+6+8:][:10]))",
                "+\tsize, err = strconv.Atoi(s)",
                "+\tif err != nil || hdr[len(hdr)-2] != '`' || hdr[len(hdr)-1] != '\\n' {",
                "+\t\terr = fmt.Errorf(\"invalid archive header\")",
                "+\t\treturn",
                "+\t}",
                "+\tname = strings.TrimSpace(string(hdr[:16]))",
                "+\treturn",
                "+}",
                "+",
                "+// FindExportData positions the reader r at the beginning of the",
                "+// export data section of an underlying GC-created object/archive",
                "+// file by reading from it. The reader must be positioned at the",
                "+// start of the file before calling this function. The hdr result",
                "+// is the string before the export data, either \"$$\" or \"$$B\".",
                "+//",
                "+func FindExportData(r *bufio.Reader) (hdr string, err error) {",
                "+\t// Read first line to make sure this is an object file.",
                "+\tline, err := r.ReadSlice('\\n')",
                "+\tif err != nil {",
                "+\t\terr = fmt.Errorf(\"can't find export data (%v)\", err)",
                "+\t\treturn",
                "+\t}",
                "+",
                "+\tif string(line) == \"!<arch>\\n\" {",
                "+\t\t// Archive file. Scan to __.PKGDEF.",
                "+\t\tvar name string",
                "+\t\tif name, _, err = readGopackHeader(r); err != nil {",
                "+\t\t\treturn",
                "+\t\t}",
                "+",
                "+\t\t// First entry should be __.PKGDEF.",
                "+\t\tif name != \"__.PKGDEF\" {",
                "+\t\t\terr = fmt.Errorf(\"go archive is missing __.PKGDEF\")",
                "+\t\t\treturn",
                "+\t\t}",
                "+",
                "+\t\t// Read first line of __.PKGDEF data, so that line",
                "+\t\t// is once again the first line of the input.",
                "+\t\tif line, err = r.ReadSlice('\\n'); err != nil {",
                "+\t\t\terr = fmt.Errorf(\"can't find export data (%v)\", err)",
                "+\t\t\treturn",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t// Now at __.PKGDEF in archive or still at beginning of file.",
                "+\t// Either way, line should begin with \"go object \".",
                "+\tif !strings.HasPrefix(string(line), \"go object \") {",
                "+\t\terr = fmt.Errorf(\"not a Go object file\")",
                "+\t\treturn",
                "+\t}",
                "+",
                "+\t// Skip over object header to export data.",
                "+\t// Begins after first line starting with $$.",
                "+\tfor line[0] != '$' {",
                "+\t\tif line, err = r.ReadSlice('\\n'); err != nil {",
                "+\t\t\terr = fmt.Errorf(\"can't find export data (%v)\", err)",
                "+\t\t\treturn",
                "+\t\t}",
                "+\t}",
                "+\thdr = string(line)",
                "+",
                "+\treturn",
                "+}",
                "diff --git a/vendor/golang.org/x/tools/go/internal/gcimporter/gcimporter.go b/vendor/golang.org/x/tools/go/internal/gcimporter/gcimporter.go",
                "new file mode 100644",
                "index 0000000..4edd6a8",
                "--- /dev/null",
                "+++ b/vendor/golang.org/x/tools/go/internal/gcimporter/gcimporter.go",
                "@@ -0,0 +1,1037 @@",
                "+// Copyright 2011 The Go Authors. All rights reserved.",
                "+// Use of this source code is governed by a BSD-style",
                "+// license that can be found in the LICENSE file.",
                "+",
                "+// This file is a copy of $GOROOT/src/go/internal/gcimporter/gcimporter.go,",
                "+// but it also contains the original source-based importer code for Go1.6.",
                "+// Once we stop supporting 1.6, we can remove that code.",
                "+",
                "+// Package gcimporter provides various functions for reading",
                "+// gc-generated object files that can be used to implement the",
                "+// Importer interface defined by the Go 1.5 standard library package.",
                "+package gcimporter",
                "+",
                "+import (",
                "+\t\"bufio\"",
                "+\t\"errors\"",
                "+\t\"fmt\"",
                "+\t\"go/build\"",
                "+\texact \"go/constant\"",
                "+\t\"go/token\"",
                "+\t\"go/types\"",
                "+\t\"io\"",
                "+\t\"io/ioutil\"",
                "+\t\"os\"",
                "+\t\"path/filepath\"",
                "+\t\"sort\"",
                "+\t\"strconv\"",
                "+\t\"strings\"",
                "+\t\"text/scanner\"",
                "+)",
                "+",
                "+// debugging/development support",
                "+const debug = false",
                "+",
                "+var pkgExts = [...]string{\".a\", \".o\"}",
                "+",
                "+// FindPkg returns the filename and unique package id for an import",
                "+// path based on package information provided by build.Import (using",
                "+// the build.Default build.Context). A relative srcDir is interpreted",
                "+// relative to the current working directory.",
                "+// If no file was found, an empty filename is returned.",
                "+//",
                "+func FindPkg(path, srcDir string) (filename, id string) {",
                "+\tif path == \"\" {",
                "+\t\treturn",
                "+\t}",
                "+",
                "+\tvar noext string",
                "+\tswitch {",
                "+\tdefault:",
                "+\t\t// \"x\" -> \"$GOPATH/pkg/$GOOS_$GOARCH/x.ext\", \"x\"",
                "+\t\t// Don't require the source files to be present.",
                "+\t\tif abs, err := filepath.Abs(srcDir); err == nil { // see issue 14282",
                "+\t\t\tsrcDir = abs",
                "+\t\t}",
                "+\t\tbp, _ := build.Import(path, srcDir, build.FindOnly|build.AllowBinary)",
                "+\t\tif bp.PkgObj == \"\" {",
                "+\t\t\treturn",
                "+\t\t}",
                "+\t\tnoext = strings.TrimSuffix(bp.PkgObj, \".a\")",
                "+\t\tid = bp.ImportPath",
                "+",
                "+\tcase build.IsLocalImport(path):",
                "+\t\t// \"./x\" -> \"/this/directory/x.ext\", \"/this/directory/x\"",
                "+\t\tnoext = filepath.Join(srcDir, path)",
                "+\t\tid = noext",
                "+",
                "+\tcase filepath.IsAbs(path):",
                "+\t\t// for completeness only - go/build.Import",
                "+\t\t// does not support absolute imports",
                "+\t\t// \"/x\" -> \"/x.ext\", \"/x\"",
                "+\t\tnoext = path",
                "+\t\tid = path",
                "+\t}",
                "+",
                "+\tif false { // for debugging",
                "+\t\tif path != id {",
                "+\t\t\tfmt.Printf(\"%s -> %s\\n\", path, id)",
                "+\t\t}",
                "+\t}",
                "+",
                "+\t// try extensions",
                "+\tfor _, ext := range pkgExts {",
                "+\t\tfilename = noext + ext",
                "+\t\tif f, err := os.Stat(filename); err == nil && !f.IsDir() {",
                "+\t\t\treturn",
                "+\t\t}",
                "+\t}",
                "+",
                "+\tfilename = \"\" // not found",
                "+\treturn",
                "+}",
                "+",
                "+// ImportData imports a package by reading the gc-generated export data,",
                "+// adds the corresponding package object to the packages map indexed by id,",
                "+// and returns the object.",
                "+//",
                "+// The packages map must contains all packages already imported. The data",
                "+// reader position must be the beginning of the export data section. The",
                "+// filename is only used in error messages.",
                "+//",
                "+// If packages[id] contains the completely imported package, that package",
                "+// can be used directly, and there is no need to call this function (but",
                "+// there is also no harm but for extra time used).",
                "+//",
                "+func ImportData(packages map[string]*types.Package, filename, id string, data io.Reader) (pkg *types.Package, err error) {",
                "+\t// support for parser error handling",
                "+\tdefer func() {",
                "+\t\tswitch r := recover().(type) {",
                "+\t\tcase nil:",
                "+\t\t\t// nothing to do",
                "+\t\tcase importError:",
                "+\t\t\terr = r",
                "+\t\tdefault:",
                "+\t\t\tpanic(r) // internal error",
                "+\t\t}",
                "+\t}()",
                "+",
                "+\tvar p parser",
                "+\tp.init(filename, id, data, packages)",
                "+\tpkg = p.parseExport()",
                "+",
                "+\treturn",
                "+}",
                "+",
                "+// Import imports a gc-generated package given its import path and srcDir, adds",
                "+// the corresponding package object to the packages map, and returns the object.",
                "+// The packages map must contain all packages already imported.",
                "+//",
                "+func Import(packages map[string]*types.Package, path, srcDir string) (pkg *types.Package, err error) {",
                "+\tfilename, id := FindPkg(path, srcDir)",
                "+\tif filename == \"\" {",
                "+\t\tif path == \"unsafe\" {",
                "+\t\t\treturn types.Unsafe, nil",
                "+\t\t}",
                "+\t\terr = fmt.Errorf(\"can't find import: %s\", id)",
                "+\t\treturn",
                "+\t}",
                "+",
                "+\t// no need to re-import if the package was imported completely before",
                "+\tif pkg = packages[id]; pkg != nil && pkg.Complete() {",
                "+\t\treturn",
                "+\t}",
                "+",
                "+\t// open file",
                "+\tf, err := os.Open(filename)",
                "+\tif err != nil {",
                "+\t\treturn",
                "+\t}",
                "+\tdefer func() {",
                "+\t\tf.Close()",
                "+\t\tif err != nil {",
                "+\t\t\t// add file name to error",
                "+\t\t\terr = fmt.Errorf(\"reading export data: %s: %v\", filename, err)",
                "+\t\t}",
                "+\t}()",
                "+",
                "+\tvar hdr string",
                "+\tbuf := bufio.NewReader(f)",
                "+\tif hdr, err = FindExportData(buf); err != nil {",
                "+\t\treturn",
                "+\t}",
                "+",
                "+\tswitch hdr {",
                "+\tcase \"$$\\n\":",
                "+\t\treturn ImportData(packages, filename, id, buf)",
                "+\tcase \"$$B\\n\":",
                "+\t\tvar data []byte",
                "+\t\tdata, err = ioutil.ReadAll(buf)",
                "+\t\tif err == nil {",
                "+\t\t\tfset := token.NewFileSet()",
                "+\t\t\t_, pkg, err = BImportData(fset, packages, data, id)",
                "+\t\t\treturn",
                "+\t\t}",
                "+\tdefault:",
                "+\t\terr = fmt.Errorf(\"unknown export data header: %q\", hdr)",
                "+\t}",
                "+",
                "+\treturn",
                "+}",
                "+",
                "+// ----------------------------------------------------------------------------",
                "+// Parser",
                "+",
                "+// TODO(gri) Imported objects don't have position information.",
                "+//           Ideally use the debug table line info; alternatively",
                "+//           create some fake position (or the position of the",
                "+//           import). That way error messages referring to imported",
                "+//           objects can print meaningful information.",
                "+",
                "+// parser parses the exports inside a gc compiler-produced",
                "+// object/archive file and populates its scope with the results.",
                "+type parser struct {",
                "+\tscanner    scanner.Scanner",
                "+\ttok        rune                      // current token",
                "+\tlit        string                    // literal string; only valid for Ident, Int, String tokens",
                "+\tid         string                    // package id of imported package",
                "+\tsharedPkgs map[string]*types.Package // package id -> package object (across importer)",
                "+\tlocalPkgs  map[string]*types.Package // package id -> package object (just this package)",
                "+}",
                "+",
                "+func (p *parser) init(filename, id string, src io.Reader, packages map[string]*types.Package) {",
                "+\tp.scanner.Init(src)",
                "+\tp.scanner.Error = func(_ *scanner.Scanner, msg string) { p.error(msg) }",
                "+\tp.scanner.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanChars | scanner.ScanStrings | scanner.ScanComments | scanner.SkipComments",
                "+\tp.scanner.Whitespace = 1<<'\\t' | 1<<' '",
                "+\tp.scanner.Filename = filename // for good error messages",
                "+\tp.next()",
                "+\tp.id = id",
                "+\tp.sharedPkgs = packages",
                "+\tif debug {",
                "+\t\t// check consistency of packages map",
                "+\t\tfor _, pkg := range packages {",
                "+\t\t\tif pkg.Name() == \"\" {",
                "+\t\t\t\tfmt.Printf(\"no package name for %s\\n\", pkg.Path())",
                "+\t\t\t}",
                "+\t\t}",
                "+\t}",
                "+}",
                "+",
                "+func (p *parser) next() {",
                "+\tp.tok = p.scanner.Scan()",
                "+\tswitch p.tok {",
                "+\tcase scanner.Ident, scanner.Int, scanner.Char, scanner.String, '\u00c2\u00b7':",
                "+\t\tp.lit = p.scanner.TokenText()",
                "+\tdefault:",
                "+\t\tp.lit = \"\"",
                "+\t}",
                "+\tif debug {",
                "+\t\tfmt.Printf(\"%s: %q -> %q\\n\", scanner.TokenString(p.tok), p.scanner.TokenText(), p.lit)",
                "+\t}",
                "+}",
                "+",
                "+func declTypeName(pkg *types.Package, name string) *types.TypeName {",
                "+\tscope := pkg.Scope()",
                "+\tif obj := scope.Lookup(name); obj != nil {",
                "+\t\treturn obj.(*types.TypeName)",
                "+\t}",
                "+\tobj := types.NewTypeName(token.NoPos, pkg, name, nil)",
                "+\t// a named type may be referred to before the underlying type",
                "+\t// is known - set it up",
                "+\ttypes.NewNamed(obj, nil, nil)",
                "+\tscope.Insert(obj)",
                "+\treturn obj",
                "+}",
                "+",
                "+// ----------------------------------------------------------------------------",
                "+// Error handling",
                "+",
                "+// Internal errors are boxed as importErrors.",
                "+type importError struct {",
                "+\tpos scanner.Position",
                "+\terr error",
                "+}",
                "+",
                "+func (e importError) Error() string {",
                "+\treturn fmt.Sprintf(\"import error %s (byte offset = %d): %s\", e.pos, e.pos.Offset, e.err)",
                "+}",
                "+",
                "+func (p *parser) error(err interface{}) {",
                "+\tif s, ok := err.(string); ok {",
                "+\t\terr = errors.New(s)",
                "+\t}",
                "+\t// panic with a runtime.Error if err is not an error",
                "+\tpanic(importError{p.scanner.Pos(), err.(error)})",
                "+}",
                "+",
                "+func (p *parser) errorf(format string, args ...interface{}) {",
                "+\tp.error(fmt.Sprintf(format, args...))",
                "+}",
                "+",
                "+func (p *parser) expect(tok rune) string {",
                "+\tlit := p.lit",
                "+\tif p.tok != tok {",
                "+\t\tp.errorf(\"expected %s, got %s (%s)\", scanner.TokenString(tok), scanner.TokenString(p.tok), lit)",
                "+\t}",
                "+\tp.next()",
                "+\treturn lit",
                "+}",
                "+",
                "+func (p *parser) expectSpecial(tok string) {",
                "+\tsep := 'x' // not white space",
                "+\ti := 0",
                "+\tfor i < len(tok) && p.tok == rune(tok[i]) && sep > ' ' {",
                "+\t\tsep = p.scanner.Peek() // if sep <= ' ', there is white space before the next token",
                "+\t\tp.next()",
                "+\t\ti++",
                "+\t}",
                "+\tif i < len(tok) {",
                "+\t\tp.errorf(\"expected %q, got %q\", tok, tok[0:i])",
                "+\t}",
                "+}",
                "+",
                "+func (p *parser) expectKeyword(keyword string) {",
                "+\tlit := p.expect(scanner.Ident)",
                "+\tif lit != keyword {",
                "+\t\tp.errorf(\"expected keyword %s, got %q\", keyword, lit)",
                "+\t}",
                "+}",
                "+",
                "+// ----------------------------------------------------------------------------",
                "+// Qualified and unqualified names",
                "+",
                "+// PackageId = string_lit .",
                "+//",
                "+func (p *parser) parsePackageId() string {",
                "+\tid, err := strconv.Unquote(p.expect(scanner.String))",
                "+\tif err != nil {",
                "+\t\tp.error(err)",
                "+\t}",
                "+\t// id == \"\" stands for the imported package id",
                "+\t// (only known at time of package installation)",
                "+\tif id == \"\" {",
                "+\t\tid = p.id",
                "+\t}",
                "+\treturn id",
                "+}",
                "+",
                "+// PackageName = ident .",
                "+//",
                "+func (p *parser) parsePackageName() string {",
                "+\treturn p.expect(scanner.Ident)",
                "+}",
                "+",
                "+// dotIdentifier = ( ident | '\u00c2\u00b7' ) { ident | int | '\u00c2\u00b7' } .",
                "+func (p *parser) parseDotIdent() string {",
                "+\tident := \"\"",
                "+\tif p.tok != scanner.Int {",
                "+\t\tsep := 'x' // not white space",
                "+\t\tfor (p.tok == scanner.Ident || p.tok == scanner.Int || p.tok == '\u00c2\u00b7') && sep > ' ' {",
                "+\t\t\tident += p.lit",
                "+\t\t\tsep = p.scanner.Peek() // if sep <= ' ', there is white space before the next token",
                "+\t\t\tp.next()",
                "+\t\t}",
                "+\t}",
                "+\tif ident == \"\" {",
                "+\t\tp.expect(scanner.Ident) // use expect() for error handling",
                "+\t}",
                "+\treturn ident",
                "+}",
                "+",
                "+// QualifiedName = \"@\" PackageId \".\" ( \"?\" | dotIdentifier ) .",
                "+//",
                "+func (p *parser) parseQualifiedName() (id, name string) {",
                "+\tp.expect('@')",
                "+\tid = p.parsePackageId()",
                "+\tp.expect('.')",
                "+\t// Per rev f280b8a485fd (10/2/2013), qualified names may be used for anonymous fields.",
                "+\tif p.tok == '?' {",
                "+\t\tp.next()",
                "+\t} else {",
                "+\t\tname = p.parseDotIdent()",
                "+\t}",
                "+\treturn",
                "+}",
                "+",
                "+// getPkg returns the package for a given id. If the package is",
                "+// not found, create the package and add it to the p.localPkgs",
                "+// and p.sharedPkgs maps. name is the (expected) name of the",
                "+// package. If name == \"\", the package name is expected to be",
                "+// set later via an import clause in the export data.",
                "+//",
                "+// id identifies a package, usually by a canonical package path like",
                "+// \"encoding/json\" but possibly by a non-canonical import path like",
                "+// \"./json\".",
                "+//",
                "+func (p *parser) getPkg(id, name string) *types.Package {",
                "+\t// package unsafe is not in the packages maps - handle explicitly",
                "+\tif id == \"unsafe\" {",
                "+\t\treturn types.Unsafe",
                "+\t}",
                "+",
                "+\tpkg := p.localPkgs[id]",
                "+\tif pkg == nil {",
                "+\t\t// first import of id from this package",
                "+\t\tpkg = p.sharedPkgs[id]",
                "+\t\tif pkg == nil {",
                "+\t\t\t// first import of id by this importer;",
                "+\t\t\t// add (possibly unnamed) pkg to shared packages",
                "+\t\t\tpkg = types.NewPackage(id, name)",
                "+\t\t\tp.sharedPkgs[id] = pkg",
                "+\t\t}",
                "+\t\t// add (possibly unnamed) pkg to local packages",
                "+\t\tif p.localPkgs == nil {",
                "+\t\t\tp.localPkgs = make(map[string]*types.Package)",
                "+\t\t}",
                "+\t\tp.localPkgs[id] = pkg",
                "+\t} else if name != \"\" {",
                "+\t\t// package exists already and we have an expected package name;",
                "+\t\t// make sure names match or set package name if necessary",
                "+\t\tif pname := pkg.Name(); pname == \"\" {",
                "+\t\t\tpkg.SetName(name)",
                "+\t\t} else if pname != name {",
                "+\t\t\tp.errorf(\"%s package name mismatch: %s (given) vs %s (expected)\", id, pname, name)",
                "+\t\t}",
                "+\t}",
                "+\treturn pkg",
                "+}",
                "+",
                "+// parseExportedName is like parseQualifiedName, but",
                "+// the package id is resolved to an imported *types.Package.",
                "+//",
                "+func (p *parser) parseExportedName() (pkg *types.Package, name string) {",
                "+\tid, name := p.parseQualifiedName()",
                "+\tpkg = p.getPkg(id, \"\")",
                "+\treturn",
                "+}",
                "+",
                "+// ----------------------------------------------------------------------------",
                "+// Types",
                "+",
                "+// BasicType = identifier .",
                "+//",
                "+func (p *parser) parseBasicType() types.Type {",
                "+\tid := p.expect(scanner.Ident)",
                "+\tobj := types.Universe.Lookup(id)",
                "+\tif obj, ok := obj.(*types.TypeName); ok {",
                "+\t\treturn obj.Type()",
                "+\t}",
                "+\tp.errorf(\"not a basic type: %s\", id)",
                "+\treturn nil",
                "+}",
                "+",
                "+// ArrayType = \"[\" int_lit \"]\" Type .",
                "+//",
                "+func (p *parser) parseArrayType(parent *types.Package) types.Type {",
                "+\t// \"[\" already consumed and lookahead known not to be \"]\"",
                "+\tlit := p.expect(scanner.Int)",
                "+\tp.expect(']')",
                "+\telem := p.parseType(parent)",
                "+\tn, err := strconv.ParseInt(lit, 10, 64)",
                "+\tif err != nil {",
                "+\t\tp.error(err)",
                "+\t}",
                "+\treturn types.NewArray(elem, n)",
                "+}",
                "+",
                "+// MapType = \"map\" \"[\" Type \"]\" Type .",
                "+//",
                "+func (p *parser) parseMapType(parent *types.Package) types.Type {",
                "+\tp.expectKeyword(\"map\")",
                "+\tp.expect('[')",
                "+\tkey := p.parseType(parent)",
                "+\tp.expect(']')",
                "+\telem := p.parseType(parent)",
                "+\treturn types.NewMap(key, elem)",
                "+}",
                "+",
                "+// Name = identifier | \"?\" | QualifiedName .",
                "+//",
                "+// For unqualified and anonymous names, the returned package is the parent",
                "+// package unless parent == nil, in which case the returned package is the",
                "+// package being imported. (The parent package is not nil if the the name",
                "+// is an unqualified struct field or interface method name belonging to a",
                "+// type declared in another package.)",
                "+//",
                "+// For qualified names, the returned package is nil (and not created if",
                "+// it doesn't exist yet) unless materializePkg is set (which creates an",
                "+// unnamed package with valid package path). In the latter case, a",
                "+// subsequent import clause is expected to provide a name for the package.",
                "+//",
                "+func (p *parser) parseName(parent *types.Package, materializePkg bool) (pkg *types.Package, name string) {",
                "+\tpkg = parent",
                "+\tif pkg == nil {",
                "+\t\tpkg = p.sharedPkgs[p.id]",
                "+\t}",
                "+\tswitch p.tok {",
                "+\tcase scanner.Ident:",
                "+\t\tname = p.lit",
                "+\t\tp.next()",
                "+\tcase '?':",
                "+\t\t// anonymous",
                "+\t\tp.next()",
                "+\tcase '@':",
                "+\t\t// exported name prefixed with package path",
                "+\t\tpkg = nil",
                "+\t\tvar id string",
                "+\t\tid, name = p.parseQualifiedName()",
                "+\t\tif materializePkg {",
                "+\t\t\tpkg = p.getPkg(id, \"\")",
                "+\t\t}",
                "+\tdefault:",
                "+\t\tp.error(\"name expected\")",
                "+\t}",
                "+\treturn",
                "+}",
                "+",
                "+func deref(typ types.Type) types.Type {",
                "+\tif p, _ := typ.(*types.Pointer); p != nil {",
                "+\t\treturn p.Elem()",
                "+\t}",
                "+\treturn typ",
                "+}",
                "+",
                "+// Field = Name Type [ string_lit ] .",
                "+//",
                "+func (p *parser) parseField(parent *types.Package) (*types.Var, string) {",
                "+\tpkg, name := p.parseName(parent, true)",
                "+",
                "+\tif name == \"_\" {",
                "+\t\t// Blank fields should be package-qualified because they",
                "+\t\t// are unexported identifiers, but gc does not qualify them.",
                "+\t\t// Assuming that the ident belongs to the current package",
                "+\t\t// causes types to change during re-exporting, leading",
                "+\t\t// to spurious \"can't assign A to B\" errors from go/types.",
                "+\t\t// As a workaround, pretend all blank fields belong",
                "+\t\t// to the same unique dummy package.",
                "+\t\tconst blankpkg = \"<_>\"",
                "+\t\tpkg = p.getPkg(blankpkg, blankpkg)",
                "+\t}",
                "+",
                "+\ttyp := p.parseType(parent)",
                "+\tanonymous := false",
                "+\tif name == \"\" {",
                "+\t\t// anonymous field - typ must be T or *T and T must be a type name",
                "+\t\tswitch typ := deref(typ).(type) {",
                "+\t\tcase *types.Basic: // basic types are named types",
                "+\t\t\tpkg = nil // objects defined in Universe scope have no package",
                "+\t\t\tname = typ.Name()",
                "+\t\tcase *types.Named:",
                "+\t\t\tname = typ.Obj().Name()",
                "+\t\tdefault:",
                "+\t\t\tp.errorf(\"anonymous field expected\")",
                "+\t\t}",
                "+\t\tanonymous = true",
                "+\t}",
                "+\ttag := \"\"",
                "+\tif p.tok == scanner.String {",
                "+\t\ts := p.expect(scanner.String)",
                "+\t\tvar err error",
                "+\t\ttag, err = strconv.Unquote(s)",
                "+\t\tif err != nil {",
                "+\t\t\tp.errorf(\"invalid struct tag %s: %s\", s, err)",
                "+\t\t}",
                "+\t}",
                "+\treturn types.NewField(token.NoPos, pkg, name, typ, anonymous), tag",
                "+}",
                "+",
                "+// StructType = \"struct\" \"{\" [ FieldList ] \"}\" .",
                "+// FieldList  = Field { \";\" Field } .",
                "+//",
                "+func (p *parser) parseStructType(parent *types.Package) types.Type {",
                "+\tvar fields []*types.Var",
                "+\tvar tags []string",
                "+",
                "+\tp.expectKeyword(\"struct\")",
                "+\tp.expect('{')",
                "+\tfor i := 0; p.tok != '}' && p.tok != scanner.EOF; i++ {",
                "+\t\tif i > 0 {",
                "+\t\t\tp.expect(';')",
                "+\t\t}",
                "+\t\tfld, tag := p.parseField(parent)",
                "+\t\tif tag != \"\" && tags == nil {",
                "+\t\t\ttags = make([]string, i)",
                "+\t\t}",
                "+\t\tif tags != nil {",
                "+\t\t\ttags = append(tags, tag)",
                "+\t\t}",
                "+\t\tfields = append(fields, fld)",
                "+\t}",
                "+\tp.expect('}')",
                "+",
                "+\treturn types.NewStruct(fields, tags)",
                "+}",
                "+",
                "+// Parameter = ( identifier | \"?\" ) [ \"...\" ] Type [ string_lit ] .",
                "+//",
                "+func (p *parser) parseParameter() (par *types.Var, isVariadic bool) {",
                "+\t_, name := p.parseName(nil, false)",
                "+\t// remove gc-specific parameter numbering",
                "+\tif i := strings.Index(name, \"\u00c2\u00b7\"); i >= 0 {",
                "+\t\tname = name[:i]",
                "+\t}",
                "+\tif p.tok == '.' {",
                "+\t\tp.expectSpecial(\"...\")",
                "+\t\tisVariadic = true",
                "+\t}",
                "+\ttyp := p.parseType(nil)",
                "+\tif isVariadic {",
                "+\t\ttyp = types.NewSlice(typ)",
                "+\t}",
                "+\t// ignore argument tag (e.g. \"noescape\")",
                "+\tif p.tok == scanner.String {",
                "+\t\tp.next()",
                "+\t}",
                "+\t// TODO(gri) should we provide a package?",
                "+\tpar = types.NewVar(token.NoPos, nil, name, typ)",
                "+\treturn",
                "+}",
                "+",
                "+// Parameters    = \"(\" [ ParameterList ] \")\" .",
                "+// ParameterList = { Parameter \",\" } Parameter .",
                "+//",
                "+func (p *parser) parseParameters() (list []*types.Var, isVariadic bool) {",
                "+\tp.expect('(')",
                "+\tfor p.tok != ')' && p.tok != scanner.EOF {",
                "+\t\tif len(list) > 0 {",
                "+\t\t\tp.expect(',')",
                "+\t\t}",
                "+\t\tpar, variadic := p.parseParameter()",
                "+\t\tlist = append(list, par)",
                "+\t\tif variadic {",
                "+\t\t\tif isVariadic {",
                "+\t\t\t\tp.error(\"... not on final argument\")",
                "+\t\t\t}",
                "+\t\t\tisVariadic = true",
                "+\t\t}",
                "+\t}",
                "+\tp.expect(')')",
                "+",
                "+\treturn",
                "+}",
                "+",
                "+// Signature = Parameters [ Result ] .",
                "+// Result    = Type | Parameters .",
                "+//",
                "+func (p *parser) parseSignature(recv *types.Var) *types.Signature {",
                "+\tparams, isVariadic := p.parseParameters()",
                "+",
                "+\t// optional result type",
                "+\tvar results []*types.Var",
                "+\tif p.tok == '(' {",
                "+\t\tvar variadic bool",
                "+\t\tresults, variadic = p.parseParameters()",
                "+\t\tif variadic {",
                "+\t\t\tp.error(\"... not permitted on result type\")",
                "+\t\t}",
                "+\t}",
                "+",
                "+\treturn types.NewSignature(recv, types.NewTuple(params...), types.NewTuple(results...), isVariadic)",
                "+}",
                "+",
                "+// InterfaceType = \"interface\" \"{\" [ MethodList ] \"}\" .",
                "+// MethodList    = Method { \";\" Method } .",
                "+// Method        = Name Signature .",
                "+//",
                "+// The methods of embedded interfaces are always \"inlined\"",
                "+// by the compiler and thus embedded interfaces are never",
                "+// visible in the export data.",
                "+//",
                "+func (p *parser) parseInterfaceType(parent *types.Package) types.Type {",
                "+\tvar methods []*types.Func",
                "+",
                "+\tp.expectKeyword(\"interface\")",
                "+\tp.expect('{')",
                "+\tfor i := 0; p.tok != '}' && p.tok != scanner.EOF; i++ {",
                "+\t\tif i > 0 {",
                "+\t\t\tp.expect(';')",
                "+\t\t}",
                "+\t\tpkg, name := p.parseName(parent, true)",
                "+\t\tsig := p.parseSignature(nil)",
                "+\t\tmethods = append(methods, types.NewFunc(token.NoPos, pkg, name, sig))",
                "+\t}",
                "+\tp.expect('}')",
                "+",
                "+\t// Complete requires the type's embedded interfaces to be fully defined,",
                "+\t// but we do not define any",
                "+\treturn types.NewInterface(methods, nil).Complete()",
                "+}",
                "+",
                "+// ChanType = ( \"chan\" [ \"<-\" ] | \"<-\" \"chan\" ) Type .",
                "+//",
                "+func (p *parser) parseChanType(parent *types.Package) types.Type {",
                "+\tdir := types.SendRecv",
                "+\tif p.tok == scanner.Ident {",
                "+\t\tp.expectKeyword(\"chan\")",
                "+\t\tif p.tok == '<' {",
                "+\t\t\tp.expectSpecial(\"<-\")",
                "+\t\t\tdir = types.SendOnly",
                "+\t\t}",
                "+\t} else {",
                "+\t\tp.expectSpecial(\"<-\")",
                "+\t\tp.expectKeyword(\"chan\")",
                "+\t\tdir = types.RecvOnly",
                "+\t}",
                "+\telem := p.parseType(parent)",
                "+\treturn types.NewChan(dir, elem)",
                "+}",
                "+",
                "+// Type =",
                "+//\tBasicType | TypeName | ArrayType | SliceType | StructType |",
                "+//      PointerType | FuncType | InterfaceType | MapType | ChanType |",
                "+//      \"(\" Type \")\" .",
                "+//",
                "+// BasicType   = ident .",
                "+// TypeName    = ExportedName .",
                "+// SliceType   = \"[\" \"]\" Type .",
                "+// PointerType = \"*\" Type .",
                "+// FuncType    = \"func\" Signature .",
                "+//",
                "+func (p *parser) parseType(parent *types.Package) types.Type {",
                "+\tswitch p.tok {",
                "+\tcase scanner.Ident:",
                "+\t\tswitch p.lit {",
                "+\t\tdefault:",
                "+\t\t\treturn p.parseBasicType()",
                "+\t\tcase \"struct\":",
                "+\t\t\treturn p.parseStructType(parent)",
                "+\t\tcase \"func\":",
                "+\t\t\t// FuncType",
                "+\t\t\tp.next()",
                "+\t\t\treturn p.parseSignature(nil)",
                "+\t\tcase \"interface\":",
                "+\t\t\treturn p.parseInterfaceType(parent)",
                "+\t\tcase \"map\":",
                "+\t\t\treturn p.parseMapType(parent)",
                "+\t\tcase \"chan\":",
                "+\t\t\treturn p.parseChanType(parent)",
                "+\t\t}",
                "+\tcase '@':",
                "+\t\t// TypeName",
                "+\t\tpkg, name := p.parseExportedName()",
                "+\t\treturn declTypeName(pkg, name).Type()",
                "+\tcase '[':",
                "+\t\tp.next() // look ahead",
                "+\t\tif p.tok == ']' {",
                "+\t\t\t// SliceType",
                "+\t\t\tp.next()",
                "+\t\t\treturn types.NewSlice(p.parseType(parent))",
                "+\t\t}",
                "+\t\treturn p.parseArrayType(parent)",
                "+\tcase '*':",
                "+\t\t// PointerType",
                "+\t\tp.next()",
                "+\t\treturn types.NewPointer(p.parseType(parent))",
                "+\tcase '<':",
                "+\t\treturn p.parseChanType(parent)",
                "+\tcase '(':",
                "+\t\t// \"(\" Type \")\"",
                "+\t\tp.next()",
                "+\t\ttyp := p.parseType(parent)",
                "+\t\tp.expect(')')",
                "+\t\treturn typ",
                "+\t}",
                "+\tp.errorf(\"expected type, got %s (%q)\", scanner.TokenString(p.tok), p.lit)",
                "+\treturn nil",
                "+}",
                "+",
                "+// ----------------------------------------------------------------------------",
                "+// Declarations",
                "+",
                "+// ImportDecl = \"import\" PackageName PackageId .",
                "+//",
                "+func (p *parser) parseImportDecl() {",
                "+\tp.expectKeyword(\"import\")",
                "+\tname := p.parsePackageName()",
                "+\tp.getPkg(p.parsePackageId(), name)",
                "+}",
                "+",
                "+// int_lit = [ \"+\" | \"-\" ] { \"0\" ... \"9\" } .",
                "+//",
                "+func (p *parser) parseInt() string {",
                "+\ts := \"\"",
                "+\tswitch p.tok {",
                "+\tcase '-':",
                "+\t\ts = \"-\"",
                "+\t\tp.next()",
                "+\tcase '+':",
                "+\t\tp.next()",
                "+\t}",
                "+\treturn s + p.expect(scanner.Int)",
                "+}",
                "+",
                "+// number = int_lit [ \"p\" int_lit ] .",
                "+//",
                "+func (p *parser) parseNumber() (typ *types.Basic, val exact.Value) {",
                "+\t// mantissa",
                "+\tmant := exact.MakeFromLiteral(p.parseInt(), token.INT, 0)",
                "+\tif mant == nil {",
                "+\t\tpanic(\"invalid mantissa\")",
                "+\t}",
                "+",
                "+\tif p.lit == \"p\" {",
                "+\t\t// exponent (base 2)",
                "+\t\tp.next()",
                "+\t\texp, err := strconv.ParseInt(p.parseInt(), 10, 0)",
                "+\t\tif err != nil {",
                "+\t\t\tp.error(err)",
                "+\t\t}",
                "+\t\tif exp < 0 {",
                "+\t\t\tdenom := exact.MakeInt64(1)",
                "+\t\t\tdenom = exact.Shift(denom, token.SHL, uint(-exp))",
                "+\t\t\ttyp = types.Typ[types.UntypedFloat]",
                "+\t\t\tval = exact.BinaryOp(mant, token.QUO, denom)",
                "+\t\t\treturn",
                "+\t\t}",
                "+\t\tif exp > 0 {",
                "+\t\t\tmant = exact.Shift(mant, token.SHL, uint(exp))",
                "+\t\t}",
                "+\t\ttyp = types.Typ[types.UntypedFloat]",
                "+\t\tval = mant",
                "+\t\treturn",
                "+\t}",
                "+",
                "+\ttyp = types.Typ[types.UntypedInt]",
                "+\tval = mant",
                "+\treturn",
                "+}",
                "+",
                "+// ConstDecl   = \"const\" ExportedName [ Type ] \"=\" Literal .",
                "+// Literal     = bool_lit | int_lit | float_lit | complex_lit | rune_lit | string_lit .",
                "+// bool_lit    = \"true\" | \"false\" .",
                "+// complex_lit = \"(\" float_lit \"+\" float_lit \"i\" \")\" .",
                "+// rune_lit    = \"(\" int_lit \"+\" int_lit \")\" .",
                "+// string_lit  = `\"` { unicode_char } `\"` .",
                "+//",
                "+func (p *parser) parseConstDecl() {",
                "+\tp.expectKeyword(\"const\")",
                "+\tpkg, name := p.parseExportedName()",
                "+",
                "+\tvar typ0 types.Type",
                "+\tif p.tok != '=' {",
                "+\t\t// constant types are never structured - no need for parent type",
                "+\t\ttyp0 = p.parseType(nil)",
                "+\t}",
                "+",
                "+\tp.expect('=')",
                "+\tvar typ types.Type",
                "+\tvar val exact.Value",
                "+\tswitch p.tok {",
                "+\tcase scanner.Ident:",
                "+\t\t// bool_lit",
                "+\t\tif p.lit != \"true\" && p.lit != \"false\" {",
                "+\t\t\tp.error(\"expected true or false\")",
                "+\t\t}",
                "+\t\ttyp = types.Typ[types.UntypedBool]",
                "+\t\tval = exact.MakeBool(p.lit == \"true\")",
                "+\t\tp.next()",
                "+",
                "+\tcase '-', scanner.Int:",
                "+\t\t// int_lit",
                "+\t\ttyp, val = p.parseNumber()",
                "+",
                "+\tcase '(':",
                "+\t\t// complex_lit or rune_lit",
                "+\t\tp.next()",
                "+\t\tif p.tok == scanner.Char {",
                "+\t\t\tp.next()",
                "+\t\t\tp.expect('+')",
                "+\t\t\ttyp = types.Typ[types.UntypedRune]",
                "+\t\t\t_, val = p.parseNumber()",
                "+\t\t\tp.expect(')')",
                "+\t\t\tbreak",
                "+\t\t}",
                "+\t\t_, re := p.parseNumber()",
                "+\t\tp.expect('+')",
                "+\t\t_, im := p.parseNumber()",
                "+\t\tp.expectKeyword(\"i\")",
                "+\t\tp.expect(')')",
                "+\t\ttyp = types.Typ[types.UntypedComplex]",
                "+\t\tval = exact.BinaryOp(re, token.ADD, exact.MakeImag(im))",
                "+",
                "+\tcase scanner.Char:",
                "+\t\t// rune_lit",
                "+\t\ttyp = types.Typ[types.UntypedRune]",
                "+\t\tval = exact.MakeFromLiteral(p.lit, token.CHAR, 0)",
                "+\t\tp.next()",
                "+",
                "+\tcase scanner.String:",
                "+\t\t// string_lit",
                "+\t\ttyp = types.Typ[types.UntypedString]",
                "+\t\tval = exact.MakeFromLiteral(p.lit, token.STRING, 0)",
                "+\t\tp.next()",
                "+",
                "+\tdefault:",
                "+\t\tp.errorf(\"expected literal got %s\", scanner.TokenString(p.tok))",
                "+\t}",
                "+",
                "+\tif typ0 == nil {",
                "+\t\ttyp0 = typ",
                "+\t}",
                "+",
                "+\tpkg.Scope().Insert(types.NewConst(token.NoPos, pkg, name, typ0, val))",
                "+}",
                "+",
                "+// TypeDecl = \"type\" ExportedName Type .",
                "+//",
                "+func (p *parser) parseTypeDecl() {",
                "+\tp.expectKeyword(\"type\")",
                "+\tpkg, name := p.parseExportedName()",
                "+\tobj := declTypeName(pkg, name)",
                "+",
                "+\t// The type object may have been imported before and thus already",
                "+\t// have a type associated with it. We still need to parse the type",
                "+\t// structure, but throw it away if the object already has a type.",
                "+\t// This ensures that all imports refer to the same type object for",
                "+\t// a given type declaration.",
                "+\ttyp := p.parseType(pkg)",
                "+",
                "+\tif name := obj.Type().(*types.Named); name.Underlying() == nil {",
                "+\t\tname.SetUnderlying(typ)",
                "+\t}",
                "+}",
                "+",
                "+// VarDecl = \"var\" ExportedName Type .",
                "+//",
                "+func (p *parser) parseVarDecl() {",
                "+\tp.expectKeyword(\"var\")",
                "+\tpkg, name := p.parseExportedName()",
                "+\ttyp := p.parseType(pkg)",
                "+\tpkg.Scope().Insert(types.NewVar(token.NoPos, pkg, name, typ))",
                "+}",
                "+",
                "+// Func = Signature [ Body ] .",
                "+// Body = \"{\" ... \"}\" .",
                "+//",
                "+func (p *parser) parseFunc(recv *types.Var) *types.Signature {",
                "+\tsig := p.parseSignature(recv)",
                "+\tif p.tok == '{' {",
                "+\t\tp.next()",
                "+\t\tfor i := 1; i > 0; p.next() {",
                "+\t\t\tswitch p.tok {",
                "+\t\t\tcase '{':",
                "+\t\t\t\ti++",
                "+\t\t\tcase '}':",
                "+\t\t\t\ti--",
                "+\t\t\t}",
                "+\t\t}",
                "+\t}",
                "+\treturn sig",
                "+}",
                "+",
                "+// MethodDecl = \"func\" Receiver Name Func .",
                "+// Receiver   = \"(\" ( identifier | \"?\" ) [ \"*\" ] ExportedName \")\" .",
                "+//",
                "+func (p *parser) parseMethodDecl() {",
                "+\t// \"func\" already consumed",
                "+\tp.expect('(')",
                "+\trecv, _ := p.parseParameter() // receiver",
                "+\tp.expect(')')",
                "+",
                "+\t// determine receiver base type object",
                "+\tbase := deref(recv.Type()).(*types.Named)",
                "+",
                "+\t// parse method name, signature, and possibly inlined body",
                "+\t_, name := p.parseName(nil, false)",
                "+\tsig := p.parseFunc(recv)",
                "+",
                "+\t// methods always belong to the same package as the base type object",
                "+\tpkg := base.Obj().Pkg()",
                "+",
                "+\t// add method to type unless type was imported before",
                "+\t// and method exists already",
                "+\t// TODO(gri) This leads to a quadratic algorithm - ok for now because method counts are small.",
                "+\tbase.AddMethod(types.NewFunc(token.NoPos, pkg, name, sig))",
                "+}",
                "+",
                "+// FuncDecl = \"func\" ExportedName Func .",
                "+//",
                "+func (p *parser) parseFuncDecl() {",
                "+\t// \"func\" already consumed",
                "+\tpkg, name := p.parseExportedName()",
                "+\ttyp := p.parseFunc(nil)",
                "+\tpkg.Scope().Insert(types.NewFunc(token.NoPos, pkg, name, typ))",
                "+}",
                "+",
                "+// Decl = [ ImportDecl | ConstDecl | TypeDecl | VarDecl | FuncDecl | MethodDecl ] \"\\n\" .",
                "+//",
                "+func (p *parser) parseDecl() {",
                "+\tif p.tok == scanner.Ident {",
                "+\t\tswitch p.lit {",
                "+\t\tcase \"import\":",
                "+\t\t\tp.parseImportDecl()",
                "+\t\tcase \"const\":",
                "+\t\t\tp.parseConstDecl()",
                "+\t\tcase \"type\":",
                "+\t\t\tp.parseTypeDecl()",
                "+\t\tcase \"var\":",
                "+\t\t\tp.parseVarDecl()",
                "+\t\tcase \"func\":",
                "+\t\t\tp.next() // look ahead",
                "+\t\t\tif p.tok == '(' {",
                "+\t\t\t\tp.parseMethodDecl()",
                "+\t\t\t} else {",
                "+\t\t\t\tp.parseFuncDecl()",
                "+\t\t\t}",
                "+\t\t}",
                "+\t}",
                "+\tp.expect('\\n')",
                "+}",
                "+",
                "+// ----------------------------------------------------------------------------",
                "+// Export",
                "+",
                "+// Export        = \"PackageClause { Decl } \"$$\" .",
                "+// PackageClause = \"package\" PackageName [ \"safe\" ] \"\\n\" .",
                "+//",
                "+func (p *parser) parseExport() *types.Package {",
                "+\tp.expectKeyword(\"package\")",
                "+\tname := p.parsePackageName()",
                "+\tif p.tok == scanner.Ident && p.lit == \"safe\" {",
                "+\t\t// package was compiled with -u option - ignore",
                "+\t\tp.next()",
                "+\t}",
                "+\tp.expect('\\n')",
                "+",
                "+\tpkg := p.getPkg(p.id, name)",
                "+",
                "+\tfor p.tok != '$' && p.tok != scanner.EOF {",
                "+\t\tp.parseDecl()",
                "+\t}",
                "+",
                "+\tif ch := p.scanner.Peek(); p.tok != '$' || ch != '$' {",
                "+\t\t// don't call next()/expect() since reading past the",
                "+\t\t// export data may cause scanner errors (e.g. NUL chars)",
                "+\t\tp.errorf(\"expected '$$', got %s %c\", scanner.TokenString(p.tok), ch)",
                "+\t}",
                "+",
                "+\tif n := p.scanner.ErrorCount; n != 0 {",
                "+\t\tp.errorf(\"expected no scanner errors, got %d\", n)",
                "+\t}",
                "+",
                "+\t// Record all locally referenced packages as imports.",
                "+\tvar imports []*types.Package",
                "+\tfor id, pkg2 := range p.localPkgs {",
                "+\t\tif pkg2.Name() == \"\" {",
                "+\t\t\tp.errorf(\"%s package has no name\", id)",
                "+\t\t}",
                "+\t\tif id == p.id {",
                "+\t\t\tcontinue // avoid self-edge",
                "+\t\t}",
                "+\t\timports = append(imports, pkg2)",
                "+\t}",
                "+\tsort.Sort(byPath(imports))",
                "+\tpkg.SetImports(imports)",
                "+",
                "+\t// package was imported completely and without errors",
                "+\tpkg.MarkComplete()",
                "+",
                "+\treturn pkg",
                "+}",
                "+",
                "+type byPath []*types.Package",
                "+",
                "+func (a byPath) Len() int           { return len(a) }",
                "+func (a byPath) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }",
                "+func (a byPath) Less(i, j int) bool { return a[i].Path() < a[j].Path() }",
                "diff --git a/vendor/golang.org/x/tools/go/internal/gcimporter/iimport.go b/vendor/golang.org/x/tools/go/internal/gcimporter/iimport.go",
                "new file mode 100644",
                "index 0000000..dfc00a3",
                "--- /dev/null",
                "+++ b/vendor/golang.org/x/tools/go/internal/gcimporter/iimport.go",
                "@@ -0,0 +1,585 @@",
                "+// Copyright 2018 The Go Authors. All rights reserved.",
                "+// Use of this source code is governed by a BSD-style",
                "+// license that can be found in the LICENSE file.",
                "+",
                "+// Indexed package import.",
                "+// See cmd/compile/internal/gc/iexport.go for the export data format.",
                "+",
                "+// This file is a copy of $GOROOT/src/go/internal/gcimporter/iimport.go.",
                "+",
                "+package gcimporter",
                "+",
                "+import (",
                "+\t\"bytes\"",
                "+\t\"encoding/binary\"",
                "+\t\"go/constant\"",
                "+\t\"go/token\"",
                "+\t\"go/types\"",
                "+\t\"io\"",
                "+\t\"sort\"",
                "+)",
                "+",
                "+type intReader struct {",
                "+\t*bytes.Reader",
                "+\tpath string",
                "+}",
                "+",
                "+func (r *intReader) int64() int64 {",
                "+\ti, err := binary.ReadVarint(r.Reader)",
                "+\tif err != nil {",
                "+\t\terrorf(\"import %q: read varint error: %v\", r.path, err)",
                "+\t}",
                "+\treturn i",
                "+}",
                "+",
                "+func (r *intReader) uint64() uint64 {",
                "+\ti, err := binary.ReadUvarint(r.Reader)",
                "+\tif err != nil {",
                "+\t\terrorf(\"import %q: read varint error: %v\", r.path, err)",
                "+\t}",
                "+\treturn i",
                "+}",
                "+",
                "+const predeclReserved = 32",
                "+",
                "+type itag uint64",
                "+",
                "+const (",
                "+\t// Types",
                "+\tdefinedType itag = iota",
                "+\tpointerType",
                "+\tsliceType",
                "+\tarrayType",
                "+\tchanType",
                "+\tmapType",
                "+\tsignatureType",
                "+\tstructType",
                "+\tinterfaceType",
                "+)",
                "+",
                "+// iImportData imports a package from the serialized package data",
                "+// and returns the number of bytes consumed and a reference to the package.",
                "+// If the export data version is not recognized or the format is otherwise",
                "+// compromised, an error is returned.",
                "+func iImportData(fset *token.FileSet, imports map[string]*types.Package, data []byte, path string) (_ int, pkg *types.Package, err error) {",
                "+\tr := &intReader{bytes.NewReader(data), path}",
                "+",
                "+\tversion := r.uint64()",
                "+\tswitch version {",
                "+\tcase 0:",
                "+\tdefault:",
                "+\t\terrorf(\"cannot import %q: unknown iexport format version %d\", path, version)",
                "+\t}",
                "+",
                "+\tsLen := int64(r.uint64())",
                "+\tdLen := int64(r.uint64())",
                "+",
                "+\twhence, _ := r.Seek(0, io.SeekCurrent)",
                "+\tstringData := data[whence : whence+sLen]",
                "+\tdeclData := data[whence+sLen : whence+sLen+dLen]",
                "+\tr.Seek(sLen+dLen, io.SeekCurrent)",
                "+",
                "+\tp := iimporter{",
                "+\t\tipath: path,",
                "+",
                "+\t\tstringData:  stringData,",
                "+\t\tstringCache: make(map[uint64]string),",
                "+\t\tpkgCache:    make(map[uint64]*types.Package),",
                "+",
                "+\t\tdeclData: declData,",
                "+\t\tpkgIndex: make(map[*types.Package]map[string]uint64),",
                "+\t\ttypCache: make(map[uint64]types.Type),",
                "+",
                "+\t\tfake: fakeFileSet{",
                "+\t\t\tfset:  fset,",
                "+\t\t\tfiles: make(map[string]*token.File),",
                "+\t\t},",
                "+\t}",
                "+",
                "+\tfor i, pt := range predeclared {",
                "+\t\tp.typCache[uint64(i)] = pt",
                "+\t}",
                "+",
                "+\tpkgList := make([]*types.Package, r.uint64())",
                "+\tfor i := range pkgList {",
                "+\t\tpkgPathOff := r.uint64()",
                "+\t\tpkgPath := p.stringAt(pkgPathOff)",
                "+\t\tpkgName := p.stringAt(r.uint64())",
                "+\t\t_ = r.uint64() // package height; unused by go/types",
                "+",
                "+\t\tif pkgPath == \"\" {",
                "+\t\t\tpkgPath = path",
                "+\t\t}",
                "+\t\tpkg := imports[pkgPath]",
                "+\t\tif pkg == nil {",
                "+\t\t\tpkg = types.NewPackage(pkgPath, pkgName)",
                "+\t\t\timports[pkgPath] = pkg",
                "+\t\t} else if pkg.Name() != pkgName {",
                "+\t\t\terrorf(\"conflicting names %s and %s for package %q\", pkg.Name(), pkgName, path)",
                "+\t\t}",
                "+",
                "+\t\tp.pkgCache[pkgPathOff] = pkg",
                "+",
                "+\t\tnameIndex := make(map[string]uint64)",
                "+\t\tfor nSyms := r.uint64(); nSyms > 0; nSyms-- {",
                "+\t\t\tname := p.stringAt(r.uint64())",
                "+\t\t\tnameIndex[name] = r.uint64()",
                "+\t\t}",
                "+",
                "+\t\tp.pkgIndex[pkg] = nameIndex",
                "+\t\tpkgList[i] = pkg",
                "+\t}",
                "+",
                "+\tlocalpkg := pkgList[0]",
                "+",
                "+\tnames := make([]string, 0, len(p.pkgIndex[localpkg]))",
                "+\tfor name := range p.pkgIndex[localpkg] {",
                "+\t\tnames = append(names, name)",
                "+\t}",
                "+\tsort.Strings(names)",
                "+\tfor _, name := range names {",
                "+\t\tp.doDecl(localpkg, name)",
                "+\t}",
                "+",
                "+\tfor _, typ := range p.interfaceList {",
                "+\t\ttyp.Complete()",
                "+\t}",
                "+",
                "+\t// record all referenced packages as imports",
                "+\tlist := append(([]*types.Package)(nil), pkgList[1:]...)",
                "+\tsort.Sort(byPath(list))",
                "+\tlocalpkg.SetImports(list)",
                "+",
                "+\t// package was imported completely and without errors",
                "+\tlocalpkg.MarkComplete()",
                "+",
                "+\tconsumed, _ := r.Seek(0, io.SeekCurrent)",
                "+\treturn int(consumed), localpkg, nil",
                "+}",
                "+",
                "+type iimporter struct {",
                "+\tipath string",
                "+",
                "+\tstringData  []byte",
                "+\tstringCache map[uint64]string",
                "+\tpkgCache    map[uint64]*types.Package",
                "+",
                "+\tdeclData []byte",
                "+\tpkgIndex map[*types.Package]map[string]uint64",
                "+\ttypCache map[uint64]types.Type",
                "+",
                "+\tfake          fakeFileSet",
                "+\tinterfaceList []*types.Interface",
                "+}",
                "+",
                "+func (p *iimporter) doDecl(pkg *types.Package, name string) {",
                "+\t// See if we've already imported this declaration.",
                "+\tif obj := pkg.Scope().Lookup(name); obj != nil {",
                "+\t\treturn",
                "+\t}",
                "+",
                "+\toff, ok := p.pkgIndex[pkg][name]",
                "+\tif !ok {",
                "+\t\terrorf(\"%v.%v not in index\", pkg, name)",
                "+\t}",
                "+",
                "+\tr := &importReader{p: p, currPkg: pkg}",
                "+\tr.declReader.Reset(p.declData[off:])",
                "+",
                "+\tr.obj(name)",
                "+}",
                "+",
                "+func (p *iimporter) stringAt(off uint64) string {",
                "+\tif s, ok := p.stringCache[off]; ok {",
                "+\t\treturn s",
                "+\t}",
                "+",
                "+\tslen, n := binary.Uvarint(p.stringData[off:])",
                "+\tif n <= 0 {",
                "+\t\terrorf(\"varint failed\")",
                "+\t}",
                "+\tspos := off + uint64(n)",
                "+\ts := string(p.stringData[spos : spos+slen])",
                "+\tp.stringCache[off] = s",
                "+\treturn s",
                "+}",
                "+",
                "+func (p *iimporter) pkgAt(off uint64) *types.Package {",
                "+\tif pkg, ok := p.pkgCache[off]; ok {",
                "+\t\treturn pkg",
                "+\t}",
                "+\tpath := p.stringAt(off)",
                "+\terrorf(\"missing package %q in %q\", path, p.ipath)",
                "+\treturn nil",
                "+}",
                "+",
                "+func (p *iimporter) typAt(off uint64, base *types.Named) types.Type {",
                "+\tif t, ok := p.typCache[off]; ok && (base == nil || !isInterface(t)) {",
                "+\t\treturn t",
                "+\t}",
                "+",
                "+\tif off < predeclReserved {",
                "+\t\terrorf(\"predeclared type missing from cache: %v\", off)",
                "+\t}",
                "+",
                "+\tr := &importReader{p: p}",
                "+\tr.declReader.Reset(p.declData[off-predeclReserved:])",
                "+\tt := r.doType(base)",
                "+",
                "+\tif base == nil || !isInterface(t) {",
                "+\t\tp.typCache[off] = t",
                "+\t}",
                "+\treturn t",
                "+}",
                "+",
                "+type importReader struct {",
                "+\tp          *iimporter",
                "+\tdeclReader bytes.Reader",
                "+\tcurrPkg    *types.Package",
                "+\tprevFile   string",
                "+\tprevLine   int64",
                "+}",
                "+",
                "+func (r *importReader) obj(name string) {",
                "+\ttag := r.byte()",
                "+\tpos := r.pos()",
                "+",
                "+\tswitch tag {",
                "+\tcase 'A':",
                "+\t\ttyp := r.typ()",
                "+",
                "+\t\tr.declare(types.NewTypeName(pos, r.currPkg, name, typ))",
                "+",
                "+\tcase 'C':",
                "+\t\ttyp, val := r.value()",
                "+",
                "+\t\tr.declare(types.NewConst(pos, r.currPkg, name, typ, val))",
                "+",
                "+\tcase 'F':",
                "+\t\tsig := r.signature(nil)",
                "+",
                "+\t\tr.declare(types.NewFunc(pos, r.currPkg, name, sig))",
                "+",
                "+\tcase 'T':",
                "+\t\t// Types can be recursive. We need to setup a stub",
                "+\t\t// declaration before recursing.",
                "+\t\tobj := types.NewTypeName(pos, r.currPkg, name, nil)",
                "+\t\tnamed := types.NewNamed(obj, nil, nil)",
                "+\t\tr.declare(obj)",
                "+",
                "+\t\tunderlying := r.p.typAt(r.uint64(), named).Underlying()",
                "+\t\tnamed.SetUnderlying(underlying)",
                "+",
                "+\t\tif !isInterface(underlying) {",
                "+\t\t\tfor n := r.uint64(); n > 0; n-- {",
                "+\t\t\t\tmpos := r.pos()",
                "+\t\t\t\tmname := r.ident()",
                "+\t\t\t\trecv := r.param()",
                "+\t\t\t\tmsig := r.signature(recv)",
                "+",
                "+\t\t\t\tnamed.AddMethod(types.NewFunc(mpos, r.currPkg, mname, msig))",
                "+\t\t\t}",
                "+\t\t}",
                "+",
                "+\tcase 'V':",
                "+\t\ttyp := r.typ()",
                "+",
                "+\t\tr.declare(types.NewVar(pos, r.currPkg, name, typ))",
                "+",
                "+\tdefault:",
                "+\t\terrorf(\"unexpected tag: %v\", tag)",
                "+\t}",
                "+}",
                "+",
                "+func (r *importReader) declare(obj types.Object) {",
                "+\tobj.Pkg().Scope().Insert(obj)",
                "+}",
                "+",
                "+func (r *importReader) value() (typ types.Type, val constant.Value) {",
                "+\ttyp = r.typ()",
                "+",
                "+\tswitch b := typ.Underlying().(*types.Basic); b.Info() & types.IsConstType {",
                "+\tcase types.IsBoolean:",
                "+\t\tval = constant.MakeBool(r.bool())",
                "+",
                "+\tcase types.IsString:",
                "+\t\tval = constant.MakeString(r.string())",
                "+",
                "+\tcase types.IsInteger:",
                "+\t\tval = r.mpint(b)",
                "+",
                "+\tcase types.IsFloat:",
                "+\t\tval = r.mpfloat(b)",
                "+",
                "+\tcase types.IsComplex:",
                "+\t\tre := r.mpfloat(b)",
                "+\t\tim := r.mpfloat(b)",
                "+\t\tval = constant.BinaryOp(re, token.ADD, constant.MakeImag(im))",
                "+",
                "+\tdefault:",
                "+\t\terrorf(\"unexpected type %v\", typ) // panics",
                "+\t\tpanic(\"unreachable\")",
                "+\t}",
                "+",
                "+\treturn",
                "+}",
                "+",
                "+func intSize(b *types.Basic) (signed bool, maxBytes uint) {",
                "+\tif (b.Info() & types.IsUntyped) != 0 {",
                "+\t\treturn true, 64",
                "+\t}",
                "+",
                "+\tswitch b.Kind() {",
                "+\tcase types.Float32, types.Complex64:",
                "+\t\treturn true, 3",
                "+\tcase types.Float64, types.Complex128:",
                "+\t\treturn true, 7",
                "+\t}",
                "+",
                "+\tsigned = (b.Info() & types.IsUnsigned) == 0",
                "+\tswitch b.Kind() {",
                "+\tcase types.Int8, types.Uint8:",
                "+\t\tmaxBytes = 1",
                "+\tcase types.Int16, types.Uint16:",
                "+\t\tmaxBytes = 2",
                "+\tcase types.Int32, types.Uint32:",
                "+\t\tmaxBytes = 4",
                "+\tdefault:",
                "+\t\tmaxBytes = 8",
                "+\t}",
                "+",
                "+\treturn",
                "+}",
                "+",
                "+func (r *importReader) mpint(b *types.Basic) constant.Value {",
                "+\tsigned, maxBytes := intSize(b)",
                "+",
                "+\tmaxSmall := 256 - maxBytes",
                "+\tif signed {",
                "+\t\tmaxSmall = 256 - 2*maxBytes",
                "+\t}",
                "+\tif maxBytes == 1 {",
                "+\t\tmaxSmall = 256",
                "+\t}",
                "+",
                "+\tn, _ := r.declReader.ReadByte()",
                "+\tif uint(n) < maxSmall {",
                "+\t\tv := int64(n)",
                "+\t\tif signed {",
                "+\t\t\tv >>= 1",
                "+\t\t\tif n&1 != 0 {",
                "+\t\t\t\tv = ^v",
                "+\t\t\t}",
                "+\t\t}",
                "+\t\treturn constant.MakeInt64(v)",
                "+\t}",
                "+",
                "+\tv := -n",
                "+\tif signed {",
                "+\t\tv = -(n &^ 1) >> 1",
                "+\t}",
                "+\tif v < 1 || uint(v) > maxBytes {",
                "+\t\terrorf(\"weird decoding: %v, %v => %v\", n, signed, v)",
                "+\t}",
                "+",
                "+\tbuf := make([]byte, v)",
                "+\tio.ReadFull(&r.declReader, buf)",
                "+",
                "+\t// convert to little endian",
                "+\t// TODO(gri) go/constant should have a more direct conversion function",
                "+\t//           (e.g., once it supports a big.Float based implementation)",
                "+\tfor i, j := 0, len(buf)-1; i < j; i, j = i+1, j-1 {",
                "+\t\tbuf[i], buf[j] = buf[j], buf[i]",
                "+\t}",
                "+",
                "+\tx := constant.MakeFromBytes(buf)",
                "+\tif signed && n&1 != 0 {",
                "+\t\tx = constant.UnaryOp(token.SUB, x, 0)",
                "+\t}",
                "+\treturn x",
                "+}",
                "+",
                "+func (r *importReader) mpfloat(b *types.Basic) constant.Value {",
                "+\tx := r.mpint(b)",
                "+\tif constant.Sign(x) == 0 {",
                "+\t\treturn x",
                "+\t}",
                "+",
                "+\texp := r.int64()",
                "+\tswitch {",
                "+\tcase exp > 0:",
                "+\t\tx = constant.Shift(x, token.SHL, uint(exp))",
                "+\tcase exp < 0:",
                "+\t\td := constant.Shift(constant.MakeInt64(1), token.SHL, uint(-exp))",
                "+\t\tx = constant.BinaryOp(x, token.QUO, d)",
                "+\t}",
                "+\treturn x",
                "+}",
                "+",
                "+func (r *importReader) ident() string {",
                "+\treturn r.string()",
                "+}",
                "+",
                "+func (r *importReader) qualifiedIdent() (*types.Package, string) {",
                "+\tname := r.string()",
                "+\tpkg := r.pkg()",
                "+\treturn pkg, name",
                "+}",
                "+",
                "+func (r *importReader) pos() token.Pos {",
                "+\tdelta := r.int64()",
                "+\tif delta != deltaNewFile {",
                "+\t\tr.prevLine += delta",
                "+\t} else if l := r.int64(); l == -1 {",
                "+\t\tr.prevLine += deltaNewFile",
                "+\t} else {",
                "+\t\tr.prevFile = r.string()",
                "+\t\tr.prevLine = l",
                "+\t}",
                "+",
                "+\tif r.prevFile == \"\" && r.prevLine == 0 {",
                "+\t\treturn token.NoPos",
                "+\t}",
                "+",
                "+\treturn r.p.fake.pos(r.prevFile, int(r.prevLine))",
                "+}",
                "+",
                "+func (r *importReader) typ() types.Type {",
                "+\treturn r.p.typAt(r.uint64(), nil)",
                "+}",
                "+",
                "+func isInterface(t types.Type) bool {",
                "+\t_, ok := t.(*types.Interface)",
                "+\treturn ok",
                "+}",
                "+",
                "+func (r *importReader) pkg() *types.Package { return r.p.pkgAt(r.uint64()) }",
                "+func (r *importReader) string() string      { return r.p.stringAt(r.uint64()) }",
                "+",
                "+func (r *importReader) doType(base *types.Named) types.Type {",
                "+\tswitch k := r.kind(); k {",
                "+\tdefault:",
                "+\t\terrorf(\"unexpected kind tag in %q: %v\", r.p.ipath, k)",
                "+\t\treturn nil",
                "+",
                "+\tcase definedType:",
                "+\t\tpkg, name := r.qualifiedIdent()",
                "+\t\tr.p.doDecl(pkg, name)",
                "+\t\treturn pkg.Scope().Lookup(name).(*types.TypeName).Type()",
                "+\tcase pointerType:",
                "+\t\treturn types.NewPointer(r.typ())",
                "+\tcase sliceType:",
                "+\t\treturn types.NewSlice(r.typ())",
                "+\tcase arrayType:",
                "+\t\tn := r.uint64()",
                "+\t\treturn types.NewArray(r.typ(), int64(n))",
                "+\tcase chanType:",
                "+\t\tdir := chanDir(int(r.uint64()))",
                "+\t\treturn types.NewChan(dir, r.typ())",
                "+\tcase mapType:",
                "+\t\treturn types.NewMap(r.typ(), r.typ())",
                "+\tcase signatureType:",
                "+\t\tr.currPkg = r.pkg()",
                "+\t\treturn r.signature(nil)",
                "+",
                "+\tcase structType:",
                "+\t\tr.currPkg = r.pkg()",
                "+",
                "+\t\tfields := make([]*types.Var, r.uint64())",
                "+\t\ttags := make([]string, len(fields))",
                "+\t\tfor i := range fields {",
                "+\t\t\tfpos := r.pos()",
                "+\t\t\tfname := r.ident()",
                "+\t\t\tftyp := r.typ()",
                "+\t\t\temb := r.bool()",
                "+\t\t\ttag := r.string()",
                "+",
                "+\t\t\tfields[i] = types.NewField(fpos, r.currPkg, fname, ftyp, emb)",
                "+\t\t\ttags[i] = tag",
                "+\t\t}",
                "+\t\treturn types.NewStruct(fields, tags)",
                "+",
                "+\tcase interfaceType:",
                "+\t\tr.currPkg = r.pkg()",
                "+",
                "+\t\tembeddeds := make([]*types.Named, r.uint64())",
                "+\t\tfor i := range embeddeds {",
                "+\t\t\t_ = r.pos()",
                "+\t\t\tembeddeds[i] = r.typ().(*types.Named)",
                "+\t\t}",
                "+",
                "+\t\tmethods := make([]*types.Func, r.uint64())",
                "+\t\tfor i := range methods {",
                "+\t\t\tmpos := r.pos()",
                "+\t\t\tmname := r.ident()",
                "+",
                "+\t\t\t// TODO(mdempsky): Matches bimport.go, but I",
                "+\t\t\t// don't agree with this.",
                "+\t\t\tvar recv *types.Var",
                "+\t\t\tif base != nil {",
                "+\t\t\t\trecv = types.NewVar(token.NoPos, r.currPkg, \"\", base)",
                "+\t\t\t}",
                "+",
                "+\t\t\tmsig := r.signature(recv)",
                "+\t\t\tmethods[i] = types.NewFunc(mpos, r.currPkg, mname, msig)",
                "+\t\t}",
                "+",
                "+\t\ttyp := types.NewInterface(methods, embeddeds)",
                "+\t\tr.p.interfaceList = append(r.p.interfaceList, typ)",
                "+\t\treturn typ",
                "+\t}",
                "+}",
                "+",
                "+func (r *importReader) kind() itag {",
                "+\treturn itag(r.uint64())",
                "+}",
                "+",
                "+func (r *importReader) signature(recv *types.Var) *types.Signature {",
                "+\tparams := r.paramList()",
                "+\tresults := r.paramList()",
                "+\tvariadic := params.Len() > 0 && r.bool()",
                "+\treturn types.NewSignature(recv, params, results, variadic)",
                "+}",
                "+",
                "+func (r *importReader) paramList() *types.Tuple {",
                "+\txs := make([]*types.Var, r.uint64())",
                "+\tfor i := range xs {",
                "+\t\txs[i] = r.param()",
                "+\t}",
                "+\treturn types.NewTuple(xs...)",
                "+}",
                "+",
                "+func (r *importReader) param() *types.Var {",
                "+\tpos := r.pos()",
                "+\tname := r.ident()",
                "+\ttyp := r.typ()",
                "+\treturn types.NewParam(pos, r.currPkg, name, typ)",
                "+}",
                "+",
                "+func (r *importReader) bool() bool {",
                "+\treturn r.uint64() != 0",
                "+}",
                "+",
                "+func (r *importReader) int64() int64 {",
                "+\tn, err := binary.ReadVarint(&r.declReader)",
                "+\tif err != nil {",
                "+\t\terrorf(\"readVarint: %v\", err)",
                "+\t}",
                "+\treturn n",
                "+}",
                "+",
                "+func (r *importReader) uint64() uint64 {",
                "+\tn, err := binary.ReadUvarint(&r.declReader)",
                "+\tif err != nil {",
                "+\t\terrorf(\"readUvarint: %v\", err)",
                "+\t}",
                "+\treturn n",
                "+}",
                "+",
                "+func (r *importReader) byte() byte {",
                "+\tx, err := r.declReader.ReadByte()",
                "+\tif err != nil {",
                "+\t\terrorf(\"declReader.ReadByte: %v\", err)",
                "+\t}",
                "+\treturn x",
                "+}",
                "diff --git a/vendor/golang.org/x/tools/go/internal/gcimporter/isAlias18.go b/vendor/golang.org/x/tools/go/internal/gcimporter/isAlias18.go",
                "new file mode 100644",
                "index 0000000..225ffee",
                "--- /dev/null",
                "+++ b/vendor/golang.org/x/tools/go/internal/gcimporter/isAlias18.go",
                "@@ -0,0 +1,13 @@",
                "+// Copyright 2017 The Go Authors. All rights reserved.",
                "+// Use of this source code is governed by a BSD-style",
                "+// license that can be found in the LICENSE file.",
                "+",
                "+// +build !go1.9",
                "+",
                "+package gcimporter",
                "+",
                "+import \"go/types\"",
                "+",
                "+func isAlias(obj *types.TypeName) bool {",
                "+\treturn false // there are no type aliases before Go 1.9",
                "+}",
                "diff --git a/vendor/golang.org/x/tools/go/internal/gcimporter/isAlias19.go b/vendor/golang.org/x/tools/go/internal/gcimporter/isAlias19.go",
                "new file mode 100644",
                "index 0000000..c2025d8",
                "--- /dev/null",
                "+++ b/vendor/golang.org/x/tools/go/internal/gcimporter/isAlias19.go",
                "@@ -0,0 +1,13 @@",
                "+// Copyright 2017 The Go Authors. All rights reserved.",
                "+// Use of this source code is governed by a BSD-style",
                "+// license that can be found in the LICENSE file.",
                "+",
                "+// +build go1.9",
                "+",
                "+package gcimporter",
                "+",
                "+import \"go/types\"",
                "+",
                "+func isAlias(obj *types.TypeName) bool {",
                "+\treturn obj.IsAlias()",
                "+}",
                "diff --git a/vendor/golang.org/x/tools/present/doc.go b/vendor/golang.org/x/tools/present/doc.go",
                "index e7f595e..3422294 100644",
                "--- a/vendor/golang.org/x/tools/present/doc.go",
                "+++ b/vendor/golang.org/x/tools/present/doc.go",
                "@@ -119,3 +119,3 @@ its simplest form to that of ed, but comes from sam and is more",
                " general. See",
                "-\thttp://plan9.bell-labs.com/sys/doc/sam/sam.html Table II",
                "+\thttps://plan9.io/sys/doc/sam/sam.html Table II",
                " for full details. The displayed block is always rounded out to a",
                "diff --git a/vendor/golang.org/x/tools/present/parse.go b/vendor/golang.org/x/tools/present/parse.go",
                "index d7289db..dd0f00b 100644",
                "--- a/vendor/golang.org/x/tools/present/parse.go",
                "+++ b/vendor/golang.org/x/tools/present/parse.go",
                "@@ -170,4 +170,13 @@ func renderElem(t *template.Template, e Elem) (template.HTML, error) {",
                "+// pageNum derives a page number from a section.",
                "+func pageNum(s Section, offset int) int {",
                "+\tif len(s.Number) == 0 {",
                "+\t\treturn offset",
                "+\t}",
                "+\treturn s.Number[0] + offset",
                "+}",
                "+",
                " func init() {",
                " \tfuncs[\"elem\"] = renderElem",
                "+\tfuncs[\"pagenum\"] = pageNum",
                " }",
                "diff --git a/vendor/google.golang.org/genproto/googleapis/iam/v1/iam_policy.pb.go b/vendor/google.golang.org/genproto/googleapis/iam/v1/iam_policy.pb.go",
                "new file mode 100644",
                "index 0000000..2f481a3",
                "--- /dev/null",
                "+++ b/vendor/google.golang.org/genproto/googleapis/iam/v1/iam_policy.pb.go",
                "@@ -0,0 +1,337 @@",
                "+// Code generated by protoc-gen-go. DO NOT EDIT.",
                "+// source: google/iam/v1/iam_policy.proto",
                "+",
                "+/*",
                "+Package iam is a generated protocol buffer package.",
                "+",
                "+It is generated from these files:",
                "+\tgoogle/iam/v1/iam_policy.proto",
                "+\tgoogle/iam/v1/policy.proto",
                "+",
                "+It has these top-level messages:",
                "+\tSetIamPolicyRequest",
                "+\tGetIamPolicyRequest",
                "+\tTestIamPermissionsRequest",
                "+\tTestIamPermissionsResponse",
                "+\tPolicy",
                "+\tBinding",
                "+\tPolicyDelta",
                "+\tBindingDelta",
                "+*/",
                "+package iam",
                "+",
                "+import proto \"github.com/golang/protobuf/proto\"",
                "+import fmt \"fmt\"",
                "+import math \"math\"",
                "+import _ \"google.golang.org/genproto/googleapis/api/annotations\"",
                "+",
                "+import (",
                "+\tcontext \"golang.org/x/net/context\"",
                "+\tgrpc \"google.golang.org/grpc\"",
                "+)",
                "+",
                "+// Reference imports to suppress errors if they are not otherwise used.",
                "+var _ = proto.Marshal",
                "+var _ = fmt.Errorf",
                "+var _ = math.Inf",
                "+",
                "+// This is a compile-time assertion to ensure that this generated file",
                "+// is compatible with the proto package it is being compiled against.",
                "+// A compilation error at this line likely means your copy of the",
                "+// proto package needs to be updated.",
                "+const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package",
                "+",
                "+// Request message for `SetIamPolicy` method.",
                "+type SetIamPolicyRequest struct {",
                "+\t// REQUIRED: The resource for which the policy is being specified.",
                "+\t// `resource` is usually specified as a path. For example, a Project",
                "+\t// resource is specified as `projects/{project}`.",
                "+\tResource string `protobuf:\"bytes,1,opt,name=resource\" json:\"resource,omitempty\"`",
                "+\t// REQUIRED: The complete policy to be applied to the `resource`. The size of",
                "+\t// the policy is limited to a few 10s of KB. An empty policy is a",
                "+\t// valid policy but certain Cloud Platform services (such as Projects)",
                "+\t// might reject them.",
                "+\tPolicy *Policy `protobuf:\"bytes,2,opt,name=policy\" json:\"policy,omitempty\"`",
                "+}",
                "+",
                "+func (m *SetIamPolicyRequest) Reset()                    { *m = SetIamPolicyRequest{} }",
                "+func (m *SetIamPolicyRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*SetIamPolicyRequest) ProtoMessage()               {}",
                "+func (*SetIamPolicyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }",
                "+",
                "+func (m *SetIamPolicyRequest) GetResource() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Resource",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *SetIamPolicyRequest) GetPolicy() *Policy {",
                "+\tif m != nil {",
                "+\t\treturn m.Policy",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Request message for `GetIamPolicy` method.",
                "+type GetIamPolicyRequest struct {",
                "+\t// REQUIRED: The resource for which the policy is being requested.",
                "+\t// `resource` is usually specified as a path. For example, a Project",
                "+\t// resource is specified as `projects/{project}`.",
                "+\tResource string `protobuf:\"bytes,1,opt,name=resource\" json:\"resource,omitempty\"`",
                "+}",
                "+",
                "+func (m *GetIamPolicyRequest) Reset()                    { *m = GetIamPolicyRequest{} }",
                "+func (m *GetIamPolicyRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*GetIamPolicyRequest) ProtoMessage()               {}",
                "+func (*GetIamPolicyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }",
                "+",
                "+func (m *GetIamPolicyRequest) GetResource() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Resource",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Request message for `TestIamPermissions` method.",
                "+type TestIamPermissionsRequest struct {",
                "+\t// REQUIRED: The resource for which the policy detail is being requested.",
                "+\t// `resource` is usually specified as a path. For example, a Project",
                "+\t// resource is specified as `projects/{project}`.",
                "+\tResource string `protobuf:\"bytes,1,opt,name=resource\" json:\"resource,omitempty\"`",
                "+\t// The set of permissions to check for the `resource`. Permissions with",
                "+\t// wildcards (such as '*' or 'storage.*') are not allowed. For more",
                "+\t// information see",
                "+\t// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).",
                "+\tPermissions []string `protobuf:\"bytes,2,rep,name=permissions\" json:\"permissions,omitempty\"`",
                "+}",
                "+",
                "+func (m *TestIamPermissionsRequest) Reset()                    { *m = TestIamPermissionsRequest{} }",
                "+func (m *TestIamPermissionsRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*TestIamPermissionsRequest) ProtoMessage()               {}",
                "+func (*TestIamPermissionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }",
                "+",
                "+func (m *TestIamPermissionsRequest) GetResource() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Resource",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *TestIamPermissionsRequest) GetPermissions() []string {",
                "+\tif m != nil {",
                "+\t\treturn m.Permissions",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Response message for `TestIamPermissions` method.",
                "+type TestIamPermissionsResponse struct {",
                "+\t// A subset of `TestPermissionsRequest.permissions` that the caller is",
                "+\t// allowed.",
                "+\tPermissions []string `protobuf:\"bytes,1,rep,name=permissions\" json:\"permissions,omitempty\"`",
                "+}",
                "+",
                "+func (m *TestIamPermissionsResponse) Reset()                    { *m = TestIamPermissionsResponse{} }",
                "+func (m *TestIamPermissionsResponse) String() string            { return proto.CompactTextString(m) }",
                "+func (*TestIamPermissionsResponse) ProtoMessage()               {}",
                "+func (*TestIamPermissionsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }",
                "+",
                "+func (m *TestIamPermissionsResponse) GetPermissions() []string {",
                "+\tif m != nil {",
                "+\t\treturn m.Permissions",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func init() {",
                "+\tproto.RegisterType((*SetIamPolicyRequest)(nil), \"google.iam.v1.SetIamPolicyRequest\")",
                "+\tproto.RegisterType((*GetIamPolicyRequest)(nil), \"google.iam.v1.GetIamPolicyRequest\")",
                "+\tproto.RegisterType((*TestIamPermissionsRequest)(nil), \"google.iam.v1.TestIamPermissionsRequest\")",
                "+\tproto.RegisterType((*TestIamPermissionsResponse)(nil), \"google.iam.v1.TestIamPermissionsResponse\")",
                "+}",
                "+",
                "+// Reference imports to suppress errors if they are not otherwise used.",
                "+var _ context.Context",
                "+var _ grpc.ClientConn",
                "+",
                "+// This is a compile-time assertion to ensure that this generated file",
                "+// is compatible with the grpc package it is being compiled against.",
                "+const _ = grpc.SupportPackageIsVersion4",
                "+",
                "+// Client API for IAMPolicy service",
                "+",
                "+type IAMPolicyClient interface {",
                "+\t// Sets the access control policy on the specified resource. Replaces any",
                "+\t// existing policy.",
                "+\tSetIamPolicy(ctx context.Context, in *SetIamPolicyRequest, opts ...grpc.CallOption) (*Policy, error)",
                "+\t// Gets the access control policy for a resource.",
                "+\t// Returns an empty policy if the resource exists and does not have a policy",
                "+\t// set.",
                "+\tGetIamPolicy(ctx context.Context, in *GetIamPolicyRequest, opts ...grpc.CallOption) (*Policy, error)",
                "+\t// Returns permissions that a caller has on the specified resource.",
                "+\t// If the resource does not exist, this will return an empty set of",
                "+\t// permissions, not a NOT_FOUND error.",
                "+\tTestIamPermissions(ctx context.Context, in *TestIamPermissionsRequest, opts ...grpc.CallOption) (*TestIamPermissionsResponse, error)",
                "+}",
                "+",
                "+type iAMPolicyClient struct {",
                "+\tcc *grpc.ClientConn",
                "+}",
                "+",
                "+func NewIAMPolicyClient(cc *grpc.ClientConn) IAMPolicyClient {",
                "+\treturn &iAMPolicyClient{cc}",
                "+}",
                "+",
                "+func (c *iAMPolicyClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyRequest, opts ...grpc.CallOption) (*Policy, error) {",
                "+\tout := new(Policy)",
                "+\terr := grpc.Invoke(ctx, \"/google.iam.v1.IAMPolicy/SetIamPolicy\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *iAMPolicyClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyRequest, opts ...grpc.CallOption) (*Policy, error) {",
                "+\tout := new(Policy)",
                "+\terr := grpc.Invoke(ctx, \"/google.iam.v1.IAMPolicy/GetIamPolicy\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *iAMPolicyClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsRequest, opts ...grpc.CallOption) (*TestIamPermissionsResponse, error) {",
                "+\tout := new(TestIamPermissionsResponse)",
                "+\terr := grpc.Invoke(ctx, \"/google.iam.v1.IAMPolicy/TestIamPermissions\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+// Server API for IAMPolicy service",
                "+",
                "+type IAMPolicyServer interface {",
                "+\t// Sets the access control policy on the specified resource. Replaces any",
                "+\t// existing policy.",
                "+\tSetIamPolicy(context.Context, *SetIamPolicyRequest) (*Policy, error)",
                "+\t// Gets the access control policy for a resource.",
                "+\t// Returns an empty policy if the resource exists and does not have a policy",
                "+\t// set.",
                "+\tGetIamPolicy(context.Context, *GetIamPolicyRequest) (*Policy, error)",
                "+\t// Returns permissions that a caller has on the specified resource.",
                "+\t// If the resource does not exist, this will return an empty set of",
                "+\t// permissions, not a NOT_FOUND error.",
                "+\tTestIamPermissions(context.Context, *TestIamPermissionsRequest) (*TestIamPermissionsResponse, error)",
                "+}",
                "+",
                "+func RegisterIAMPolicyServer(s *grpc.Server, srv IAMPolicyServer) {",
                "+\ts.RegisterService(&_IAMPolicy_serviceDesc, srv)",
                "+}",
                "+",
                "+func _IAMPolicy_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(SetIamPolicyRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(IAMPolicyServer).SetIamPolicy(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.iam.v1.IAMPolicy/SetIamPolicy\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(IAMPolicyServer).SetIamPolicy(ctx, req.(*SetIamPolicyRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _IAMPolicy_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(GetIamPolicyRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(IAMPolicyServer).GetIamPolicy(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.iam.v1.IAMPolicy/GetIamPolicy\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(IAMPolicyServer).GetIamPolicy(ctx, req.(*GetIamPolicyRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _IAMPolicy_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(TestIamPermissionsRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(IAMPolicyServer).TestIamPermissions(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.iam.v1.IAMPolicy/TestIamPermissions\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(IAMPolicyServer).TestIamPermissions(ctx, req.(*TestIamPermissionsRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+var _IAMPolicy_serviceDesc = grpc.ServiceDesc{",
                "+\tServiceName: \"google.iam.v1.IAMPolicy\",",
                "+\tHandlerType: (*IAMPolicyServer)(nil),",
                "+\tMethods: []grpc.MethodDesc{",
                "+\t\t{",
                "+\t\t\tMethodName: \"SetIamPolicy\",",
                "+\t\t\tHandler:    _IAMPolicy_SetIamPolicy_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"GetIamPolicy\",",
                "+\t\t\tHandler:    _IAMPolicy_GetIamPolicy_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"TestIamPermissions\",",
                "+\t\t\tHandler:    _IAMPolicy_TestIamPermissions_Handler,",
                "+\t\t},",
                "+\t},",
                "+\tStreams:  []grpc.StreamDesc{},",
                "+\tMetadata: \"google/iam/v1/iam_policy.proto\",",
                "+}",
                "+",
                "+func init() { proto.RegisterFile(\"google/iam/v1/iam_policy.proto\", fileDescriptor0) }",
                "+",
                "+var fileDescriptor0 = []byte{",
                "+\t// 396 bytes of a gzipped FileDescriptorProto",
                "+\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0xcf, 0x4a, 0xe3, 0x40,",
                "+\t0x18, 0x67, 0x52, 0x28, 0xdb, 0xe9, 0xee, 0xc2, 0xa6, 0x2c, 0xd4, 0x20, 0x25, 0x8c, 0x1e, 0xd2,",
                "+\t0x80, 0x13, 0x53, 0x6f, 0x15, 0x05, 0xeb, 0x21, 0xf4, 0x20, 0x94, 0x2a, 0x82, 0x5e, 0x74, 0xac,",
                "+\t0x43, 0x18, 0x48, 0x32, 0x31, 0x33, 0x2d, 0x88, 0x78, 0xf1, 0x15, 0xf4, 0xe4, 0x23, 0xf8, 0x3a,",
                "+\t0xbe, 0x82, 0x0f, 0xe1, 0x51, 0x92, 0x89, 0x35, 0x6d, 0xaa, 0x54, 0xf0, 0x54, 0x3a, 0xf3, 0xfb,",
                "+\t0xf7, 0xfd, 0xbe, 0x0c, 0x6c, 0xf9, 0x9c, 0xfb, 0x01, 0x75, 0x18, 0x09, 0x9d, 0x89, 0x9b, 0xfe,",
                "+\t0x9c, 0xc5, 0x3c, 0x60, 0xa3, 0x6b, 0x1c, 0x27, 0x5c, 0x72, 0xfd, 0x8f, 0xba, 0xc7, 0x8c, 0x84,",
                "+\t0x78, 0xe2, 0x1a, 0xab, 0x39, 0x9c, 0xc4, 0xcc, 0x21, 0x51, 0xc4, 0x25, 0x91, 0x8c, 0x47, 0x42,",
                "+\t0x81, 0x0d, 0x63, 0x56, 0xac, 0x28, 0x84, 0xce, 0x61, 0xe3, 0x90, 0xca, 0x3e, 0x09, 0x07, 0xd9,",
                "+\t0xe9, 0x90, 0x5e, 0x8d, 0xa9, 0x90, 0xba, 0x01, 0x7f, 0x25, 0x54, 0xf0, 0x71, 0x32, 0xa2, 0x4d,",
                "+\t0x60, 0x02, 0xab, 0x36, 0x9c, 0xfe, 0xd7, 0x37, 0x60, 0x55, 0x49, 0x34, 0x35, 0x13, 0x58, 0xf5,",
                "+\t0xce, 0x7f, 0x3c, 0x13, 0x06, 0xe7, 0x4a, 0x39, 0x08, 0xb9, 0xb0, 0xe1, 0x7d, 0xcf, 0x01, 0x9d,",
                "+\t0xc0, 0x95, 0x23, 0x2a, 0x32, 0x0e, 0x4d, 0x42, 0x26, 0x44, 0x3a, 0xcc, 0x32, 0xd1, 0x4c, 0x58,",
                "+\t0x8f, 0x3f, 0x18, 0x4d, 0xcd, 0xac, 0x58, 0xb5, 0x61, 0xf1, 0x08, 0xed, 0x42, 0x63, 0x91, 0xb4,",
                "+\t0x88, 0x79, 0x24, 0x4a, 0x7c, 0x50, 0xe2, 0x77, 0x1e, 0x2a, 0xb0, 0xd6, 0xdf, 0x3b, 0x50, 0xb3,",
                "+\t0xe8, 0x12, 0xfe, 0x2e, 0xb6, 0xa7, 0xa3, 0xb9, 0x2a, 0x16, 0x54, 0x6b, 0x2c, 0xae, 0x0b, 0xb5,",
                "+\t0xef, 0x9e, 0x5f, 0xee, 0xb5, 0x35, 0xd4, 0x4a, 0x57, 0x74, 0xf3, 0x3e, 0xd1, 0x8e, 0x6d, 0xdf,",
                "+\t0x76, 0x45, 0x41, 0xa5, 0x0b, 0xec, 0xd4, 0xd5, 0xfb, 0xca, 0xd5, 0xfb, 0x11, 0x57, 0x7f, 0xce,",
                "+\t0xf5, 0x11, 0x40, 0xbd, 0x5c, 0x9d, 0x6e, 0xcd, 0x09, 0x7f, 0xba, 0x38, 0xa3, 0xbd, 0x04, 0x52,",
                "+\t0xed, 0x01, 0x39, 0x59, 0xac, 0x36, 0x5a, 0x2f, 0xc7, 0x92, 0x25, 0x56, 0x17, 0xd8, 0xbd, 0x18,",
                "+\t0xfe, 0x1b, 0xf1, 0x70, 0xd6, 0xa0, 0xf7, 0x77, 0x9a, 0x7f, 0x90, 0x7e, 0xeb, 0x03, 0x70, 0xba,",
                "+\t0x99, 0x03, 0x7c, 0x1e, 0x90, 0xc8, 0xc7, 0x3c, 0xf1, 0x1d, 0x9f, 0x46, 0xd9, 0x4b, 0x70, 0xd4,",
                "+\t0x15, 0x89, 0x99, 0xc8, 0x1f, 0xca, 0x36, 0x23, 0xe1, 0x2b, 0x00, 0x4f, 0x5a, 0xc3, 0x53, 0xac,",
                "+\t0xfd, 0x80, 0x8f, 0x2f, 0x71, 0x9f, 0x84, 0xf8, 0xd8, 0xbd, 0xa8, 0x66, 0xac, 0xad, 0xb7, 0x00,",
                "+\t0x00, 0x00, 0xff, 0xff, 0x6c, 0x3a, 0x2b, 0x4d, 0xaa, 0x03, 0x00, 0x00,",
                "+}",
                "diff --git a/vendor/google.golang.org/genproto/googleapis/iam/v1/policy.pb.go b/vendor/google.golang.org/genproto/googleapis/iam/v1/policy.pb.go",
                "new file mode 100644",
                "index 0000000..a22ae91",
                "--- /dev/null",
                "+++ b/vendor/google.golang.org/genproto/googleapis/iam/v1/policy.pb.go",
                "@@ -0,0 +1,269 @@",
                "+// Code generated by protoc-gen-go. DO NOT EDIT.",
                "+// source: google/iam/v1/policy.proto",
                "+",
                "+package iam",
                "+",
                "+import proto \"github.com/golang/protobuf/proto\"",
                "+import fmt \"fmt\"",
                "+import math \"math\"",
                "+import _ \"google.golang.org/genproto/googleapis/api/annotations\"",
                "+",
                "+// Reference imports to suppress errors if they are not otherwise used.",
                "+var _ = proto.Marshal",
                "+var _ = fmt.Errorf",
                "+var _ = math.Inf",
                "+",
                "+// The type of action performed on a Binding in a policy.",
                "+type BindingDelta_Action int32",
                "+",
                "+const (",
                "+\t// Unspecified.",
                "+\tBindingDelta_ACTION_UNSPECIFIED BindingDelta_Action = 0",
                "+\t// Addition of a Binding.",
                "+\tBindingDelta_ADD BindingDelta_Action = 1",
                "+\t// Removal of a Binding.",
                "+\tBindingDelta_REMOVE BindingDelta_Action = 2",
                "+)",
                "+",
                "+var BindingDelta_Action_name = map[int32]string{",
                "+\t0: \"ACTION_UNSPECIFIED\",",
                "+\t1: \"ADD\",",
                "+\t2: \"REMOVE\",",
                "+}",
                "+var BindingDelta_Action_value = map[string]int32{",
                "+\t\"ACTION_UNSPECIFIED\": 0,",
                "+\t\"ADD\":                1,",
                "+\t\"REMOVE\":             2,",
                "+}",
                "+",
                "+func (x BindingDelta_Action) String() string {",
                "+\treturn proto.EnumName(BindingDelta_Action_name, int32(x))",
                "+}",
                "+func (BindingDelta_Action) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{3, 0} }",
                "+",
                "+// Defines an Identity and Access Management (IAM) policy. It is used to",
                "+// specify access control policies for Cloud Platform resources.",
                "+//",
                "+//",
                "+// A `Policy` consists of a list of `bindings`. A `Binding` binds a list of",
                "+// `members` to a `role`, where the members can be user accounts, Google groups,",
                "+// Google domains, and service accounts. A `role` is a named list of permissions",
                "+// defined by IAM.",
                "+//",
                "+// **Example**",
                "+//",
                "+//     {",
                "+//       \"bindings\": [",
                "+//         {",
                "+//           \"role\": \"roles/owner\",",
                "+//           \"members\": [",
                "+//             \"user:mike@example.com\",",
                "+//             \"group:admins@example.com\",",
                "+//             \"domain:google.com\",",
                "+//             \"serviceAccount:my-other-app@appspot.gserviceaccount.com\",",
                "+//           ]",
                "+//         },",
                "+//         {",
                "+//           \"role\": \"roles/viewer\",",
                "+//           \"members\": [\"user:sean@example.com\"]",
                "+//         }",
                "+//       ]",
                "+//     }",
                "+//",
                "+// For a description of IAM and its features, see the",
                "+// [IAM developer's guide](https://cloud.google.com/iam).",
                "+type Policy struct {",
                "+\t// Version of the `Policy`. The default version is 0.",
                "+\tVersion int32 `protobuf:\"varint,1,opt,name=version\" json:\"version,omitempty\"`",
                "+\t// Associates a list of `members` to a `role`.",
                "+\t// Multiple `bindings` must not be specified for the same `role`.",
                "+\t// `bindings` with no members will result in an error.",
                "+\tBindings []*Binding `protobuf:\"bytes,4,rep,name=bindings\" json:\"bindings,omitempty\"`",
                "+\t// `etag` is used for optimistic concurrency control as a way to help",
                "+\t// prevent simultaneous updates of a policy from overwriting each other.",
                "+\t// It is strongly suggested that systems make use of the `etag` in the",
                "+\t// read-modify-write cycle to perform policy updates in order to avoid race",
                "+\t// conditions: An `etag` is returned in the response to `getIamPolicy`, and",
                "+\t// systems are expected to put that etag in the request to `setIamPolicy` to",
                "+\t// ensure that their change will be applied to the same version of the policy.",
                "+\t//",
                "+\t// If no `etag` is provided in the call to `setIamPolicy`, then the existing",
                "+\t// policy is overwritten blindly.",
                "+\tEtag []byte `protobuf:\"bytes,3,opt,name=etag,proto3\" json:\"etag,omitempty\"`",
                "+}",
                "+",
                "+func (m *Policy) Reset()                    { *m = Policy{} }",
                "+func (m *Policy) String() string            { return proto.CompactTextString(m) }",
                "+func (*Policy) ProtoMessage()               {}",
                "+func (*Policy) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }",
                "+",
                "+func (m *Policy) GetVersion() int32 {",
                "+\tif m != nil {",
                "+\t\treturn m.Version",
                "+\t}",
                "+\treturn 0",
                "+}",
                "+",
                "+func (m *Policy) GetBindings() []*Binding {",
                "+\tif m != nil {",
                "+\t\treturn m.Bindings",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *Policy) GetEtag() []byte {",
                "+\tif m != nil {",
                "+\t\treturn m.Etag",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Associates `members` with a `role`.",
                "+type Binding struct {",
                "+\t// Role that is assigned to `members`.",
                "+\t// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.",
                "+\t// Required",
                "+\tRole string `protobuf:\"bytes,1,opt,name=role\" json:\"role,omitempty\"`",
                "+\t// Specifies the identities requesting access for a Cloud Platform resource.",
                "+\t// `members` can have the following values:",
                "+\t//",
                "+\t// * `allUsers`: A special identifier that represents anyone who is",
                "+\t//    on the internet; with or without a Google account.",
                "+\t//",
                "+\t// * `allAuthenticatedUsers`: A special identifier that represents anyone",
                "+\t//    who is authenticated with a Google account or a service account.",
                "+\t//",
                "+\t// * `user:{emailid}`: An email address that represents a specific Google",
                "+\t//    account. For example, `alice@gmail.com` or `joe@example.com`.",
                "+\t//",
                "+\t//",
                "+\t// * `serviceAccount:{emailid}`: An email address that represents a service",
                "+\t//    account. For example, `my-other-app@appspot.gserviceaccount.com`.",
                "+\t//",
                "+\t// * `group:{emailid}`: An email address that represents a Google group.",
                "+\t//    For example, `admins@example.com`.",
                "+\t//",
                "+\t// * `domain:{domain}`: A Google Apps domain name that represents all the",
                "+\t//    users of that domain. For example, `google.com` or `example.com`.",
                "+\t//",
                "+\t//",
                "+\tMembers []string `protobuf:\"bytes,2,rep,name=members\" json:\"members,omitempty\"`",
                "+}",
                "+",
                "+func (m *Binding) Reset()                    { *m = Binding{} }",
                "+func (m *Binding) String() string            { return proto.CompactTextString(m) }",
                "+func (*Binding) ProtoMessage()               {}",
                "+func (*Binding) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }",
                "+",
                "+func (m *Binding) GetRole() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Role",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *Binding) GetMembers() []string {",
                "+\tif m != nil {",
                "+\t\treturn m.Members",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// The difference delta between two policies.",
                "+type PolicyDelta struct {",
                "+\t// The delta for Bindings between two policies.",
                "+\tBindingDeltas []*BindingDelta `protobuf:\"bytes,1,rep,name=binding_deltas,json=bindingDeltas\" json:\"binding_deltas,omitempty\"`",
                "+}",
                "+",
                "+func (m *PolicyDelta) Reset()                    { *m = PolicyDelta{} }",
                "+func (m *PolicyDelta) String() string            { return proto.CompactTextString(m) }",
                "+func (*PolicyDelta) ProtoMessage()               {}",
                "+func (*PolicyDelta) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }",
                "+",
                "+func (m *PolicyDelta) GetBindingDeltas() []*BindingDelta {",
                "+\tif m != nil {",
                "+\t\treturn m.BindingDeltas",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// One delta entry for Binding. Each individual change (only one member in each",
                "+// entry) to a binding will be a separate entry.",
                "+type BindingDelta struct {",
                "+\t// The action that was performed on a Binding.",
                "+\t// Required",
                "+\tAction BindingDelta_Action `protobuf:\"varint,1,opt,name=action,enum=google.iam.v1.BindingDelta_Action\" json:\"action,omitempty\"`",
                "+\t// Role that is assigned to `members`.",
                "+\t// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.",
                "+\t// Required",
                "+\tRole string `protobuf:\"bytes,2,opt,name=role\" json:\"role,omitempty\"`",
                "+\t// A single identity requesting access for a Cloud Platform resource.",
                "+\t// Follows the same format of Binding.members.",
                "+\t// Required",
                "+\tMember string `protobuf:\"bytes,3,opt,name=member\" json:\"member,omitempty\"`",
                "+}",
                "+",
                "+func (m *BindingDelta) Reset()                    { *m = BindingDelta{} }",
                "+func (m *BindingDelta) String() string            { return proto.CompactTextString(m) }",
                "+func (*BindingDelta) ProtoMessage()               {}",
                "+func (*BindingDelta) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }",
                "+",
                "+func (m *BindingDelta) GetAction() BindingDelta_Action {",
                "+\tif m != nil {",
                "+\t\treturn m.Action",
                "+\t}",
                "+\treturn BindingDelta_ACTION_UNSPECIFIED",
                "+}",
                "+",
                "+func (m *BindingDelta) GetRole() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Role",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *BindingDelta) GetMember() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Member",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func init() {",
                "+\tproto.RegisterType((*Policy)(nil), \"google.iam.v1.Policy\")",
                "+\tproto.RegisterType((*Binding)(nil), \"google.iam.v1.Binding\")",
                "+\tproto.RegisterType((*PolicyDelta)(nil), \"google.iam.v1.PolicyDelta\")",
                "+\tproto.RegisterType((*BindingDelta)(nil), \"google.iam.v1.BindingDelta\")",
                "+\tproto.RegisterEnum(\"google.iam.v1.BindingDelta_Action\", BindingDelta_Action_name, BindingDelta_Action_value)",
                "+}",
                "+",
                "+func init() { proto.RegisterFile(\"google/iam/v1/policy.proto\", fileDescriptor1) }",
                "+",
                "+var fileDescriptor1 = []byte{",
                "+\t// 387 bytes of a gzipped FileDescriptorProto",
                "+\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x52, 0x4d, 0x8f, 0xd3, 0x30,",
                "+\t0x10, 0xc5, 0xed, 0x92, 0xd2, 0xd9, 0x0f, 0x15, 0x23, 0x55, 0xd1, 0xc2, 0xa1, 0xca, 0x29, 0x27,",
                "+\t0x87, 0x16, 0x21, 0x24, 0x38, 0x35, 0x4d, 0x40, 0x39, 0xb0, 0x1b, 0x0c, 0xec, 0x81, 0xcb, 0xca,",
                "+\t0x69, 0x2d, 0xcb, 0x28, 0xb6, 0xa3, 0x24, 0x54, 0xe2, 0x2f, 0x21, 0xf1, 0xff, 0x38, 0xa2, 0xd8,",
                "+\t0xee, 0xaa, 0x95, 0x10, 0xb7, 0x79, 0x79, 0xef, 0x65, 0xde, 0xcc, 0x18, 0xae, 0x85, 0x31, 0xa2,",
                "+\t0xe6, 0x89, 0x64, 0x2a, 0xd9, 0x2f, 0x93, 0xc6, 0xd4, 0x72, 0xfb, 0x93, 0x34, 0xad, 0xe9, 0x0d,",
                "+\t0xbe, 0x74, 0x1c, 0x91, 0x4c, 0x91, 0xfd, 0xf2, 0xfa, 0x85, 0x97, 0xb2, 0x46, 0x26, 0x4c, 0x6b,",
                "+\t0xd3, 0xb3, 0x5e, 0x1a, 0xdd, 0x39, 0x71, 0xf4, 0x1d, 0x82, 0xd2, 0x9a, 0x71, 0x08, 0x93, 0x3d,",
                "+\t0x6f, 0x3b, 0x69, 0x74, 0x88, 0x16, 0x28, 0x7e, 0x4c, 0x0f, 0x10, 0xaf, 0xe0, 0x49, 0x25, 0xf5,",
                "+\t0x4e, 0x6a, 0xd1, 0x85, 0x67, 0x8b, 0x71, 0x7c, 0xbe, 0x9a, 0x93, 0x93, 0x1e, 0x24, 0x75, 0x34,",
                "+\t0x7d, 0xd0, 0x61, 0x0c, 0x67, 0xbc, 0x67, 0x22, 0x1c, 0x2f, 0x50, 0x7c, 0x41, 0x6d, 0x1d, 0xbd,",
                "+\t0x81, 0x89, 0x17, 0x0e, 0x74, 0x6b, 0x6a, 0x6e, 0x3b, 0x4d, 0xa9, 0xad, 0x87, 0x00, 0x8a, 0xab,",
                "+\t0x8a, 0xb7, 0x5d, 0x38, 0x5a, 0x8c, 0xe3, 0x29, 0x3d, 0xc0, 0xe8, 0x13, 0x9c, 0xbb, 0x90, 0x19,",
                "+\t0xaf, 0x7b, 0x86, 0x53, 0xb8, 0xf2, 0x7d, 0xee, 0x77, 0xc3, 0x87, 0x2e, 0x44, 0x36, 0xd5, 0xf3,",
                "+\t0x7f, 0xa7, 0xb2, 0x26, 0x7a, 0x59, 0x1d, 0xa1, 0x2e, 0xfa, 0x8d, 0xe0, 0xe2, 0x98, 0xc7, 0x6f,",
                "+\t0x21, 0x60, 0xdb, 0xfe, 0x30, 0xfd, 0xd5, 0x2a, 0xfa, 0xcf, 0xcf, 0xc8, 0xda, 0x2a, 0xa9, 0x77,",
                "+\t0x3c, 0x4c, 0x33, 0x3a, 0x9a, 0x66, 0x0e, 0x81, 0x8b, 0x6f, 0x57, 0x30, 0xa5, 0x1e, 0x45, 0xaf,",
                "+\t0x21, 0x70, 0x6e, 0x3c, 0x07, 0xbc, 0xde, 0x7c, 0x29, 0x6e, 0x6f, 0xee, 0xbf, 0xde, 0x7c, 0x2e,",
                "+\t0xf3, 0x4d, 0xf1, 0xbe, 0xc8, 0xb3, 0xd9, 0x23, 0x3c, 0x81, 0xf1, 0x3a, 0xcb, 0x66, 0x08, 0x03,",
                "+\t0x04, 0x34, 0xff, 0x78, 0x7b, 0x97, 0xcf, 0x46, 0xa9, 0x82, 0xa7, 0x5b, 0xa3, 0x4e, 0x33, 0xa5,",
                "+\t0x7e, 0x2b, 0xe5, 0x70, 0xc9, 0x12, 0x7d, 0x7b, 0xe9, 0x59, 0x61, 0x6a, 0xa6, 0x05, 0x31, 0xad,",
                "+\t0x48, 0x04, 0xd7, 0xf6, 0xce, 0x89, 0xa3, 0x58, 0x23, 0x3b, 0xff, 0x66, 0xde, 0x49, 0xa6, 0xfe,",
                "+\t0x20, 0xf4, 0x6b, 0xf4, 0xec, 0x83, 0x73, 0x6d, 0x6a, 0xf3, 0x63, 0x47, 0x0a, 0xa6, 0xc8, 0xdd,",
                "+\t0xb2, 0x0a, 0xac, 0xeb, 0xd5, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8c, 0x4a, 0x85, 0x10, 0x68,",
                "+\t0x02, 0x00, 0x00,",
                "+}",
                "diff --git a/vendor/google.golang.org/genproto/googleapis/pubsub/v1/pubsub.pb.go b/vendor/google.golang.org/genproto/googleapis/pubsub/v1/pubsub.pb.go",
                "new file mode 100644",
                "index 0000000..ab4768d",
                "--- /dev/null",
                "+++ b/vendor/google.golang.org/genproto/googleapis/pubsub/v1/pubsub.pb.go",
                "@@ -0,0 +1,2523 @@",
                "+// Code generated by protoc-gen-go. DO NOT EDIT.",
                "+// source: google/pubsub/v1/pubsub.proto",
                "+",
                "+/*",
                "+Package pubsub is a generated protocol buffer package.",
                "+",
                "+It is generated from these files:",
                "+\tgoogle/pubsub/v1/pubsub.proto",
                "+",
                "+It has these top-level messages:",
                "+\tTopic",
                "+\tPubsubMessage",
                "+\tGetTopicRequest",
                "+\tUpdateTopicRequest",
                "+\tPublishRequest",
                "+\tPublishResponse",
                "+\tListTopicsRequest",
                "+\tListTopicsResponse",
                "+\tListTopicSubscriptionsRequest",
                "+\tListTopicSubscriptionsResponse",
                "+\tDeleteTopicRequest",
                "+\tSubscription",
                "+\tPushConfig",
                "+\tReceivedMessage",
                "+\tGetSubscriptionRequest",
                "+\tUpdateSubscriptionRequest",
                "+\tListSubscriptionsRequest",
                "+\tListSubscriptionsResponse",
                "+\tDeleteSubscriptionRequest",
                "+\tModifyPushConfigRequest",
                "+\tPullRequest",
                "+\tPullResponse",
                "+\tModifyAckDeadlineRequest",
                "+\tAcknowledgeRequest",
                "+\tStreamingPullRequest",
                "+\tStreamingPullResponse",
                "+\tCreateSnapshotRequest",
                "+\tUpdateSnapshotRequest",
                "+\tSnapshot",
                "+\tListSnapshotsRequest",
                "+\tListSnapshotsResponse",
                "+\tDeleteSnapshotRequest",
                "+\tSeekRequest",
                "+\tSeekResponse",
                "+*/",
                "+package pubsub",
                "+",
                "+import proto \"github.com/golang/protobuf/proto\"",
                "+import fmt \"fmt\"",
                "+import math \"math\"",
                "+import _ \"google.golang.org/genproto/googleapis/api/annotations\"",
                "+import google_protobuf1 \"github.com/golang/protobuf/ptypes/duration\"",
                "+import google_protobuf2 \"github.com/golang/protobuf/ptypes/empty\"",
                "+import google_protobuf3 \"google.golang.org/genproto/protobuf/field_mask\"",
                "+import google_protobuf4 \"github.com/golang/protobuf/ptypes/timestamp\"",
                "+",
                "+import (",
                "+\tcontext \"golang.org/x/net/context\"",
                "+\tgrpc \"google.golang.org/grpc\"",
                "+)",
                "+",
                "+// Reference imports to suppress errors if they are not otherwise used.",
                "+var _ = proto.Marshal",
                "+var _ = fmt.Errorf",
                "+var _ = math.Inf",
                "+",
                "+// This is a compile-time assertion to ensure that this generated file",
                "+// is compatible with the proto package it is being compiled against.",
                "+// A compilation error at this line likely means your copy of the",
                "+// proto package needs to be updated.",
                "+const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package",
                "+",
                "+// A topic resource.",
                "+type Topic struct {",
                "+\t// The name of the topic. It must have the format",
                "+\t// `\"projects/{project}/topics/{topic}\"`. `{topic}` must start with a letter,",
                "+\t// and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),",
                "+\t// underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent",
                "+\t// signs (`%`). It must be between 3 and 255 characters in length, and it",
                "+\t// must not start with `\"goog\"`.",
                "+\tName string `protobuf:\"bytes,1,opt,name=name\" json:\"name,omitempty\"`",
                "+\t// User labels.",
                "+\tLabels map[string]string `protobuf:\"bytes,2,rep,name=labels\" json:\"labels,omitempty\" protobuf_key:\"bytes,1,opt,name=key\" protobuf_val:\"bytes,2,opt,name=value\"`",
                "+}",
                "+",
                "+func (m *Topic) Reset()                    { *m = Topic{} }",
                "+func (m *Topic) String() string            { return proto.CompactTextString(m) }",
                "+func (*Topic) ProtoMessage()               {}",
                "+func (*Topic) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }",
                "+",
                "+func (m *Topic) GetName() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Name",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *Topic) GetLabels() map[string]string {",
                "+\tif m != nil {",
                "+\t\treturn m.Labels",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// A message data and its attributes. The message payload must not be empty;",
                "+// it must contain either a non-empty data field, or at least one attribute.",
                "+type PubsubMessage struct {",
                "+\t// The message payload.",
                "+\tData []byte `protobuf:\"bytes,1,opt,name=data,proto3\" json:\"data,omitempty\"`",
                "+\t// Optional attributes for this message.",
                "+\tAttributes map[string]string `protobuf:\"bytes,2,rep,name=attributes\" json:\"attributes,omitempty\" protobuf_key:\"bytes,1,opt,name=key\" protobuf_val:\"bytes,2,opt,name=value\"`",
                "+\t// ID of this message, assigned by the server when the message is published.",
                "+\t// Guaranteed to be unique within the topic. This value may be read by a",
                "+\t// subscriber that receives a `PubsubMessage` via a `Pull` call or a push",
                "+\t// delivery. It must not be populated by the publisher in a `Publish` call.",
                "+\tMessageId string `protobuf:\"bytes,3,opt,name=message_id,json=messageId\" json:\"message_id,omitempty\"`",
                "+\t// The time at which the message was published, populated by the server when",
                "+\t// it receives the `Publish` call. It must not be populated by the",
                "+\t// publisher in a `Publish` call.",
                "+\tPublishTime *google_protobuf4.Timestamp `protobuf:\"bytes,4,opt,name=publish_time,json=publishTime\" json:\"publish_time,omitempty\"`",
                "+}",
                "+",
                "+func (m *PubsubMessage) Reset()                    { *m = PubsubMessage{} }",
                "+func (m *PubsubMessage) String() string            { return proto.CompactTextString(m) }",
                "+func (*PubsubMessage) ProtoMessage()               {}",
                "+func (*PubsubMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }",
                "+",
                "+func (m *PubsubMessage) GetData() []byte {",
                "+\tif m != nil {",
                "+\t\treturn m.Data",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *PubsubMessage) GetAttributes() map[string]string {",
                "+\tif m != nil {",
                "+\t\treturn m.Attributes",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *PubsubMessage) GetMessageId() string {",
                "+\tif m != nil {",
                "+\t\treturn m.MessageId",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *PubsubMessage) GetPublishTime() *google_protobuf4.Timestamp {",
                "+\tif m != nil {",
                "+\t\treturn m.PublishTime",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Request for the GetTopic method.",
                "+type GetTopicRequest struct {",
                "+\t// The name of the topic to get.",
                "+\t// Format is `projects/{project}/topics/{topic}`.",
                "+\tTopic string `protobuf:\"bytes,1,opt,name=topic\" json:\"topic,omitempty\"`",
                "+}",
                "+",
                "+func (m *GetTopicRequest) Reset()                    { *m = GetTopicRequest{} }",
                "+func (m *GetTopicRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*GetTopicRequest) ProtoMessage()               {}",
                "+func (*GetTopicRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }",
                "+",
                "+func (m *GetTopicRequest) GetTopic() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Topic",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Request for the UpdateTopic method.",
                "+type UpdateTopicRequest struct {",
                "+\t// The topic to update.",
                "+\tTopic *Topic `protobuf:\"bytes,1,opt,name=topic\" json:\"topic,omitempty\"`",
                "+\t// Indicates which fields in the provided topic to update.",
                "+\t// Must be specified and non-empty.",
                "+\tUpdateMask *google_protobuf3.FieldMask `protobuf:\"bytes,2,opt,name=update_mask,json=updateMask\" json:\"update_mask,omitempty\"`",
                "+}",
                "+",
                "+func (m *UpdateTopicRequest) Reset()                    { *m = UpdateTopicRequest{} }",
                "+func (m *UpdateTopicRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*UpdateTopicRequest) ProtoMessage()               {}",
                "+func (*UpdateTopicRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }",
                "+",
                "+func (m *UpdateTopicRequest) GetTopic() *Topic {",
                "+\tif m != nil {",
                "+\t\treturn m.Topic",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *UpdateTopicRequest) GetUpdateMask() *google_protobuf3.FieldMask {",
                "+\tif m != nil {",
                "+\t\treturn m.UpdateMask",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Request for the Publish method.",
                "+type PublishRequest struct {",
                "+\t// The messages in the request will be published on this topic.",
                "+\t// Format is `projects/{project}/topics/{topic}`.",
                "+\tTopic string `protobuf:\"bytes,1,opt,name=topic\" json:\"topic,omitempty\"`",
                "+\t// The messages to publish.",
                "+\tMessages []*PubsubMessage `protobuf:\"bytes,2,rep,name=messages\" json:\"messages,omitempty\"`",
                "+}",
                "+",
                "+func (m *PublishRequest) Reset()                    { *m = PublishRequest{} }",
                "+func (m *PublishRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*PublishRequest) ProtoMessage()               {}",
                "+func (*PublishRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }",
                "+",
                "+func (m *PublishRequest) GetTopic() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Topic",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *PublishRequest) GetMessages() []*PubsubMessage {",
                "+\tif m != nil {",
                "+\t\treturn m.Messages",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Response for the `Publish` method.",
                "+type PublishResponse struct {",
                "+\t// The server-assigned ID of each published message, in the same order as",
                "+\t// the messages in the request. IDs are guaranteed to be unique within",
                "+\t// the topic.",
                "+\tMessageIds []string `protobuf:\"bytes,1,rep,name=message_ids,json=messageIds\" json:\"message_ids,omitempty\"`",
                "+}",
                "+",
                "+func (m *PublishResponse) Reset()                    { *m = PublishResponse{} }",
                "+func (m *PublishResponse) String() string            { return proto.CompactTextString(m) }",
                "+func (*PublishResponse) ProtoMessage()               {}",
                "+func (*PublishResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }",
                "+",
                "+func (m *PublishResponse) GetMessageIds() []string {",
                "+\tif m != nil {",
                "+\t\treturn m.MessageIds",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Request for the `ListTopics` method.",
                "+type ListTopicsRequest struct {",
                "+\t// The name of the cloud project that topics belong to.",
                "+\t// Format is `projects/{project}`.",
                "+\tProject string `protobuf:\"bytes,1,opt,name=project\" json:\"project,omitempty\"`",
                "+\t// Maximum number of topics to return.",
                "+\tPageSize int32 `protobuf:\"varint,2,opt,name=page_size,json=pageSize\" json:\"page_size,omitempty\"`",
                "+\t// The value returned by the last `ListTopicsResponse`; indicates that this is",
                "+\t// a continuation of a prior `ListTopics` call, and that the system should",
                "+\t// return the next page of data.",
                "+\tPageToken string `protobuf:\"bytes,3,opt,name=page_token,json=pageToken\" json:\"page_token,omitempty\"`",
                "+}",
                "+",
                "+func (m *ListTopicsRequest) Reset()                    { *m = ListTopicsRequest{} }",
                "+func (m *ListTopicsRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*ListTopicsRequest) ProtoMessage()               {}",
                "+func (*ListTopicsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }",
                "+",
                "+func (m *ListTopicsRequest) GetProject() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Project",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *ListTopicsRequest) GetPageSize() int32 {",
                "+\tif m != nil {",
                "+\t\treturn m.PageSize",
                "+\t}",
                "+\treturn 0",
                "+}",
                "+",
                "+func (m *ListTopicsRequest) GetPageToken() string {",
                "+\tif m != nil {",
                "+\t\treturn m.PageToken",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Response for the `ListTopics` method.",
                "+type ListTopicsResponse struct {",
                "+\t// The resulting topics.",
                "+\tTopics []*Topic `protobuf:\"bytes,1,rep,name=topics\" json:\"topics,omitempty\"`",
                "+\t// If not empty, indicates that there may be more topics that match the",
                "+\t// request; this value should be passed in a new `ListTopicsRequest`.",
                "+\tNextPageToken string `protobuf:\"bytes,2,opt,name=next_page_token,json=nextPageToken\" json:\"next_page_token,omitempty\"`",
                "+}",
                "+",
                "+func (m *ListTopicsResponse) Reset()                    { *m = ListTopicsResponse{} }",
                "+func (m *ListTopicsResponse) String() string            { return proto.CompactTextString(m) }",
                "+func (*ListTopicsResponse) ProtoMessage()               {}",
                "+func (*ListTopicsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }",
                "+",
                "+func (m *ListTopicsResponse) GetTopics() []*Topic {",
                "+\tif m != nil {",
                "+\t\treturn m.Topics",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *ListTopicsResponse) GetNextPageToken() string {",
                "+\tif m != nil {",
                "+\t\treturn m.NextPageToken",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Request for the `ListTopicSubscriptions` method.",
                "+type ListTopicSubscriptionsRequest struct {",
                "+\t// The name of the topic that subscriptions are attached to.",
                "+\t// Format is `projects/{project}/topics/{topic}`.",
                "+\tTopic string `protobuf:\"bytes,1,opt,name=topic\" json:\"topic,omitempty\"`",
                "+\t// Maximum number of subscription names to return.",
                "+\tPageSize int32 `protobuf:\"varint,2,opt,name=page_size,json=pageSize\" json:\"page_size,omitempty\"`",
                "+\t// The value returned by the last `ListTopicSubscriptionsResponse`; indicates",
                "+\t// that this is a continuation of a prior `ListTopicSubscriptions` call, and",
                "+\t// that the system should return the next page of data.",
                "+\tPageToken string `protobuf:\"bytes,3,opt,name=page_token,json=pageToken\" json:\"page_token,omitempty\"`",
                "+}",
                "+",
                "+func (m *ListTopicSubscriptionsRequest) Reset()                    { *m = ListTopicSubscriptionsRequest{} }",
                "+func (m *ListTopicSubscriptionsRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*ListTopicSubscriptionsRequest) ProtoMessage()               {}",
                "+func (*ListTopicSubscriptionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }",
                "+",
                "+func (m *ListTopicSubscriptionsRequest) GetTopic() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Topic",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *ListTopicSubscriptionsRequest) GetPageSize() int32 {",
                "+\tif m != nil {",
                "+\t\treturn m.PageSize",
                "+\t}",
                "+\treturn 0",
                "+}",
                "+",
                "+func (m *ListTopicSubscriptionsRequest) GetPageToken() string {",
                "+\tif m != nil {",
                "+\t\treturn m.PageToken",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Response for the `ListTopicSubscriptions` method.",
                "+type ListTopicSubscriptionsResponse struct {",
                "+\t// The names of the subscriptions that match the request.",
                "+\tSubscriptions []string `protobuf:\"bytes,1,rep,name=subscriptions\" json:\"subscriptions,omitempty\"`",
                "+\t// If not empty, indicates that there may be more subscriptions that match",
                "+\t// the request; this value should be passed in a new",
                "+\t// `ListTopicSubscriptionsRequest` to get more subscriptions.",
                "+\tNextPageToken string `protobuf:\"bytes,2,opt,name=next_page_token,json=nextPageToken\" json:\"next_page_token,omitempty\"`",
                "+}",
                "+",
                "+func (m *ListTopicSubscriptionsResponse) Reset()                    { *m = ListTopicSubscriptionsResponse{} }",
                "+func (m *ListTopicSubscriptionsResponse) String() string            { return proto.CompactTextString(m) }",
                "+func (*ListTopicSubscriptionsResponse) ProtoMessage()               {}",
                "+func (*ListTopicSubscriptionsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }",
                "+",
                "+func (m *ListTopicSubscriptionsResponse) GetSubscriptions() []string {",
                "+\tif m != nil {",
                "+\t\treturn m.Subscriptions",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *ListTopicSubscriptionsResponse) GetNextPageToken() string {",
                "+\tif m != nil {",
                "+\t\treturn m.NextPageToken",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Request for the `DeleteTopic` method.",
                "+type DeleteTopicRequest struct {",
                "+\t// Name of the topic to delete.",
                "+\t// Format is `projects/{project}/topics/{topic}`.",
                "+\tTopic string `protobuf:\"bytes,1,opt,name=topic\" json:\"topic,omitempty\"`",
                "+}",
                "+",
                "+func (m *DeleteTopicRequest) Reset()                    { *m = DeleteTopicRequest{} }",
                "+func (m *DeleteTopicRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*DeleteTopicRequest) ProtoMessage()               {}",
                "+func (*DeleteTopicRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }",
                "+",
                "+func (m *DeleteTopicRequest) GetTopic() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Topic",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// A subscription resource.",
                "+type Subscription struct {",
                "+\t// The name of the subscription. It must have the format",
                "+\t// `\"projects/{project}/subscriptions/{subscription}\"`. `{subscription}` must",
                "+\t// start with a letter, and contain only letters (`[A-Za-z]`), numbers",
                "+\t// (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),",
                "+\t// plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters",
                "+\t// in length, and it must not start with `\"goog\"`.",
                "+\tName string `protobuf:\"bytes,1,opt,name=name\" json:\"name,omitempty\"`",
                "+\t// The name of the topic from which this subscription is receiving messages.",
                "+\t// Format is `projects/{project}/topics/{topic}`.",
                "+\t// The value of this field will be `_deleted-topic_` if the topic has been",
                "+\t// deleted.",
                "+\tTopic string `protobuf:\"bytes,2,opt,name=topic\" json:\"topic,omitempty\"`",
                "+\t// If push delivery is used with this subscription, this field is",
                "+\t// used to configure it. An empty `pushConfig` signifies that the subscriber",
                "+\t// will pull and ack messages using API methods.",
                "+\tPushConfig *PushConfig `protobuf:\"bytes,4,opt,name=push_config,json=pushConfig\" json:\"push_config,omitempty\"`",
                "+\t// This value is the maximum time after a subscriber receives a message",
                "+\t// before the subscriber should acknowledge the message. After message",
                "+\t// delivery but before the ack deadline expires and before the message is",
                "+\t// acknowledged, it is an outstanding message and will not be delivered",
                "+\t// again during that time (on a best-effort basis).",
                "+\t//",
                "+\t// For pull subscriptions, this value is used as the initial value for the ack",
                "+\t// deadline. To override this value for a given message, call",
                "+\t// `ModifyAckDeadline` with the corresponding `ack_id` if using",
                "+\t// pull.",
                "+\t// The minimum custom deadline you can specify is 10 seconds.",
                "+\t// The maximum custom deadline you can specify is 600 seconds (10 minutes).",
                "+\t// If this parameter is 0, a default value of 10 seconds is used.",
                "+\t//",
                "+\t// For push delivery, this value is also used to set the request timeout for",
                "+\t// the call to the push endpoint.",
                "+\t//",
                "+\t// If the subscriber never acknowledges the message, the Pub/Sub",
                "+\t// system will eventually redeliver the message.",
                "+\tAckDeadlineSeconds int32 `protobuf:\"varint,5,opt,name=ack_deadline_seconds,json=ackDeadlineSeconds\" json:\"ack_deadline_seconds,omitempty\"`",
                "+\t// Indicates whether to retain acknowledged messages. If true, then",
                "+\t// messages are not expunged from the subscription's backlog, even if they are",
                "+\t// acknowledged, until they fall out of the `message_retention_duration`",
                "+\t// window.",
                "+\tRetainAckedMessages bool `protobuf:\"varint,7,opt,name=retain_acked_messages,json=retainAckedMessages\" json:\"retain_acked_messages,omitempty\"`",
                "+\t// How long to retain unacknowledged messages in the subscription's backlog,",
                "+\t// from the moment a message is published.",
                "+\t// If `retain_acked_messages` is true, then this also configures the retention",
                "+\t// of acknowledged messages, and thus configures how far back in time a `Seek`",
                "+\t// can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10",
                "+\t// minutes.",
                "+\tMessageRetentionDuration *google_protobuf1.Duration `protobuf:\"bytes,8,opt,name=message_retention_duration,json=messageRetentionDuration\" json:\"message_retention_duration,omitempty\"`",
                "+\t// User labels.",
                "+\tLabels map[string]string `protobuf:\"bytes,9,rep,name=labels\" json:\"labels,omitempty\" protobuf_key:\"bytes,1,opt,name=key\" protobuf_val:\"bytes,2,opt,name=value\"`",
                "+}",
                "+",
                "+func (m *Subscription) Reset()                    { *m = Subscription{} }",
                "+func (m *Subscription) String() string            { return proto.CompactTextString(m) }",
                "+func (*Subscription) ProtoMessage()               {}",
                "+func (*Subscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }",
                "+",
                "+func (m *Subscription) GetName() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Name",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *Subscription) GetTopic() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Topic",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *Subscription) GetPushConfig() *PushConfig {",
                "+\tif m != nil {",
                "+\t\treturn m.PushConfig",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *Subscription) GetAckDeadlineSeconds() int32 {",
                "+\tif m != nil {",
                "+\t\treturn m.AckDeadlineSeconds",
                "+\t}",
                "+\treturn 0",
                "+}",
                "+",
                "+func (m *Subscription) GetRetainAckedMessages() bool {",
                "+\tif m != nil {",
                "+\t\treturn m.RetainAckedMessages",
                "+\t}",
                "+\treturn false",
                "+}",
                "+",
                "+func (m *Subscription) GetMessageRetentionDuration() *google_protobuf1.Duration {",
                "+\tif m != nil {",
                "+\t\treturn m.MessageRetentionDuration",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *Subscription) GetLabels() map[string]string {",
                "+\tif m != nil {",
                "+\t\treturn m.Labels",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Configuration for a push delivery endpoint.",
                "+type PushConfig struct {",
                "+\t// A URL locating the endpoint to which messages should be pushed.",
                "+\t// For example, a Webhook endpoint might use \"https://example.com/push\".",
                "+\tPushEndpoint string `protobuf:\"bytes,1,opt,name=push_endpoint,json=pushEndpoint\" json:\"push_endpoint,omitempty\"`",
                "+\t// Endpoint configuration attributes.",
                "+\t//",
                "+\t// Every endpoint has a set of API supported attributes that can be used to",
                "+\t// control different aspects of the message delivery.",
                "+\t//",
                "+\t// The currently supported attribute is `x-goog-version`, which you can",
                "+\t// use to change the format of the pushed message. This attribute",
                "+\t// indicates the version of the data expected by the endpoint. This",
                "+\t// controls the shape of the pushed message (i.e., its fields and metadata).",
                "+\t// The endpoint version is based on the version of the Pub/Sub API.",
                "+\t//",
                "+\t// If not present during the `CreateSubscription` call, it will default to",
                "+\t// the version of the API used to make such call. If not present during a",
                "+\t// `ModifyPushConfig` call, its value will not be changed. `GetSubscription`",
                "+\t// calls will always return a valid version, even if the subscription was",
                "+\t// created without this attribute.",
                "+\t//",
                "+\t// The possible values for this attribute are:",
                "+\t//",
                "+\t// * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.",
                "+\t// * `v1` or `v1beta2`: uses the push format defined in the v1 Pub/Sub API.",
                "+\tAttributes map[string]string `protobuf:\"bytes,2,rep,name=attributes\" json:\"attributes,omitempty\" protobuf_key:\"bytes,1,opt,name=key\" protobuf_val:\"bytes,2,opt,name=value\"`",
                "+}",
                "+",
                "+func (m *PushConfig) Reset()                    { *m = PushConfig{} }",
                "+func (m *PushConfig) String() string            { return proto.CompactTextString(m) }",
                "+func (*PushConfig) ProtoMessage()               {}",
                "+func (*PushConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }",
                "+",
                "+func (m *PushConfig) GetPushEndpoint() string {",
                "+\tif m != nil {",
                "+\t\treturn m.PushEndpoint",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *PushConfig) GetAttributes() map[string]string {",
                "+\tif m != nil {",
                "+\t\treturn m.Attributes",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// A message and its corresponding acknowledgment ID.",
                "+type ReceivedMessage struct {",
                "+\t// This ID can be used to acknowledge the received message.",
                "+\tAckId string `protobuf:\"bytes,1,opt,name=ack_id,json=ackId\" json:\"ack_id,omitempty\"`",
                "+\t// The message.",
                "+\tMessage *PubsubMessage `protobuf:\"bytes,2,opt,name=message\" json:\"message,omitempty\"`",
                "+}",
                "+",
                "+func (m *ReceivedMessage) Reset()                    { *m = ReceivedMessage{} }",
                "+func (m *ReceivedMessage) String() string            { return proto.CompactTextString(m) }",
                "+func (*ReceivedMessage) ProtoMessage()               {}",
                "+func (*ReceivedMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }",
                "+",
                "+func (m *ReceivedMessage) GetAckId() string {",
                "+\tif m != nil {",
                "+\t\treturn m.AckId",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *ReceivedMessage) GetMessage() *PubsubMessage {",
                "+\tif m != nil {",
                "+\t\treturn m.Message",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Request for the GetSubscription method.",
                "+type GetSubscriptionRequest struct {",
                "+\t// The name of the subscription to get.",
                "+\t// Format is `projects/{project}/subscriptions/{sub}`.",
                "+\tSubscription string `protobuf:\"bytes,1,opt,name=subscription\" json:\"subscription,omitempty\"`",
                "+}",
                "+",
                "+func (m *GetSubscriptionRequest) Reset()                    { *m = GetSubscriptionRequest{} }",
                "+func (m *GetSubscriptionRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*GetSubscriptionRequest) ProtoMessage()               {}",
                "+func (*GetSubscriptionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }",
                "+",
                "+func (m *GetSubscriptionRequest) GetSubscription() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Subscription",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Request for the UpdateSubscription method.",
                "+type UpdateSubscriptionRequest struct {",
                "+\t// The updated subscription object.",
                "+\tSubscription *Subscription `protobuf:\"bytes,1,opt,name=subscription\" json:\"subscription,omitempty\"`",
                "+\t// Indicates which fields in the provided subscription to update.",
                "+\t// Must be specified and non-empty.",
                "+\tUpdateMask *google_protobuf3.FieldMask `protobuf:\"bytes,2,opt,name=update_mask,json=updateMask\" json:\"update_mask,omitempty\"`",
                "+}",
                "+",
                "+func (m *UpdateSubscriptionRequest) Reset()                    { *m = UpdateSubscriptionRequest{} }",
                "+func (m *UpdateSubscriptionRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*UpdateSubscriptionRequest) ProtoMessage()               {}",
                "+func (*UpdateSubscriptionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }",
                "+",
                "+func (m *UpdateSubscriptionRequest) GetSubscription() *Subscription {",
                "+\tif m != nil {",
                "+\t\treturn m.Subscription",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *UpdateSubscriptionRequest) GetUpdateMask() *google_protobuf3.FieldMask {",
                "+\tif m != nil {",
                "+\t\treturn m.UpdateMask",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Request for the `ListSubscriptions` method.",
                "+type ListSubscriptionsRequest struct {",
                "+\t// The name of the cloud project that subscriptions belong to.",
                "+\t// Format is `projects/{project}`.",
                "+\tProject string `protobuf:\"bytes,1,opt,name=project\" json:\"project,omitempty\"`",
                "+\t// Maximum number of subscriptions to return.",
                "+\tPageSize int32 `protobuf:\"varint,2,opt,name=page_size,json=pageSize\" json:\"page_size,omitempty\"`",
                "+\t// The value returned by the last `ListSubscriptionsResponse`; indicates that",
                "+\t// this is a continuation of a prior `ListSubscriptions` call, and that the",
                "+\t// system should return the next page of data.",
                "+\tPageToken string `protobuf:\"bytes,3,opt,name=page_token,json=pageToken\" json:\"page_token,omitempty\"`",
                "+}",
                "+",
                "+func (m *ListSubscriptionsRequest) Reset()                    { *m = ListSubscriptionsRequest{} }",
                "+func (m *ListSubscriptionsRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*ListSubscriptionsRequest) ProtoMessage()               {}",
                "+func (*ListSubscriptionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }",
                "+",
                "+func (m *ListSubscriptionsRequest) GetProject() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Project",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *ListSubscriptionsRequest) GetPageSize() int32 {",
                "+\tif m != nil {",
                "+\t\treturn m.PageSize",
                "+\t}",
                "+\treturn 0",
                "+}",
                "+",
                "+func (m *ListSubscriptionsRequest) GetPageToken() string {",
                "+\tif m != nil {",
                "+\t\treturn m.PageToken",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Response for the `ListSubscriptions` method.",
                "+type ListSubscriptionsResponse struct {",
                "+\t// The subscriptions that match the request.",
                "+\tSubscriptions []*Subscription `protobuf:\"bytes,1,rep,name=subscriptions\" json:\"subscriptions,omitempty\"`",
                "+\t// If not empty, indicates that there may be more subscriptions that match",
                "+\t// the request; this value should be passed in a new",
                "+\t// `ListSubscriptionsRequest` to get more subscriptions.",
                "+\tNextPageToken string `protobuf:\"bytes,2,opt,name=next_page_token,json=nextPageToken\" json:\"next_page_token,omitempty\"`",
                "+}",
                "+",
                "+func (m *ListSubscriptionsResponse) Reset()                    { *m = ListSubscriptionsResponse{} }",
                "+func (m *ListSubscriptionsResponse) String() string            { return proto.CompactTextString(m) }",
                "+func (*ListSubscriptionsResponse) ProtoMessage()               {}",
                "+func (*ListSubscriptionsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }",
                "+",
                "+func (m *ListSubscriptionsResponse) GetSubscriptions() []*Subscription {",
                "+\tif m != nil {",
                "+\t\treturn m.Subscriptions",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *ListSubscriptionsResponse) GetNextPageToken() string {",
                "+\tif m != nil {",
                "+\t\treturn m.NextPageToken",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Request for the DeleteSubscription method.",
                "+type DeleteSubscriptionRequest struct {",
                "+\t// The subscription to delete.",
                "+\t// Format is `projects/{project}/subscriptions/{sub}`.",
                "+\tSubscription string `protobuf:\"bytes,1,opt,name=subscription\" json:\"subscription,omitempty\"`",
                "+}",
                "+",
                "+func (m *DeleteSubscriptionRequest) Reset()                    { *m = DeleteSubscriptionRequest{} }",
                "+func (m *DeleteSubscriptionRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*DeleteSubscriptionRequest) ProtoMessage()               {}",
                "+func (*DeleteSubscriptionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }",
                "+",
                "+func (m *DeleteSubscriptionRequest) GetSubscription() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Subscription",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Request for the ModifyPushConfig method.",
                "+type ModifyPushConfigRequest struct {",
                "+\t// The name of the subscription.",
                "+\t// Format is `projects/{project}/subscriptions/{sub}`.",
                "+\tSubscription string `protobuf:\"bytes,1,opt,name=subscription\" json:\"subscription,omitempty\"`",
                "+\t// The push configuration for future deliveries.",
                "+\t//",
                "+\t// An empty `pushConfig` indicates that the Pub/Sub system should",
                "+\t// stop pushing messages from the given subscription and allow",
                "+\t// messages to be pulled and acknowledged - effectively pausing",
                "+\t// the subscription if `Pull` is not called.",
                "+\tPushConfig *PushConfig `protobuf:\"bytes,2,opt,name=push_config,json=pushConfig\" json:\"push_config,omitempty\"`",
                "+}",
                "+",
                "+func (m *ModifyPushConfigRequest) Reset()                    { *m = ModifyPushConfigRequest{} }",
                "+func (m *ModifyPushConfigRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*ModifyPushConfigRequest) ProtoMessage()               {}",
                "+func (*ModifyPushConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }",
                "+",
                "+func (m *ModifyPushConfigRequest) GetSubscription() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Subscription",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *ModifyPushConfigRequest) GetPushConfig() *PushConfig {",
                "+\tif m != nil {",
                "+\t\treturn m.PushConfig",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Request for the `Pull` method.",
                "+type PullRequest struct {",
                "+\t// The subscription from which messages should be pulled.",
                "+\t// Format is `projects/{project}/subscriptions/{sub}`.",
                "+\tSubscription string `protobuf:\"bytes,1,opt,name=subscription\" json:\"subscription,omitempty\"`",
                "+\t// If this field set to true, the system will respond immediately even if",
                "+\t// it there are no messages available to return in the `Pull` response.",
                "+\t// Otherwise, the system may wait (for a bounded amount of time) until at",
                "+\t// least one message is available, rather than returning no messages. The",
                "+\t// client may cancel the request if it does not wish to wait any longer for",
                "+\t// the response.",
                "+\tReturnImmediately bool `protobuf:\"varint,2,opt,name=return_immediately,json=returnImmediately\" json:\"return_immediately,omitempty\"`",
                "+\t// The maximum number of messages returned for this request. The Pub/Sub",
                "+\t// system may return fewer than the number specified.",
                "+\tMaxMessages int32 `protobuf:\"varint,3,opt,name=max_messages,json=maxMessages\" json:\"max_messages,omitempty\"`",
                "+}",
                "+",
                "+func (m *PullRequest) Reset()                    { *m = PullRequest{} }",
                "+func (m *PullRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*PullRequest) ProtoMessage()               {}",
                "+func (*PullRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }",
                "+",
                "+func (m *PullRequest) GetSubscription() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Subscription",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *PullRequest) GetReturnImmediately() bool {",
                "+\tif m != nil {",
                "+\t\treturn m.ReturnImmediately",
                "+\t}",
                "+\treturn false",
                "+}",
                "+",
                "+func (m *PullRequest) GetMaxMessages() int32 {",
                "+\tif m != nil {",
                "+\t\treturn m.MaxMessages",
                "+\t}",
                "+\treturn 0",
                "+}",
                "+",
                "+// Response for the `Pull` method.",
                "+type PullResponse struct {",
                "+\t// Received Pub/Sub messages. The Pub/Sub system will return zero messages if",
                "+\t// there are no more available in the backlog. The Pub/Sub system may return",
                "+\t// fewer than the `maxMessages` requested even if there are more messages",
                "+\t// available in the backlog.",
                "+\tReceivedMessages []*ReceivedMessage `protobuf:\"bytes,1,rep,name=received_messages,json=receivedMessages\" json:\"received_messages,omitempty\"`",
                "+}",
                "+",
                "+func (m *PullResponse) Reset()                    { *m = PullResponse{} }",
                "+func (m *PullResponse) String() string            { return proto.CompactTextString(m) }",
                "+func (*PullResponse) ProtoMessage()               {}",
                "+func (*PullResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }",
                "+",
                "+func (m *PullResponse) GetReceivedMessages() []*ReceivedMessage {",
                "+\tif m != nil {",
                "+\t\treturn m.ReceivedMessages",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Request for the ModifyAckDeadline method.",
                "+type ModifyAckDeadlineRequest struct {",
                "+\t// The name of the subscription.",
                "+\t// Format is `projects/{project}/subscriptions/{sub}`.",
                "+\tSubscription string `protobuf:\"bytes,1,opt,name=subscription\" json:\"subscription,omitempty\"`",
                "+\t// List of acknowledgment IDs.",
                "+\tAckIds []string `protobuf:\"bytes,4,rep,name=ack_ids,json=ackIds\" json:\"ack_ids,omitempty\"`",
                "+\t// The new ack deadline with respect to the time this request was sent to",
                "+\t// the Pub/Sub system. For example, if the value is 10, the new",
                "+\t// ack deadline will expire 10 seconds after the `ModifyAckDeadline` call",
                "+\t// was made. Specifying zero may immediately make the message available for",
                "+\t// another pull request.",
                "+\t// The minimum deadline you can specify is 0 seconds.",
                "+\t// The maximum deadline you can specify is 600 seconds (10 minutes).",
                "+\tAckDeadlineSeconds int32 `protobuf:\"varint,3,opt,name=ack_deadline_seconds,json=ackDeadlineSeconds\" json:\"ack_deadline_seconds,omitempty\"`",
                "+}",
                "+",
                "+func (m *ModifyAckDeadlineRequest) Reset()                    { *m = ModifyAckDeadlineRequest{} }",
                "+func (m *ModifyAckDeadlineRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*ModifyAckDeadlineRequest) ProtoMessage()               {}",
                "+func (*ModifyAckDeadlineRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }",
                "+",
                "+func (m *ModifyAckDeadlineRequest) GetSubscription() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Subscription",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *ModifyAckDeadlineRequest) GetAckIds() []string {",
                "+\tif m != nil {",
                "+\t\treturn m.AckIds",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *ModifyAckDeadlineRequest) GetAckDeadlineSeconds() int32 {",
                "+\tif m != nil {",
                "+\t\treturn m.AckDeadlineSeconds",
                "+\t}",
                "+\treturn 0",
                "+}",
                "+",
                "+// Request for the Acknowledge method.",
                "+type AcknowledgeRequest struct {",
                "+\t// The subscription whose message is being acknowledged.",
                "+\t// Format is `projects/{project}/subscriptions/{sub}`.",
                "+\tSubscription string `protobuf:\"bytes,1,opt,name=subscription\" json:\"subscription,omitempty\"`",
                "+\t// The acknowledgment ID for the messages being acknowledged that was returned",
                "+\t// by the Pub/Sub system in the `Pull` response. Must not be empty.",
                "+\tAckIds []string `protobuf:\"bytes,2,rep,name=ack_ids,json=ackIds\" json:\"ack_ids,omitempty\"`",
                "+}",
                "+",
                "+func (m *AcknowledgeRequest) Reset()                    { *m = AcknowledgeRequest{} }",
                "+func (m *AcknowledgeRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*AcknowledgeRequest) ProtoMessage()               {}",
                "+func (*AcknowledgeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }",
                "+",
                "+func (m *AcknowledgeRequest) GetSubscription() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Subscription",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *AcknowledgeRequest) GetAckIds() []string {",
                "+\tif m != nil {",
                "+\t\treturn m.AckIds",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Request for the `StreamingPull` streaming RPC method. This request is used to",
                "+// establish the initial stream as well as to stream acknowledgements and ack",
                "+// deadline modifications from the client to the server.",
                "+type StreamingPullRequest struct {",
                "+\t// The subscription for which to initialize the new stream. This must be",
                "+\t// provided in the first request on the stream, and must not be set in",
                "+\t// subsequent requests from client to server.",
                "+\t// Format is `projects/{project}/subscriptions/{sub}`.",
                "+\tSubscription string `protobuf:\"bytes,1,opt,name=subscription\" json:\"subscription,omitempty\"`",
                "+\t// List of acknowledgement IDs for acknowledging previously received messages",
                "+\t// (received on this stream or a different stream). If an ack ID has expired,",
                "+\t// the corresponding message may be redelivered later. Acknowledging a message",
                "+\t// more than once will not result in an error. If the acknowledgement ID is",
                "+\t// malformed, the stream will be aborted with status `INVALID_ARGUMENT`.",
                "+\tAckIds []string `protobuf:\"bytes,2,rep,name=ack_ids,json=ackIds\" json:\"ack_ids,omitempty\"`",
                "+\t// The list of new ack deadlines for the IDs listed in",
                "+\t// `modify_deadline_ack_ids`. The size of this list must be the same as the",
                "+\t// size of `modify_deadline_ack_ids`. If it differs the stream will be aborted",
                "+\t// with `INVALID_ARGUMENT`. Each element in this list is applied to the",
                "+\t// element in the same position in `modify_deadline_ack_ids`. The new ack",
                "+\t// deadline is with respect to the time this request was sent to the Pub/Sub",
                "+\t// system. Must be >= 0. For example, if the value is 10, the new ack deadline",
                "+\t// will expire 10 seconds after this request is received. If the value is 0,",
                "+\t// the message is immediately made available for another streaming or",
                "+\t// non-streaming pull request. If the value is < 0 (an error), the stream will",
                "+\t// be aborted with status `INVALID_ARGUMENT`.",
                "+\tModifyDeadlineSeconds []int32 `protobuf:\"varint,3,rep,packed,name=modify_deadline_seconds,json=modifyDeadlineSeconds\" json:\"modify_deadline_seconds,omitempty\"`",
                "+\t// List of acknowledgement IDs whose deadline will be modified based on the",
                "+\t// corresponding element in `modify_deadline_seconds`. This field can be used",
                "+\t// to indicate that more time is needed to process a message by the",
                "+\t// subscriber, or to make the message available for redelivery if the",
                "+\t// processing was interrupted.",
                "+\tModifyDeadlineAckIds []string `protobuf:\"bytes,4,rep,name=modify_deadline_ack_ids,json=modifyDeadlineAckIds\" json:\"modify_deadline_ack_ids,omitempty\"`",
                "+\t// The ack deadline to use for the stream. This must be provided in the",
                "+\t// first request on the stream, but it can also be updated on subsequent",
                "+\t// requests from client to server. The minimum deadline you can specify is 10",
                "+\t// seconds. The maximum deadline you can specify is 600 seconds (10 minutes).",
                "+\tStreamAckDeadlineSeconds int32 `protobuf:\"varint,5,opt,name=stream_ack_deadline_seconds,json=streamAckDeadlineSeconds\" json:\"stream_ack_deadline_seconds,omitempty\"`",
                "+}",
                "+",
                "+func (m *StreamingPullRequest) Reset()                    { *m = StreamingPullRequest{} }",
                "+func (m *StreamingPullRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*StreamingPullRequest) ProtoMessage()               {}",
                "+func (*StreamingPullRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }",
                "+",
                "+func (m *StreamingPullRequest) GetSubscription() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Subscription",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *StreamingPullRequest) GetAckIds() []string {",
                "+\tif m != nil {",
                "+\t\treturn m.AckIds",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *StreamingPullRequest) GetModifyDeadlineSeconds() []int32 {",
                "+\tif m != nil {",
                "+\t\treturn m.ModifyDeadlineSeconds",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *StreamingPullRequest) GetModifyDeadlineAckIds() []string {",
                "+\tif m != nil {",
                "+\t\treturn m.ModifyDeadlineAckIds",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *StreamingPullRequest) GetStreamAckDeadlineSeconds() int32 {",
                "+\tif m != nil {",
                "+\t\treturn m.StreamAckDeadlineSeconds",
                "+\t}",
                "+\treturn 0",
                "+}",
                "+",
                "+// Response for the `StreamingPull` method. This response is used to stream",
                "+// messages from the server to the client.",
                "+type StreamingPullResponse struct {",
                "+\t// Received Pub/Sub messages. This will not be empty.",
                "+\tReceivedMessages []*ReceivedMessage `protobuf:\"bytes,1,rep,name=received_messages,json=receivedMessages\" json:\"received_messages,omitempty\"`",
                "+}",
                "+",
                "+func (m *StreamingPullResponse) Reset()                    { *m = StreamingPullResponse{} }",
                "+func (m *StreamingPullResponse) String() string            { return proto.CompactTextString(m) }",
                "+func (*StreamingPullResponse) ProtoMessage()               {}",
                "+func (*StreamingPullResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }",
                "+",
                "+func (m *StreamingPullResponse) GetReceivedMessages() []*ReceivedMessage {",
                "+\tif m != nil {",
                "+\t\treturn m.ReceivedMessages",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Request for the `CreateSnapshot` method.",
                "+type CreateSnapshotRequest struct {",
                "+\t// Optional user-provided name for this snapshot.",
                "+\t// If the name is not provided in the request, the server will assign a random",
                "+\t// name for this snapshot on the same project as the subscription.",
                "+\t// Note that for REST API requests, you must specify a name.",
                "+\t// Format is `projects/{project}/snapshots/{snap}`.",
                "+\tName string `protobuf:\"bytes,1,opt,name=name\" json:\"name,omitempty\"`",
                "+\t// The subscription whose backlog the snapshot retains.",
                "+\t// Specifically, the created snapshot is guaranteed to retain:",
                "+\t//  (a) The existing backlog on the subscription. More precisely, this is",
                "+\t//      defined as the messages in the subscription's backlog that are",
                "+\t//      unacknowledged upon the successful completion of the",
                "+\t//      `CreateSnapshot` request; as well as:",
                "+\t//  (b) Any messages published to the subscription's topic following the",
                "+\t//      successful completion of the CreateSnapshot request.",
                "+\t// Format is `projects/{project}/subscriptions/{sub}`.",
                "+\tSubscription string `protobuf:\"bytes,2,opt,name=subscription\" json:\"subscription,omitempty\"`",
                "+}",
                "+",
                "+func (m *CreateSnapshotRequest) Reset()                    { *m = CreateSnapshotRequest{} }",
                "+func (m *CreateSnapshotRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*CreateSnapshotRequest) ProtoMessage()               {}",
                "+func (*CreateSnapshotRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }",
                "+",
                "+func (m *CreateSnapshotRequest) GetName() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Name",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *CreateSnapshotRequest) GetSubscription() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Subscription",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Request for the UpdateSnapshot method.",
                "+type UpdateSnapshotRequest struct {",
                "+\t// The updated snpashot object.",
                "+\tSnapshot *Snapshot `protobuf:\"bytes,1,opt,name=snapshot\" json:\"snapshot,omitempty\"`",
                "+\t// Indicates which fields in the provided snapshot to update.",
                "+\t// Must be specified and non-empty.",
                "+\tUpdateMask *google_protobuf3.FieldMask `protobuf:\"bytes,2,opt,name=update_mask,json=updateMask\" json:\"update_mask,omitempty\"`",
                "+}",
                "+",
                "+func (m *UpdateSnapshotRequest) Reset()                    { *m = UpdateSnapshotRequest{} }",
                "+func (m *UpdateSnapshotRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*UpdateSnapshotRequest) ProtoMessage()               {}",
                "+func (*UpdateSnapshotRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }",
                "+",
                "+func (m *UpdateSnapshotRequest) GetSnapshot() *Snapshot {",
                "+\tif m != nil {",
                "+\t\treturn m.Snapshot",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *UpdateSnapshotRequest) GetUpdateMask() *google_protobuf3.FieldMask {",
                "+\tif m != nil {",
                "+\t\treturn m.UpdateMask",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// A snapshot resource.",
                "+type Snapshot struct {",
                "+\t// The name of the snapshot.",
                "+\tName string `protobuf:\"bytes,1,opt,name=name\" json:\"name,omitempty\"`",
                "+\t// The name of the topic from which this snapshot is retaining messages.",
                "+\tTopic string `protobuf:\"bytes,2,opt,name=topic\" json:\"topic,omitempty\"`",
                "+\t// The snapshot is guaranteed to exist up until this time.",
                "+\t// A newly-created snapshot expires no later than 7 days from the time of its",
                "+\t// creation. Its exact lifetime is determined at creation by the existing",
                "+\t// backlog in the source subscription. Specifically, the lifetime of the",
                "+\t// snapshot is `7 days - (age of oldest unacked message in the subscription)`.",
                "+\t// For example, consider a subscription whose oldest unacked message is 3 days",
                "+\t// old. If a snapshot is created from this subscription, the snapshot -- which",
                "+\t// will always capture this 3-day-old backlog as long as the snapshot",
                "+\t// exists -- will expire in 4 days.",
                "+\tExpireTime *google_protobuf4.Timestamp `protobuf:\"bytes,3,opt,name=expire_time,json=expireTime\" json:\"expire_time,omitempty\"`",
                "+\t// User labels.",
                "+\tLabels map[string]string `protobuf:\"bytes,4,rep,name=labels\" json:\"labels,omitempty\" protobuf_key:\"bytes,1,opt,name=key\" protobuf_val:\"bytes,2,opt,name=value\"`",
                "+}",
                "+",
                "+func (m *Snapshot) Reset()                    { *m = Snapshot{} }",
                "+func (m *Snapshot) String() string            { return proto.CompactTextString(m) }",
                "+func (*Snapshot) ProtoMessage()               {}",
                "+func (*Snapshot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }",
                "+",
                "+func (m *Snapshot) GetName() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Name",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *Snapshot) GetTopic() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Topic",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *Snapshot) GetExpireTime() *google_protobuf4.Timestamp {",
                "+\tif m != nil {",
                "+\t\treturn m.ExpireTime",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *Snapshot) GetLabels() map[string]string {",
                "+\tif m != nil {",
                "+\t\treturn m.Labels",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+// Request for the `ListSnapshots` method.",
                "+type ListSnapshotsRequest struct {",
                "+\t// The name of the cloud project that snapshots belong to.",
                "+\t// Format is `projects/{project}`.",
                "+\tProject string `protobuf:\"bytes,1,opt,name=project\" json:\"project,omitempty\"`",
                "+\t// Maximum number of snapshots to return.",
                "+\tPageSize int32 `protobuf:\"varint,2,opt,name=page_size,json=pageSize\" json:\"page_size,omitempty\"`",
                "+\t// The value returned by the last `ListSnapshotsResponse`; indicates that this",
                "+\t// is a continuation of a prior `ListSnapshots` call, and that the system",
                "+\t// should return the next page of data.",
                "+\tPageToken string `protobuf:\"bytes,3,opt,name=page_token,json=pageToken\" json:\"page_token,omitempty\"`",
                "+}",
                "+",
                "+func (m *ListSnapshotsRequest) Reset()                    { *m = ListSnapshotsRequest{} }",
                "+func (m *ListSnapshotsRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*ListSnapshotsRequest) ProtoMessage()               {}",
                "+func (*ListSnapshotsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }",
                "+",
                "+func (m *ListSnapshotsRequest) GetProject() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Project",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *ListSnapshotsRequest) GetPageSize() int32 {",
                "+\tif m != nil {",
                "+\t\treturn m.PageSize",
                "+\t}",
                "+\treturn 0",
                "+}",
                "+",
                "+func (m *ListSnapshotsRequest) GetPageToken() string {",
                "+\tif m != nil {",
                "+\t\treturn m.PageToken",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Response for the `ListSnapshots` method.",
                "+type ListSnapshotsResponse struct {",
                "+\t// The resulting snapshots.",
                "+\tSnapshots []*Snapshot `protobuf:\"bytes,1,rep,name=snapshots\" json:\"snapshots,omitempty\"`",
                "+\t// If not empty, indicates that there may be more snapshot that match the",
                "+\t// request; this value should be passed in a new `ListSnapshotsRequest`.",
                "+\tNextPageToken string `protobuf:\"bytes,2,opt,name=next_page_token,json=nextPageToken\" json:\"next_page_token,omitempty\"`",
                "+}",
                "+",
                "+func (m *ListSnapshotsResponse) Reset()                    { *m = ListSnapshotsResponse{} }",
                "+func (m *ListSnapshotsResponse) String() string            { return proto.CompactTextString(m) }",
                "+func (*ListSnapshotsResponse) ProtoMessage()               {}",
                "+func (*ListSnapshotsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }",
                "+",
                "+func (m *ListSnapshotsResponse) GetSnapshots() []*Snapshot {",
                "+\tif m != nil {",
                "+\t\treturn m.Snapshots",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *ListSnapshotsResponse) GetNextPageToken() string {",
                "+\tif m != nil {",
                "+\t\treturn m.NextPageToken",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Request for the `DeleteSnapshot` method.",
                "+type DeleteSnapshotRequest struct {",
                "+\t// The name of the snapshot to delete.",
                "+\t// Format is `projects/{project}/snapshots/{snap}`.",
                "+\tSnapshot string `protobuf:\"bytes,1,opt,name=snapshot\" json:\"snapshot,omitempty\"`",
                "+}",
                "+",
                "+func (m *DeleteSnapshotRequest) Reset()                    { *m = DeleteSnapshotRequest{} }",
                "+func (m *DeleteSnapshotRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*DeleteSnapshotRequest) ProtoMessage()               {}",
                "+func (*DeleteSnapshotRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }",
                "+",
                "+func (m *DeleteSnapshotRequest) GetSnapshot() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Snapshot",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// Request for the `Seek` method.",
                "+type SeekRequest struct {",
                "+\t// The subscription to affect.",
                "+\tSubscription string `protobuf:\"bytes,1,opt,name=subscription\" json:\"subscription,omitempty\"`",
                "+\t// Types that are valid to be assigned to Target:",
                "+\t//\t*SeekRequest_Time",
                "+\t//\t*SeekRequest_Snapshot",
                "+\tTarget isSeekRequest_Target `protobuf_oneof:\"target\"`",
                "+}",
                "+",
                "+func (m *SeekRequest) Reset()                    { *m = SeekRequest{} }",
                "+func (m *SeekRequest) String() string            { return proto.CompactTextString(m) }",
                "+func (*SeekRequest) ProtoMessage()               {}",
                "+func (*SeekRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }",
                "+",
                "+type isSeekRequest_Target interface {",
                "+\tisSeekRequest_Target()",
                "+}",
                "+",
                "+type SeekRequest_Time struct {",
                "+\tTime *google_protobuf4.Timestamp `protobuf:\"bytes,2,opt,name=time,oneof\"`",
                "+}",
                "+type SeekRequest_Snapshot struct {",
                "+\tSnapshot string `protobuf:\"bytes,3,opt,name=snapshot,oneof\"`",
                "+}",
                "+",
                "+func (*SeekRequest_Time) isSeekRequest_Target()     {}",
                "+func (*SeekRequest_Snapshot) isSeekRequest_Target() {}",
                "+",
                "+func (m *SeekRequest) GetTarget() isSeekRequest_Target {",
                "+\tif m != nil {",
                "+\t\treturn m.Target",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *SeekRequest) GetSubscription() string {",
                "+\tif m != nil {",
                "+\t\treturn m.Subscription",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+func (m *SeekRequest) GetTime() *google_protobuf4.Timestamp {",
                "+\tif x, ok := m.GetTarget().(*SeekRequest_Time); ok {",
                "+\t\treturn x.Time",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func (m *SeekRequest) GetSnapshot() string {",
                "+\tif x, ok := m.GetTarget().(*SeekRequest_Snapshot); ok {",
                "+\t\treturn x.Snapshot",
                "+\t}",
                "+\treturn \"\"",
                "+}",
                "+",
                "+// XXX_OneofFuncs is for the internal use of the proto package.",
                "+func (*SeekRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {",
                "+\treturn _SeekRequest_OneofMarshaler, _SeekRequest_OneofUnmarshaler, _SeekRequest_OneofSizer, []interface{}{",
                "+\t\t(*SeekRequest_Time)(nil),",
                "+\t\t(*SeekRequest_Snapshot)(nil),",
                "+\t}",
                "+}",
                "+",
                "+func _SeekRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {",
                "+\tm := msg.(*SeekRequest)",
                "+\t// target",
                "+\tswitch x := m.Target.(type) {",
                "+\tcase *SeekRequest_Time:",
                "+\t\tb.EncodeVarint(2<<3 | proto.WireBytes)",
                "+\t\tif err := b.EncodeMessage(x.Time); err != nil {",
                "+\t\t\treturn err",
                "+\t\t}",
                "+\tcase *SeekRequest_Snapshot:",
                "+\t\tb.EncodeVarint(3<<3 | proto.WireBytes)",
                "+\t\tb.EncodeStringBytes(x.Snapshot)",
                "+\tcase nil:",
                "+\tdefault:",
                "+\t\treturn fmt.Errorf(\"SeekRequest.Target has unexpected type %T\", x)",
                "+\t}",
                "+\treturn nil",
                "+}",
                "+",
                "+func _SeekRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {",
                "+\tm := msg.(*SeekRequest)",
                "+\tswitch tag {",
                "+\tcase 2: // target.time",
                "+\t\tif wire != proto.WireBytes {",
                "+\t\t\treturn true, proto.ErrInternalBadWireType",
                "+\t\t}",
                "+\t\tmsg := new(google_protobuf4.Timestamp)",
                "+\t\terr := b.DecodeMessage(msg)",
                "+\t\tm.Target = &SeekRequest_Time{msg}",
                "+\t\treturn true, err",
                "+\tcase 3: // target.snapshot",
                "+\t\tif wire != proto.WireBytes {",
                "+\t\t\treturn true, proto.ErrInternalBadWireType",
                "+\t\t}",
                "+\t\tx, err := b.DecodeStringBytes()",
                "+\t\tm.Target = &SeekRequest_Snapshot{x}",
                "+\t\treturn true, err",
                "+\tdefault:",
                "+\t\treturn false, nil",
                "+\t}",
                "+}",
                "+",
                "+func _SeekRequest_OneofSizer(msg proto.Message) (n int) {",
                "+\tm := msg.(*SeekRequest)",
                "+\t// target",
                "+\tswitch x := m.Target.(type) {",
                "+\tcase *SeekRequest_Time:",
                "+\t\ts := proto.Size(x.Time)",
                "+\t\tn += proto.SizeVarint(2<<3 | proto.WireBytes)",
                "+\t\tn += proto.SizeVarint(uint64(s))",
                "+\t\tn += s",
                "+\tcase *SeekRequest_Snapshot:",
                "+\t\tn += proto.SizeVarint(3<<3 | proto.WireBytes)",
                "+\t\tn += proto.SizeVarint(uint64(len(x.Snapshot)))",
                "+\t\tn += len(x.Snapshot)",
                "+\tcase nil:",
                "+\tdefault:",
                "+\t\tpanic(fmt.Sprintf(\"proto: unexpected type %T in oneof\", x))",
                "+\t}",
                "+\treturn n",
                "+}",
                "+",
                "+type SeekResponse struct {",
                "+}",
                "+",
                "+func (m *SeekResponse) Reset()                    { *m = SeekResponse{} }",
                "+func (m *SeekResponse) String() string            { return proto.CompactTextString(m) }",
                "+func (*SeekResponse) ProtoMessage()               {}",
                "+func (*SeekResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }",
                "+",
                "+func init() {",
                "+\tproto.RegisterType((*Topic)(nil), \"google.pubsub.v1.Topic\")",
                "+\tproto.RegisterType((*PubsubMessage)(nil), \"google.pubsub.v1.PubsubMessage\")",
                "+\tproto.RegisterType((*GetTopicRequest)(nil), \"google.pubsub.v1.GetTopicRequest\")",
                "+\tproto.RegisterType((*UpdateTopicRequest)(nil), \"google.pubsub.v1.UpdateTopicRequest\")",
                "+\tproto.RegisterType((*PublishRequest)(nil), \"google.pubsub.v1.PublishRequest\")",
                "+\tproto.RegisterType((*PublishResponse)(nil), \"google.pubsub.v1.PublishResponse\")",
                "+\tproto.RegisterType((*ListTopicsRequest)(nil), \"google.pubsub.v1.ListTopicsRequest\")",
                "+\tproto.RegisterType((*ListTopicsResponse)(nil), \"google.pubsub.v1.ListTopicsResponse\")",
                "+\tproto.RegisterType((*ListTopicSubscriptionsRequest)(nil), \"google.pubsub.v1.ListTopicSubscriptionsRequest\")",
                "+\tproto.RegisterType((*ListTopicSubscriptionsResponse)(nil), \"google.pubsub.v1.ListTopicSubscriptionsResponse\")",
                "+\tproto.RegisterType((*DeleteTopicRequest)(nil), \"google.pubsub.v1.DeleteTopicRequest\")",
                "+\tproto.RegisterType((*Subscription)(nil), \"google.pubsub.v1.Subscription\")",
                "+\tproto.RegisterType((*PushConfig)(nil), \"google.pubsub.v1.PushConfig\")",
                "+\tproto.RegisterType((*ReceivedMessage)(nil), \"google.pubsub.v1.ReceivedMessage\")",
                "+\tproto.RegisterType((*GetSubscriptionRequest)(nil), \"google.pubsub.v1.GetSubscriptionRequest\")",
                "+\tproto.RegisterType((*UpdateSubscriptionRequest)(nil), \"google.pubsub.v1.UpdateSubscriptionRequest\")",
                "+\tproto.RegisterType((*ListSubscriptionsRequest)(nil), \"google.pubsub.v1.ListSubscriptionsRequest\")",
                "+\tproto.RegisterType((*ListSubscriptionsResponse)(nil), \"google.pubsub.v1.ListSubscriptionsResponse\")",
                "+\tproto.RegisterType((*DeleteSubscriptionRequest)(nil), \"google.pubsub.v1.DeleteSubscriptionRequest\")",
                "+\tproto.RegisterType((*ModifyPushConfigRequest)(nil), \"google.pubsub.v1.ModifyPushConfigRequest\")",
                "+\tproto.RegisterType((*PullRequest)(nil), \"google.pubsub.v1.PullRequest\")",
                "+\tproto.RegisterType((*PullResponse)(nil), \"google.pubsub.v1.PullResponse\")",
                "+\tproto.RegisterType((*ModifyAckDeadlineRequest)(nil), \"google.pubsub.v1.ModifyAckDeadlineRequest\")",
                "+\tproto.RegisterType((*AcknowledgeRequest)(nil), \"google.pubsub.v1.AcknowledgeRequest\")",
                "+\tproto.RegisterType((*StreamingPullRequest)(nil), \"google.pubsub.v1.StreamingPullRequest\")",
                "+\tproto.RegisterType((*StreamingPullResponse)(nil), \"google.pubsub.v1.StreamingPullResponse\")",
                "+\tproto.RegisterType((*CreateSnapshotRequest)(nil), \"google.pubsub.v1.CreateSnapshotRequest\")",
                "+\tproto.RegisterType((*UpdateSnapshotRequest)(nil), \"google.pubsub.v1.UpdateSnapshotRequest\")",
                "+\tproto.RegisterType((*Snapshot)(nil), \"google.pubsub.v1.Snapshot\")",
                "+\tproto.RegisterType((*ListSnapshotsRequest)(nil), \"google.pubsub.v1.ListSnapshotsRequest\")",
                "+\tproto.RegisterType((*ListSnapshotsResponse)(nil), \"google.pubsub.v1.ListSnapshotsResponse\")",
                "+\tproto.RegisterType((*DeleteSnapshotRequest)(nil), \"google.pubsub.v1.DeleteSnapshotRequest\")",
                "+\tproto.RegisterType((*SeekRequest)(nil), \"google.pubsub.v1.SeekRequest\")",
                "+\tproto.RegisterType((*SeekResponse)(nil), \"google.pubsub.v1.SeekResponse\")",
                "+}",
                "+",
                "+// Reference imports to suppress errors if they are not otherwise used.",
                "+var _ context.Context",
                "+var _ grpc.ClientConn",
                "+",
                "+// This is a compile-time assertion to ensure that this generated file",
                "+// is compatible with the grpc package it is being compiled against.",
                "+const _ = grpc.SupportPackageIsVersion4",
                "+",
                "+// Client API for Subscriber service",
                "+",
                "+type SubscriberClient interface {",
                "+\t// Creates a subscription to a given topic.",
                "+\t// If the subscription already exists, returns `ALREADY_EXISTS`.",
                "+\t// If the corresponding topic doesn't exist, returns `NOT_FOUND`.",
                "+\t//",
                "+\t// If the name is not provided in the request, the server will assign a random",
                "+\t// name for this subscription on the same project as the topic, conforming",
                "+\t// to the",
                "+\t// [resource name format](https://cloud.google.com/pubsub/docs/overview#names).",
                "+\t// The generated name is populated in the returned Subscription object.",
                "+\t// Note that for REST API requests, you must specify a name in the request.",
                "+\tCreateSubscription(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*Subscription, error)",
                "+\t// Gets the configuration details of a subscription.",
                "+\tGetSubscription(ctx context.Context, in *GetSubscriptionRequest, opts ...grpc.CallOption) (*Subscription, error)",
                "+\t// Updates an existing subscription. Note that certain properties of a",
                "+\t// subscription, such as its topic, are not modifiable.",
                "+\t// NOTE:  The style guide requires body: \"subscription\" instead of body: \"*\".",
                "+\t// Keeping the latter for internal consistency in V1, however it should be",
                "+\t// corrected in V2.  See",
                "+\t// https://cloud.google.com/apis/design/standard_methods#update for details.",
                "+\tUpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...grpc.CallOption) (*Subscription, error)",
                "+\t// Lists matching subscriptions.",
                "+\tListSubscriptions(ctx context.Context, in *ListSubscriptionsRequest, opts ...grpc.CallOption) (*ListSubscriptionsResponse, error)",
                "+\t// Deletes an existing subscription. All messages retained in the subscription",
                "+\t// are immediately dropped. Calls to `Pull` after deletion will return",
                "+\t// `NOT_FOUND`. After a subscription is deleted, a new one may be created with",
                "+\t// the same name, but the new one has no association with the old",
                "+\t// subscription or its topic unless the same topic is specified.",
                "+\tDeleteSubscription(ctx context.Context, in *DeleteSubscriptionRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error)",
                "+\t// Modifies the ack deadline for a specific message. This method is useful",
                "+\t// to indicate that more time is needed to process a message by the",
                "+\t// subscriber, or to make the message available for redelivery if the",
                "+\t// processing was interrupted. Note that this does not modify the",
                "+\t// subscription-level `ackDeadlineSeconds` used for subsequent messages.",
                "+\tModifyAckDeadline(ctx context.Context, in *ModifyAckDeadlineRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error)",
                "+\t// Acknowledges the messages associated with the `ack_ids` in the",
                "+\t// `AcknowledgeRequest`. The Pub/Sub system can remove the relevant messages",
                "+\t// from the subscription.",
                "+\t//",
                "+\t// Acknowledging a message whose ack deadline has expired may succeed,",
                "+\t// but such a message may be redelivered later. Acknowledging a message more",
                "+\t// than once will not result in an error.",
                "+\tAcknowledge(ctx context.Context, in *AcknowledgeRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error)",
                "+\t// Pulls messages from the server. Returns an empty list if there are no",
                "+\t// messages available in the backlog. The server may return `UNAVAILABLE` if",
                "+\t// there are too many concurrent pull requests pending for the given",
                "+\t// subscription.",
                "+\tPull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error)",
                "+\t// (EXPERIMENTAL) StreamingPull is an experimental feature. This RPC will",
                "+\t// respond with UNIMPLEMENTED errors unless you have been invited to test",
                "+\t// this feature. Contact cloud-pubsub@google.com with any questions.",
                "+\t//",
                "+\t// Establishes a stream with the server, which sends messages down to the",
                "+\t// client. The client streams acknowledgements and ack deadline modifications",
                "+\t// back to the server. The server will close the stream and return the status",
                "+\t// on any error. The server may close the stream with status `OK` to reassign",
                "+\t// server-side resources, in which case, the client should re-establish the",
                "+\t// stream. `UNAVAILABLE` may also be returned in the case of a transient error",
                "+\t// (e.g., a server restart). These should also be retried by the client. Flow",
                "+\t// control can be achieved by configuring the underlying RPC channel.",
                "+\tStreamingPull(ctx context.Context, opts ...grpc.CallOption) (Subscriber_StreamingPullClient, error)",
                "+\t// Modifies the `PushConfig` for a specified subscription.",
                "+\t//",
                "+\t// This may be used to change a push subscription to a pull one (signified by",
                "+\t// an empty `PushConfig`) or vice versa, or change the endpoint URL and other",
                "+\t// attributes of a push subscription. Messages will accumulate for delivery",
                "+\t// continuously through the call regardless of changes to the `PushConfig`.",
                "+\tModifyPushConfig(ctx context.Context, in *ModifyPushConfigRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error)",
                "+\t// Lists the existing snapshots.",
                "+\tListSnapshots(ctx context.Context, in *ListSnapshotsRequest, opts ...grpc.CallOption) (*ListSnapshotsResponse, error)",
                "+\t// Creates a snapshot from the requested subscription.",
                "+\t// If the snapshot already exists, returns `ALREADY_EXISTS`.",
                "+\t// If the requested subscription doesn't exist, returns `NOT_FOUND`.",
                "+\t//",
                "+\t// If the name is not provided in the request, the server will assign a random",
                "+\t// name for this snapshot on the same project as the subscription, conforming",
                "+\t// to the",
                "+\t// [resource name format](https://cloud.google.com/pubsub/docs/overview#names).",
                "+\t// The generated name is populated in the returned Snapshot object.",
                "+\t// Note that for REST API requests, you must specify a name in the request.",
                "+\tCreateSnapshot(ctx context.Context, in *CreateSnapshotRequest, opts ...grpc.CallOption) (*Snapshot, error)",
                "+\t// Updates an existing snapshot. Note that certain properties of a snapshot",
                "+\t// are not modifiable.",
                "+\t// NOTE:  The style guide requires body: \"snapshot\" instead of body: \"*\".",
                "+\t// Keeping the latter for internal consistency in V1, however it should be",
                "+\t// corrected in V2.  See",
                "+\t// https://cloud.google.com/apis/design/standard_methods#update for details.",
                "+\tUpdateSnapshot(ctx context.Context, in *UpdateSnapshotRequest, opts ...grpc.CallOption) (*Snapshot, error)",
                "+\t// Removes an existing snapshot. All messages retained in the snapshot",
                "+\t// are immediately dropped. After a snapshot is deleted, a new one may be",
                "+\t// created with the same name, but the new one has no association with the old",
                "+\t// snapshot or its subscription, unless the same subscription is specified.",
                "+\tDeleteSnapshot(ctx context.Context, in *DeleteSnapshotRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error)",
                "+\t// Seeks an existing subscription to a point in time or to a given snapshot,",
                "+\t// whichever is provided in the request.",
                "+\tSeek(ctx context.Context, in *SeekRequest, opts ...grpc.CallOption) (*SeekResponse, error)",
                "+}",
                "+",
                "+type subscriberClient struct {",
                "+\tcc *grpc.ClientConn",
                "+}",
                "+",
                "+func NewSubscriberClient(cc *grpc.ClientConn) SubscriberClient {",
                "+\treturn &subscriberClient{cc}",
                "+}",
                "+",
                "+func (c *subscriberClient) CreateSubscription(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*Subscription, error) {",
                "+\tout := new(Subscription)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/CreateSubscription\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) GetSubscription(ctx context.Context, in *GetSubscriptionRequest, opts ...grpc.CallOption) (*Subscription, error) {",
                "+\tout := new(Subscription)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/GetSubscription\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) UpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...grpc.CallOption) (*Subscription, error) {",
                "+\tout := new(Subscription)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/UpdateSubscription\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) ListSubscriptions(ctx context.Context, in *ListSubscriptionsRequest, opts ...grpc.CallOption) (*ListSubscriptionsResponse, error) {",
                "+\tout := new(ListSubscriptionsResponse)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/ListSubscriptions\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) DeleteSubscription(ctx context.Context, in *DeleteSubscriptionRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error) {",
                "+\tout := new(google_protobuf2.Empty)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/DeleteSubscription\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) ModifyAckDeadline(ctx context.Context, in *ModifyAckDeadlineRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error) {",
                "+\tout := new(google_protobuf2.Empty)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/ModifyAckDeadline\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) Acknowledge(ctx context.Context, in *AcknowledgeRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error) {",
                "+\tout := new(google_protobuf2.Empty)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/Acknowledge\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error) {",
                "+\tout := new(PullResponse)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/Pull\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) StreamingPull(ctx context.Context, opts ...grpc.CallOption) (Subscriber_StreamingPullClient, error) {",
                "+\tstream, err := grpc.NewClientStream(ctx, &_Subscriber_serviceDesc.Streams[0], c.cc, \"/google.pubsub.v1.Subscriber/StreamingPull\", opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tx := &subscriberStreamingPullClient{stream}",
                "+\treturn x, nil",
                "+}",
                "+",
                "+type Subscriber_StreamingPullClient interface {",
                "+\tSend(*StreamingPullRequest) error",
                "+\tRecv() (*StreamingPullResponse, error)",
                "+\tgrpc.ClientStream",
                "+}",
                "+",
                "+type subscriberStreamingPullClient struct {",
                "+\tgrpc.ClientStream",
                "+}",
                "+",
                "+func (x *subscriberStreamingPullClient) Send(m *StreamingPullRequest) error {",
                "+\treturn x.ClientStream.SendMsg(m)",
                "+}",
                "+",
                "+func (x *subscriberStreamingPullClient) Recv() (*StreamingPullResponse, error) {",
                "+\tm := new(StreamingPullResponse)",
                "+\tif err := x.ClientStream.RecvMsg(m); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn m, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) ModifyPushConfig(ctx context.Context, in *ModifyPushConfigRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error) {",
                "+\tout := new(google_protobuf2.Empty)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/ModifyPushConfig\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) ListSnapshots(ctx context.Context, in *ListSnapshotsRequest, opts ...grpc.CallOption) (*ListSnapshotsResponse, error) {",
                "+\tout := new(ListSnapshotsResponse)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/ListSnapshots\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) CreateSnapshot(ctx context.Context, in *CreateSnapshotRequest, opts ...grpc.CallOption) (*Snapshot, error) {",
                "+\tout := new(Snapshot)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/CreateSnapshot\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) UpdateSnapshot(ctx context.Context, in *UpdateSnapshotRequest, opts ...grpc.CallOption) (*Snapshot, error) {",
                "+\tout := new(Snapshot)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/UpdateSnapshot\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) DeleteSnapshot(ctx context.Context, in *DeleteSnapshotRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error) {",
                "+\tout := new(google_protobuf2.Empty)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/DeleteSnapshot\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *subscriberClient) Seek(ctx context.Context, in *SeekRequest, opts ...grpc.CallOption) (*SeekResponse, error) {",
                "+\tout := new(SeekResponse)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Subscriber/Seek\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+// Server API for Subscriber service",
                "+",
                "+type SubscriberServer interface {",
                "+\t// Creates a subscription to a given topic.",
                "+\t// If the subscription already exists, returns `ALREADY_EXISTS`.",
                "+\t// If the corresponding topic doesn't exist, returns `NOT_FOUND`.",
                "+\t//",
                "+\t// If the name is not provided in the request, the server will assign a random",
                "+\t// name for this subscription on the same project as the topic, conforming",
                "+\t// to the",
                "+\t// [resource name format](https://cloud.google.com/pubsub/docs/overview#names).",
                "+\t// The generated name is populated in the returned Subscription object.",
                "+\t// Note that for REST API requests, you must specify a name in the request.",
                "+\tCreateSubscription(context.Context, *Subscription) (*Subscription, error)",
                "+\t// Gets the configuration details of a subscription.",
                "+\tGetSubscription(context.Context, *GetSubscriptionRequest) (*Subscription, error)",
                "+\t// Updates an existing subscription. Note that certain properties of a",
                "+\t// subscription, such as its topic, are not modifiable.",
                "+\t// NOTE:  The style guide requires body: \"subscription\" instead of body: \"*\".",
                "+\t// Keeping the latter for internal consistency in V1, however it should be",
                "+\t// corrected in V2.  See",
                "+\t// https://cloud.google.com/apis/design/standard_methods#update for details.",
                "+\tUpdateSubscription(context.Context, *UpdateSubscriptionRequest) (*Subscription, error)",
                "+\t// Lists matching subscriptions.",
                "+\tListSubscriptions(context.Context, *ListSubscriptionsRequest) (*ListSubscriptionsResponse, error)",
                "+\t// Deletes an existing subscription. All messages retained in the subscription",
                "+\t// are immediately dropped. Calls to `Pull` after deletion will return",
                "+\t// `NOT_FOUND`. After a subscription is deleted, a new one may be created with",
                "+\t// the same name, but the new one has no association with the old",
                "+\t// subscription or its topic unless the same topic is specified.",
                "+\tDeleteSubscription(context.Context, *DeleteSubscriptionRequest) (*google_protobuf2.Empty, error)",
                "+\t// Modifies the ack deadline for a specific message. This method is useful",
                "+\t// to indicate that more time is needed to process a message by the",
                "+\t// subscriber, or to make the message available for redelivery if the",
                "+\t// processing was interrupted. Note that this does not modify the",
                "+\t// subscription-level `ackDeadlineSeconds` used for subsequent messages.",
                "+\tModifyAckDeadline(context.Context, *ModifyAckDeadlineRequest) (*google_protobuf2.Empty, error)",
                "+\t// Acknowledges the messages associated with the `ack_ids` in the",
                "+\t// `AcknowledgeRequest`. The Pub/Sub system can remove the relevant messages",
                "+\t// from the subscription.",
                "+\t//",
                "+\t// Acknowledging a message whose ack deadline has expired may succeed,",
                "+\t// but such a message may be redelivered later. Acknowledging a message more",
                "+\t// than once will not result in an error.",
                "+\tAcknowledge(context.Context, *AcknowledgeRequest) (*google_protobuf2.Empty, error)",
                "+\t// Pulls messages from the server. Returns an empty list if there are no",
                "+\t// messages available in the backlog. The server may return `UNAVAILABLE` if",
                "+\t// there are too many concurrent pull requests pending for the given",
                "+\t// subscription.",
                "+\tPull(context.Context, *PullRequest) (*PullResponse, error)",
                "+\t// (EXPERIMENTAL) StreamingPull is an experimental feature. This RPC will",
                "+\t// respond with UNIMPLEMENTED errors unless you have been invited to test",
                "+\t// this feature. Contact cloud-pubsub@google.com with any questions.",
                "+\t//",
                "+\t// Establishes a stream with the server, which sends messages down to the",
                "+\t// client. The client streams acknowledgements and ack deadline modifications",
                "+\t// back to the server. The server will close the stream and return the status",
                "+\t// on any error. The server may close the stream with status `OK` to reassign",
                "+\t// server-side resources, in which case, the client should re-establish the",
                "+\t// stream. `UNAVAILABLE` may also be returned in the case of a transient error",
                "+\t// (e.g., a server restart). These should also be retried by the client. Flow",
                "+\t// control can be achieved by configuring the underlying RPC channel.",
                "+\tStreamingPull(Subscriber_StreamingPullServer) error",
                "+\t// Modifies the `PushConfig` for a specified subscription.",
                "+\t//",
                "+\t// This may be used to change a push subscription to a pull one (signified by",
                "+\t// an empty `PushConfig`) or vice versa, or change the endpoint URL and other",
                "+\t// attributes of a push subscription. Messages will accumulate for delivery",
                "+\t// continuously through the call regardless of changes to the `PushConfig`.",
                "+\tModifyPushConfig(context.Context, *ModifyPushConfigRequest) (*google_protobuf2.Empty, error)",
                "+\t// Lists the existing snapshots.",
                "+\tListSnapshots(context.Context, *ListSnapshotsRequest) (*ListSnapshotsResponse, error)",
                "+\t// Creates a snapshot from the requested subscription.",
                "+\t// If the snapshot already exists, returns `ALREADY_EXISTS`.",
                "+\t// If the requested subscription doesn't exist, returns `NOT_FOUND`.",
                "+\t//",
                "+\t// If the name is not provided in the request, the server will assign a random",
                "+\t// name for this snapshot on the same project as the subscription, conforming",
                "+\t// to the",
                "+\t// [resource name format](https://cloud.google.com/pubsub/docs/overview#names).",
                "+\t// The generated name is populated in the returned Snapshot object.",
                "+\t// Note that for REST API requests, you must specify a name in the request.",
                "+\tCreateSnapshot(context.Context, *CreateSnapshotRequest) (*Snapshot, error)",
                "+\t// Updates an existing snapshot. Note that certain properties of a snapshot",
                "+\t// are not modifiable.",
                "+\t// NOTE:  The style guide requires body: \"snapshot\" instead of body: \"*\".",
                "+\t// Keeping the latter for internal consistency in V1, however it should be",
                "+\t// corrected in V2.  See",
                "+\t// https://cloud.google.com/apis/design/standard_methods#update for details.",
                "+\tUpdateSnapshot(context.Context, *UpdateSnapshotRequest) (*Snapshot, error)",
                "+\t// Removes an existing snapshot. All messages retained in the snapshot",
                "+\t// are immediately dropped. After a snapshot is deleted, a new one may be",
                "+\t// created with the same name, but the new one has no association with the old",
                "+\t// snapshot or its subscription, unless the same subscription is specified.",
                "+\tDeleteSnapshot(context.Context, *DeleteSnapshotRequest) (*google_protobuf2.Empty, error)",
                "+\t// Seeks an existing subscription to a point in time or to a given snapshot,",
                "+\t// whichever is provided in the request.",
                "+\tSeek(context.Context, *SeekRequest) (*SeekResponse, error)",
                "+}",
                "+",
                "+func RegisterSubscriberServer(s *grpc.Server, srv SubscriberServer) {",
                "+\ts.RegisterService(&_Subscriber_serviceDesc, srv)",
                "+}",
                "+",
                "+func _Subscriber_CreateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(Subscription)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).CreateSubscription(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/CreateSubscription\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).CreateSubscription(ctx, req.(*Subscription))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_GetSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(GetSubscriptionRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).GetSubscription(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/GetSubscription\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).GetSubscription(ctx, req.(*GetSubscriptionRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_UpdateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(UpdateSubscriptionRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).UpdateSubscription(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/UpdateSubscription\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).UpdateSubscription(ctx, req.(*UpdateSubscriptionRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_ListSubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(ListSubscriptionsRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).ListSubscriptions(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/ListSubscriptions\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).ListSubscriptions(ctx, req.(*ListSubscriptionsRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_DeleteSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(DeleteSubscriptionRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).DeleteSubscription(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/DeleteSubscription\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).DeleteSubscription(ctx, req.(*DeleteSubscriptionRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_ModifyAckDeadline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(ModifyAckDeadlineRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).ModifyAckDeadline(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/ModifyAckDeadline\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).ModifyAckDeadline(ctx, req.(*ModifyAckDeadlineRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_Acknowledge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(AcknowledgeRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).Acknowledge(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/Acknowledge\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).Acknowledge(ctx, req.(*AcknowledgeRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_Pull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(PullRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).Pull(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/Pull\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).Pull(ctx, req.(*PullRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_StreamingPull_Handler(srv interface{}, stream grpc.ServerStream) error {",
                "+\treturn srv.(SubscriberServer).StreamingPull(&subscriberStreamingPullServer{stream})",
                "+}",
                "+",
                "+type Subscriber_StreamingPullServer interface {",
                "+\tSend(*StreamingPullResponse) error",
                "+\tRecv() (*StreamingPullRequest, error)",
                "+\tgrpc.ServerStream",
                "+}",
                "+",
                "+type subscriberStreamingPullServer struct {",
                "+\tgrpc.ServerStream",
                "+}",
                "+",
                "+func (x *subscriberStreamingPullServer) Send(m *StreamingPullResponse) error {",
                "+\treturn x.ServerStream.SendMsg(m)",
                "+}",
                "+",
                "+func (x *subscriberStreamingPullServer) Recv() (*StreamingPullRequest, error) {",
                "+\tm := new(StreamingPullRequest)",
                "+\tif err := x.ServerStream.RecvMsg(m); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn m, nil",
                "+}",
                "+",
                "+func _Subscriber_ModifyPushConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(ModifyPushConfigRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).ModifyPushConfig(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/ModifyPushConfig\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).ModifyPushConfig(ctx, req.(*ModifyPushConfigRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_ListSnapshots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(ListSnapshotsRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).ListSnapshots(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/ListSnapshots\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).ListSnapshots(ctx, req.(*ListSnapshotsRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_CreateSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(CreateSnapshotRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).CreateSnapshot(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/CreateSnapshot\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).CreateSnapshot(ctx, req.(*CreateSnapshotRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_UpdateSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(UpdateSnapshotRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).UpdateSnapshot(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/UpdateSnapshot\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).UpdateSnapshot(ctx, req.(*UpdateSnapshotRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_DeleteSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(DeleteSnapshotRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).DeleteSnapshot(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/DeleteSnapshot\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).DeleteSnapshot(ctx, req.(*DeleteSnapshotRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Subscriber_Seek_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(SeekRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(SubscriberServer).Seek(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Subscriber/Seek\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(SubscriberServer).Seek(ctx, req.(*SeekRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+var _Subscriber_serviceDesc = grpc.ServiceDesc{",
                "+\tServiceName: \"google.pubsub.v1.Subscriber\",",
                "+\tHandlerType: (*SubscriberServer)(nil),",
                "+\tMethods: []grpc.MethodDesc{",
                "+\t\t{",
                "+\t\t\tMethodName: \"CreateSubscription\",",
                "+\t\t\tHandler:    _Subscriber_CreateSubscription_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"GetSubscription\",",
                "+\t\t\tHandler:    _Subscriber_GetSubscription_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"UpdateSubscription\",",
                "+\t\t\tHandler:    _Subscriber_UpdateSubscription_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"ListSubscriptions\",",
                "+\t\t\tHandler:    _Subscriber_ListSubscriptions_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"DeleteSubscription\",",
                "+\t\t\tHandler:    _Subscriber_DeleteSubscription_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"ModifyAckDeadline\",",
                "+\t\t\tHandler:    _Subscriber_ModifyAckDeadline_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"Acknowledge\",",
                "+\t\t\tHandler:    _Subscriber_Acknowledge_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"Pull\",",
                "+\t\t\tHandler:    _Subscriber_Pull_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"ModifyPushConfig\",",
                "+\t\t\tHandler:    _Subscriber_ModifyPushConfig_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"ListSnapshots\",",
                "+\t\t\tHandler:    _Subscriber_ListSnapshots_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"CreateSnapshot\",",
                "+\t\t\tHandler:    _Subscriber_CreateSnapshot_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"UpdateSnapshot\",",
                "+\t\t\tHandler:    _Subscriber_UpdateSnapshot_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"DeleteSnapshot\",",
                "+\t\t\tHandler:    _Subscriber_DeleteSnapshot_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"Seek\",",
                "+\t\t\tHandler:    _Subscriber_Seek_Handler,",
                "+\t\t},",
                "+\t},",
                "+\tStreams: []grpc.StreamDesc{",
                "+\t\t{",
                "+\t\t\tStreamName:    \"StreamingPull\",",
                "+\t\t\tHandler:       _Subscriber_StreamingPull_Handler,",
                "+\t\t\tServerStreams: true,",
                "+\t\t\tClientStreams: true,",
                "+\t\t},",
                "+\t},",
                "+\tMetadata: \"google/pubsub/v1/pubsub.proto\",",
                "+}",
                "+",
                "+// Client API for Publisher service",
                "+",
                "+type PublisherClient interface {",
                "+\t// Creates the given topic with the given name.",
                "+\tCreateTopic(ctx context.Context, in *Topic, opts ...grpc.CallOption) (*Topic, error)",
                "+\t// Updates an existing topic. Note that certain properties of a topic are not",
                "+\t// modifiable.  Options settings follow the style guide:",
                "+\t// NOTE:  The style guide requires body: \"topic\" instead of body: \"*\".",
                "+\t// Keeping the latter for internal consistency in V1, however it should be",
                "+\t// corrected in V2.  See",
                "+\t// https://cloud.google.com/apis/design/standard_methods#update for details.",
                "+\tUpdateTopic(ctx context.Context, in *UpdateTopicRequest, opts ...grpc.CallOption) (*Topic, error)",
                "+\t// Adds one or more messages to the topic. Returns `NOT_FOUND` if the topic",
                "+\t// does not exist. The message payload must not be empty; it must contain",
                "+\t//  either a non-empty data field, or at least one attribute.",
                "+\tPublish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error)",
                "+\t// Gets the configuration of a topic.",
                "+\tGetTopic(ctx context.Context, in *GetTopicRequest, opts ...grpc.CallOption) (*Topic, error)",
                "+\t// Lists matching topics.",
                "+\tListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error)",
                "+\t// Lists the name of the subscriptions for this topic.",
                "+\tListTopicSubscriptions(ctx context.Context, in *ListTopicSubscriptionsRequest, opts ...grpc.CallOption) (*ListTopicSubscriptionsResponse, error)",
                "+\t// Deletes the topic with the given name. Returns `NOT_FOUND` if the topic",
                "+\t// does not exist. After a topic is deleted, a new topic may be created with",
                "+\t// the same name; this is an entirely new topic with none of the old",
                "+\t// configuration or subscriptions. Existing subscriptions to this topic are",
                "+\t// not deleted, but their `topic` field is set to `_deleted-topic_`.",
                "+\tDeleteTopic(ctx context.Context, in *DeleteTopicRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error)",
                "+}",
                "+",
                "+type publisherClient struct {",
                "+\tcc *grpc.ClientConn",
                "+}",
                "+",
                "+func NewPublisherClient(cc *grpc.ClientConn) PublisherClient {",
                "+\treturn &publisherClient{cc}",
                "+}",
                "+",
                "+func (c *publisherClient) CreateTopic(ctx context.Context, in *Topic, opts ...grpc.CallOption) (*Topic, error) {",
                "+\tout := new(Topic)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Publisher/CreateTopic\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *publisherClient) UpdateTopic(ctx context.Context, in *UpdateTopicRequest, opts ...grpc.CallOption) (*Topic, error) {",
                "+\tout := new(Topic)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Publisher/UpdateTopic\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *publisherClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error) {",
                "+\tout := new(PublishResponse)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Publisher/Publish\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *publisherClient) GetTopic(ctx context.Context, in *GetTopicRequest, opts ...grpc.CallOption) (*Topic, error) {",
                "+\tout := new(Topic)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Publisher/GetTopic\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *publisherClient) ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error) {",
                "+\tout := new(ListTopicsResponse)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Publisher/ListTopics\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *publisherClient) ListTopicSubscriptions(ctx context.Context, in *ListTopicSubscriptionsRequest, opts ...grpc.CallOption) (*ListTopicSubscriptionsResponse, error) {",
                "+\tout := new(ListTopicSubscriptionsResponse)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Publisher/ListTopicSubscriptions\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+func (c *publisherClient) DeleteTopic(ctx context.Context, in *DeleteTopicRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error) {",
                "+\tout := new(google_protobuf2.Empty)",
                "+\terr := grpc.Invoke(ctx, \"/google.pubsub.v1.Publisher/DeleteTopic\", in, out, c.cc, opts...)",
                "+\tif err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\treturn out, nil",
                "+}",
                "+",
                "+// Server API for Publisher service",
                "+",
                "+type PublisherServer interface {",
                "+\t// Creates the given topic with the given name.",
                "+\tCreateTopic(context.Context, *Topic) (*Topic, error)",
                "+\t// Updates an existing topic. Note that certain properties of a topic are not",
                "+\t// modifiable.  Options settings follow the style guide:",
                "+\t// NOTE:  The style guide requires body: \"topic\" instead of body: \"*\".",
                "+\t// Keeping the latter for internal consistency in V1, however it should be",
                "+\t// corrected in V2.  See",
                "+\t// https://cloud.google.com/apis/design/standard_methods#update for details.",
                "+\tUpdateTopic(context.Context, *UpdateTopicRequest) (*Topic, error)",
                "+\t// Adds one or more messages to the topic. Returns `NOT_FOUND` if the topic",
                "+\t// does not exist. The message payload must not be empty; it must contain",
                "+\t//  either a non-empty data field, or at least one attribute.",
                "+\tPublish(context.Context, *PublishRequest) (*PublishResponse, error)",
                "+\t// Gets the configuration of a topic.",
                "+\tGetTopic(context.Context, *GetTopicRequest) (*Topic, error)",
                "+\t// Lists matching topics.",
                "+\tListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error)",
                "+\t// Lists the name of the subscriptions for this topic.",
                "+\tListTopicSubscriptions(context.Context, *ListTopicSubscriptionsRequest) (*ListTopicSubscriptionsResponse, error)",
                "+\t// Deletes the topic with the given name. Returns `NOT_FOUND` if the topic",
                "+\t// does not exist. After a topic is deleted, a new topic may be created with",
                "+\t// the same name; this is an entirely new topic with none of the old",
                "+\t// configuration or subscriptions. Existing subscriptions to this topic are",
                "+\t// not deleted, but their `topic` field is set to `_deleted-topic_`.",
                "+\tDeleteTopic(context.Context, *DeleteTopicRequest) (*google_protobuf2.Empty, error)",
                "+}",
                "+",
                "+func RegisterPublisherServer(s *grpc.Server, srv PublisherServer) {",
                "+\ts.RegisterService(&_Publisher_serviceDesc, srv)",
                "+}",
                "+",
                "+func _Publisher_CreateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(Topic)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(PublisherServer).CreateTopic(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Publisher/CreateTopic\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(PublisherServer).CreateTopic(ctx, req.(*Topic))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Publisher_UpdateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(UpdateTopicRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(PublisherServer).UpdateTopic(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Publisher/UpdateTopic\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(PublisherServer).UpdateTopic(ctx, req.(*UpdateTopicRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Publisher_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(PublishRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(PublisherServer).Publish(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Publisher/Publish\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(PublisherServer).Publish(ctx, req.(*PublishRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Publisher_GetTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(GetTopicRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(PublisherServer).GetTopic(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Publisher/GetTopic\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(PublisherServer).GetTopic(ctx, req.(*GetTopicRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Publisher_ListTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(ListTopicsRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(PublisherServer).ListTopics(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Publisher/ListTopics\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(PublisherServer).ListTopics(ctx, req.(*ListTopicsRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Publisher_ListTopicSubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(ListTopicSubscriptionsRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(PublisherServer).ListTopicSubscriptions(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Publisher/ListTopicSubscriptions\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(PublisherServer).ListTopicSubscriptions(ctx, req.(*ListTopicSubscriptionsRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+func _Publisher_DeleteTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
                "+\tin := new(DeleteTopicRequest)",
                "+\tif err := dec(in); err != nil {",
                "+\t\treturn nil, err",
                "+\t}",
                "+\tif interceptor == nil {",
                "+\t\treturn srv.(PublisherServer).DeleteTopic(ctx, in)",
                "+\t}",
                "+\tinfo := &grpc.UnaryServerInfo{",
                "+\t\tServer:     srv,",
                "+\t\tFullMethod: \"/google.pubsub.v1.Publisher/DeleteTopic\",",
                "+\t}",
                "+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {",
                "+\t\treturn srv.(PublisherServer).DeleteTopic(ctx, req.(*DeleteTopicRequest))",
                "+\t}",
                "+\treturn interceptor(ctx, in, info, handler)",
                "+}",
                "+",
                "+var _Publisher_serviceDesc = grpc.ServiceDesc{",
                "+\tServiceName: \"google.pubsub.v1.Publisher\",",
                "+\tHandlerType: (*PublisherServer)(nil),",
                "+\tMethods: []grpc.MethodDesc{",
                "+\t\t{",
                "+\t\t\tMethodName: \"CreateTopic\",",
                "+\t\t\tHandler:    _Publisher_CreateTopic_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"UpdateTopic\",",
                "+\t\t\tHandler:    _Publisher_UpdateTopic_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"Publish\",",
                "+\t\t\tHandler:    _Publisher_Publish_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"GetTopic\",",
                "+\t\t\tHandler:    _Publisher_GetTopic_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"ListTopics\",",
                "+\t\t\tHandler:    _Publisher_ListTopics_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"ListTopicSubscriptions\",",
                "+\t\t\tHandler:    _Publisher_ListTopicSubscriptions_Handler,",
                "+\t\t},",
                "+\t\t{",
                "+\t\t\tMethodName: \"DeleteTopic\",",
                "+\t\t\tHandler:    _Publisher_DeleteTopic_Handler,",
                "+\t\t},",
                "+\t},",
                "+\tStreams:  []grpc.StreamDesc{},",
                "+\tMetadata: \"google/pubsub/v1/pubsub.proto\",",
                "+}",
                "+",
                "+func init() { proto.RegisterFile(\"google/pubsub/v1/pubsub.proto\", fileDescriptor0) }",
                "+",
                "+var fileDescriptor0 = []byte{",
                "+\t// 2011 bytes of a gzipped FileDescriptorProto",
                "+\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0xcb, 0x73, 0xdb, 0xc6,",
                "+\t0x19, 0xcf, 0x92, 0x7a, 0x50, 0x1f, 0xf4, 0xf2, 0x56, 0xb2, 0x69, 0xf8, 0x25, 0xc1, 0x8a, 0x45,",
                "+\t0x33, 0x36, 0x29, 0x33, 0x13, 0x37, 0xb6, 0x2a, 0x67, 0x24, 0xcb, 0x75, 0xdc, 0xb1, 0x1b, 0x15,",
                "+\t0x72, 0xdb, 0x99, 0x1e, 0xca, 0x01, 0x89, 0x35, 0x8d, 0x90, 0x04, 0x10, 0x00, 0x54, 0xad, 0xb4,",
                "+\t0x9e, 0x49, 0x93, 0x4e, 0x67, 0x3a, 0xf5, 0xa1, 0x69, 0x6e, 0x9d, 0x1c, 0x3a, 0xd3, 0x5b, 0x8f,",
                "+\t0x9d, 0xe9, 0xb5, 0xff, 0x44, 0xff, 0x85, 0x1e, 0x7b, 0x6f, 0x8f, 0x99, 0x7d, 0x00, 0xc4, 0x63,",
                "+\t0x41, 0x8a, 0xb2, 0x7d, 0x03, 0xf6, 0xfb, 0x76, 0xbf, 0xdf, 0xf7, 0xfe, 0x80, 0x85, 0x4b, 0x1d,",
                "+\t0xc7, 0xe9, 0xf4, 0x48, 0xdd, 0x1d, 0xb4, 0xfc, 0x41, 0xab, 0x7e, 0x74, 0x4b, 0x3c, 0xd5, 0x5c,",
                "+\t0xcf, 0x09, 0x1c, 0xbc, 0xcc, 0xc9, 0x35, 0xb1, 0x78, 0x74, 0x4b, 0xbd, 0x28, 0x36, 0x18, 0xae,",
                "+\t0x55, 0x37, 0x6c, 0xdb, 0x09, 0x8c, 0xc0, 0x72, 0x6c, 0x9f, 0xf3, 0xab, 0x97, 0xc3, 0xe3, 0xe8,",
                "+\t0x5b, 0x6b, 0xf0, 0xac, 0x6e, 0x0e, 0x3c, 0xc6, 0x20, 0xe8, 0x17, 0xd2, 0x74, 0xd2, 0x77, 0x83,",
                "+\t0x63, 0x41, 0x5c, 0x4b, 0x13, 0x9f, 0x59, 0xa4, 0x67, 0x36, 0xfb, 0x86, 0xdf, 0x15, 0x1c, 0x57,",
                "+\t0xd2, 0x1c, 0x81, 0xd5, 0x27, 0x7e, 0x60, 0xf4, 0x5d, 0xce, 0xa0, 0x7d, 0x83, 0x60, 0xfa, 0xa9,",
                "+\t0xe3, 0x5a, 0x6d, 0x8c, 0x61, 0xca, 0x36, 0xfa, 0xa4, 0x8c, 0xd6, 0x50, 0x65, 0x4e, 0x67, 0xcf,",
                "+\t0x78, 0x1b, 0x66, 0x7a, 0x46, 0x8b, 0xf4, 0xfc, 0x72, 0x61, 0xad, 0x58, 0x51, 0x1a, 0x57, 0x6b,",
                "+\t0x69, 0xf5, 0x6a, 0x6c, 0x73, 0xed, 0x31, 0xe3, 0x7a, 0x60, 0x07, 0xde, 0xb1, 0x2e, 0xb6, 0xa8,",
                "+\t0x77, 0x40, 0x89, 0x2d, 0xe3, 0x65, 0x28, 0x76, 0xc9, 0xb1, 0x38, 0x9e, 0x3e, 0xe2, 0x15, 0x98,",
                "+\t0x3e, 0x32, 0x7a, 0x03, 0x52, 0x2e, 0xb0, 0x35, 0xfe, 0x72, 0xb7, 0xf0, 0x21, 0xd2, 0xbe, 0x2e,",
                "+\t0xc0, 0xc2, 0x01, 0x13, 0xf1, 0x84, 0xf8, 0xbe, 0xd1, 0x21, 0x14, 0x9d, 0x69, 0x04, 0x06, 0xdb,",
                "+\t0x3e, 0xaf, 0xb3, 0x67, 0xfc, 0x09, 0x80, 0x11, 0x04, 0x9e, 0xd5, 0x1a, 0x04, 0x24, 0x44, 0x58,",
                "+\t0xcf, 0x22, 0x4c, 0x1c, 0x54, 0xdb, 0x8d, 0x76, 0x70, 0xb4, 0xb1, 0x23, 0xf0, 0x25, 0x80, 0x3e,",
                "+\t0x67, 0x6b, 0x5a, 0x66, 0xb9, 0xc8, 0x50, 0xcd, 0x89, 0x95, 0x47, 0x26, 0xde, 0x81, 0x79, 0x77,",
                "+\t0xd0, 0xea, 0x59, 0xfe, 0xf3, 0x26, 0x35, 0x63, 0x79, 0x6a, 0x0d, 0x55, 0x94, 0x86, 0x1a, 0x49,",
                "+\t0x14, 0x36, 0xae, 0x3d, 0x0d, 0x6d, 0xac, 0x2b, 0x82, 0x9f, 0xae, 0xa8, 0x3b, 0xb0, 0x94, 0x12,",
                "+\t0x3e, 0x91, 0x4d, 0x36, 0x61, 0xe9, 0x21, 0x09, 0x98, 0xb9, 0x75, 0xf2, 0xd9, 0x80, 0xf8, 0x01,",
                "+\t0x65, 0x0e, 0xe8, 0xbb, 0x38, 0x80, 0xbf, 0x68, 0x5f, 0x20, 0xc0, 0x3f, 0x75, 0x4d, 0x23, 0x20,",
                "+\t0x09, 0xe6, 0x9b, 0x71, 0x66, 0xa5, 0x71, 0x2e, 0xc7, 0x95, 0xe2, 0x14, 0xbc, 0x0d, 0xca, 0x80,",
                "+\t0x1d, 0xc2, 0xc2, 0x89, 0xc1, 0x91, 0xe9, 0xfa, 0x43, 0x1a, 0x71, 0x4f, 0x0c, 0xbf, 0xab, 0x03,",
                "+\t0x67, 0xa7, 0xcf, 0x5a, 0x1b, 0x16, 0x0f, 0xb8, 0xe6, 0x23, 0xa1, 0xe2, 0x6d, 0x28, 0x09, 0xf3,",
                "+\t0x86, 0xfe, 0xbb, 0x32, 0xc6, 0x7f, 0x7a, 0xb4, 0x41, 0x6b, 0xc0, 0x52, 0x24, 0xc4, 0x77, 0x1d,",
                "+\t0xdb, 0x27, 0xf8, 0x0a, 0x28, 0x43, 0x07, 0xfa, 0x65, 0xb4, 0x56, 0xac, 0xcc, 0xe9, 0x10, 0x79,",
                "+\t0xd0, 0xd7, 0x2c, 0x38, 0xf3, 0xd8, 0xf2, 0xb9, 0x15, 0xfd, 0x10, 0x5b, 0x19, 0x66, 0x5d, 0xcf,",
                "+\t0xf9, 0x94, 0xb4, 0x03, 0x81, 0x2e, 0x7c, 0xc5, 0x17, 0x60, 0xce, 0xa5, 0x87, 0xf9, 0xd6, 0xe7,",
                "+\t0xdc, 0x23, 0xd3, 0x7a, 0x89, 0x2e, 0x1c, 0x5a, 0x9f, 0x13, 0x1a, 0x2d, 0x8c, 0x18, 0x38, 0x5d,",
                "+\t0x62, 0x87, 0xd1, 0x42, 0x57, 0x9e, 0xd2, 0x05, 0xad, 0x0f, 0x38, 0x2e, 0x4a, 0x20, 0xac, 0xc3,",
                "+\t0x0c, 0x53, 0x9d, 0x83, 0x1b, 0xe1, 0x06, 0xc1, 0x86, 0xaf, 0xc1, 0x92, 0x4d, 0x5e, 0x04, 0xcd,",
                "+\t0x98, 0x28, 0x1e, 0x1a, 0x0b, 0x74, 0xf9, 0x20, 0x12, 0xf7, 0x19, 0x5c, 0x8a, 0xc4, 0x1d, 0x0e,",
                "+\t0x5a, 0x7e, 0xdb, 0xb3, 0x5c, 0x56, 0x68, 0x46, 0x7b, 0xe0, 0x75, 0x34, 0xb4, 0xe1, 0x72, 0x9e,",
                "+\t0x48, 0xa1, 0xed, 0x06, 0x2c, 0xf8, 0x71, 0x82, 0xf0, 0x48, 0x72, 0xf1, 0xc4, 0x2a, 0x56, 0x01,",
                "+\t0xef, 0x93, 0x1e, 0x49, 0xc5, 0xb5, 0x3c, 0x09, 0xfe, 0x59, 0x84, 0xf9, 0x38, 0x26, 0x69, 0x79,",
                "+\t0x8b, 0xb6, 0x16, 0xe2, 0x26, 0xd9, 0x01, 0xc5, 0x1d, 0xf8, 0xcf, 0x9b, 0x6d, 0xc7, 0x7e, 0x66,",
                "+\t0x75, 0x44, 0x96, 0x5f, 0x94, 0xc5, 0xa5, 0xff, 0xfc, 0x3e, 0xe3, 0xd1, 0xc1, 0x8d, 0x9e, 0xf1,",
                "+\t0x16, 0xac, 0x18, 0xed, 0x6e, 0xd3, 0x24, 0x86, 0xd9, 0xb3, 0x6c, 0xd2, 0xf4, 0x49, 0xdb, 0xb1,",
                "+\t0x4d, 0xbf, 0x3c, 0xcd, 0x8c, 0x8b, 0x8d, 0x76, 0x77, 0x5f, 0x90, 0x0e, 0x39, 0x05, 0x37, 0x60,",
                "+\t0xd5, 0x23, 0x81, 0x61, 0xd9, 0x4d, 0xa3, 0xdd, 0x25, 0x66, 0x33, 0x4a, 0x89, 0xd9, 0x35, 0x54,",
                "+\t0x29, 0xe9, 0xdf, 0xe3, 0xc4, 0x5d, 0x4a, 0x13, 0x59, 0xe0, 0xe3, 0x9f, 0x83, 0x1a, 0x46, 0xba,",
                "+\t0x47, 0x02, 0x62, 0x53, 0x1d, 0x9b, 0x61, 0xef, 0x28, 0x97, 0x18, 0xe6, 0xf3, 0x99, 0x6c, 0xdd,",
                "+\t0x17, 0x0c, 0x7a, 0x59, 0x6c, 0xd6, 0xc3, 0xbd, 0x21, 0x05, 0xef, 0x45, 0x25, 0x7f, 0x8e, 0x05,",
                "+\t0x68, 0x35, 0xab, 0x78, 0xdc, 0xae, 0x6f, 0xba, 0xf2, 0xff, 0x0b, 0x01, 0x0c, 0x0d, 0x8b, 0xaf,",
                "+\t0xc2, 0x02, 0xf3, 0x05, 0xb1, 0x4d, 0xd7, 0xb1, 0xec, 0x30, 0x41, 0xe7, 0xe9, 0xe2, 0x03, 0xb1,",
                "+\t0x86, 0x1f, 0x4b, 0xfa, 0xc0, 0x8d, 0x51, 0xfe, 0x1a, 0xd5, 0x04, 0x5e, 0xb7, 0x4c, 0xb7, 0x61,",
                "+\t0x49, 0x27, 0x6d, 0x62, 0x1d, 0x45, 0xce, 0xc2, 0xab, 0x30, 0x43, 0x23, 0xc2, 0x32, 0xc3, 0x10,",
                "+\t0x35, 0xda, 0xdd, 0x47, 0x26, 0xbe, 0x03, 0xb3, 0xc2, 0x0b, 0xa2, 0xba, 0x8e, 0xad, 0x7d, 0x21,",
                "+\t0xbf, 0xf6, 0x03, 0x38, 0xfb, 0x90, 0x04, 0x71, 0x3f, 0x84, 0xd9, 0xa0, 0xc1, 0x7c, 0x3c, 0xb9,",
                "+\t0x42, 0x7b, 0xc5, 0xd7, 0xb4, 0x6f, 0x11, 0x9c, 0xe7, 0x0d, 0x42, 0x76, 0xc2, 0x9e, 0xe4, 0x04,",
                "+\t0xa5, 0x71, 0x79, 0x74, 0x18, 0x24, 0x25, 0xbc, 0x5e, 0xf3, 0x70, 0xa1, 0x4c, 0xcb, 0x8a, 0xb4,",
                "+\t0x88, 0xbd, 0x9d, 0x52, 0xfd, 0x07, 0x04, 0xe7, 0x25, 0x22, 0x45, 0x11, 0xdb, 0x97, 0x15, 0xb1,",
                "+\t0xf1, 0x16, 0x39, 0x65, 0x91, 0xfb, 0x08, 0xce, 0xf3, 0x22, 0x77, 0x5a, 0xef, 0xfe, 0x06, 0xce,",
                "+\t0x3d, 0x71, 0x4c, 0xeb, 0xd9, 0x71, 0xac, 0x3e, 0x9d, 0x7c, 0x7b, 0xba, 0xfa, 0x15, 0x26, 0xab,",
                "+\t0x7e, 0xda, 0x57, 0x08, 0x94, 0x83, 0x41, 0xaf, 0x37, 0x89, 0xc8, 0x9b, 0x80, 0x3d, 0x12, 0x0c,",
                "+\t0x3c, 0xbb, 0x69, 0xf5, 0xfb, 0xc4, 0xb4, 0x8c, 0x80, 0xf4, 0x8e, 0x99, 0xe4, 0x92, 0x7e, 0x86,",
                "+\t0x53, 0x1e, 0x0d, 0x09, 0x78, 0x1d, 0xe6, 0xfb, 0xc6, 0x8b, 0x61, 0x95, 0x2c, 0x32, 0x67, 0x2b,",
                "+\t0x7d, 0xe3, 0x45, 0x58, 0x1d, 0xb5, 0x5f, 0xc2, 0x3c, 0x07, 0x21, 0x5c, 0xf8, 0x63, 0x38, 0xe3,",
                "+\t0x89, 0xa4, 0x1c, 0xee, 0xe3, 0x6e, 0x5c, 0xcf, 0xaa, 0x96, 0xca, 0x5f, 0x7d, 0xd9, 0x4b, 0x2e,",
                "+\t0xf8, 0x34, 0x60, 0xca, 0xdc, 0xc8, 0xbb, 0xc3, 0x72, 0x3e, 0x89, 0xca, 0xe7, 0x60, 0x96, 0x97,",
                "+\t0x04, 0xbf, 0x3c, 0xc5, 0x5a, 0xe2, 0x0c, 0xab, 0x09, 0x7e, 0x6e, 0xf7, 0x28, 0xe6, 0x75, 0x0f,",
                "+\t0xed, 0x27, 0x80, 0x77, 0xdb, 0x5d, 0xdb, 0xf9, 0x55, 0x8f, 0x98, 0x9d, 0xd3, 0x82, 0x28, 0xc4,",
                "+\t0x41, 0x68, 0xbf, 0x2d, 0xc0, 0xca, 0x61, 0xe0, 0x11, 0xa3, 0x6f, 0xd9, 0x9d, 0x49, 0xbd, 0x99,",
                "+\t0x77, 0x2a, 0xbe, 0x0d, 0xe7, 0xfa, 0xcc, 0x66, 0x32, 0xed, 0x8a, 0x95, 0x69, 0x7d, 0x95, 0x93,",
                "+\t0xd3, 0xed, 0xf1, 0x83, 0xec, 0xbe, 0xa4, 0xed, 0x56, 0x92, 0xfb, 0x76, 0xb9, 0xb8, 0x1d, 0xb8,",
                "+\t0xe0, 0x33, 0x1d, 0x9a, 0x23, 0xda, 0x71, 0x99, 0xb3, 0xec, 0x66, 0xcd, 0xda, 0x81, 0xd5, 0x94,",
                "+\t0x09, 0xde, 0x52, 0x2c, 0x7d, 0x02, 0xab, 0xf7, 0x3d, 0x42, 0x8b, 0xb1, 0x6d, 0xb8, 0xfe, 0x73,",
                "+\t0x27, 0x08, 0x8d, 0x2d, 0x9b, 0x58, 0xd2, 0x0e, 0x28, 0x48, 0x0a, 0xc0, 0x2b, 0x04, 0xab, 0xa2,",
                "+\t0xbc, 0xa7, 0x4e, 0xbc, 0x0d, 0x25, 0x5f, 0x2c, 0x89, 0xb2, 0xae, 0x4a, 0x8a, 0x58, 0xb8, 0x29,",
                "+\t0xe2, 0x7d, 0xbd, 0x72, 0xfe, 0x5f, 0x04, 0xa5, 0xf0, 0xcc, 0x09, 0xa6, 0xb0, 0x6d, 0x50, 0xc8,",
                "+\t0x0b, 0xd7, 0xf2, 0x08, 0xff, 0xd6, 0x2a, 0x8e, 0xfd, 0xd6, 0x02, 0xce, 0x4e, 0x17, 0xf0, 0xbd,",
                "+\t0x68, 0x88, 0x99, 0x62, 0x8e, 0xb9, 0x96, 0xaf, 0xe6, 0x9b, 0x1e, 0x60, 0x7a, 0xb0, 0xc2, 0x5a,",
                "+\t0x89, 0x38, 0xfe, 0x2d, 0x77, 0xae, 0x63, 0x58, 0x4d, 0x49, 0x13, 0x51, 0xfa, 0x21, 0xcc, 0x85,",
                "+\t0xee, 0x0b, 0xa3, 0x73, 0x94, 0xaf, 0x87, 0xcc, 0x27, 0x6e, 0x54, 0xef, 0xc3, 0xaa, 0x68, 0x54,",
                "+\t0xa9, 0x28, 0x53, 0x53, 0x51, 0x36, 0x37, 0x8c, 0x24, 0xed, 0x8f, 0x08, 0x94, 0x43, 0x42, 0xba,",
                "+\t0x93, 0x14, 0x94, 0x2d, 0x98, 0x62, 0x21, 0x50, 0x18, 0x17, 0x02, 0x1f, 0xbf, 0xa3, 0x33, 0x4e,",
                "+\t0x7c, 0x31, 0x86, 0x80, 0x99, 0xec, 0xe3, 0x77, 0x86, 0x18, 0xf6, 0x4a, 0x30, 0x13, 0x18, 0x5e,",
                "+\t0x87, 0x04, 0xda, 0x22, 0xcc, 0x73, 0x30, 0xdc, 0x68, 0x8d, 0xff, 0x2d, 0x03, 0x88, 0xb6, 0xdb,",
                "+\t0x22, 0x1e, 0xfe, 0x3d, 0x02, 0x2c, 0x52, 0x33, 0x8e, 0x67, 0x4c, 0xe3, 0x57, 0xc7, 0xd0, 0xb5,",
                "+\t0xad, 0x2f, 0xff, 0xfd, 0x9f, 0x6f, 0x0a, 0x55, 0xf5, 0xdd, 0xfa, 0xd1, 0xad, 0xfa, 0xaf, 0x69,",
                "+\t0x0a, 0xec, 0x88, 0x50, 0xf0, 0xeb, 0xd5, 0x7a, 0x62, 0x6a, 0xa8, 0x57, 0x5f, 0xde, 0x45, 0x55,",
                "+\t0xfc, 0x67, 0xc4, 0xbe, 0xfd, 0x13, 0x28, 0x2a, 0x59, 0x29, 0xf2, 0x91, 0x70, 0x2c, 0x9e, 0x0f,",
                "+\t0x18, 0x9e, 0x3a, 0xbe, 0xc9, 0xf0, 0xc4, 0xe5, 0x8f, 0xc2, 0x85, 0xff, 0x1a, 0xfd, 0x66, 0x48,",
                "+\t0xe0, 0x7a, 0x2f, 0x2b, 0x2d, 0x77, 0xd6, 0x1c, 0x0b, 0x6d, 0x87, 0x41, 0xfb, 0x7e, 0xa3, 0x91,",
                "+\t0x81, 0x56, 0x3b, 0x89, 0xdd, 0xbe, 0x45, 0xfc, 0x73, 0x3f, 0x31, 0xd7, 0x61, 0xc9, 0x17, 0x4d,",
                "+\t0xde, 0xbc, 0xa9, 0xbe, 0x77, 0x22, 0x5e, 0x1e, 0x3e, 0x5a, 0x8d, 0xa1, 0xad, 0xe0, 0x6b, 0x0c,",
                "+\t0xad, 0xc0, 0x16, 0xc3, 0xf8, 0x32, 0x09, 0x12, 0xff, 0x09, 0x85, 0x1f, 0xb4, 0xe3, 0x2c, 0x98,",
                "+\t0x3b, 0x11, 0xaa, 0x67, 0x33, 0xe9, 0xf0, 0xa0, 0xef, 0x06, 0xc7, 0xa1, 0x53, 0xab, 0x13, 0x3a,",
                "+\t0xf5, 0x6f, 0x08, 0xce, 0x64, 0x06, 0x1b, 0x99, 0xc5, 0xf2, 0xa6, 0x9f, 0x5c, 0x40, 0x3f, 0x62,",
                "+\t0x80, 0xf6, 0xb5, 0x8f, 0x26, 0x02, 0x74, 0xb7, 0x9f, 0x96, 0x43, 0xfd, 0xfa, 0x35, 0x02, 0x25,",
                "+\t0x36, 0xf3, 0xe0, 0x8d, 0x2c, 0xbe, 0xec, 0x48, 0x94, 0x8b, 0x6c, 0x9f, 0x21, 0xbb, 0xa7, 0xdd,",
                "+\t0x99, 0x0c, 0x99, 0x31, 0x94, 0x40, 0x31, 0xfd, 0x0e, 0xc1, 0x14, 0x9d, 0x13, 0xf0, 0x25, 0xd9,",
                "+\t0xac, 0x1c, 0x8d, 0x50, 0xb2, 0x90, 0x8f, 0x8f, 0x17, 0x61, 0xc8, 0x6b, 0x8d, 0xc9, 0xd0, 0xb8,",
                "+\t0x83, 0x5e, 0x8f, 0xc2, 0x30, 0x61, 0x21, 0x31, 0xb6, 0x60, 0x59, 0xeb, 0x93, 0x8c, 0x76, 0xea,",
                "+\t0xe6, 0x58, 0x3e, 0x0e, 0xb0, 0x82, 0xb6, 0x10, 0xcd, 0xfd, 0xe5, 0xf4, 0x47, 0x06, 0xbe, 0x9e,",
                "+\t0x17, 0x25, 0x99, 0x0f, 0x91, 0x5c, 0x57, 0x3c, 0x62, 0xca, 0xdf, 0xd7, 0xee, 0x9d, 0x26, 0x48,",
                "+\t0x86, 0x62, 0xa8, 0x21, 0x5e, 0x21, 0x58, 0x48, 0xb4, 0x46, 0x99, 0x25, 0x64, 0x9d, 0x5a, 0x66,",
                "+\t0x09, 0x69, 0x8f, 0xd5, 0xaa, 0x0c, 0xed, 0x06, 0xd6, 0xf2, 0xf3, 0x3d, 0x12, 0xfe, 0x15, 0x82,",
                "+\t0xc5, 0xe4, 0x98, 0x87, 0x25, 0x72, 0xa4, 0x83, 0xa0, 0x3a, 0xa2, 0x71, 0x6b, 0x37, 0x18, 0x86,",
                "+\t0x6b, 0xea, 0xba, 0xbc, 0x99, 0x84, 0xf2, 0x45, 0x41, 0x7c, 0x85, 0x60, 0x31, 0x39, 0x1a, 0xca,",
                "+\t0x50, 0x48, 0x87, 0xc7, 0x91, 0x28, 0x44, 0xb5, 0x69, 0x54, 0xb9, 0xdf, 0xc2, 0xd1, 0x6a, 0x1c,",
                "+\t0x9c, 0x2f, 0x10, 0x2c, 0x26, 0x67, 0x08, 0x19, 0x1c, 0xe9, 0x94, 0x91, 0x1b, 0x42, 0x37, 0x19,",
                "+\t0x94, 0xcd, 0xea, 0xbb, 0x09, 0x28, 0x79, 0x28, 0x58, 0xda, 0xd2, 0x19, 0x40, 0x96, 0xb6, 0xb1,",
                "+\t0x41, 0x45, 0xda, 0xa9, 0x62, 0xa3, 0xc3, 0x69, 0xd3, 0xd6, 0x27, 0xa4, 0x7b, 0x17, 0x55, 0x1b,",
                "+\t0x7f, 0x99, 0x85, 0x39, 0xf1, 0x33, 0x9b, 0x78, 0xf8, 0x53, 0x50, 0x78, 0x24, 0xf0, 0x9b, 0x99,",
                "+\t0xbc, 0x7f, 0xc4, 0x6a, 0x1e, 0x41, 0xbb, 0xce, 0xd0, 0x5c, 0x55, 0x2f, 0x4b, 0xa3, 0x82, 0xff,",
                "+\t0x59, 0x16, 0x3e, 0x78, 0x09, 0x4a, 0xec, 0xb2, 0x40, 0x56, 0x4a, 0xb3, 0x77, 0x09, 0xf9, 0x82,",
                "+\t0xeb, 0x4c, 0xf0, 0xf5, 0xc6, 0x06, 0x13, 0xcc, 0x04, 0xd5, 0x46, 0x8a, 0xff, 0x12, 0xc1, 0xac,",
                "+\t0x50, 0x1c, 0xaf, 0x49, 0xff, 0x7f, 0xc5, 0x6e, 0x11, 0xd4, 0xf5, 0x11, 0x1c, 0xc2, 0x11, 0x0d,",
                "+\t0x86, 0xe0, 0x86, 0xb6, 0x39, 0x44, 0x20, 0x17, 0x2e, 0xae, 0x66, 0x28, 0x08, 0x07, 0x4a, 0xe1,",
                "+\t0xd5, 0x0a, 0x5e, 0x97, 0xce, 0x55, 0x27, 0xd3, 0x7e, 0x93, 0xc9, 0x5e, 0xc7, 0x57, 0xc6, 0xc8,",
                "+\t0xa6, 0x81, 0x0f, 0xc3, 0xcb, 0x01, 0x7c, 0x55, 0x5e, 0x71, 0x12, 0xb7, 0x14, 0xea, 0xc6, 0x68,",
                "+\t0x26, 0xa1, 0x7e, 0x12, 0x82, 0xac, 0x26, 0x89, 0x7b, 0x85, 0x7f, 0x20, 0x38, 0x2b, 0xff, 0x7b,",
                "+\t0x8f, 0xeb, 0x23, 0x24, 0x49, 0xa7, 0xa4, 0xad, 0x93, 0x6f, 0x10, 0x30, 0x93, 0x33, 0x67, 0xbe,",
                "+\t0xa5, 0x52, 0x13, 0x53, 0x00, 0x4a, 0xec, 0x06, 0x40, 0x16, 0xac, 0xd9, 0x0b, 0x82, 0xdc, 0x4a,",
                "+\t0x21, 0x4c, 0x55, 0x1d, 0xe7, 0xad, 0xbd, 0x63, 0x58, 0x69, 0x3b, 0xfd, 0x8c, 0xac, 0x3d, 0x85,",
                "+\t0xff, 0x9d, 0x3d, 0xa0, 0xc7, 0x1e, 0xa0, 0x5f, 0xdc, 0x16, 0x0c, 0x1d, 0xa7, 0x67, 0xd8, 0x9d,",
                "+\t0x9a, 0xe3, 0x75, 0xea, 0x1d, 0x62, 0x33, 0xa1, 0x75, 0x4e, 0x32, 0x5c, 0xcb, 0x1f, 0x5e, 0x1c,",
                "+\t0x6f, 0xf3, 0xa7, 0xff, 0x23, 0xf4, 0xf7, 0xc2, 0xd9, 0x87, 0x7c, 0xef, 0xfd, 0x9e, 0x33, 0x30,",
                "+\t0x69, 0x4c, 0x1f, 0x0e, 0x5a, 0xb5, 0x9f, 0xdd, 0x6a, 0xcd, 0xb0, 0xed, 0xef, 0x7f, 0x17, 0x00,",
                "+\t0x00, 0xff, 0xff, 0x68, 0xa2, 0x62, 0x98, 0x76, 0x1e, 0x00, 0x00,",
                "+}",
                "diff --git a/vendor/gopkg.in/yaml.v2/emitterc.go b/vendor/gopkg.in/yaml.v2/emitterc.go",
                "index dcaf502..41de8b8 100644",
                "--- a/vendor/gopkg.in/yaml.v2/emitterc.go",
                "+++ b/vendor/gopkg.in/yaml.v2/emitterc.go",
                "@@ -997,5 +997,5 @@ func yaml_emitter_analyze_scalar(emitter *yaml_emitter_t, value []byte) bool {",
                " \t\tpreceded_by_whitespace = false",
                "-\t\tfollowed_by_whitespace = false",
                "-\t\tprevious_space         = false",
                "-\t\tprevious_break         = false",
                "+\t\tfollowed_by_whitespace  = false",
                "+\t\tprevious_space          = false",
                "+\t\tprevious_break          = false",
                " \t)"
            ],
            "changed_files": [
                "Godeps/Godeps.json",
                "vendor/cloud.google.com/go/iam/iam.go",
                "vendor/cloud.google.com/go/pubsub/apiv1/doc.go",
                "vendor/cloud.google.com/go/pubsub/apiv1/publisher_client.go",
                "vendor/cloud.google.com/go/pubsub/apiv1/subscriber_client.go",
                "vendor/cloud.google.com/go/pubsub/doc.go",
                "vendor/cloud.google.com/go/pubsub/flow_controller.go",
                "vendor/cloud.google.com/go/pubsub/iterator.go",
                "vendor/cloud.google.com/go/pubsub/message.go",
                "vendor/cloud.google.com/go/pubsub/pubsub.go",
                "vendor/cloud.google.com/go/pubsub/service.go",
                "vendor/cloud.google.com/go/pubsub/snapshot.go",
                "vendor/cloud.google.com/go/pubsub/subscription.go",
                "vendor/cloud.google.com/go/pubsub/topic.go",
                "vendor/golang.org/x/sync/errgroup/errgroup.go",
                "vendor/golang.org/x/tools/go/gcexportdata/gcexportdata.go",
                "vendor/golang.org/x/tools/go/internal/gcimporter/bexport.go",
                "vendor/golang.org/x/tools/go/internal/gcimporter/bimport.go",
                "vendor/golang.org/x/tools/go/internal/gcimporter/exportdata.go",
                "vendor/golang.org/x/tools/go/internal/gcimporter/gcimporter.go",
                "vendor/golang.org/x/tools/go/internal/gcimporter/iimport.go",
                "vendor/golang.org/x/tools/go/internal/gcimporter/isAlias18.go",
                "vendor/golang.org/x/tools/go/internal/gcimporter/isAlias19.go",
                "vendor/golang.org/x/tools/present/doc.go",
                "vendor/golang.org/x/tools/present/parse.go",
                "vendor/google.golang.org/genproto/googleapis/iam/v1/iam_policy.pb.go",
                "vendor/google.golang.org/genproto/googleapis/iam/v1/policy.pb.go",
                "vendor/google.golang.org/genproto/googleapis/pubsub/v1/pubsub.pb.go",
                "vendor/gopkg.in/yaml.v2/emitterc.go"
            ],
            "message_reference_content": [],
            "jira_refs": {},
            "ghissue_refs": {
                "553": "cloud.google.com/go/pubsub added to vendor #557",
                "557": "panic: http: multiple registrations for /debug/requests #553"
            },
            "cve_refs": [],
            "twins": [],
            "tags": [],
            "matched_rules": [
                {
                    "id": "ADV_KEYWORDS_IN_FILES",
                    "message": "An advisory keyword is contained in the changed files: import",
                    "relevance": 4
                },
                {
                    "id": "GITHUB_ISSUE_IN_MESSAGE",
                    "message": "The commit message references some github issue: 553, 557",
                    "relevance": 2
                }
            ]
        }
    ]
}
